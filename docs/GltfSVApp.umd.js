(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('gl-matrix'), require('axios'), require('jpeg-js'), require('fast-png')) :
    typeof define === 'function' && define.amd ? define(['exports', 'gl-matrix', 'axios', 'jpeg-js', 'fast-png'], factory) :
    (global = global || self, factory(global.SampleViewerApp = {}, global.glMatrix, global.axios$2, global.jpeg, global.png));
}(this, (function (exports, glMatrix, axios$2, jpeg, png) { 'use strict';

    axios$2 = axios$2 && Object.prototype.hasOwnProperty.call(axios$2, 'default') ? axios$2['default'] : axios$2;

    function jsToGl(array) {
        let tensor = new glMatrix.glMatrix.ARRAY_TYPE(array.length);

        for (let i = 0; i < array.length; ++i) {
            tensor[i] = array[i];
        }

        return tensor;
    }

    function jsToGlSlice(array, offset, stride) {
        let tensor = new glMatrix.glMatrix.ARRAY_TYPE(stride);

        for (let i = 0; i < stride; ++i) {
            tensor[i] = array[offset + i];
        }

        return tensor;
    }

    function initGlForMembers(gltfObj, gltf, webGlContext) {
        for (const name of Object.keys(gltfObj)) {
            const member = gltfObj[name];

            if (member === undefined) {
                continue;
            }
            if (member.initGl !== undefined) {
                member.initGl(gltf, webGlContext);
            }
            if (Array.isArray(member)) {
                for (const element of member) {
                    if (element !== null && element !== undefined && element.initGl !== undefined) {
                        element.initGl(gltf, webGlContext);
                    }
                }
            }
        }
    }

    function objectsFromJsons(jsonObjects, GltfType) {
        if (jsonObjects === undefined) {
            return [];
        }

        const objects = [];
        for (const jsonObject of jsonObjects) {
            objects.push(objectFromJson(jsonObject, GltfType));
        }
        return objects;
    }

    function objectFromJson(jsonObject, GltfType) {
        const object = new GltfType();
        object.fromJson(jsonObject);
        return object;
    }

    function fromKeys(target, jsonObj, ignore = []) {
        for (let k of Object.keys(target)) {
            if (ignore && ignore.find(function (elem) { return elem == k; }) !== undefined) {
                continue; // skip
            }
            if (jsonObj[k] !== undefined) {
                let normalizedK = k.replace("^@", "");
                target[normalizedK] = jsonObj[k];
            }
        }
    }

    function stringHash(str, seed = 0) {
        let hash = seed;
        if (str.length === 0) return hash;
        for (let i = 0; i < str.length; i++) {
            let chr = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + chr;
            hash |= 0; // Convert to 32bit integer
        }
        return hash;
    }

    function clamp(number, min, max) {
        return Math.min(Math.max(number, min), max);
    }

    function getIsGlb(filename) {
        return getExtension(filename) == "glb";
    }

    function getExtension(filename) {
        const split = filename.toLowerCase().split(".");
        if (split.length == 1) {
            return undefined;
        }
        return split[split.length - 1];
    }

    function getContainingFolder(filePath) {
        return filePath.substring(0, filePath.lastIndexOf("/") + 1);
    }

    // marker interface used to for parsing the uniforms
    class UniformStruct { }

    class AnimationTimer {
        constructor() {
            this.startTime = 0;
            this.paused = true;
            this.fixedTime = null;
            this.pausedTime = 0;
        }

        elapsedSec() {
            if (this.paused) {
                return this.pausedTime / 1000;
            }
            else {
                return this.fixedTime || (new Date().getTime() - this.startTime) / 1000;
            }
        }

        toggle() {
            if (this.paused) {
                this.unpause();
            }
            else {
                this.pause();
            }
        }

        start() {
            this.startTime = new Date().getTime();
            this.paused = false;
        }

        pause() {
            this.pausedTime = new Date().getTime() - this.startTime;
            this.paused = true;
        }

        unpause() {
            this.startTime += new Date().getTime() - this.startTime - this.pausedTime;
            this.paused = false;
        }

        reset() {
            if (!this.paused) {
                // Animation is running.
                this.startTime = new Date().getTime();
            }
            else {
                this.startTime = 0;
            }
            this.pausedTime = 0;
        }

        setFixedTime(timeInSec) {
            this.paused = false;
            this.fixedTime = timeInSec;
        }
    }

    // base class for all gltf objects
    class GltfObject
    {
        constructor()
        {
            this.extensions = undefined;
            this.extras = undefined;
        }

        fromJson(json)
        {
            fromKeys(this, json);
        }

        initGl(gltf, webGlContext)
        {
            initGlForMembers(this, gltf, webGlContext);
        }
    }

    class gltfCamera extends GltfObject
    {
        constructor(
            type = "perspective",
            znear = 0.01,
            zfar = Infinity,
            yfov = 45.0 * Math.PI / 180.0,
            aspectRatio = undefined,
            xmag = 1.0,
            ymag = 1.0,
            name = undefined,
            nodeIndex = undefined)
        {
            super();
            this.type = type;
            this.znear = znear;
            this.zfar = zfar;
            this.yfov = yfov; // radians
            this.xmag = xmag;
            this.ymag = ymag;
            this.aspectRatio = aspectRatio;
            this.name = name;
            this.node = nodeIndex;
        }

        initGl(gltf, webGlContext)
        {
            super.initGl(gltf, webGlContext);

            let cameraIndex = undefined;
            for (let i = 0; i < gltf.nodes.length; i++)
            {
                cameraIndex = gltf.nodes[i].camera;
                if (cameraIndex === undefined)
                {
                    continue;
                }

                if (gltf.cameras[cameraIndex] === this)
                {
                    this.node = i;
                    break;
                }
            }

            // cameraIndex stays undefined if camera is not assigned to any node
            if(this.node === undefined && cameraIndex !== undefined)
            {
                console.error("Invalid node for camera " + cameraIndex);
            }
        }

        fromJson(jsonCamera)
        {
            this.name = name;
            if(jsonCamera.perspective !== undefined)
            {
                this.type = "perspective";
                fromKeys(this, jsonCamera.perspective);
            }
            else if(jsonCamera.orthographic !== undefined)
            {
                this.type = "orthographic";
                fromKeys(this, jsonCamera.orthographic);
            }
        }

        sortPrimitivesByDepth(gltf, drawables)
        {
            // Precompute the distances to avoid their computation during sorting.
            for (const drawable of drawables)
            {
                const modelView = glMatrix.mat4.create();
                glMatrix.mat4.multiply(modelView, this.getViewMatrix(gltf), drawable.node.worldTransform);

                // Transform primitive centroid to find the primitive's depth.
                const pos = glMatrix.vec3.transformMat4(glMatrix.vec3.create(), glMatrix.vec3.clone(drawable.primitive.centroid), modelView);

                drawable.depth = pos[2];
            }

            // 1. Remove primitives that are behind the camera.
            //    --> They will never be visible and it is cheap to discard them here.
            // 2. Sort primitives so that the furthest nodes are rendered first.
            //    This is required for correct transparency rendering.
            return drawables
                .filter((a) => a.depth <= 0)
                .sort((a, b) => a.depth - b.depth);
        }

        getProjectionMatrix()
        {
            const projection = glMatrix.mat4.create();

            if (this.type === "perspective")
            {
                glMatrix.mat4.perspective(projection, this.yfov, this.aspectRatio, this.znear, this.zfar);
            }
            else if (this.type === "orthographic")
            {
                projection[0]  = 1.0 / this.xmag;
                projection[5]  = 1.0 / this.ymag;
                projection[10] = 2.0 / (this.znear - this.zfar);
                projection[14] = (this.zfar + this.znear) / (this.znear - this.zfar);
            }

            return projection;
        }

        getViewMatrix(gltf)
        {
            let result = glMatrix.mat4.create();
            glMatrix.mat4.invert(result, this.getTransformMatrix(gltf));
            return result;
        }

        getTarget(gltf)
        {
            const target = glMatrix.vec3.create();
            const position = this.getPosition(gltf);
            const lookDirection = this.getLookDirection(gltf);
            glMatrix.vec3.add(target, lookDirection, position);
            return target;
        }

        getPosition(gltf)
        {
            const position = glMatrix.vec3.create();
            const node = this.getNode(gltf);
            glMatrix.mat4.getTranslation(position, node.worldTransform);
            return position;
        }

        getLookDirection(gltf)
        {
            const direction = glMatrix.vec3.create();
            const rotation = this.getRotation(gltf);
            glMatrix.vec3.transformQuat(direction, glMatrix.vec3.fromValues(0, 0, -1), rotation);
            return direction;
        }

        getRotation(gltf)
        {
            const rotation = glMatrix.quat.create();
            const node = this.getNode(gltf);
            glMatrix.mat4.getRotation(rotation, node.worldTransform);
            return rotation;
        }

        clone()
        {
            return new gltfCamera(
                this.type,
                this.znear,
                this.zfar,
                this.yfov,
                this.aspectRatio,
                this.xmag,
                this.ymag,
                this.name,
                this.node);
        }

        getNode(gltf)
        {
            return gltf.nodes[this.node];
        }

        getTransformMatrix(gltf)
        {
            const node = this.getNode(gltf);
            if (node !== undefined && node.worldTransform !== undefined)
            {
                return node.worldTransform;
            }
            return glMatrix.mat4.create();

        }

        // Returns a JSON object describing the user camera's current values.
        getDescription(gltf)
        {
            const asset = {
                "generator": "gltf-sample-viewer",
                "version": "2.0"
            };

            const camera = {
                "type": this.type
            };

            if (this.name !== undefined)
            {
                camera["name"] = this.name;
            }

            if (this.type === "perspective")
            {
                camera["perspective"] = {};
                if (this.aspectRatio !== undefined)
                {
                    camera["perspective"]["aspectRatio"] = this.aspectRatio;
                }
                camera["perspective"]["yfov"] = this.yfov;
                if (this.zfar != Infinity)
                {
                    camera["perspective"]["zfar"] = this.zfar;
                }
                camera["perspective"]["znear"] = this.znear;
            }
            else if (this.type === "orthographic")
            {
                camera["orthographic"] = {};
                camera["orthographic"]["xmag"] = this.xmag;
                camera["orthographic"]["ymag"] = this.ymag;
                camera["orthographic"]["zfar"] = this.zfar;
                camera["orthographic"]["znear"] = this.znear;
            }

            const mat = this.getTransformMatrix(gltf);

            const node = {
                "camera": 0,
                "matrix": [mat[0], mat[1], mat[2], mat[3],
                           mat[4], mat[5], mat[6], mat[7],
                           mat[8], mat[9], mat[10], mat[11],
                           mat[12], mat[13], mat[14], mat[15]]
            };

            if (this.nodeIndex !== undefined && gltf.nodes[this.nodeIndex].name !== undefined)
            {
                node["name"] = gltf.nodes[this.nodeIndex].name;
            }

            return {
                "asset": asset,
                "cameras": [camera],
                "nodes": [node]
            };
        }
    }

    function getSceneExtents(gltf, sceneIndex, outMin, outMax)
    {
        for (const i of [0, 1, 2])
        {
            outMin[i] = Number.POSITIVE_INFINITY;
            outMax[i] = Number.NEGATIVE_INFINITY;
        }

        const scene = gltf.scenes[sceneIndex];

        let nodeIndices = scene.nodes.slice();
        while(nodeIndices.length > 0)
        {
            const node = gltf.nodes[nodeIndices.pop()];
            nodeIndices = nodeIndices.concat(node.children);

            if (node.mesh === undefined)
            {
                continue;
            }

            const mesh = gltf.meshes[node.mesh];
            if (mesh.primitives === undefined)
            {
                continue;
            }

            for (const primitive of mesh.primitives)
            {
                const attribute = primitive.glAttributes.find(a => a.attribute == "POSITION");
                if (attribute === undefined)
                {
                    continue;
                }

                const accessor = gltf.accessors[attribute.accessor];
                const assetMin = glMatrix.vec3.create();
                const assetMax = glMatrix.vec3.create();
                getExtentsFromAccessor(accessor, node.worldTransform, assetMin, assetMax);

                for (const i of [0, 1, 2])
                {
                    outMin[i] = Math.min(outMin[i], assetMin[i]);
                    outMax[i] = Math.max(outMax[i], assetMax[i]);
                }
            }
        }
    }

    function getExtentsFromAccessor(accessor, worldTransform, outMin, outMax)
    {
        const boxMin = glMatrix.vec3.create();
        let min = jsToGl(accessor.min);
        if (accessor.normalized){
            glMatrix.vec3.normalize(min, min);
        }
        glMatrix.vec3.transformMat4(boxMin, min, worldTransform);

        const boxMax = glMatrix.vec3.create();
        let max = jsToGl(accessor.max);
        if (accessor.normalized){
            glMatrix.vec3.normalize(max, max);
        }
        glMatrix.vec3.transformMat4(boxMax, max, worldTransform);

        const center = glMatrix.vec3.create();
        glMatrix.vec3.add(center, boxMax, boxMin);
        glMatrix.vec3.scale(center, center, 0.5);

        const centerToSurface = glMatrix.vec3.create();
        glMatrix.vec3.sub(centerToSurface, boxMax, center);

        const radius = glMatrix.vec3.length(centerToSurface);

        for (const i of [0, 1, 2])
        {
            outMin[i] = center[i] - radius;
            outMax[i] = center[i] + radius;
        }
    }

    const PanSpeedDenominator = 3500;
    const MaxNearFarRatio = 10000;

    class UserCamera extends gltfCamera
    {
        /**
         * Create a new user camera.
         */
        constructor()
        {
            super();

            this.transform = glMatrix.mat4.create();
            this.rotAroundY = 0;
            this.rotAroundX = 0;
            this.distance = 1;
            this.baseDistance = 1.0;
            this.zoomExponent = 5.0;
            this.zoomFactor = 0.01;
            this.orbitSpeed = 1 / 180;
            this.panSpeed = 1;
            this.sceneExtents = {
                min: glMatrix.vec3.create(),
                max: glMatrix.vec3.create()
            };
        }

        getTransformMatrix()
        {
            return this.transform;
        }

        /**
         * Sets the vertical FoV of the user camera.
         * @param {number} yfov 
         */
        setVerticalFoV(yfov)
        {
            this.yfov = yfov;
        }

        /**
         * Returns the current position of the user camera as a vec3.
         */
        getPosition()
        {
            let pos = glMatrix.vec3.create();
            glMatrix.mat4.getTranslation(pos, this.transform);
            return pos;
        }

        /**
         * Returns the current rotation of the user camera as quat.
         */
        getRotation()
        {
            let rot = glMatrix.quat.create();
            glMatrix.mat4.getRotation(rot, this.transform);
            return rot;
        }

        /**
         * Returns the normalized direction the user camera looks at as vec3.
         */
        getLookDirection()
        {
            let dir = [-this.transform[8], -this.transform[9], -this.transform[10]];
            glMatrix.vec3.normalize(dir, dir);
            return dir;
        }

        /**
         * Returns the current target the camera looks at as vec3.
         * This multiplies the viewing direction with the distance.
         * For distance 0 the normalized viewing direction is used.
         */
        getTarget()
        {
            const target = glMatrix.vec3.create();
            const position = this.getPosition();
            let lookDirection = this.getLookDirection();
            if (this.distance != 0 && this.distance != 1)
            {
                lookDirection = lookDirection.map(x => x * this.distance);
            }
            glMatrix.vec3.add(target, lookDirection, position);
            return target;
        }

        /**
         * Look from user camera to target.
         * This changes the transformation of the user camera.
         * @param {vec3} from 
         * @param {vec3} to 
         */
        lookAt(from, to)
        {
            this.transform = glMatrix.mat4.create();
            glMatrix.mat4.lookAt(this.transform, from, to, glMatrix.vec3.fromValues(0, 1, 0));
        }

        /**
         * Sets the position of the user camera.
         * @param {vec3} position 
         */
        setPosition(position)
        {
            this.transform[12] = position[0];
            this.transform[13] = position[1];
            this.transform[14] = position[2];
        }

        /**
         * This rotates the user camera towards the target and sets the position of the user camera
         * according to the current distance.
         * @param {vec3} target 
         */
        setTarget(target)
        {
            let pos = glMatrix.vec3.create();
            glMatrix.mat4.getTranslation(pos, this.transform);
            this.transform = glMatrix.mat4.create();
            glMatrix.mat4.lookAt(this.transform, pos, target, glMatrix.vec3.fromValues(0, 1, 0));
            this.setDistanceFromTarget(this.distance, target);
        }

        /**
         * Sets the rotation of the camera.
         * Yaw and pitch in euler angles (degrees).
         * @param {number} yaw 
         * @param {number} pitch 
         */
        setRotation(yaw, pitch)
        {
            const tmpPos = this.getPosition();
            let mat4x = glMatrix.mat4.create();
            let mat4y = glMatrix.mat4.create();
            glMatrix.mat4.fromXRotation(mat4x, pitch);
            glMatrix.mat4.fromYRotation(mat4y, yaw);
            this.transform = mat4y;
            this.setPosition(tmpPos);
            glMatrix.mat4.multiply(this.transform, this.transform, mat4x);
        }

        /**
         * Transforms the user camera to look at a target from a specfic distance using the current rotation.
         * This will only change the position of the user camera, not the rotation.
         * Use this function to set the distance.
         * @param {number} distance 
         * @param {vec3} target 
         */
        setDistanceFromTarget(distance, target)
        {
            const lookDirection = this.getLookDirection();
            const distVec = lookDirection.map(x => x * -distance);
            let pos = glMatrix.vec3.create();
            glMatrix.vec3.add(pos, target, distVec);
            this.setPosition(pos);
            this.distance = distance;
        }

        /**
         * Zoom exponentially according to this.zoomFactor and this.zoomExponent.
         * The default zoomFactor provides good zoom speed for values from [-1,1].
         * @param {number} value 
         */
        zoomBy(value)
        {
            let target = this.getTarget();

            // zoom exponentially
            let zoomDistance = Math.pow(this.distance / this.baseDistance, 1.0 / this.zoomExponent);
            zoomDistance += this.zoomFactor * value;
            zoomDistance = Math.max(zoomDistance, 0.0001);
            this.distance = Math.pow(zoomDistance, this.zoomExponent) * this.baseDistance;

            this.setDistanceFromTarget(this.distance, target);
            this.fitCameraPlanesToExtents(this.sceneExtents.min, this.sceneExtents.max);
        }

        /**
         * Orbit around the target.
         * x and y should be in radient and are added to the current rotation.
         * The rotation around the x-axis is limited to 180 degree.
         * The axes are inverted: e.g. if y is positive the camera will look further down.
         * @param {number} x 
         * @param {number} y 
         */
        orbit(x, y)
        {
            const target = this.getTarget();
            const rotAroundXMax = Math.PI / 2 - 0.01;
            this.rotAroundY += (-x * this.orbitSpeed);
            this.rotAroundX += (-y * this.orbitSpeed);
            this.rotAroundX = clamp(this.rotAroundX, -rotAroundXMax, rotAroundXMax);
            this.setRotation(this.rotAroundY, this.rotAroundX);
            this.setDistanceFromTarget(this.distance, target);
        }

        /**
         * Pan the user camera.
         * The axes are inverted: e.g. if y is positive the camera will move down.
         * @param {number} x 
         * @param {number} y 
         */
        pan(x, y)
        {
            const right = glMatrix.vec3.fromValues(this.transform[0], this.transform[1], this.transform[2]);
            glMatrix.vec3.normalize(right, right);
            glMatrix.vec3.scale(right, right, -x * this.panSpeed * (this.distance / this.baseDistance));

            const up = glMatrix.vec3.fromValues(this.transform[4], this.transform[5], this.transform[6]);
            glMatrix.vec3.normalize(up, up);
            glMatrix.vec3.scale(up, up, -y * this.panSpeed * (this.distance / this.baseDistance));

            let pos = this.getPosition();

            glMatrix.vec3.add(pos, pos, up);
            glMatrix.vec3.add(pos, pos, right);

            this.setPosition(pos);
        }

        fitPanSpeedToScene(min, max)
        {
            const longestDistance = glMatrix.vec3.distance(min, max);
            this.panSpeed = longestDistance / PanSpeedDenominator;
        }

        reset()
        {
            this.transform = glMatrix.mat4.create();
            this.rotAroundX = 0;
            this.rotAroundY = 0;
            this.fitDistanceToExtents(this.sceneExtents.min, this.sceneExtents.max);
            this.fitCameraTargetToExtents(this.sceneExtents.min, this.sceneExtents.max);
        }

        /**
         * Calculates a camera position which looks at the center of the scene from an appropriate distance.
         * This calculates near and far plane as well.
         * @param {Gltf} gltf 
         * @param {number} sceneIndex 
         */
        fitViewToScene(gltf, sceneIndex)
        {
            this.transform = glMatrix.mat4.create();
            this.rotAroundX = 0;
            this.rotAroundY = 0;
            getSceneExtents(gltf, sceneIndex, this.sceneExtents.min, this.sceneExtents.max);
            this.fitDistanceToExtents(this.sceneExtents.min, this.sceneExtents.max);
            this.fitCameraTargetToExtents(this.sceneExtents.min, this.sceneExtents.max);

            this.fitPanSpeedToScene(this.sceneExtents.min, this.sceneExtents.max);
            this.fitCameraPlanesToExtents(this.sceneExtents.min, this.sceneExtents.max);

        }

        fitDistanceToExtents(min, max)
        {
            const maxAxisLength = Math.max(max[0] - min[0], max[1] - min[1]);
            const yfov = this.yfov;
            const xfov = this.yfov * this.aspectRatio;

            const yZoom = maxAxisLength / 2 / Math.tan(yfov / 2);
            const xZoom = maxAxisLength / 2 / Math.tan(xfov / 2);

            this.distance = Math.max(xZoom, yZoom);
            this.baseDistance = this.distance;
        }

        fitCameraTargetToExtents(min, max)
        {
            let target = [0,0,0];
            for (const i of [0, 1, 2])
            {
                target[i] = (max[i] + min[i]) / 2;
            }
            this.setRotation(this.rotAroundY, this.rotAroundX);
            this.setDistanceFromTarget(this.distance, target);
        }

        fitCameraPlanesToExtents(min, max)
        {
            // depends only on scene min/max and the camera distance

            // Manually increase scene extent just for the camera planes to avoid camera clipping in most situations.
            const longestDistance = 10 * glMatrix.vec3.distance(min, max);
            let zNear = this.distance - (longestDistance * 0.6);
            let zFar = this.distance + (longestDistance * 0.6);

            // minimum near plane value needs to depend on far plane value to avoid z fighting or too large near planes
            zNear = Math.max(zNear, zFar / MaxNearFarRatio);

            this.znear = zNear;
            this.zfar = zFar;
        }
    }

    /**
     * GltfState containing a state for visualization in GltfView
     */
    class GltfState
    {
        /**
         * GltfState represents all state that can be visualized in a view. You could have
         * multiple GltfStates configured and switch between them on demand.
         * @param {*} view GltfView to which this state belongs
         */
        constructor(view)
        {
            /** loaded gltf data @see ResourceLoader.loadGltf */
            this.gltf = undefined;
            /** loaded environment data @see ResourceLoader.loadEnvironment */
            this.environment = undefined;
            /** user camera @see UserCamera, convenient camera controls */
            this.userCamera = new UserCamera();
            /** gltf scene that is visible in the view */
            this.sceneIndex = 0;
            /**
             * index of the camera that is used to render the view. a
             * value of 'undefined' enables the user camera
             */
            this.cameraIndex = undefined;
            /** indices of active animations */
            this.animationIndices = [];
            /** animation timer allows to control the animation time */
            this.animationTimer = new AnimationTimer();
            /** KHR_materials_variants */
            this.variant = undefined;

            /** parameters used to configure the rendering */
            this.renderingParameters = {
                /** morphing between vertices */
                morphing: true,
                /** skin / skeleton */
                skinning: true,

                enabledExtensions: {
                    /** KHR_materials_clearcoat */
                    KHR_materials_clearcoat: true,
                    /** KHR_materials_sheen */
                    KHR_materials_sheen: true,
                    /** KHR_materials_transmission */
                    KHR_materials_transmission: true,
                    /** KHR_materials_volume */
                    KHR_materials_volume: true,
                    /** KHR_materials_ior makes the index of refraction configurable */
                    KHR_materials_ior: true,
                    /** KHR_materials_specular allows configuring specular color (f0 color) and amount of specular reflection */
                    KHR_materials_specular: true,
                    /** KHR_materials_iridescence adds a thin-film iridescence effect */
                    KHR_materials_iridescence: true,
                    KHR_materials_emissive_strength: true,
                },
                /** clear color expressed as list of ints in the range [0, 255] */
                clearColor: [58, 64, 74, 255],
                /** exposure factor */
                exposure: 1.0,
                /** KHR_lights_punctual */
                usePunctual: true,
                /** image based lighting */
                useIBL: true,
                /** image based lighting intensity */
                iblIntensity: 1.0,
                /** render the environment map in the background */
                renderEnvironmentMap: true,
                /** apply blur to the background environment map */
                blurEnvironmentMap: true,
                /** which tonemap to use, use ACES for a filmic effect */
                toneMap: GltfState.ToneMaps.LINEAR,
                /** render some debug output channes, such as for example the normals */
                debugOutput: GltfState.DebugOutput.NONE,
                /**
                 * By default the front face of the environment is +Z (90)
                 * Front faces:
                 * +X = 0 
                 * +Z = 90 
                 * -X = 180 
                 * -Z = 270
                 */
                environmentRotation: 90.0,
                /** If this is set to true, directional lights will be generated if IBL is disabled */
                useDirectionalLightsWithDisabledIBL: false,
                /** MSAA used for cases which are not handled by the browser (e.g. Transmission)*/
                internalMSAA: 4
            };

            // retain a reference to the view with which the state was created, so that it can be validated
            this._view = view;
        }
    }

    /** 
     * ToneMaps enum for the different tonemappings that are supported 
     * by gltf sample viewer
    */
    GltfState.ToneMaps = {
        /** don't apply tone mapping */
        NONE: "None",
        /** ACES sRGB RRT+ODT implementation for 3D Commerce based on Stephen Hill's implementation with a exposure factor of 1.0 / 0.6 */
        ACES_HILL_EXPOSURE_BOOST: "ACES Filmic Tone Mapping (Hill - Exposure Boost)",
        /** fast implementation of the ACES sRGB RRT+ODT based on Krzysztof Narkowicz' implementation*/
        ACES_NARKOWICZ: "ACES Filmic Tone Mapping (Narkowicz)",
        /** more accurate implementation of the ACES sRGB RRT+ODT based on Stephen Hill's implementation*/
        ACES_HILL: "ACES Filmic Tone Mapping (Hill)",
    };

    /**
     * DebugOutput enum for selecting debug output channels
     * such as "NORMAL"
     */
    GltfState.DebugOutput = {
        /** standard rendering - debug output is disabled */
        NONE: "None",

        /** generic debug outputs */
        generic: {
            /** output the texture coordinates 0 */
            UV_COORDS_0: "Texture Coordinates 0",
            /** output the texture coordinates 1 */
            UV_COORDS_1: "Texture Coordinates 1",
            /** output the world space normals (i.e. with TBN applied) */
            NORMAL: "Normal Texture",
            /** output the normal from the TBN*/
            GEOMETRYNORMAL: "Geometry Normal",
            /** output the tangent from the TBN*/
            TANGENT: "Geometry Tangent",
            /** output the bitangent from the TBN */
            BITANGENT: "Geometry Bitangent",
            /** output the world space normals (i.e. with TBN applied) */
            WORLDSPACENORMAL: "Shading Normal",
            /** output the alpha value */
            ALPHA: "Alpha",
            /** output the occlusion value */
            OCCLUSION: "Occlusion",
            /** output the emissive value */
            EMISSIVE: "Emissive",
        },

        /** output metallic roughness */
        mr: {
            /** output the combined metallic roughness */
            METALLIC_ROUGHNESS: "Metallic Roughness",
            /** output the base color value */
            BASECOLOR: "Base Color",
            /** output the metallic value from pbr metallic roughness */
            METALLIC: "Metallic",
            /** output the roughness value from pbr metallic roughness */
            ROUGHNESS: "Roughness",
        },

        /** output clearcoat lighting */
        clearcoat: {
            /** output the combined clear coat */
            CLEARCOAT: "ClearCoat",
            /** output the clear coat factor */
            CLEARCOAT_FACTOR: "ClearCoat Factor",
            /** output the clear coat roughness */
            CLEARCOAT_ROUGHNESS: "ClearCoat Roughness",
            /** output the clear coat normal */
            CLEARCOAT_NORMAL: "ClearCoat Normal",    
        },

        /** output sheen lighting */
        sheen: {
            /** output the combined sheen */
            SHEEN: "Sheen",
            /** output the sheen color*/
            SHEEN_COLOR: "Sheen Color",
            /** output the sheen roughness*/
            SHEEN_ROUGHNESS: "Sheen Roughness",
        },

        /** output specular lighting */
        specular: {
            /** output the combined specular */
            SPECULAR: "Specular",
            /** output the specular factor*/
            SPECULAR_FACTOR: "Specular Factor",
            /** output the specular color*/
            SPECULAR_COLOR: "Specular Color",
        },

        /** output tranmission lighting */
        transmission: {
            /** output the combined transmission/volume */
            TRANSMISSION_VOLUME: "Transmission/Volume",
            /** output the transmission factor*/
            TRANSMISSION_FACTOR: "Transmission Factor",
            /** output the volume thickness*/
            VOLUME_THICKNESS: "Volume Thickness",
        },

        /** output tranmission lighting */
        iridescence: {
            /** output the combined iridescence */
            IRIDESCENCE: "Iridescence",
            /** output the iridescence factor*/
            IRIDESCENCE_FACTOR: "Iridescence Factor",
            /** output the iridescence thickness*/
            IRIDESCENCE_THICKNESS: "Iridescence Thickness",
        },
    };

    const ImageMimeType = {JPEG: "image/jpeg", PNG: "image/png", HDR: "image/vnd.radiance", KTX2: "image/ktx2", GLTEXTURE: "image/texture"};

    let GL = undefined;

    class gltfWebGl
    {
        constructor(context)
        {
            this.context = context;
            if(GL === undefined)
            {
                GL = context;
            }
        }

        loadWebGlExtensions(webglExtensions)
        {
            for (let extension of webglExtensions)
            {
                if (this.context.getExtension(extension) === null)
                {
                    console.warn("Extension " + extension + " not supported!");
                }
            }

            let EXT_texture_filter_anisotropic = this.context.getExtension("EXT_texture_filter_anisotropic");

            if (EXT_texture_filter_anisotropic)
            {
                this.context.anisotropy = EXT_texture_filter_anisotropic.TEXTURE_MAX_ANISOTROPY_EXT;
                this.context.maxAnisotropy = this.context.getParameter(EXT_texture_filter_anisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
                this.context.supports_EXT_texture_filter_anisotropic = true;
            }
            else
            {
                this.context.supports_EXT_texture_filter_anisotropic = false;
            }
        }

        setTexture(loc, gltf, textureInfo, texSlot)
        {
            if (loc === -1)
            {
                return false;
            }

            let gltfTex = gltf.textures[textureInfo.index];

            if (gltfTex === undefined)
            {
                console.warn("Texture is undefined: " + textureInfo.index);
                return false;
            }

            const image = gltf.images[gltfTex.source];
            if (image === undefined)
            {
                console.warn("Image is undefined for texture: " + gltfTex.source);
                return false;
            }

            if (gltfTex.glTexture === undefined)
            {
                if (image.mimeType === ImageMimeType.KTX2 ||
                    image.mimeType === ImageMimeType.GLTEXTURE)
                {
                    // these image resources are directly loaded to a GPU resource by resource loader
                    gltfTex.glTexture = image.image;
                }
                else
                {
                    // other images will be uploaded in a later step
                    gltfTex.glTexture = this.context.createTexture();
                }
            }

            this.context.activeTexture(GL.TEXTURE0 + texSlot);
            this.context.bindTexture(gltfTex.type, gltfTex.glTexture);

            this.context.uniform1i(loc, texSlot);

            if (!gltfTex.initialized)
            {
                const gltfSampler = gltf.samplers[gltfTex.sampler];

                if (gltfSampler === undefined)
                {
                    console.warn("Sampler is undefined for texture: " + textureInfo.index);
                    return false;
                }

                this.context.pixelStorei(GL.UNPACK_FLIP_Y_WEBGL, false);

                // upload images that are not directly loaded as GPU resource
                if (image.mimeType === ImageMimeType.PNG ||
                    image.mimeType === ImageMimeType.JPEG ||
                    image.mimeType === ImageMimeType.HDR)
                {
                    // the check `GL.SRGB8_ALPHA8 === undefined` is needed as at the moment node-gles does not define the full format enum
                    const internalformat = (textureInfo.linear || GL.SRGB8_ALPHA8 === undefined) ? GL.RGBA : GL.SRGB8_ALPHA8;
                    this.context.texImage2D(image.type, image.miplevel, internalformat, GL.RGBA, GL.UNSIGNED_BYTE, image.image);
                }

                this.setSampler(gltfSampler, gltfTex.type, textureInfo.generateMips);

                if (textureInfo.generateMips)
                {
                    switch (gltfSampler.minFilter)
                    {
                    case GL.NEAREST_MIPMAP_NEAREST:
                    case GL.NEAREST_MIPMAP_LINEAR:
                    case GL.LINEAR_MIPMAP_NEAREST:
                    case GL.LINEAR_MIPMAP_LINEAR:
                        this.context.generateMipmap(gltfTex.type);
                        break;
                    }
                }

                gltfTex.initialized = true;
            }

            return gltfTex.initialized;
        }

        setIndices(gltf, accessorIndex)
        {
            let gltfAccessor = gltf.accessors[accessorIndex];

            if (gltfAccessor.glBuffer === undefined)
            {
                gltfAccessor.glBuffer = this.context.createBuffer();

                let data = gltfAccessor.getTypedView(gltf);

                if (data === undefined)
                {
                    return false;
                }

                this.context.bindBuffer(GL.ELEMENT_ARRAY_BUFFER, gltfAccessor.glBuffer);
                this.context.bufferData(GL.ELEMENT_ARRAY_BUFFER, data, GL.STATIC_DRAW);
            }
            else
            {
                this.context.bindBuffer(GL.ELEMENT_ARRAY_BUFFER, gltfAccessor.glBuffer);
            }

            return true;
        }

        enableAttribute(gltf, attributeLocation, gltfAccessor)
        {
            if (attributeLocation === -1)
            {
                console.warn("Tried to access unknown attribute");
                return false;
            }

            if(gltfAccessor.bufferView === undefined)
            {
                console.warn("Tried to access undefined bufferview");
                return true;
            }

            let gltfBufferView = gltf.bufferViews[gltfAccessor.bufferView];

            if (gltfAccessor.glBuffer === undefined)
            {
                gltfAccessor.glBuffer = this.context.createBuffer();

                let data = gltfAccessor.getTypedView(gltf);

                if (data === undefined)
                {
                    return false;
                }

                this.context.bindBuffer(GL.ARRAY_BUFFER, gltfAccessor.glBuffer);
                this.context.bufferData(GL.ARRAY_BUFFER, data, GL.STATIC_DRAW);
            }
            else
            {
                this.context.bindBuffer(GL.ARRAY_BUFFER, gltfAccessor.glBuffer);
            }

            this.context.vertexAttribPointer(attributeLocation, gltfAccessor.getComponentCount(gltfAccessor.type), gltfAccessor.componentType, gltfAccessor.normalized, gltfBufferView.byteStride, 0);
            this.context.enableVertexAttribArray(attributeLocation);

            return true;
        }

        compileShader(shaderIdentifier, isVert, shaderSource)
        {
            const shader = this.context.createShader(isVert ? GL.VERTEX_SHADER : GL.FRAGMENT_SHADER);
            this.context.shaderSource(shader, shaderSource);
            this.context.compileShader(shader);
            const compiled = this.context.getShaderParameter(shader, GL.COMPILE_STATUS);

            if (!compiled)
            {
                // output surrounding source code
                let info = "";
                const messages = this.context.getShaderInfoLog(shader).split("\n");
                for(const message of messages)
                {
                    
                    const matches = message.match(/(WARNING|ERROR): ([0-9]*):([0-9]*):(.*)/i);
                    if (matches && matches.length == 5)
                    {
                        const lineNumber = parseInt(matches[3]) - 1;
                        const lines = shaderSource.split("\n");

                        info += `${matches[1]}: ${shaderIdentifier}+includes:${lineNumber}: ${matches[4]}`;

                        for(let i = Math.max(0, lineNumber - 2); i < Math.min(lines.length, lineNumber + 3); i++)
                        {
                            if (lineNumber === i)
                            {
                                info += "->";
                            }
                            info += "\t" + lines[i] + "\n";
                        }
                    }
                    else
                    {
                        info += message + "\n";
                    }
                }

                throw new Error("Could not compile WebGL program '" + shaderIdentifier + "': " + info);
            }

            return shader;
        }

        linkProgram(vertex, fragment)
        {
            let program = this.context.createProgram();
            this.context.attachShader(program, vertex);
            this.context.attachShader(program, fragment);
            this.context.linkProgram(program);

            if (!this.context.getProgramParameter(program, GL.LINK_STATUS))
            {
                var info = this.context.getProgramInfoLog(program);
                throw new Error('Could not link WebGL program. \n\n' + info);
            }

            return program;
        }

        //https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants
        setSampler(gltfSamplerObj, type, generateMipmaps) // TEXTURE_2D
        {
            if (generateMipmaps)
            {
                this.context.texParameteri(type, GL.TEXTURE_WRAP_S, gltfSamplerObj.wrapS);
                this.context.texParameteri(type, GL.TEXTURE_WRAP_T, gltfSamplerObj.wrapT);
            }
            else
            {
                this.context.texParameteri(type, GL.TEXTURE_WRAP_S, GL.CLAMP_TO_EDGE);
                this.context.texParameteri(type, GL.TEXTURE_WRAP_T, GL.CLAMP_TO_EDGE);
            }

            // If not mip-mapped, force to non-mip-mapped sampler.
            if (!generateMipmaps && (gltfSamplerObj.minFilter != GL.NEAREST) && (gltfSamplerObj.minFilter != GL.LINEAR))
            {
                if ((gltfSamplerObj.minFilter == GL.NEAREST_MIPMAP_NEAREST) || (gltfSamplerObj.minFilter == GL.NEAREST_MIPMAP_LINEAR))
                {
                    this.context.texParameteri(type, GL.TEXTURE_MIN_FILTER, GL.NEAREST);
                }
                else
                {
                    this.context.texParameteri(type, GL.TEXTURE_MIN_FILTER, GL.LINEAR);
                }
            }
            else
            {
                this.context.texParameteri(type, GL.TEXTURE_MIN_FILTER, gltfSamplerObj.minFilter);
            }
            this.context.texParameteri(type, GL.TEXTURE_MAG_FILTER, gltfSamplerObj.magFilter);

            if (this.context.supports_EXT_texture_filter_anisotropic)
            {
                this.context.texParameterf(type, this.context.anisotropy, this.context.maxAnisotropy); // => 16xAF
            }
        }
    }

    class gltfShader
    {
        constructor(program, hash, gl)
        {
            this.program = program;
            this.hash = hash;
            this.uniforms = new Map();
            this.attributes = new Map();
            this.unknownAttributes = [];
            this.unknownUniforms = [];
            this.gl = gl;

            if(this.program !== undefined)
            {
                const uniformCount = this.gl.context.getProgramParameter(this.program, GL.ACTIVE_UNIFORMS);
                for(let i = 0; i < uniformCount; ++i)
                {
                    const info = this.gl.context.getActiveUniform(this.program, i);
                    const loc = this.gl.context.getUniformLocation(this.program, info.name);
                    this.uniforms.set(info.name, {type: info.type, loc: loc});
                }

                const attribCount = this.gl.context.getProgramParameter(this.program, GL.ACTIVE_ATTRIBUTES);
                for(let i = 0; i < attribCount; ++i)
                {
                    const info = this.gl.context.getActiveAttrib(this.program, i);
                    const loc = this.gl.context.getAttribLocation(this.program, info.name);
                    this.attributes.set(info.name, loc);
                }
            }
        }

        destroy()
        {
            if (this.program !== undefined)
            {
                this.deleteProgram(this.program);
            }

            this.program = undefined;
        }

        getAttributeLocation(name)
        {
            const loc = this.attributes.get(name);
            if (loc === undefined)
            {
                if (this.unknownAttributes.find(n => n === name) === undefined)
                {
                    console.log("Attribute '%s' does not exist", name);
                    this.unknownAttributes.push(name);
                }
                return -1;
            }
            return loc;
        }

        getUniformLocation(name)
        {
            const uniform = this.uniforms.get(name);
            if (uniform === undefined)
            {
                if (this.unknownUniforms.find(n => n === name) === undefined)
                {
                    this.unknownUniforms.push(name);
                }
                return -1;
            }
            return uniform.loc;
        }

        updateUniform(objectName, object, log = false)
        {
            if (object instanceof UniformStruct)
            {
                this.updateUniformStruct(objectName, object, log);
            }
            else if (Array.isArray(object))
            {
                this.updateUniformArray(objectName, object, log);
            }
            else
            {
                this.updateUniformValue(objectName, object, log);
            }
        }

        updateUniformArray(arrayName, array, log)
        {
            if(array[0] instanceof UniformStruct)
            {
                for (let i = 0; i < array.length; ++i)
                {
                    let element = array[i];
                    let uniformName = arrayName + "[" + i + "]";
                    this.updateUniform(uniformName, element, log);
                }
            }else {
                let uniformName = arrayName + "[0]";

                let flat = [];

                if(Array.isArray(array[0]) || array[0].length !== undefined)
                {
                    for (let i = 0; i < array.length; ++i)
                    {
                        flat.push.apply(flat, Array.from(array[i]));
                    }
                }
                else
                {
                    flat = array;
                }

                if(flat.length === 0)
                {
                    console.error("Failed to flatten uniform array " + uniformName);
                    return;
                }

                this.updateUniformValue(uniformName, flat, log);
            }
        }

        updateUniformStruct(structName, object, log)
        {
            let memberNames = Object.keys(object);
            for (let memberName of memberNames)
            {
                let uniformName = structName + "." + memberName;
                this.updateUniform(uniformName, object[memberName], log);
            }
        }

        // upload the values of a uniform with the given name using type resolve to get correct function call
        updateUniformValue(uniformName, value, log)
        {
            const uniform = this.uniforms.get(uniformName);

            if(uniform !== undefined)
            {
                switch (uniform.type) {
                case GL.FLOAT:
                {
                    if(Array.isArray(value) || value instanceof Float32Array)
                    {
                        this.gl.context.uniform1fv(uniform.loc, value);
                    }else {
                        this.gl.context.uniform1f(uniform.loc, value);
                    }
                    break;
                }
                case GL.FLOAT_VEC2: this.gl.context.uniform2fv(uniform.loc, value); break;
                case GL.FLOAT_VEC3: this.gl.context.uniform3fv(uniform.loc, value); break;
                case GL.FLOAT_VEC4: this.gl.context.uniform4fv(uniform.loc, value); break;

                case GL.INT:
                {
                    if(Array.isArray(value) || value instanceof Uint32Array || value instanceof Int32Array)
                    {
                        this.gl.context.uniform1iv(uniform.loc, value);
                    }else {
                        this.gl.context.uniform1i(uniform.loc, value);
                    }
                    break;
                }
                case GL.INT_VEC2: this.gl.context.uniform2iv(uniform.loc, value); break;
                case GL.INT_VEC3: this.gl.context.uniform3iv(uniform.loc, value); break;
                case GL.INT_VEC4: this.gl.context.uniform4iv(uniform.loc, value); break;

                case GL.FLOAT_MAT2: this.gl.context.uniformMatrix2fv(uniform.loc, false, value); break;
                case GL.FLOAT_MAT3: this.gl.context.uniformMatrix3fv(uniform.loc, false, value); break;
                case GL.FLOAT_MAT4: this.gl.context.uniformMatrix4fv(uniform.loc, false, value); break;
                }
            }
            else if(log)
            {
                console.warn("Unkown uniform: " + uniformName);
            }
        }
    }

    // THis class generates and caches the shader source text for a given permutation
    class ShaderCache
    {
        constructor(sources, gl)
        {
            this.sources  = sources; // shader name -> source code
            this.shaders  = new Map(); // name & permutations hashed -> compiled shader
            this.programs = new Map(); // (vertex shader, fragment shader) -> program
            this.gl = gl;

            // resovle / expande sources (TODO: break include cycles)
            for (let [key, src] of this.sources)
            {
                let changed = false;
                for (let [includeName, includeSource] of this.sources)
                {
                    //var pattern = RegExp(/#include</ + includeName + />/);
                    const pattern = "#include <" + includeName + ">";

                    if(src.includes(pattern))
                    {
                        // only replace the first occurance
                        src = src.replace(pattern, includeSource);

                        // remove the others
                        while (src.includes(pattern))
                        {
                            src = src.replace(pattern, "");
                        }

                        changed = true;
                    }
                }

                if(changed)
                {
                    this.sources.set(key, src);
                }
            }
        }

        destroy()
        {
            for (let [, shader] of this.shaders.entries())
            {
                this.gl.context.deleteShader(shader);
                shader = undefined;
            }

            this.shaders.clear();

            for (let [, program] of this.programs)
            {
                program.destroy();
            }

            this.programs.clear();
        }

        // example args: "pbr.vert", ["NORMALS", "TANGENTS"]
        selectShader(shaderIdentifier, permutationDefines)
        {
            // first check shaders for the exact permutation
            // if not present, check sources and compile it
            // if not present, return null object

            const src = this.sources.get(shaderIdentifier);
            if(src === undefined)
            {
                console.log("Shader source for " + shaderIdentifier + " not found");
                return null;
            }

            const isVert = shaderIdentifier.endsWith(".vert");
            let hash = stringHash(shaderIdentifier);

            // console.log(shaderIdentifier);

            let defines = "#version 300 es\n";
            for(let define of permutationDefines)
            {
                // console.log(define);
                hash ^= stringHash(define);
                defines += "#define " + define + "\n";
            }

            let shader = this.shaders.get(hash);

            if(shader === undefined)
            {
                // console.log(defines);
                // compile this variant
                shader = this.gl.compileShader(shaderIdentifier, isVert, defines + src);
                this.shaders.set(hash, shader);
            }

            return hash;
        }

        getShaderProgram(vertexShaderHash, fragmentShaderHash)
        {
            // just use a long string for this (the javascript engine should be fast enough with comparing this)
            const hash = String(vertexShaderHash) + "," + String(fragmentShaderHash);

            let program = this.programs.get(hash);

            if (program) // program already linked
            {
                return program;
            }
            else // link this shader program type!
            {
                let linkedProg = this.gl.linkProgram(this.shaders.get(vertexShaderHash), this.shaders.get(fragmentShaderHash));
                if(linkedProg)
                {
                    let program = new gltfShader(linkedProg, hash, this.gl);
                    this.programs.set(hash, program);
                    return program;
                }
            }

            return undefined;
        }
    }

    class EnvironmentRenderer
    {
        constructor(webgl)
        {
            const gl = webgl.context;

            this.indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([
                1, 2, 0,
                2, 3, 0,
                6, 2, 1,
                1, 5, 6,
                6, 5, 4,
                4, 7, 6,
                6, 3, 2,
                7, 3, 6,
                3, 7, 0,
                7, 4, 0,
                5, 1, 0,
                4, 5, 0
            ]), gl.STATIC_DRAW);

            this.vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                -1, -1, -1,
                 1, -1, -1,
                 1,  1, -1,
                -1,  1, -1,
                -1, -1,  1,
                 1, -1,  1,
                 1,  1,  1,
                -1,  1,  1
            ]), gl.STATIC_DRAW);
        }

        drawEnvironmentMap(webGl, viewProjectionMatrix, state, shaderCache, fragDefines)
        {
            if (state.environment == undefined || state.renderingParameters.renderEnvironmentMap == false)
            {
                return;
            }

            const gl = webGl.context;

            const vertShader = shaderCache.selectShader("cubemap.vert", []);
            const fragShader = shaderCache.selectShader("cubemap.frag", fragDefines);
            const shader = shaderCache.getShaderProgram(vertShader, fragShader);

            gl.useProgram(shader.program);
            webGl.setTexture(shader.getUniformLocation("u_GGXEnvSampler"), state.environment, state.environment.specularEnvMap, 0);
            shader.updateUniform("u_MipCount", state.environment.mipCount);
            shader.updateUniform("u_EnvBlurNormalized", state.renderingParameters.blurEnvironmentMap ? 0.6 : 0.0);
            shader.updateUniform("u_EnvIntensity", state.renderingParameters.iblIntensity);

            shader.updateUniform("u_ViewProjectionMatrix", viewProjectionMatrix);
            shader.updateUniform("u_Exposure", state.renderingParameters.exposure, false);

            let rotMatrix4 = glMatrix.mat4.create();
            glMatrix.mat4.rotateY(rotMatrix4, rotMatrix4,  state.renderingParameters.environmentRotation / 180.0 * Math.PI);
            let rotMatrix3 = glMatrix.mat3.create();
            glMatrix.mat3.fromMat4(rotMatrix3, rotMatrix4);
            shader.updateUniform("u_EnvRotation", rotMatrix3);

            gl.frontFace(gl.CCW);
            gl.enable(gl.CULL_FACE);
            gl.disable(gl.BLEND);
            gl.disable(gl.DEPTH_TEST);

            const positionAttributeLocation = shader.getAttributeLocation("a_position");
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
            gl.vertexAttribPointer(positionAttributeLocation, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(positionAttributeLocation);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            gl.enable(gl.DEPTH_TEST);
        }
    }

    var pbrShader = "//\n// This fragment shader defines a reference implementation for Physically Based Shading of\n// a microfacet surface material defined by a glTF model.\n//\n// References:\n// [1] Real Shading in Unreal Engine 4\n//     http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\n// [2] Physically Based Shading at Disney\n//     http://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf\n// [3] README.md - Environment Maps\n//     https://github.com/KhronosGroup/glTF-WebGL-PBR/#environment-maps\n// [4] \"An Inexpensive BRDF Model for Physically based Rendering\" by Christophe Schlick\n//     https://www.cs.virginia.edu/~jdl/bib/appearance/analytic%20models/schlick94b.pdf\n// [5] \"KHR_materials_clearcoat\"\n//     https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n\nprecision highp float;\n#define GLSLIFY 1\n\n#include <tonemapping.glsl>\n#include <textures.glsl>\n#include <functions.glsl>\n#include <brdf.glsl>\n#include <punctual.glsl>\n#include <ibl.glsl>\n#include <material_info.glsl>\n\n#ifdef MATERIAL_IRIDESCENCE\n#include <iridescence.glsl>\n#endif\n\nout vec4 g_finalColor;\n\nvoid main()\n{\n    vec4 baseColor = getBaseColor();\n\n#if ALPHAMODE == ALPHAMODE_OPAQUE\n    baseColor.a = 1.0;\n#endif\n\n    vec3 v = normalize(u_Camera - v_Position);\n    NormalInfo normalInfo = getNormalInfo(v);\n    vec3 n = normalInfo.n;\n    vec3 t = normalInfo.t;\n    vec3 b = normalInfo.b;\n\n    float NdotV = clampedDot(n, v);\n    float TdotV = clampedDot(t, v);\n    float BdotV = clampedDot(b, v);\n\n    MaterialInfo materialInfo;\n    materialInfo.baseColor = baseColor.rgb;\n    \n    // The default index of refraction of 1.5 yields a dielectric normal incidence reflectance of 0.04.\n    materialInfo.ior = 1.5;\n    materialInfo.f0 = vec3(0.04);\n    materialInfo.specularWeight = 1.0;\n\n    // If the MR debug output is selected, we have to enforce evaluation of the non-iridescence BRDF functions.\n#if DEBUG == DEBUG_METALLIC_ROUGHNESS\n#undef MATERIAL_IRIDESCENCE\n#endif\n\n#ifdef MATERIAL_IOR\n    materialInfo = getIorInfo(materialInfo);\n#endif\n\n#ifdef MATERIAL_SPECULARGLOSSINESS\n    materialInfo = getSpecularGlossinessInfo(materialInfo);\n#endif\n\n#ifdef MATERIAL_METALLICROUGHNESS\n    materialInfo = getMetallicRoughnessInfo(materialInfo);\n#endif\n\n#ifdef MATERIAL_SHEEN\n    materialInfo = getSheenInfo(materialInfo);\n#endif\n\n#ifdef MATERIAL_CLEARCOAT\n    materialInfo = getClearCoatInfo(materialInfo, normalInfo);\n#endif\n\n#ifdef MATERIAL_SPECULAR\n    materialInfo = getSpecularInfo(materialInfo);\n#endif\n\n#ifdef MATERIAL_TRANSMISSION\n    materialInfo = getTransmissionInfo(materialInfo);\n#endif\n\n#ifdef MATERIAL_VOLUME\n    materialInfo = getVolumeInfo(materialInfo);\n#endif\n\n#ifdef MATERIAL_IRIDESCENCE\n    materialInfo = getIridescenceInfo(materialInfo);\n#endif\n\n    materialInfo.perceptualRoughness = clamp(materialInfo.perceptualRoughness, 0.0, 1.0);\n    materialInfo.metallic = clamp(materialInfo.metallic, 0.0, 1.0);\n\n    // Roughness is authored as perceptual roughness; as is convention,\n    // convert to material roughness by squaring the perceptual roughness.\n    materialInfo.alphaRoughness = materialInfo.perceptualRoughness * materialInfo.perceptualRoughness;\n\n    // Compute reflectance.\n    float reflectance = max(max(materialInfo.f0.r, materialInfo.f0.g), materialInfo.f0.b);\n\n    // Anything less than 2% is physically impossible and is instead considered to be shadowing. Compare to \"Real-Time-Rendering\" 4th editon on page 325.\n    materialInfo.f90 = vec3(1.0);\n\n    // LIGHTING\n    vec3 f_specular = vec3(0.0);\n    vec3 f_diffuse = vec3(0.0);\n    vec3 f_emissive = vec3(0.0);\n    vec3 f_clearcoat = vec3(0.0);\n    vec3 f_sheen = vec3(0.0);\n    vec3 f_transmission = vec3(0.0);\n\n    float albedoSheenScaling = 1.0;\n\n#ifdef MATERIAL_IRIDESCENCE\n    vec3 iridescenceFresnel = materialInfo.f0;\n    vec3 iridescenceF0 = materialInfo.f0;\n\n    if (materialInfo.iridescenceThickness == 0.0) {\n        materialInfo.iridescenceFactor = 0.0;\n    }\n\n    if (materialInfo.iridescenceFactor > 0.0) {\n        iridescenceFresnel = evalIridescence(1.0, materialInfo.iridescenceIor, NdotV, materialInfo.iridescenceThickness, materialInfo.f0);\n        iridescenceF0 = Schlick_to_F0(iridescenceFresnel, NdotV);\n    }\n#endif\n\n    // Calculate lighting contribution from image based lighting source (IBL)\n#ifdef USE_IBL\n#ifdef MATERIAL_IRIDESCENCE\n    f_specular += getIBLRadianceGGXIridescence(n, v, materialInfo.perceptualRoughness, materialInfo.f0, iridescenceFresnel, materialInfo.iridescenceFactor, materialInfo.specularWeight);\n    f_diffuse += getIBLRadianceLambertianIridescence(n, v, materialInfo.perceptualRoughness, materialInfo.c_diff, materialInfo.f0, iridescenceF0, materialInfo.iridescenceFactor, materialInfo.specularWeight);\n#else\n    f_specular += getIBLRadianceGGX(n, v, materialInfo.perceptualRoughness, materialInfo.f0, materialInfo.specularWeight);\n    f_diffuse += getIBLRadianceLambertian(n, v, materialInfo.perceptualRoughness, materialInfo.c_diff, materialInfo.f0, materialInfo.specularWeight);\n#endif\n\n#ifdef MATERIAL_CLEARCOAT\n    f_clearcoat += getIBLRadianceGGX(materialInfo.clearcoatNormal, v, materialInfo.clearcoatRoughness, materialInfo.clearcoatF0, 1.0);\n#endif\n\n#ifdef MATERIAL_SHEEN\n    f_sheen += getIBLRadianceCharlie(n, v, materialInfo.sheenRoughnessFactor, materialInfo.sheenColorFactor);\n#endif\n#endif\n\n#if defined(MATERIAL_TRANSMISSION) && (defined(USE_PUNCTUAL) || defined(USE_IBL))\n    f_transmission += getIBLVolumeRefraction(\n        n, v,\n        materialInfo.perceptualRoughness,\n        materialInfo.c_diff, materialInfo.f0, materialInfo.f90,\n        v_Position, u_ModelMatrix, u_ViewMatrix, u_ProjectionMatrix,\n        materialInfo.ior, materialInfo.thickness, materialInfo.attenuationColor, materialInfo.attenuationDistance);\n#endif\n\n    float ao = 1.0;\n    // Apply optional PBR terms for additional (optional) shading\n#ifdef HAS_OCCLUSION_MAP\n    ao = texture(u_OcclusionSampler,  getOcclusionUV()).r;\n    f_diffuse = mix(f_diffuse, f_diffuse * ao, u_OcclusionStrength);\n    // apply ambient occlusion to all lighting that is not punctual\n    f_specular = mix(f_specular, f_specular * ao, u_OcclusionStrength);\n    f_sheen = mix(f_sheen, f_sheen * ao, u_OcclusionStrength);\n    f_clearcoat = mix(f_clearcoat, f_clearcoat * ao, u_OcclusionStrength);\n#endif\n\n#ifdef USE_PUNCTUAL\n    for (int i = 0; i < LIGHT_COUNT; ++i)\n    {\n        Light light = u_Lights[i];\n\n        vec3 pointToLight;\n        if (light.type != LightType_Directional)\n        {\n            pointToLight = light.position - v_Position;\n        }\n        else\n        {\n            pointToLight = -light.direction;\n        }\n\n        // BSTF\n        vec3 l = normalize(pointToLight);   // Direction from surface point to light\n        vec3 h = normalize(l + v);          // Direction of the vector between l and v, called halfway vector\n        float NdotL = clampedDot(n, l);\n        float NdotV = clampedDot(n, v);\n        float NdotH = clampedDot(n, h);\n        float LdotH = clampedDot(l, h);\n        float VdotH = clampedDot(v, h);\n        if (NdotL > 0.0 || NdotV > 0.0)\n        {\n            // Calculation of analytical light\n            // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#acknowledgments AppendixB\n            vec3 intensity = getLighIntensity(light, pointToLight);\n#ifdef MATERIAL_IRIDESCENCE\n            f_diffuse += intensity * NdotL *  BRDF_lambertianIridescence(materialInfo.f0, materialInfo.f90, iridescenceFresnel, materialInfo.iridescenceFactor, materialInfo.c_diff, materialInfo.specularWeight, VdotH);\n            f_specular += intensity * NdotL * BRDF_specularGGXIridescence(materialInfo.f0, materialInfo.f90, iridescenceFresnel, materialInfo.alphaRoughness, materialInfo.iridescenceFactor, materialInfo.specularWeight, VdotH, NdotL, NdotV, NdotH);\n#else\n            f_diffuse += intensity * NdotL *  BRDF_lambertian(materialInfo.f0, materialInfo.f90, materialInfo.c_diff, materialInfo.specularWeight, VdotH);\n            f_specular += intensity * NdotL * BRDF_specularGGX(materialInfo.f0, materialInfo.f90, materialInfo.alphaRoughness, materialInfo.specularWeight, VdotH, NdotL, NdotV, NdotH);\n#endif\n\n#ifdef MATERIAL_SHEEN\n            f_sheen += intensity * getPunctualRadianceSheen(materialInfo.sheenColorFactor, materialInfo.sheenRoughnessFactor, NdotL, NdotV, NdotH);\n            albedoSheenScaling = min(1.0 - max3(materialInfo.sheenColorFactor) * albedoSheenScalingLUT(NdotV, materialInfo.sheenRoughnessFactor),\n                1.0 - max3(materialInfo.sheenColorFactor) * albedoSheenScalingLUT(NdotL, materialInfo.sheenRoughnessFactor));\n#endif\n\n#ifdef MATERIAL_CLEARCOAT\n            f_clearcoat += intensity * getPunctualRadianceClearCoat(materialInfo.clearcoatNormal, v, l, h, VdotH,\n                materialInfo.clearcoatF0, materialInfo.clearcoatF90, materialInfo.clearcoatRoughness);\n#endif\n        }\n\n        // BDTF\n#ifdef MATERIAL_TRANSMISSION\n        // If the light ray travels through the geometry, use the point it exits the geometry again.\n        // That will change the angle to the light source, if the material refracts the light ray.\n        vec3 transmissionRay = getVolumeTransmissionRay(n, v, materialInfo.thickness, materialInfo.ior, u_ModelMatrix);\n        pointToLight -= transmissionRay;\n        l = normalize(pointToLight);\n\n        vec3 intensity = getLighIntensity(light, pointToLight);\n        vec3 transmittedLight = intensity * getPunctualRadianceTransmission(n, v, l, materialInfo.alphaRoughness, materialInfo.f0, materialInfo.f90, materialInfo.c_diff, materialInfo.ior);\n\n#ifdef MATERIAL_VOLUME\n        transmittedLight = applyVolumeAttenuation(transmittedLight, length(transmissionRay), materialInfo.attenuationColor, materialInfo.attenuationDistance);\n#endif\n\n        f_transmission += transmittedLight;\n#endif\n    }\n#endif\n\n    f_emissive = u_EmissiveFactor;\n#ifdef MATERIAL_EMISSIVE_STRENGTH\n    f_emissive *= u_EmissiveStrength;\n#endif\n#ifdef HAS_EMISSIVE_MAP\n    f_emissive *= texture(u_EmissiveSampler, getEmissiveUV()).rgb;\n#endif\n\n    // Layer blending\n\n    float clearcoatFactor = 0.0;\n    vec3 clearcoatFresnel = vec3(0);\n\n#ifdef MATERIAL_CLEARCOAT\n    clearcoatFactor = materialInfo.clearcoatFactor;\n    clearcoatFresnel = F_Schlick(materialInfo.clearcoatF0, materialInfo.clearcoatF90, clampedDot(materialInfo.clearcoatNormal, v));\n    f_clearcoat = f_clearcoat * clearcoatFactor;\n#endif\n\n#ifdef MATERIAL_TRANSMISSION\n    vec3 diffuse = mix(f_diffuse, f_transmission, materialInfo.transmissionFactor);\n#else\n    vec3 diffuse = f_diffuse;\n#endif\n\n    vec3 color = vec3(0);\n#ifdef MATERIAL_UNLIT\n    color = baseColor.rgb;\n#else\n    color = f_emissive + diffuse + f_specular;\n    color = f_sheen + color * albedoSheenScaling;\n    color = color * (1.0 - clearcoatFactor * clearcoatFresnel) + f_clearcoat;\n#endif\n\n#if DEBUG == DEBUG_NONE\n\n#if ALPHAMODE == ALPHAMODE_MASK\n    // Late discard to avoid samplig artifacts. See https://github.com/KhronosGroup/glTF-Sample-Viewer/issues/267\n    if (baseColor.a < u_AlphaCutoff)\n    {\n        discard;\n    }\n    baseColor.a = 1.0;\n#endif\n\n#ifdef LINEAR_OUTPUT\n    g_finalColor = vec4(color.rgb, baseColor.a);\n#else\n    g_finalColor = vec4(toneMap(color), baseColor.a);\n#endif\n\n#else\n    // In case of missing data for a debug view, render a magenta stripe pattern.\n    g_finalColor = vec4(1, 0, 1, 1);\n    g_finalColor.rb = vec2(max(2.0 * sin(0.1 * (gl_FragCoord.x + gl_FragCoord.y)), 0.0) + 0.3);\n#endif\n\n    // Debug views:\n\n    // Generic:\n#if DEBUG == DEBUG_UV_0 && defined(HAS_TEXCOORD_0_VEC2)\n    g_finalColor.rgb = vec3(v_texcoord_0, 0);\n#endif\n#if DEBUG == DEBUG_UV_1 && defined(HAS_TEXCOORD_1_VEC2)\n    g_finalColor.rgb = vec3(v_texcoord_1, 0);\n#endif\n#if DEBUG == DEBUG_NORMAL_TEXTURE && defined(HAS_NORMAL_MAP)\n    g_finalColor.rgb = (normalInfo.ntex + 1.0) / 2.0;\n#endif\n#if DEBUG == DEBUG_NORMAL_SHADING\n    g_finalColor.rgb = (n + 1.0) / 2.0;\n#endif\n#if DEBUG == DEBUG_NORMAL_GEOMETRY\n    g_finalColor.rgb = (normalInfo.ng + 1.0) / 2.0;\n#endif\n#if DEBUG == DEBUG_TANGENT\n    g_finalColor.rgb = (normalInfo.t + 1.0) / 2.0;\n#endif\n#if DEBUG == DEBUG_BITANGENT\n    g_finalColor.rgb = (normalInfo.b + 1.0) / 2.0;\n#endif\n#if DEBUG == DEBUG_ALPHA\n    g_finalColor.rgb = linearTosRGB(vec3(baseColor.a));\n#endif\n#if DEBUG == DEBUG_OCCLUSION && defined(HAS_OCCLUSION_MAP)\n    g_finalColor.rgb = linearTosRGB(vec3(ao));\n#endif\n#if DEBUG == DEBUG_EMISSIVE\n    g_finalColor.rgb = linearTosRGB(f_emissive);\n#endif\n\n    // MR:\n#ifdef MATERIAL_METALLICROUGHNESS\n#if DEBUG == DEBUG_METALLIC_ROUGHNESS\n    g_finalColor.rgb = linearTosRGB(f_diffuse + f_specular);\n#endif\n#if DEBUG == DEBUG_METALLIC\n    g_finalColor.rgb = linearTosRGB(vec3(materialInfo.metallic));\n#endif\n#if DEBUG == DEBUG_ROUGHNESS\n    g_finalColor.rgb = linearTosRGB(vec3(materialInfo.perceptualRoughness));\n#endif\n#if DEBUG == DEBUG_BASE_COLOR\n    g_finalColor.rgb = linearTosRGB(materialInfo.baseColor);\n#endif\n#endif\n\n    // Clearcoat:\n#ifdef MATERIAL_CLEARCOAT\n#if DEBUG == DEBUG_CLEARCOAT\n    g_finalColor.rgb = linearTosRGB(f_clearcoat);\n#endif\n#if DEBUG == DEBUG_CLEARCOAT_FACTOR\n    g_finalColor.rgb = linearTosRGB(vec3(materialInfo.clearcoatFactor));\n#endif\n#if DEBUG == DEBUG_CLEARCOAT_ROUGHNESS\n    g_finalColor.rgb = linearTosRGB(vec3(materialInfo.clearcoatRoughness));\n#endif\n#if DEBUG == DEBUG_CLEARCOAT_NORMAL\n    g_finalColor.rgb = (materialInfo.clearcoatNormal + vec3(1)) / 2.0;\n#endif\n#endif\n\n    // Sheen:\n#ifdef MATERIAL_SHEEN\n#if DEBUG == DEBUG_SHEEN\n    g_finalColor.rgb = linearTosRGB(f_sheen);\n#endif\n#if DEBUG == DEBUG_SHEEN_COLOR\n    g_finalColor.rgb = linearTosRGB(materialInfo.sheenColorFactor);\n#endif\n#if DEBUG == DEBUG_SHEEN_ROUGHNESS\n    g_finalColor.rgb = linearTosRGB(vec3(materialInfo.sheenRoughnessFactor));\n#endif\n#endif\n\n    // Specular:\n#ifdef MATERIAL_SPECULAR\n#if DEBUG == DEBUG_SPECULAR\n    g_finalColor.rgb = linearTosRGB(f_specular);\n#endif\n#if DEBUG == DEBUG_SPECULAR_FACTOR\n    g_finalColor.rgb = vec3(materialInfo.specularWeight);\n#endif\n\n#if DEBUG == DEBUG_SPECULAR_COLOR\nvec3 specularTexture = vec3(1.0);\n#ifdef HAS_SPECULAR_COLOR_MAP\n    specularTexture.rgb = texture(u_SpecularColorSampler, getSpecularColorUV()).rgb;\n#endif\n    g_finalColor.rgb = u_KHR_materials_specular_specularColorFactor * specularTexture.rgb;\n#endif\n#endif\n\n    // Transmission, Volume:\n#ifdef MATERIAL_TRANSMISSION\n#if DEBUG == DEBUG_TRANSMISSION_VOLUME\n    g_finalColor.rgb = linearTosRGB(f_transmission);\n#endif\n#if DEBUG == DEBUG_TRANSMISSION_FACTOR\n    g_finalColor.rgb = linearTosRGB(vec3(materialInfo.transmissionFactor));\n#endif\n#endif\n#ifdef MATERIAL_VOLUME\n#if DEBUG == DEBUG_VOLUME_THICKNESS\n    g_finalColor.rgb = linearTosRGB(vec3(materialInfo.thickness));\n#endif\n#endif\n\n    // Iridescence:\n#ifdef MATERIAL_IRIDESCENCE\n#if DEBUG == DEBUG_IRIDESCENCE\n    g_finalColor.rgb = linearTosRGB(iridescenceFresnel);\n#endif\n#if DEBUG == DEBUG_IRIDESCENCE_FACTOR\n    g_finalColor.rgb = linearTosRGB(vec3(materialInfo.iridescenceFactor));\n#endif\n#if DEBUG == DEBUG_IRIDESCENCE_THICKNESS\n    g_finalColor.rgb = linearTosRGB(vec3(materialInfo.iridescenceThickness / 1200.0));\n#endif\n#endif\n}\n"; // eslint-disable-line

    var brdfShader = "#define GLSLIFY 1\n//\n// Fresnel\n//\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// https://github.com/wdas/brdf/tree/master/src/brdfs\n// https://google.github.io/filament/Filament.md.html\n//\n\n// The following equation models the Fresnel reflectance term of the spec equation (aka F())\n// Implementation of fresnel from [4], Equation 15\nvec3 F_Schlick(vec3 f0, vec3 f90, float VdotH)\n{\n    return f0 + (f90 - f0) * pow(clamp(1.0 - VdotH, 0.0, 1.0), 5.0);\n}\n\nfloat F_Schlick(float f0, float f90, float VdotH)\n{\n    float x = clamp(1.0 - VdotH, 0.0, 1.0);\n    float x2 = x * x;\n    float x5 = x * x2 * x2;\n    return f0 + (f90 - f0) * x5;\n}\n\nfloat F_Schlick(float f0, float VdotH)\n{\n    float f90 = 1.0; //clamp(50.0 * f0, 0.0, 1.0);\n    return F_Schlick(f0, f90, VdotH);\n}\n\nvec3 F_Schlick(vec3 f0, float f90, float VdotH)\n{\n    float x = clamp(1.0 - VdotH, 0.0, 1.0);\n    float x2 = x * x;\n    float x5 = x * x2 * x2;\n    return f0 + (f90 - f0) * x5;\n}\n\nvec3 F_Schlick(vec3 f0, float VdotH)\n{\n    float f90 = 1.0; //clamp(dot(f0, vec3(50.0 * 0.33)), 0.0, 1.0);\n    return F_Schlick(f0, f90, VdotH);\n}\n\nvec3 Schlick_to_F0(vec3 f, vec3 f90, float VdotH) {\n    float x = clamp(1.0 - VdotH, 0.0, 1.0);\n    float x2 = x * x;\n    float x5 = clamp(x * x2 * x2, 0.0, 0.9999);\n\n    return (f - f90 * x5) / (1.0 - x5);\n}\n\nfloat Schlick_to_F0(float f, float f90, float VdotH) {\n    float x = clamp(1.0 - VdotH, 0.0, 1.0);\n    float x2 = x * x;\n    float x5 = clamp(x * x2 * x2, 0.0, 0.9999);\n\n    return (f - f90 * x5) / (1.0 - x5);\n}\n\nvec3 Schlick_to_F0(vec3 f, float VdotH) {\n    return Schlick_to_F0(f, vec3(1.0), VdotH);\n}\n\nfloat Schlick_to_F0(float f, float VdotH) {\n    return Schlick_to_F0(f, 1.0, VdotH);\n}\n\n// Smith Joint GGX\n// Note: Vis = G / (4 * NdotL * NdotV)\n// see Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs. Journal of Computer Graphics Techniques, 3\n// see Real-Time Rendering. Page 331 to 336.\n// see https://google.github.io/filament/Filament.md.html#materialsystem/specularbrdf/geometricshadowing(specularg)\nfloat V_GGX(float NdotL, float NdotV, float alphaRoughness)\n{\n    float alphaRoughnessSq = alphaRoughness * alphaRoughness;\n\n    float GGXV = NdotL * sqrt(NdotV * NdotV * (1.0 - alphaRoughnessSq) + alphaRoughnessSq);\n    float GGXL = NdotV * sqrt(NdotL * NdotL * (1.0 - alphaRoughnessSq) + alphaRoughnessSq);\n\n    float GGX = GGXV + GGXL;\n    if (GGX > 0.0)\n    {\n        return 0.5 / GGX;\n    }\n    return 0.0;\n}\n\n// The following equation(s) model the distribution of microfacet normals across the area being drawn (aka D())\n// Implementation from \"Average Irregularity Representation of a Roughened Surface for Ray Reflection\" by T. S. Trowbridge, and K. P. Reitz\n// Follows the distribution function recommended in the SIGGRAPH 2013 course notes from EPIC Games [1], Equation 3.\nfloat D_GGX(float NdotH, float alphaRoughness)\n{\n    float alphaRoughnessSq = alphaRoughness * alphaRoughness;\n    float f = (NdotH * NdotH) * (alphaRoughnessSq - 1.0) + 1.0;\n    return alphaRoughnessSq / (M_PI * f * f);\n}\n\nfloat lambdaSheenNumericHelper(float x, float alphaG)\n{\n    float oneMinusAlphaSq = (1.0 - alphaG) * (1.0 - alphaG);\n    float a = mix(21.5473, 25.3245, oneMinusAlphaSq);\n    float b = mix(3.82987, 3.32435, oneMinusAlphaSq);\n    float c = mix(0.19823, 0.16801, oneMinusAlphaSq);\n    float d = mix(-1.97760, -1.27393, oneMinusAlphaSq);\n    float e = mix(-4.32054, -4.85967, oneMinusAlphaSq);\n    return a / (1.0 + b * pow(x, c)) + d * x + e;\n}\n\nfloat lambdaSheen(float cosTheta, float alphaG)\n{\n    if (abs(cosTheta) < 0.5)\n    {\n        return exp(lambdaSheenNumericHelper(cosTheta, alphaG));\n    }\n    else\n    {\n        return exp(2.0 * lambdaSheenNumericHelper(0.5, alphaG) - lambdaSheenNumericHelper(1.0 - cosTheta, alphaG));\n    }\n}\n\nfloat V_Sheen(float NdotL, float NdotV, float sheenRoughness)\n{\n    sheenRoughness = max(sheenRoughness, 0.000001); //clamp (0,1]\n    float alphaG = sheenRoughness * sheenRoughness;\n\n    return clamp(1.0 / ((1.0 + lambdaSheen(NdotV, alphaG) + lambdaSheen(NdotL, alphaG)) *\n        (4.0 * NdotV * NdotL)), 0.0, 1.0);\n}\n\n//Sheen implementation-------------------------------------------------------------------------------------\n// See  https://github.com/sebavan/glTF/tree/KHR_materials_sheen/extensions/2.0/Khronos/KHR_materials_sheen\n\n// Estevez and Kulla http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\nfloat D_Charlie(float sheenRoughness, float NdotH)\n{\n    sheenRoughness = max(sheenRoughness, 0.000001); //clamp (0,1]\n    float alphaG = sheenRoughness * sheenRoughness;\n    float invR = 1.0 / alphaG;\n    float cos2h = NdotH * NdotH;\n    float sin2h = 1.0 - cos2h;\n    return (2.0 + invR) * pow(sin2h, invR * 0.5) / (2.0 * M_PI);\n}\n\n//https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#acknowledgments AppendixB\nvec3 BRDF_lambertian(vec3 f0, vec3 f90, vec3 diffuseColor, float specularWeight, float VdotH)\n{\n    // see https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/\n    return (1.0 - specularWeight * F_Schlick(f0, f90, VdotH)) * (diffuseColor / M_PI);\n}\n\n#ifdef MATERIAL_IRIDESCENCE\n//https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#acknowledgments AppendixB\nvec3 BRDF_lambertianIridescence(vec3 f0, vec3 f90, vec3 iridescenceFresnel, float iridescenceFactor, vec3 diffuseColor, float specularWeight, float VdotH)\n{\n    // Use the maximum component of the iridescence Fresnel color\n    // Maximum is used instead of the RGB value to not get inverse colors for the diffuse BRDF\n    vec3 iridescenceFresnelMax = vec3(max(max(iridescenceFresnel.r, iridescenceFresnel.g), iridescenceFresnel.b));\n\n    vec3 schlickFresnel = F_Schlick(f0, f90, VdotH);\n\n    // Blend default specular Fresnel with iridescence Fresnel\n    vec3 F = mix(schlickFresnel, iridescenceFresnelMax, iridescenceFactor);\n\n    // see https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/\n    return (1.0 - specularWeight * F) * (diffuseColor / M_PI);\n}\n#endif\n\n//  https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#acknowledgments AppendixB\nvec3 BRDF_specularGGX(vec3 f0, vec3 f90, float alphaRoughness, float specularWeight, float VdotH, float NdotL, float NdotV, float NdotH)\n{\n    vec3 F = F_Schlick(f0, f90, VdotH);\n    float Vis = V_GGX(NdotL, NdotV, alphaRoughness);\n    float D = D_GGX(NdotH, alphaRoughness);\n\n    return specularWeight * F * Vis * D;\n}\n\n#ifdef MATERIAL_IRIDESCENCE\nvec3 BRDF_specularGGXIridescence(vec3 f0, vec3 f90, vec3 iridescenceFresnel, float alphaRoughness, float iridescenceFactor, float specularWeight, float VdotH, float NdotL, float NdotV, float NdotH)\n{\n    vec3 F = mix(F_Schlick(f0, f90, VdotH), iridescenceFresnel, iridescenceFactor);\n    float Vis = V_GGX(NdotL, NdotV, alphaRoughness);\n    float D = D_GGX(NdotH, alphaRoughness);\n\n    return specularWeight * F * Vis * D;\n}\n#endif\n\n// f_sheen\nvec3 BRDF_specularSheen(vec3 sheenColor, float sheenRoughness, float NdotL, float NdotV, float NdotH)\n{\n    float sheenDistribution = D_Charlie(sheenRoughness, NdotH);\n    float sheenVisibility = V_Sheen(NdotL, NdotV, sheenRoughness);\n    return sheenColor * sheenDistribution * sheenVisibility;\n}\n"; // eslint-disable-line

    var iridescenceShader = "#define GLSLIFY 1\n// XYZ to sRGB color space\nconst mat3 XYZ_TO_REC709 = mat3(\n     3.2404542, -0.9692660,  0.0556434,\n    -1.5371385,  1.8760108, -0.2040259,\n    -0.4985314,  0.0415560,  1.0572252\n);\n\n// Assume air interface for top\n// Note: We don't handle the case fresnel0 == 1\nvec3 Fresnel0ToIor(vec3 fresnel0) {\n    vec3 sqrtF0 = sqrt(fresnel0);\n    return (vec3(1.0) + sqrtF0) / (vec3(1.0) - sqrtF0);\n}\n\n// Conversion FO/IOR\nvec3 IorToFresnel0(vec3 transmittedIor, float incidentIor) {\n    return sq((transmittedIor - vec3(incidentIor)) / (transmittedIor + vec3(incidentIor)));\n}\n\n// ior is a value between 1.0 and 3.0. 1.0 is air interface\nfloat IorToFresnel0(float transmittedIor, float incidentIor) {\n    return sq((transmittedIor - incidentIor) / (transmittedIor + incidentIor));\n}\n\n// Fresnel equations for dielectric/dielectric interfaces.\n// Ref: https://belcour.github.io/blog/research/2017/05/01/brdf-thin-film.html\n// Evaluation XYZ sensitivity curves in Fourier space\nvec3 evalSensitivity(float OPD, vec3 shift) {\n    float phase = 2.0 * M_PI * OPD * 1.0e-9;\n    vec3 val = vec3(5.4856e-13, 4.4201e-13, 5.2481e-13);\n    vec3 pos = vec3(1.6810e+06, 1.7953e+06, 2.2084e+06);\n    vec3 var = vec3(4.3278e+09, 9.3046e+09, 6.6121e+09);\n\n    vec3 xyz = val * sqrt(2.0 * M_PI * var) * cos(pos * phase + shift) * exp(-sq(phase) * var);\n    xyz.x += 9.7470e-14 * sqrt(2.0 * M_PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * sq(phase));\n    xyz /= 1.0685e-7;\n\n    vec3 srgb = XYZ_TO_REC709 * xyz;\n    return srgb;\n}\n\nvec3 evalIridescence(float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0) {\n    vec3 I;\n\n    // Force iridescenceIor -> outsideIOR when thinFilmThickness -> 0.0\n    float iridescenceIor = mix(outsideIOR, eta2, smoothstep(0.0, 0.03, thinFilmThickness));\n    // Evaluate the cosTheta on the base layer (Snell law)\n    float sinTheta2Sq = sq(outsideIOR / iridescenceIor) * (1.0 - sq(cosTheta1));\n\n    // Handle TIR:\n    float cosTheta2Sq = 1.0 - sinTheta2Sq;\n    if (cosTheta2Sq < 0.0) {\n        return vec3(1.0);\n    }\n\n    float cosTheta2 = sqrt(cosTheta2Sq);\n\n    // First interface\n    float R0 = IorToFresnel0(iridescenceIor, outsideIOR);\n    float R12 = F_Schlick(R0, cosTheta1);\n    float R21 = R12;\n    float T121 = 1.0 - R12;\n    float phi12 = 0.0;\n    if (iridescenceIor < outsideIOR) phi12 = M_PI;\n    float phi21 = M_PI - phi12;\n\n    // Second interface\n    vec3 baseIOR = Fresnel0ToIor(clamp(baseF0, 0.0, 0.9999)); // guard against 1.0\n    vec3 R1 = IorToFresnel0(baseIOR, iridescenceIor);\n    vec3 R23 = F_Schlick(R1, cosTheta2);\n    vec3 phi23 = vec3(0.0);\n    if (baseIOR[0] < iridescenceIor) phi23[0] = M_PI;\n    if (baseIOR[1] < iridescenceIor) phi23[1] = M_PI;\n    if (baseIOR[2] < iridescenceIor) phi23[2] = M_PI;\n\n    // Phase shift\n    float OPD = 2.0 * iridescenceIor * thinFilmThickness * cosTheta2;\n    vec3 phi = vec3(phi21) + phi23;\n\n    // Compound terms\n    vec3 R123 = clamp(R12 * R23, 1e-5, 0.9999);\n    vec3 r123 = sqrt(R123);\n    vec3 Rs = sq(T121) * R23 / (vec3(1.0) - R123);\n\n    // Reflectance term for m = 0 (DC term amplitude)\n    vec3 C0 = R12 + Rs;\n    I = C0;\n\n    // Reflectance term for m > 0 (pairs of diracs)\n    vec3 Cm = Rs - T121;\n    for (int m = 1; m <= 2; ++m)\n    {\n        Cm *= r123;\n        vec3 Sm = 2.0 * evalSensitivity(float(m) * OPD, float(m) * phi);\n        I += Cm * Sm;\n    }\n\n    // Since out of gamut colors might be produced, negative color values are clamped to 0.\n    return max(I, vec3(0.0));\n}\n"; // eslint-disable-line

    var materialInfoShader = "#define GLSLIFY 1\n// Metallic Roughness\nuniform float u_MetallicFactor;\nuniform float u_RoughnessFactor;\nuniform vec4 u_BaseColorFactor;\n\n// Specular Glossiness\nuniform vec3 u_SpecularFactor;\nuniform vec4 u_DiffuseFactor;\nuniform float u_GlossinessFactor;\n\n// Sheen\nuniform float u_SheenRoughnessFactor;\nuniform vec3 u_SheenColorFactor;\n\n// Clearcoat\nuniform float u_ClearcoatFactor;\nuniform float u_ClearcoatRoughnessFactor;\n\n// Specular\nuniform vec3 u_KHR_materials_specular_specularColorFactor;\nuniform float u_KHR_materials_specular_specularFactor;\n\n// Transmission\nuniform float u_TransmissionFactor;\n\n// Volume\nuniform float u_ThicknessFactor;\nuniform vec3 u_AttenuationColor;\nuniform float u_AttenuationDistance;\n\n// Iridescence\nuniform float u_IridescenceFactor;\nuniform float u_IridescenceIor;\nuniform float u_IridescenceThicknessMinimum;\nuniform float u_IridescenceThicknessMaximum;\n\n// Emissive Strength\nuniform float u_EmissiveStrength;\n\n// PBR Next IOR\nuniform float u_Ior;\n\n// Alpha mode\nuniform float u_AlphaCutoff;\n\nuniform vec3 u_Camera;\n\n#ifdef MATERIAL_TRANSMISSION\nuniform ivec2 u_ScreenSize;\n#endif\n\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_ViewMatrix;\nuniform mat4 u_ProjectionMatrix;\n\nstruct MaterialInfo\n{\n    float ior;\n    float perceptualRoughness;      // roughness value, as authored by the model creator (input to shader)\n    vec3 f0;                        // full reflectance color (n incidence angle)\n\n    float alphaRoughness;           // roughness mapped to a more linear change in the roughness (proposed by [2])\n    vec3 c_diff;\n\n    vec3 f90;                       // reflectance color at grazing angle\n    float metallic;\n\n    vec3 baseColor;\n\n    float sheenRoughnessFactor;\n    vec3 sheenColorFactor;\n\n    vec3 clearcoatF0;\n    vec3 clearcoatF90;\n    float clearcoatFactor;\n    vec3 clearcoatNormal;\n    float clearcoatRoughness;\n\n    // KHR_materials_specular \n    float specularWeight; // product of specularFactor and specularTexture.a\n\n    float transmissionFactor;\n\n    float thickness;\n    vec3 attenuationColor;\n    float attenuationDistance;\n\n    // KHR_materials_iridescence\n    float iridescenceFactor;\n    float iridescenceIor;\n    float iridescenceThickness;\n};\n\n// Get normal, tangent and bitangent vectors.\nNormalInfo getNormalInfo(vec3 v)\n{\n    vec2 UV = getNormalUV();\n    vec3 uv_dx = dFdx(vec3(UV, 0.0));\n    vec3 uv_dy = dFdy(vec3(UV, 0.0));\n\n    vec3 t_ = (uv_dy.t * dFdx(v_Position) - uv_dx.t * dFdy(v_Position)) /\n        (uv_dx.s * uv_dy.t - uv_dy.s * uv_dx.t);\n\n    vec3 n, t, b, ng;\n\n    // Compute geometrical TBN:\n#ifdef HAS_NORMAL_VEC3\n#ifdef HAS_TANGENT_VEC4\n    // Trivial TBN computation, present as vertex attribute.\n    // Normalize eigenvectors as matrix is linearly interpolated.\n    t = normalize(v_TBN[0]);\n    b = normalize(v_TBN[1]);\n    ng = normalize(v_TBN[2]);\n#else\n    // Normals are either present as vertex attributes or approximated.\n    ng = normalize(v_Normal);\n    t = normalize(t_ - ng * dot(ng, t_));\n    b = cross(ng, t);\n#endif\n#else\n    ng = normalize(cross(dFdx(v_Position), dFdy(v_Position)));\n    t = normalize(t_ - ng * dot(ng, t_));\n    b = cross(ng, t);\n#endif\n\n    // For a back-facing surface, the tangential basis vectors are negated.\n    if (gl_FrontFacing == false)\n    {\n        t *= -1.0;\n        b *= -1.0;\n        ng *= -1.0;\n    }\n\n    // Compute normals:\n    NormalInfo info;\n    info.ng = ng;\n#ifdef HAS_NORMAL_MAP\n    info.ntex = texture(u_NormalSampler, UV).rgb * 2.0 - vec3(1.0);\n    info.ntex *= vec3(u_NormalScale, u_NormalScale, 1.0);\n    info.ntex = normalize(info.ntex);\n    info.n = normalize(mat3(t, b, ng) * info.ntex);\n#else\n    info.n = ng;\n#endif\n    info.t = t;\n    info.b = b;\n    return info;\n}\n\n#ifdef MATERIAL_CLEARCOAT\nvec3 getClearcoatNormal(NormalInfo normalInfo)\n{\n#ifdef HAS_CLEARCOAT_NORMAL_MAP\n    vec3 n = texture(u_ClearcoatNormalSampler, getClearcoatNormalUV()).rgb * 2.0 - vec3(1.0);\n    n *= vec3(u_ClearcoatNormalScale, u_ClearcoatNormalScale, 1.0);\n    n = mat3(normalInfo.t, normalInfo.b, normalInfo.ng) * normalize(n);\n    return n;\n#else\n    return normalInfo.ng;\n#endif\n}\n#endif\n\nvec4 getBaseColor()\n{\n    vec4 baseColor = vec4(1);\n\n#if defined(MATERIAL_SPECULARGLOSSINESS)\n    baseColor = u_DiffuseFactor;\n#elif defined(MATERIAL_METALLICROUGHNESS)\n    baseColor = u_BaseColorFactor;\n#endif\n\n#if defined(MATERIAL_SPECULARGLOSSINESS) && defined(HAS_DIFFUSE_MAP)\n    baseColor *= texture(u_DiffuseSampler, getDiffuseUV());\n#elif defined(MATERIAL_METALLICROUGHNESS) && defined(HAS_BASE_COLOR_MAP)\n    baseColor *= texture(u_BaseColorSampler, getBaseColorUV());\n#endif\n\n    return baseColor * getVertexColor();\n}\n\n#ifdef MATERIAL_SPECULARGLOSSINESS\nMaterialInfo getSpecularGlossinessInfo(MaterialInfo info)\n{\n    info.f0 = u_SpecularFactor;\n    info.perceptualRoughness = u_GlossinessFactor;\n\n#ifdef HAS_SPECULAR_GLOSSINESS_MAP\n    vec4 sgSample = texture(u_SpecularGlossinessSampler, getSpecularGlossinessUV());\n    info.perceptualRoughness *= sgSample.a ; // glossiness to roughness\n    info.f0 *= sgSample.rgb; // specular\n#endif // ! HAS_SPECULAR_GLOSSINESS_MAP\n\n    info.perceptualRoughness = 1.0 - info.perceptualRoughness; // 1 - glossiness\n    info.c_diff = info.baseColor.rgb * (1.0 - max(max(info.f0.r, info.f0.g), info.f0.b));\n    return info;\n}\n#endif\n\n#ifdef MATERIAL_METALLICROUGHNESS\nMaterialInfo getMetallicRoughnessInfo(MaterialInfo info)\n{\n    info.metallic = u_MetallicFactor;\n    info.perceptualRoughness = u_RoughnessFactor;\n\n#ifdef HAS_METALLIC_ROUGHNESS_MAP\n    // Roughness is stored in the 'g' channel, metallic is stored in the 'b' channel.\n    // This layout intentionally reserves the 'r' channel for (optional) occlusion map data\n    vec4 mrSample = texture(u_MetallicRoughnessSampler, getMetallicRoughnessUV());\n    info.perceptualRoughness *= mrSample.g;\n    info.metallic *= mrSample.b;\n#endif\n\n    // Achromatic f0 based on IOR.\n    info.c_diff = mix(info.baseColor.rgb,  vec3(0), info.metallic);\n    info.f0 = mix(info.f0, info.baseColor.rgb, info.metallic);\n    return info;\n}\n#endif\n\n#ifdef MATERIAL_SHEEN\nMaterialInfo getSheenInfo(MaterialInfo info)\n{\n    info.sheenColorFactor = u_SheenColorFactor;\n    info.sheenRoughnessFactor = u_SheenRoughnessFactor;\n\n#ifdef HAS_SHEEN_COLOR_MAP\n    vec4 sheenColorSample = texture(u_SheenColorSampler, getSheenColorUV());\n    info.sheenColorFactor *= sheenColorSample.rgb;\n#endif\n\n#ifdef HAS_SHEEN_ROUGHNESS_MAP\n    vec4 sheenRoughnessSample = texture(u_SheenRoughnessSampler, getSheenRoughnessUV());\n    info.sheenRoughnessFactor *= sheenRoughnessSample.a;\n#endif\n    return info;\n}\n#endif\n\n#ifdef MATERIAL_SPECULAR\nMaterialInfo getSpecularInfo(MaterialInfo info)\n{   \n    vec4 specularTexture = vec4(1.0);\n#ifdef HAS_SPECULAR_MAP\n    specularTexture.a = texture(u_SpecularSampler, getSpecularUV()).a;\n#endif\n#ifdef HAS_SPECULAR_COLOR_MAP\n    specularTexture.rgb = texture(u_SpecularColorSampler, getSpecularColorUV()).rgb;\n#endif\n\n    vec3 dielectricSpecularF0 = min(info.f0 * u_KHR_materials_specular_specularColorFactor * specularTexture.rgb, vec3(1.0));\n    info.f0 = mix(dielectricSpecularF0, info.baseColor.rgb, info.metallic);\n    info.specularWeight = u_KHR_materials_specular_specularFactor * specularTexture.a;\n    info.c_diff = mix(info.baseColor.rgb, vec3(0), info.metallic);\n    return info;\n}\n#endif\n\n#ifdef MATERIAL_TRANSMISSION\nMaterialInfo getTransmissionInfo(MaterialInfo info)\n{\n    info.transmissionFactor = u_TransmissionFactor;\n\n#ifdef HAS_TRANSMISSION_MAP\n    vec4 transmissionSample = texture(u_TransmissionSampler, getTransmissionUV());\n    info.transmissionFactor *= transmissionSample.r;\n#endif\n    return info;\n}\n#endif\n\n#ifdef MATERIAL_VOLUME\nMaterialInfo getVolumeInfo(MaterialInfo info)\n{\n    info.thickness = u_ThicknessFactor;\n    info.attenuationColor = u_AttenuationColor;\n    info.attenuationDistance = u_AttenuationDistance;\n\n#ifdef HAS_THICKNESS_MAP\n    vec4 thicknessSample = texture(u_ThicknessSampler, getThicknessUV());\n    info.thickness *= thicknessSample.g;\n#endif\n    return info;\n}\n#endif\n\n#ifdef MATERIAL_IRIDESCENCE\nMaterialInfo getIridescenceInfo(MaterialInfo info)\n{\n    info.iridescenceFactor = u_IridescenceFactor;\n    info.iridescenceIor = u_IridescenceIor;\n    info.iridescenceThickness = u_IridescenceThicknessMaximum;\n\n    #ifdef HAS_IRIDESCENCE_MAP\n        info.iridescenceFactor *= texture(u_IridescenceSampler, getIridescenceUV()).r;\n    #endif\n\n    #ifdef HAS_IRIDESCENCE_THICKNESS_MAP\n        float thicknessSampled = texture(u_IridescenceThicknessSampler, getIridescenceThicknessUV()).g;\n        float thickness = mix(u_IridescenceThicknessMinimum, u_IridescenceThicknessMaximum, thicknessSampled);\n        info.iridescenceThickness = thickness;\n    #endif\n\n    return info;\n}\n#endif\n\n#ifdef MATERIAL_CLEARCOAT\nMaterialInfo getClearCoatInfo(MaterialInfo info, NormalInfo normalInfo)\n{\n    info.clearcoatFactor = u_ClearcoatFactor;\n    info.clearcoatRoughness = u_ClearcoatRoughnessFactor;\n    info.clearcoatF0 = vec3(pow((info.ior - 1.0) / (info.ior + 1.0), 2.0));\n    info.clearcoatF90 = vec3(1.0);\n\n#ifdef HAS_CLEARCOAT_MAP\n    vec4 clearcoatSample = texture(u_ClearcoatSampler, getClearcoatUV());\n    info.clearcoatFactor *= clearcoatSample.r;\n#endif\n\n#ifdef HAS_CLEARCOAT_ROUGHNESS_MAP\n    vec4 clearcoatSampleRoughness = texture(u_ClearcoatRoughnessSampler, getClearcoatRoughnessUV());\n    info.clearcoatRoughness *= clearcoatSampleRoughness.g;\n#endif\n\n    info.clearcoatNormal = getClearcoatNormal(normalInfo);\n    info.clearcoatRoughness = clamp(info.clearcoatRoughness, 0.0, 1.0);\n    return info;\n}\n#endif\n\n#ifdef MATERIAL_IOR\nMaterialInfo getIorInfo(MaterialInfo info)\n{\n    info.f0 = vec3(pow(( u_Ior - 1.0) /  (u_Ior + 1.0), 2.0));\n    info.ior = u_Ior;\n    return info;\n}\n#endif\n\nfloat albedoSheenScalingLUT(float NdotV, float sheenRoughnessFactor)\n{\n    return texture(u_SheenELUT, vec2(NdotV, sheenRoughnessFactor)).r;\n}\n"; // eslint-disable-line

    var iblShader = "#define GLSLIFY 1\nuniform float u_EnvIntensity;\n\nvec3 getDiffuseLight(vec3 n)\n{\n    return texture(u_LambertianEnvSampler, u_EnvRotation * n).rgb * u_EnvIntensity;\n}\n\nvec4 getSpecularSample(vec3 reflection, float lod)\n{\n    return textureLod(u_GGXEnvSampler, u_EnvRotation * reflection, lod) * u_EnvIntensity;\n}\n\nvec4 getSheenSample(vec3 reflection, float lod)\n{\n    return textureLod(u_CharlieEnvSampler, u_EnvRotation * reflection, lod) * u_EnvIntensity;\n}\n\nvec3 getIBLRadianceGGX(vec3 n, vec3 v, float roughness, vec3 F0, float specularWeight)\n{\n    float NdotV = clampedDot(n, v);\n    float lod = roughness * float(u_MipCount - 1);\n    vec3 reflection = normalize(reflect(-v, n));\n\n    vec2 brdfSamplePoint = clamp(vec2(NdotV, roughness), vec2(0.0, 0.0), vec2(1.0, 1.0));\n    vec2 f_ab = texture(u_GGXLUT, brdfSamplePoint).rg;\n    vec4 specularSample = getSpecularSample(reflection, lod);\n\n    vec3 specularLight = specularSample.rgb;\n\n    // see https://bruop.github.io/ibl/#single_scattering_results at Single Scattering Results\n    // Roughness dependent fresnel, from Fdez-Aguera\n    vec3 Fr = max(vec3(1.0 - roughness), F0) - F0;\n    vec3 k_S = F0 + Fr * pow(1.0 - NdotV, 5.0);\n    vec3 FssEss = k_S * f_ab.x + f_ab.y;\n\n    return specularWeight * specularLight * FssEss;\n}\n\n#ifdef MATERIAL_IRIDESCENCE\nvec3 getIBLRadianceGGXIridescence(vec3 n, vec3 v, float roughness, vec3 F0, vec3 iridescenceFresnel, float iridescenceFactor, float specularWeight)\n{\n    float NdotV = clampedDot(n, v);\n    float lod = roughness * float(u_MipCount - 1);\n    vec3 reflection = normalize(reflect(-v, n));\n\n    vec2 brdfSamplePoint = clamp(vec2(NdotV, roughness), vec2(0.0, 0.0), vec2(1.0, 1.0));\n    vec2 f_ab = texture(u_GGXLUT, brdfSamplePoint).rg;\n    vec4 specularSample = getSpecularSample(reflection, lod);\n\n    vec3 specularLight = specularSample.rgb;\n\n    // see https://bruop.github.io/ibl/#single_scattering_results at Single Scattering Results\n    // Roughness dependent fresnel, from Fdez-Aguera\n    vec3 Fr = max(vec3(1.0 - roughness), F0) - F0;\n    vec3 k_S = mix(F0 + Fr * pow(1.0 - NdotV, 5.0), iridescenceFresnel, iridescenceFactor);\n    vec3 FssEss = k_S * f_ab.x + f_ab.y;\n\n    return specularWeight * specularLight * FssEss;\n}\n#endif\n\n#ifdef MATERIAL_TRANSMISSION\nvec3 getTransmissionSample(vec2 fragCoord, float roughness, float ior)\n{\n    float framebufferLod = log2(float(u_TransmissionFramebufferSize.x)) * applyIorToRoughness(roughness, ior);\n    vec3 transmittedLight = textureLod(u_TransmissionFramebufferSampler, fragCoord.xy, framebufferLod).rgb;\n    return transmittedLight;\n}\n#endif\n\n#ifdef MATERIAL_TRANSMISSION\nvec3 getIBLVolumeRefraction(vec3 n, vec3 v, float perceptualRoughness, vec3 baseColor, vec3 f0, vec3 f90,\n    vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness, vec3 attenuationColor, float attenuationDistance)\n{\n    vec3 transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);\n    vec3 refractedRayExit = position + transmissionRay;\n\n    // Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\n    vec4 ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);\n    vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n    refractionCoords += 1.0;\n    refractionCoords /= 2.0;\n\n    // Sample framebuffer to get pixel the refracted ray hits.\n    vec3 transmittedLight = getTransmissionSample(refractionCoords, perceptualRoughness, ior);\n\n    vec3 attenuatedColor = applyVolumeAttenuation(transmittedLight, length(transmissionRay), attenuationColor, attenuationDistance);\n\n    // Sample GGX LUT to get the specular component.\n    float NdotV = clampedDot(n, v);\n    vec2 brdfSamplePoint = clamp(vec2(NdotV, perceptualRoughness), vec2(0.0, 0.0), vec2(1.0, 1.0));\n    vec2 brdf = texture(u_GGXLUT, brdfSamplePoint).rg;\n    vec3 specularColor = f0 * brdf.x + f90 * brdf.y;\n\n    return (1.0 - specularColor) * attenuatedColor * baseColor;\n}\n#endif\n\n// specularWeight is introduced with KHR_materials_specular\nvec3 getIBLRadianceLambertian(vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 F0, float specularWeight)\n{\n    float NdotV = clampedDot(n, v);\n    vec2 brdfSamplePoint = clamp(vec2(NdotV, roughness), vec2(0.0, 0.0), vec2(1.0, 1.0));\n    vec2 f_ab = texture(u_GGXLUT, brdfSamplePoint).rg;\n\n    vec3 irradiance = getDiffuseLight(n);\n\n    // see https://bruop.github.io/ibl/#single_scattering_results at Single Scattering Results\n    // Roughness dependent fresnel, from Fdez-Aguera\n\n    vec3 Fr = max(vec3(1.0 - roughness), F0) - F0;\n    vec3 k_S = F0 + Fr * pow(1.0 - NdotV, 5.0);\n    vec3 FssEss = specularWeight * k_S * f_ab.x + f_ab.y; // <--- GGX / specular light contribution (scale it down if the specularWeight is low)\n\n    // Multiple scattering, from Fdez-Aguera\n    float Ems = (1.0 - (f_ab.x + f_ab.y));\n    vec3 F_avg = specularWeight * (F0 + (1.0 - F0) / 21.0);\n    vec3 FmsEms = Ems * FssEss * F_avg / (1.0 - F_avg * Ems);\n    vec3 k_D = diffuseColor * (1.0 - FssEss + FmsEms); // we use +FmsEms as indicated by the formula in the blog post (might be a typo in the implementation)\n\n    return (FmsEms + k_D) * irradiance;\n}\n\n#ifdef MATERIAL_IRIDESCENCE\n// specularWeight is introduced with KHR_materials_specular\nvec3 getIBLRadianceLambertianIridescence(vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 F0, vec3 iridescenceF0, float iridescenceFactor, float specularWeight)\n{\n    float NdotV = clampedDot(n, v);\n    vec2 brdfSamplePoint = clamp(vec2(NdotV, roughness), vec2(0.0, 0.0), vec2(1.0, 1.0));\n    vec2 f_ab = texture(u_GGXLUT, brdfSamplePoint).rg;\n\n    vec3 irradiance = getDiffuseLight(n);\n\n    // Use the maximum component of the iridescence Fresnel color\n    // Maximum is used instead of the RGB value to not get inverse colors for the diffuse BRDF\n    vec3 iridescenceF0Max = vec3(max(max(iridescenceF0.r, iridescenceF0.g), iridescenceF0.b));\n\n    // Blend between base F0 and iridescence F0\n    vec3 mixedF0 = mix(F0, iridescenceF0Max, iridescenceFactor);\n\n    // see https://bruop.github.io/ibl/#single_scattering_results at Single Scattering Results\n    // Roughness dependent fresnel, from Fdez-Aguera\n\n    vec3 Fr = max(vec3(1.0 - roughness), mixedF0) - mixedF0;\n    vec3 k_S = mixedF0 + Fr * pow(1.0 - NdotV, 5.0);\n    vec3 FssEss = specularWeight * k_S * f_ab.x + f_ab.y; // <--- GGX / specular light contribution (scale it down if the specularWeight is low)\n\n    // Multiple scattering, from Fdez-Aguera\n    float Ems = (1.0 - (f_ab.x + f_ab.y));\n    vec3 F_avg = specularWeight * (mixedF0 + (1.0 - mixedF0) / 21.0);\n    vec3 FmsEms = Ems * FssEss * F_avg / (1.0 - F_avg * Ems);\n    vec3 k_D = diffuseColor * (1.0 - FssEss + FmsEms); // we use +FmsEms as indicated by the formula in the blog post (might be a typo in the implementation)\n\n    return (FmsEms + k_D) * irradiance;\n}\n#endif\n\nvec3 getIBLRadianceCharlie(vec3 n, vec3 v, float sheenRoughness, vec3 sheenColor)\n{\n    float NdotV = clampedDot(n, v);\n    float lod = sheenRoughness * float(u_MipCount - 1);\n    vec3 reflection = normalize(reflect(-v, n));\n\n    vec2 brdfSamplePoint = clamp(vec2(NdotV, sheenRoughness), vec2(0.0, 0.0), vec2(1.0, 1.0));\n    float brdf = texture(u_CharlieLUT, brdfSamplePoint).b;\n    vec4 sheenSample = getSheenSample(reflection, lod);\n\n    vec3 sheenLight = sheenSample.rgb;\n    return sheenLight * sheenColor * brdf;\n}\n"; // eslint-disable-line

    var punctualShader = "#define GLSLIFY 1\n// KHR_lights_punctual extension.\n// see https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\nstruct Light\n{\n    vec3 direction;\n    float range;\n\n    vec3 color;\n    float intensity;\n\n    vec3 position;\n    float innerConeCos;\n\n    float outerConeCos;\n    int type;\n};\n\nconst int LightType_Directional = 0;\nconst int LightType_Point = 1;\nconst int LightType_Spot = 2;\n\n#ifdef USE_PUNCTUAL\nuniform Light u_Lights[LIGHT_COUNT + 1]; //Array [0] is not allowed\n#endif\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#range-property\nfloat getRangeAttenuation(float range, float distance)\n{\n    if (range <= 0.0)\n    {\n        // negative range means unlimited\n        return 1.0 / pow(distance, 2.0);\n    }\n    return max(min(1.0 - pow(distance / range, 4.0), 1.0), 0.0) / pow(distance, 2.0);\n}\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#inner-and-outer-cone-angles\nfloat getSpotAttenuation(vec3 pointToLight, vec3 spotDirection, float outerConeCos, float innerConeCos)\n{\n    float actualCos = dot(normalize(spotDirection), normalize(-pointToLight));\n    if (actualCos > outerConeCos)\n    {\n        if (actualCos < innerConeCos)\n        {\n            return smoothstep(outerConeCos, innerConeCos, actualCos);\n        }\n        return 1.0;\n    }\n    return 0.0;\n}\n\nvec3 getLighIntensity(Light light, vec3 pointToLight)\n{\n    float rangeAttenuation = 1.0;\n    float spotAttenuation = 1.0;\n\n    if (light.type != LightType_Directional)\n    {\n        rangeAttenuation = getRangeAttenuation(light.range, length(pointToLight));\n    }\n    if (light.type == LightType_Spot)\n    {\n        spotAttenuation = getSpotAttenuation(pointToLight, light.direction, light.outerConeCos, light.innerConeCos);\n    }\n\n    return rangeAttenuation * spotAttenuation * light.intensity * light.color;\n}\n\nvec3 getPunctualRadianceTransmission(vec3 normal, vec3 view, vec3 pointToLight, float alphaRoughness,\n    vec3 f0, vec3 f90, vec3 baseColor, float ior)\n{\n    float transmissionRougness = applyIorToRoughness(alphaRoughness, ior);\n\n    vec3 n = normalize(normal);           // Outward direction of surface point\n    vec3 v = normalize(view);             // Direction from surface point to view\n    vec3 l = normalize(pointToLight);\n    vec3 l_mirror = normalize(l + 2.0*n*dot(-l, n));     // Mirror light reflection vector on surface\n    vec3 h = normalize(l_mirror + v);            // Halfway vector between transmission light vector and v\n\n    float D = D_GGX(clamp(dot(n, h), 0.0, 1.0), transmissionRougness);\n    vec3 F = F_Schlick(f0, f90, clamp(dot(v, h), 0.0, 1.0));\n    float Vis = V_GGX(clamp(dot(n, l_mirror), 0.0, 1.0), clamp(dot(n, v), 0.0, 1.0), transmissionRougness);\n\n    // Transmission BTDF\n    return (1.0 - F) * baseColor * D * Vis;\n}\n\nvec3 getPunctualRadianceClearCoat(vec3 clearcoatNormal, vec3 v, vec3 l, vec3 h, float VdotH, vec3 f0, vec3 f90, float clearcoatRoughness)\n{\n    float NdotL = clampedDot(clearcoatNormal, l);\n    float NdotV = clampedDot(clearcoatNormal, v);\n    float NdotH = clampedDot(clearcoatNormal, h);\n    return NdotL * BRDF_specularGGX(f0, f90, clearcoatRoughness * clearcoatRoughness, 1.0, VdotH, NdotL, NdotV, NdotH);\n}\n\nvec3 getPunctualRadianceSheen(vec3 sheenColor, float sheenRoughness, float NdotL, float NdotV, float NdotH)\n{\n    return NdotL * BRDF_specularSheen(sheenColor, sheenRoughness, NdotL, NdotV, NdotH);\n}\n\n// Compute attenuated light as it travels through a volume.\nvec3 applyVolumeAttenuation(vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance)\n{\n    if (attenuationDistance == 0.0)\n    {\n        // Attenuation distance is +∞ (which we indicate by zero), i.e. the transmitted color is not attenuated at all.\n        return radiance;\n    }\n    else\n    {\n        // Compute light attenuation using Beer's law.\n        vec3 attenuationCoefficient = -log(attenuationColor) / attenuationDistance;\n        vec3 transmittance = exp(-attenuationCoefficient * transmissionDistance); // Beer's law\n        return transmittance * radiance;\n    }\n}\n\nvec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix)\n{\n    // Direction of refracted light.\n    vec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);\n\n    // Compute rotation-independant scaling of the model matrix.\n    vec3 modelScale;\n    modelScale.x = length(vec3(modelMatrix[0].xyz));\n    modelScale.y = length(vec3(modelMatrix[1].xyz));\n    modelScale.z = length(vec3(modelMatrix[2].xyz));\n\n    // The thickness is specified in local space.\n    return normalize(refractionVector) * thickness * modelScale;\n}\n"; // eslint-disable-line

    var primitiveShader = "#define GLSLIFY 1\n#include <animation.glsl>\n\nuniform mat4 u_ViewProjectionMatrix;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_NormalMatrix;\n\nin vec3 a_position;\nout vec3 v_Position;\n\n#ifdef HAS_NORMAL_VEC3\nin vec3 a_normal;\n#endif\n\n#ifdef HAS_NORMAL_VEC3\n#ifdef HAS_TANGENT_VEC4\nin vec4 a_tangent;\nout mat3 v_TBN;\n#else\nout vec3 v_Normal;\n#endif\n#endif\n\n#ifdef HAS_TEXCOORD_0_VEC2\nin vec2 a_texcoord_0;\n#endif\n\n#ifdef HAS_TEXCOORD_1_VEC2\nin vec2 a_texcoord_1;\n#endif\n\nout vec2 v_texcoord_0;\nout vec2 v_texcoord_1;\n\n#ifdef HAS_COLOR_0_VEC3\nin vec3 a_color_0;\nout vec3 v_Color;\n#endif\n\n#ifdef HAS_COLOR_0_VEC4\nin vec4 a_color_0;\nout vec4 v_Color;\n#endif\n\nvec4 getPosition()\n{\n    vec4 pos = vec4(a_position, 1.0);\n\n#ifdef USE_MORPHING\n    pos += getTargetPosition(gl_VertexID);\n#endif\n\n#ifdef USE_SKINNING\n    pos = getSkinningMatrix() * pos;\n#endif\n\n    return pos;\n}\n\n#ifdef HAS_NORMAL_VEC3\nvec3 getNormal()\n{\n    vec3 normal = a_normal;\n\n#ifdef USE_MORPHING\n    normal += getTargetNormal(gl_VertexID);\n#endif\n\n#ifdef USE_SKINNING\n    normal = mat3(getSkinningNormalMatrix()) * normal;\n#endif\n\n    return normalize(normal);\n}\n#endif\n\n#ifdef HAS_NORMAL_VEC3\n#ifdef HAS_TANGENT_VEC4\nvec3 getTangent()\n{\n    vec3 tangent = a_tangent.xyz;\n\n#ifdef USE_MORPHING\n    tangent += getTargetTangent(gl_VertexID);\n#endif\n\n#ifdef USE_SKINNING\n    tangent = mat3(getSkinningMatrix()) * tangent;\n#endif\n\n    return normalize(tangent);\n}\n#endif\n#endif\n\nvoid main()\n{\n    gl_PointSize = 1.0f;\n    vec4 pos = u_ModelMatrix * getPosition();\n    v_Position = vec3(pos.xyz) / pos.w;\n\n#ifdef HAS_NORMAL_VEC3\n#ifdef HAS_TANGENT_VEC4\n    vec3 tangent = getTangent();\n    vec3 normalW = normalize(vec3(u_NormalMatrix * vec4(getNormal(), 0.0)));\n    vec3 tangentW = normalize(vec3(u_ModelMatrix * vec4(tangent, 0.0)));\n    vec3 bitangentW = cross(normalW, tangentW) * a_tangent.w;\n    v_TBN = mat3(tangentW, bitangentW, normalW);\n#else\n    v_Normal = normalize(vec3(u_NormalMatrix * vec4(getNormal(), 0.0)));\n#endif\n#endif\n\n    v_texcoord_0 = vec2(0.0, 0.0);\n    v_texcoord_1 = vec2(0.0, 0.0);\n\n#ifdef HAS_TEXCOORD_0_VEC2\n    v_texcoord_0 = a_texcoord_0;\n#endif\n\n#ifdef HAS_TEXCOORD_1_VEC2\n    v_texcoord_1 = a_texcoord_1;\n#endif\n\n#ifdef USE_MORPHING\n    v_texcoord_0 += getTargetTexCoord0(gl_VertexID);\n    v_texcoord_1 += getTargetTexCoord1(gl_VertexID);\n#endif\n\n#if defined(HAS_COLOR_0_VEC3) \n    v_Color = a_color_0;\n#if defined(USE_MORPHING)\n    v_Color = clamp(v_Color + getTargetColor0(gl_VertexID).xyz, 0.0f, 1.0f);\n#endif\n#endif\n\n#if defined(HAS_COLOR_0_VEC4) \n    v_Color = a_color_0;\n#if defined(USE_MORPHING)\n    v_Color = clamp(v_Color + getTargetColor0(gl_VertexID), 0.0f, 1.0f);\n#endif\n#endif\n\n    gl_Position = u_ViewProjectionMatrix * pos;\n}\n"; // eslint-disable-line

    var texturesShader = "#define GLSLIFY 1\n// IBL\n\nuniform int u_MipCount;\nuniform samplerCube u_LambertianEnvSampler;\nuniform samplerCube u_GGXEnvSampler;\nuniform sampler2D u_GGXLUT;\nuniform samplerCube u_CharlieEnvSampler;\nuniform sampler2D u_CharlieLUT;\nuniform sampler2D u_SheenELUT;\nuniform mat3 u_EnvRotation;\n\n// General Material\n\nuniform sampler2D u_NormalSampler;\nuniform float u_NormalScale;\nuniform int u_NormalUVSet;\nuniform mat3 u_NormalUVTransform;\n\nuniform vec3 u_EmissiveFactor;\nuniform sampler2D u_EmissiveSampler;\nuniform int u_EmissiveUVSet;\nuniform mat3 u_EmissiveUVTransform;\n\nuniform sampler2D u_OcclusionSampler;\nuniform int u_OcclusionUVSet;\nuniform float u_OcclusionStrength;\nuniform mat3 u_OcclusionUVTransform;\n\nin vec2 v_texcoord_0;\nin vec2 v_texcoord_1;\n\nvec2 getNormalUV()\n{\n    vec3 uv = vec3(u_NormalUVSet < 1 ? v_texcoord_0 : v_texcoord_1, 1.0);\n\n#ifdef HAS_NORMAL_UV_TRANSFORM\n    uv = u_NormalUVTransform * uv;\n#endif\n\n    return uv.xy;\n}\n\nvec2 getEmissiveUV()\n{\n    vec3 uv = vec3(u_EmissiveUVSet < 1 ? v_texcoord_0 : v_texcoord_1, 1.0);\n\n#ifdef HAS_EMISSIVE_UV_TRANSFORM\n    uv = u_EmissiveUVTransform * uv;\n#endif\n\n    return uv.xy;\n}\n\nvec2 getOcclusionUV()\n{\n    vec3 uv = vec3(u_OcclusionUVSet < 1 ? v_texcoord_0 : v_texcoord_1, 1.0);\n\n#ifdef HAS_OCCLUSION_UV_TRANSFORM\n    uv = u_OcclusionUVTransform * uv;\n#endif\n\n    return uv.xy;\n}\n\n// Metallic Roughness Material\n\n#ifdef MATERIAL_METALLICROUGHNESS\n\nuniform sampler2D u_BaseColorSampler;\nuniform int u_BaseColorUVSet;\nuniform mat3 u_BaseColorUVTransform;\n\nuniform sampler2D u_MetallicRoughnessSampler;\nuniform int u_MetallicRoughnessUVSet;\nuniform mat3 u_MetallicRoughnessUVTransform;\n\nvec2 getBaseColorUV()\n{\n    vec3 uv = vec3(u_BaseColorUVSet < 1 ? v_texcoord_0 : v_texcoord_1, 1.0);\n\n#ifdef HAS_BASECOLOR_UV_TRANSFORM\n    uv = u_BaseColorUVTransform * uv;\n#endif\n\n    return uv.xy;\n}\n\nvec2 getMetallicRoughnessUV()\n{\n    vec3 uv = vec3(u_MetallicRoughnessUVSet < 1 ? v_texcoord_0 : v_texcoord_1, 1.0);\n\n#ifdef HAS_METALLICROUGHNESS_UV_TRANSFORM\n    uv = u_MetallicRoughnessUVTransform * uv;\n#endif\n\n    return uv.xy;\n}\n\n#endif\n\n// Specular Glossiness Material\n\n#ifdef MATERIAL_SPECULARGLOSSINESS\n\nuniform sampler2D u_DiffuseSampler;\nuniform int u_DiffuseUVSet;\nuniform mat3 u_DiffuseUVTransform;\n\nuniform sampler2D u_SpecularGlossinessSampler;\nuniform int u_SpecularGlossinessUVSet;\nuniform mat3 u_SpecularGlossinessUVTransform;\n\nvec2 getSpecularGlossinessUV()\n{\n    vec3 uv = vec3(u_SpecularGlossinessUVSet < 1 ? v_texcoord_0 : v_texcoord_1, 1.0);\n\n#ifdef HAS_SPECULARGLOSSINESS_UV_TRANSFORM\n    uv = u_SpecularGlossinessUVTransform * uv;\n#endif\n\n    return uv.xy;\n}\n\nvec2 getDiffuseUV()\n{\n    vec3 uv = vec3(u_DiffuseUVSet < 1 ? v_texcoord_0 : v_texcoord_1, 1.0);\n\n#ifdef HAS_DIFFUSE_UV_TRANSFORM\n    uv = u_DiffuseUVTransform * uv;\n#endif\n\n    return uv.xy;\n}\n\n#endif\n\n// Clearcoat Material\n\n#ifdef MATERIAL_CLEARCOAT\n\nuniform sampler2D u_ClearcoatSampler;\nuniform int u_ClearcoatUVSet;\nuniform mat3 u_ClearcoatUVTransform;\n\nuniform sampler2D u_ClearcoatRoughnessSampler;\nuniform int u_ClearcoatRoughnessUVSet;\nuniform mat3 u_ClearcoatRoughnessUVTransform;\n\nuniform sampler2D u_ClearcoatNormalSampler;\nuniform int u_ClearcoatNormalUVSet;\nuniform mat3 u_ClearcoatNormalUVTransform;\nuniform float u_ClearcoatNormalScale;\n\nvec2 getClearcoatUV()\n{\n    vec3 uv = vec3(u_ClearcoatUVSet < 1 ? v_texcoord_0 : v_texcoord_1, 1.0);\n#ifdef HAS_CLEARCOAT_UV_TRANSFORM\n    uv = u_ClearcoatUVTransform * uv;\n#endif\n    return uv.xy;\n}\n\nvec2 getClearcoatRoughnessUV()\n{\n    vec3 uv = vec3(u_ClearcoatRoughnessUVSet < 1 ? v_texcoord_0 : v_texcoord_1, 1.0);\n#ifdef HAS_CLEARCOATROUGHNESS_UV_TRANSFORM\n    uv = u_ClearcoatRoughnessUVTransform * uv;\n#endif\n    return uv.xy;\n}\n\nvec2 getClearcoatNormalUV()\n{\n    vec3 uv = vec3(u_ClearcoatNormalUVSet < 1 ? v_texcoord_0 : v_texcoord_1, 1.0);\n#ifdef HAS_CLEARCOATNORMAL_UV_TRANSFORM\n    uv = u_ClearcoatNormalUVTransform * uv;\n#endif\n    return uv.xy;\n}\n\n#endif\n\n// Sheen Material\n\n#ifdef MATERIAL_SHEEN\n\nuniform sampler2D u_SheenColorSampler;\nuniform int u_SheenColorUVSet;\nuniform mat3 u_SheenColorUVTransform;\nuniform sampler2D u_SheenRoughnessSampler;\nuniform int u_SheenRoughnessUVSet;\nuniform mat3 u_SheenRoughnessUVTransform;\n\nvec2 getSheenColorUV()\n{\n    vec3 uv = vec3(u_SheenColorUVSet < 1 ? v_texcoord_0 : v_texcoord_1, 1.0);\n#ifdef HAS_SHEENCOLOR_UV_TRANSFORM\n    uv = u_SheenColorUVTransform * uv;\n#endif\n    return uv.xy;\n}\n\nvec2 getSheenRoughnessUV()\n{\n    vec3 uv = vec3(u_SheenRoughnessUVSet < 1 ? v_texcoord_0 : v_texcoord_1, 1.0);\n#ifdef HAS_SHEENROUGHNESS_UV_TRANSFORM\n    uv = u_SheenRoughnessUVTransform * uv;\n#endif\n    return uv.xy;\n}\n\n#endif\n\n// Specular Material\n\n#ifdef MATERIAL_SPECULAR\n\nuniform sampler2D u_SpecularSampler;\nuniform int u_SpecularUVSet;\nuniform mat3 u_SpecularUVTransform;\nuniform sampler2D u_SpecularColorSampler;\nuniform int u_SpecularColorUVSet;\nuniform mat3 u_SpecularColorUVTransform;\n\nvec2 getSpecularUV()\n{\n    vec3 uv = vec3(u_SpecularUVSet < 1 ? v_texcoord_0 : v_texcoord_1, 1.0);\n#ifdef HAS_SPECULAR_UV_TRANSFORM\n    uv = u_SpecularUVTransform * uv;\n#endif\n    return uv.xy;\n}\n\nvec2 getSpecularColorUV()\n{\n    vec3 uv = vec3(u_SpecularColorUVSet < 1 ? v_texcoord_0 : v_texcoord_1, 1.0);\n#ifdef HAS_SPECULARCOLOR_UV_TRANSFORM\n    uv = u_SpecularColorUVTransform * uv;\n#endif\n    return uv.xy;\n}\n\n#endif\n\n// Transmission Material\n\n#ifdef MATERIAL_TRANSMISSION\n\nuniform sampler2D u_TransmissionSampler;\nuniform int u_TransmissionUVSet;\nuniform mat3 u_TransmissionUVTransform;\nuniform sampler2D u_TransmissionFramebufferSampler;\nuniform ivec2 u_TransmissionFramebufferSize;\n\nvec2 getTransmissionUV()\n{\n    vec3 uv = vec3(u_TransmissionUVSet < 1 ? v_texcoord_0 : v_texcoord_1, 1.0);\n#ifdef HAS_TRANSMISSION_UV_TRANSFORM\n    uv = u_TransmissionUVTransform * uv;\n#endif\n    return uv.xy;\n}\n\n#endif\n\n// Volume Material\n\n#ifdef MATERIAL_VOLUME\n\nuniform sampler2D u_ThicknessSampler;\nuniform int u_ThicknessUVSet;\nuniform mat3 u_ThicknessUVTransform;\n\nvec2 getThicknessUV()\n{\n    vec3 uv = vec3(u_ThicknessUVSet < 1 ? v_texcoord_0 : v_texcoord_1, 1.0);\n#ifdef HAS_THICKNESS_UV_TRANSFORM\n    uv = u_ThicknessUVTransform * uv;\n#endif\n    return uv.xy;\n}\n\n#endif\n\n// Iridescence\n\n#ifdef MATERIAL_IRIDESCENCE\n\nuniform sampler2D u_IridescenceSampler;\nuniform int u_IridescenceUVSet;\nuniform mat3 u_IridescenceUVTransform;\n\nuniform sampler2D u_IridescenceThicknessSampler;\nuniform int u_IridescenceThicknessUVSet;\nuniform mat3 u_IridescenceThicknessUVTransform;\n\nvec2 getIridescenceUV()\n{\n    vec3 uv = vec3(u_IridescenceUVSet < 1 ? v_texcoord_0 : v_texcoord_1, 1.0);\n#ifdef HAS_IRIDESCENCE_UV_TRANSFORM\n    uv = u_IridescenceUVTransform * uv;\n#endif\n    return uv.xy;\n}\n\nvec2 getIridescenceThicknessUV()\n{\n    vec3 uv = vec3(u_IridescenceThicknessUVSet < 1 ? v_texcoord_0 : v_texcoord_1, 1.0);\n#ifdef HAS_IRIDESCENCETHICKNESS_UV_TRANSFORM\n    uv = u_IridescenceThicknessUVTransform * uv;\n#endif\n    return uv.xy;\n}\n\n#endif\n"; // eslint-disable-line

    var tonemappingShader = "#define GLSLIFY 1\nuniform float u_Exposure;\n\nconst float GAMMA = 2.2;\nconst float INV_GAMMA = 1.0 / GAMMA;\n\n// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\nconst mat3 ACESInputMat = mat3\n(\n    0.59719, 0.07600, 0.02840,\n    0.35458, 0.90834, 0.13383,\n    0.04823, 0.01566, 0.83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 ACESOutputMat = mat3\n(\n    1.60475, -0.10208, -0.00327,\n    -0.53108,  1.10813, -0.07276,\n    -0.07367, -0.00605,  1.07602\n);\n\n// linear to sRGB approximation\n// see http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html\nvec3 linearTosRGB(vec3 color)\n{\n    return pow(color, vec3(INV_GAMMA));\n}\n\n// sRGB to linear approximation\n// see http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html\nvec3 sRGBToLinear(vec3 srgbIn)\n{\n    return vec3(pow(srgbIn.xyz, vec3(GAMMA)));\n}\n\nvec4 sRGBToLinear(vec4 srgbIn)\n{\n    return vec4(sRGBToLinear(srgbIn.xyz), srgbIn.w);\n}\n\n// ACES tone map (faster approximation)\n// see: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 toneMapACES_Narkowicz(vec3 color)\n{\n    const float A = 2.51;\n    const float B = 0.03;\n    const float C = 2.43;\n    const float D = 0.59;\n    const float E = 0.14;\n    return clamp((color * (A * color + B)) / (color * (C * color + D) + E), 0.0, 1.0);\n}\n\n// ACES filmic tone map approximation\n// see https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\nvec3 RRTAndODTFit(vec3 color)\n{\n    vec3 a = color * (color + 0.0245786) - 0.000090537;\n    vec3 b = color * (0.983729 * color + 0.4329510) + 0.238081;\n    return a / b;\n}\n\n// tone mapping \nvec3 toneMapACES_Hill(vec3 color)\n{\n    color = ACESInputMat * color;\n\n    // Apply RRT and ODT\n    color = RRTAndODTFit(color);\n\n    color = ACESOutputMat * color;\n\n    // Clamp to [0, 1]\n    color = clamp(color, 0.0, 1.0);\n\n    return color;\n}\n\nvec3 toneMap(vec3 color)\n{\n    color *= u_Exposure;\n\n#ifdef TONEMAP_ACES_NARKOWICZ\n    color = toneMapACES_Narkowicz(color);\n#endif\n\n#ifdef TONEMAP_ACES_HILL\n    color = toneMapACES_Hill(color);\n#endif\n\n#ifdef TONEMAP_ACES_HILL_EXPOSURE_BOOST\n    // boost exposure as discussed in https://github.com/mrdoob/three.js/pull/19621\n    // this factor is based on the exposure correction of Krzysztof Narkowicz in his\n    // implemetation of ACES tone mapping\n    color /= 0.6;\n    color = toneMapACES_Hill(color);\n#endif\n\n    return linearTosRGB(color);\n}\n"; // eslint-disable-line

    var shaderFunctions = "#define GLSLIFY 1\nconst float M_PI = 3.141592653589793;\n\nin vec3 v_Position;\n\n#ifdef HAS_NORMAL_VEC3\n#ifdef HAS_TANGENT_VEC4\nin mat3 v_TBN;\n#else\nin vec3 v_Normal;\n#endif\n#endif\n\n#ifdef HAS_COLOR_0_VEC3\nin vec3 v_Color;\n#endif\n#ifdef HAS_COLOR_0_VEC4\nin vec4 v_Color;\n#endif\n\nvec4 getVertexColor()\n{\n   vec4 color = vec4(1.0);\n\n#ifdef HAS_COLOR_0_VEC3\n    color.rgb = v_Color.rgb;\n#endif\n#ifdef HAS_COLOR_0_VEC4\n    color = v_Color;\n#endif\n\n   return color;\n}\n\nstruct NormalInfo {\n    vec3 ng;   // Geometry normal\n    vec3 t;    // Geometry tangent\n    vec3 b;    // Geometry bitangent\n    vec3 n;    // Shading normal\n    vec3 ntex; // Normal from texture, scaling is accounted for.\n};\n\nfloat clampedDot(vec3 x, vec3 y)\n{\n    return clamp(dot(x, y), 0.0, 1.0);\n}\n\nfloat max3(vec3 v)\n{\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n    return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n    return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n    return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n    return t * t;\n}\n\nfloat applyIorToRoughness(float roughness, float ior)\n{\n    // Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and\n    // an IOR of 1.5 results in the default amount of microfacet refraction.\n    return roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);\n}\n"; // eslint-disable-line

    var animationShader = "#define GLSLIFY 1\n#ifdef HAS_MORPH_TARGETS\nuniform highp sampler2DArray u_MorphTargetsSampler;\n#endif\n\n#ifdef USE_MORPHING\nuniform float u_morphWeights[WEIGHT_COUNT];\n#endif\n\n#ifdef HAS_JOINTS_0_VEC4\nin vec4 a_joints_0;\n#endif\n\n#ifdef HAS_JOINTS_1_VEC4\nin vec4 a_joints_1;\n#endif\n\n#ifdef HAS_WEIGHTS_0_VEC4\nin vec4 a_weights_0;\n#endif\n\n#ifdef HAS_WEIGHTS_1_VEC4\nin vec4 a_weights_1;\n#endif\n\n#ifdef USE_SKINNING\nuniform sampler2D u_jointsSampler;\n#endif\n\n#ifdef USE_SKINNING\n\nmat4 getMatrixFromTexture(sampler2D s, int index)\n{\n    mat4 result = mat4(1);\n    int texSize = textureSize(s, 0)[0];\n    int pixelIndex = index * 4;\n    for (int i = 0; i < 4; ++i)\n    {\n        int x = (pixelIndex + i) % texSize;\n        //Rounding mode of integers is undefined:\n        //https://www.khronos.org/registry/OpenGL/specs/es/3.0/GLSL_ES_Specification_3.00.pdf (section 12.33)\n        int y = (pixelIndex + i - x) / texSize; \n        result[i] = texelFetch(s, ivec2(x,y), 0);\n    }\n    return result;\n}\n\nmat4 getSkinningMatrix()\n{\n    mat4 skin = mat4(0);\n\n#if defined(HAS_WEIGHTS_0_VEC4) && defined(HAS_JOINTS_0_VEC4)\n    skin +=\n        a_weights_0.x * getMatrixFromTexture(u_jointsSampler, int(a_joints_0.x) * 2) +\n        a_weights_0.y * getMatrixFromTexture(u_jointsSampler, int(a_joints_0.y) * 2) +\n        a_weights_0.z * getMatrixFromTexture(u_jointsSampler, int(a_joints_0.z) * 2) +\n        a_weights_0.w * getMatrixFromTexture(u_jointsSampler, int(a_joints_0.w) * 2);\n#endif\n\n#if defined(HAS_WEIGHTS_1_VEC4) && defined(HAS_JOINTS_1_VEC4)\n    skin +=\n        a_weights_1.x * getMatrixFromTexture(u_jointsSampler, int(a_joints_1.x) * 2) +\n        a_weights_1.y * getMatrixFromTexture(u_jointsSampler, int(a_joints_1.y) * 2) +\n        a_weights_1.z * getMatrixFromTexture(u_jointsSampler, int(a_joints_1.z) * 2) +\n        a_weights_1.w * getMatrixFromTexture(u_jointsSampler, int(a_joints_1.w) * 2);\n#endif\n    if (skin == mat4(0)) { \n        return mat4(1); \n    }\n    return skin;\n}\n\nmat4 getSkinningNormalMatrix()\n{\n    mat4 skin = mat4(0);\n\n#if defined(HAS_WEIGHTS_0_VEC4) && defined(HAS_JOINTS_0_VEC4)\n    skin +=\n        a_weights_0.x * getMatrixFromTexture(u_jointsSampler, int(a_joints_0.x) * 2 + 1) +\n        a_weights_0.y * getMatrixFromTexture(u_jointsSampler, int(a_joints_0.y) * 2 + 1) +\n        a_weights_0.z * getMatrixFromTexture(u_jointsSampler, int(a_joints_0.z) * 2 + 1) +\n        a_weights_0.w * getMatrixFromTexture(u_jointsSampler, int(a_joints_0.w) * 2 + 1);\n#endif\n\n#if defined(HAS_WEIGHTS_1_VEC4) && defined(HAS_JOINTS_1_VEC4)\n    skin +=\n        a_weights_1.x * getMatrixFromTexture(u_jointsSampler, int(a_joints_1.x) * 2 + 1) +\n        a_weights_1.y * getMatrixFromTexture(u_jointsSampler, int(a_joints_1.y) * 2 + 1) +\n        a_weights_1.z * getMatrixFromTexture(u_jointsSampler, int(a_joints_1.z) * 2 + 1) +\n        a_weights_1.w * getMatrixFromTexture(u_jointsSampler, int(a_joints_1.w) * 2 + 1);\n#endif\n    if (skin == mat4(0)) { \n        return mat4(1); \n    }\n    return skin;\n}\n\n#endif // !USE_SKINNING\n\n#ifdef USE_MORPHING\n\n#ifdef HAS_MORPH_TARGETS\nvec4 getDisplacement(int vertexID, int targetIndex, int texSize)\n{\n    int x = vertexID % texSize;\n    //Rounding mode of integers is undefined:\n    //https://www.khronos.org/registry/OpenGL/specs/es/3.0/GLSL_ES_Specification_3.00.pdf (section 12.33)\n    int y = (vertexID - x) / texSize; \n    return texelFetch(u_MorphTargetsSampler, ivec3(x, y, targetIndex), 0);\n}\n#endif\n\nvec4 getTargetPosition(int vertexID)\n{\n    vec4 pos = vec4(0);\n#ifdef HAS_MORPH_TARGET_POSITION\n    int texSize = textureSize(u_MorphTargetsSampler, 0)[0];\n    for(int i = 0; i < WEIGHT_COUNT; i++)\n    {\n        vec4 displacement = getDisplacement(vertexID, MORPH_TARGET_POSITION_OFFSET + i, texSize);\n        pos += u_morphWeights[i] * displacement;\n    }\n#endif\n\n    return pos;\n}\n\nvec3 getTargetNormal(int vertexID)\n{\n    vec3 normal = vec3(0);\n\n#ifdef HAS_MORPH_TARGET_NORMAL\n    int texSize = textureSize(u_MorphTargetsSampler, 0)[0];\n    for(int i = 0; i < WEIGHT_COUNT; i++)\n    {\n        vec3 displacement = getDisplacement(vertexID, MORPH_TARGET_NORMAL_OFFSET + i, texSize).xyz;\n        normal += u_morphWeights[i] * displacement;\n    }\n#endif\n\n    return normal;\n}\n\nvec3 getTargetTangent(int vertexID)\n{\n    vec3 tangent = vec3(0);\n\n#ifdef HAS_MORPH_TARGET_TANGENT\n    int texSize = textureSize(u_MorphTargetsSampler, 0)[0];\n    for(int i = 0; i < WEIGHT_COUNT; i++)\n    {\n        vec3 displacement = getDisplacement(vertexID, MORPH_TARGET_TANGENT_OFFSET + i, texSize).xyz;\n        tangent += u_morphWeights[i] * displacement;\n    }\n#endif\n\n    return tangent;\n}\n\nvec2 getTargetTexCoord0(int vertexID)\n{\n    vec2 uv = vec2(0);\n\n#ifdef HAS_MORPH_TARGET_TEXCOORD_0\n    int texSize = textureSize(u_MorphTargetsSampler, 0)[0];\n    for(int i = 0; i < WEIGHT_COUNT; i++)\n    {\n        vec2 displacement = getDisplacement(vertexID, MORPH_TARGET_TEXCOORD_0_OFFSET + i, texSize).xy;\n        uv += u_morphWeights[i] * displacement;\n    }\n#endif\n\n    return uv;\n}\n\nvec2 getTargetTexCoord1(int vertexID)\n{\n    vec2 uv = vec2(0);\n\n#ifdef HAS_MORPH_TARGET_TEXCOORD_1\n    int texSize = textureSize(u_MorphTargetsSampler, 0)[0];\n    for(int i = 0; i < WEIGHT_COUNT; i++)\n    {\n        vec2 displacement = getDisplacement(vertexID, MORPH_TARGET_TEXCOORD_1_OFFSET + i, texSize).xy;\n        uv += u_morphWeights[i] * displacement;\n    }\n#endif\n\n    return uv;\n}\n\nvec4 getTargetColor0(int vertexID)\n{\n    vec4 color = vec4(0);\n\n#ifdef HAS_MORPH_TARGET_COLOR_0\n    int texSize = textureSize(u_MorphTargetsSampler, 0)[0];\n    for(int i = 0; i < WEIGHT_COUNT; i++)\n    {\n        vec4 displacement = getDisplacement(vertexID, MORPH_TARGET_COLOR_0_OFFSET + i, texSize);\n        color += u_morphWeights[i] * displacement;\n    }\n#endif\n\n    return color;\n}\n\n#endif // !USE_MORPHING\n"; // eslint-disable-line

    var cubemapVertShader = "#define GLSLIFY 1\nuniform mat4 u_ViewProjectionMatrix;\nuniform mat3 u_EnvRotation;\n\nin vec3 a_position;\nout vec3 v_TexCoords;\n\nvoid main()\n{\n    v_TexCoords = u_EnvRotation * a_position;\n    mat4 mat = u_ViewProjectionMatrix;\n    mat[3] = vec4(0.0, 0.0, 0.0, 0.1);\n    vec4 pos = mat * vec4(a_position, 1.0);\n    gl_Position = pos.xyww;\n}\n"; // eslint-disable-line

    var cubemapFragShader = "precision highp float;\n#define GLSLIFY 1\n\n#include <tonemapping.glsl>\n\nuniform float u_EnvIntensity;\nuniform float u_EnvBlurNormalized;\nuniform int u_MipCount;\nuniform samplerCube u_GGXEnvSampler;\n\nout vec4 FragColor;\nin vec3 v_TexCoords;\n\nvoid main()\n{\n    vec4 color = textureLod(u_GGXEnvSampler, v_TexCoords, u_EnvBlurNormalized * float(u_MipCount - 1)) * u_EnvIntensity;\n\n#ifdef LINEAR_OUTPUT\n    FragColor = color.rgba;\n#else\n    FragColor = vec4(toneMap(color.rgb), color.a);\n#endif\n}\n"; // eslint-disable-line

    class gltfLight extends GltfObject
    {
        constructor(
            type = "directional",
            color = [1, 1, 1],
            intensity = 1,
            innerConeAngle = 0,
            outerConeAngle = Math.PI / 4,
            range = -1,
            name = undefined,
            node = undefined)
        {
            super();
            this.type = type;
            this.color = color;
            this.intensity = intensity;
            this.innerConeAngle = innerConeAngle;
            this.outerConeAngle = outerConeAngle;
            this.range = range;
            this.name = name;
            // non gltf
            this.node = node;
            //Can be used to overwrite direction from node
            this.direction = undefined;
        }

        initGl(gltf, webGlContext)
        {
            super.initGl(gltf, webGlContext);

            for (let i = 0; i < gltf.nodes.length; i++)
            {
                const nodeExtensions = gltf.nodes[i].extensions;
                if (nodeExtensions === undefined)
                {
                    continue;
                }

                const lightsExtension = nodeExtensions.KHR_lights_punctual;
                if (lightsExtension === undefined)
                {
                    continue;
                }

                const lightIndex = lightsExtension.light;
                if (gltf.lights[lightIndex] === this)
                {
                    this.node = i;
                    break;
                }
            }
        }

        fromJson(jsonLight)
        {
            super.fromJson(jsonLight);

            if(jsonLight.spot !== undefined)
            {
                fromKeys(this, jsonLight.spot);
            }
        }

        toUniform(gltf)
        {
            const uLight = new UniformLight();

            if (this.node !== undefined)
            {
                const matrix = gltf.nodes[this.node].worldTransform;

                var scale = glMatrix.vec3.fromValues(1, 1, 1);
                glMatrix.mat4.getScaling(scale, matrix);

                // To extract a correct rotation, the scaling component must be eliminated.
                const mn = glMatrix.mat4.create();
                for(const col of [0, 1, 2])
                {
                    mn[col] = matrix[col] / scale[0];
                    mn[col + 4] = matrix[col + 4] / scale[1];
                    mn[col + 8] = matrix[col + 8] / scale[2];
                }
                var rotation = glMatrix.quat.create();
                glMatrix.mat4.getRotation(rotation, mn);
                glMatrix.quat.normalize(rotation, rotation);

                const alongNegativeZ = glMatrix.vec3.fromValues(0, 0, -1);
                glMatrix.vec3.transformQuat(uLight.direction, alongNegativeZ, rotation);

                var translation = glMatrix.vec3.fromValues(0, 0, 0);
                glMatrix.mat4.getTranslation(translation, matrix);
                uLight.position = translation;
            }

            if (this.direction !== undefined)
            {
                uLight.direction = this.direction;
            }

            uLight.range = this.range;
            uLight.color = jsToGl(this.color);
            uLight.intensity = this.intensity;

            uLight.innerConeCos = Math.cos(this.innerConeAngle);
            uLight.outerConeCos = Math.cos(this.outerConeAngle);

            switch(this.type)
            {
            case "spot":
                uLight.type = Type_Spot;
                break;
            case "point":
                uLight.type = Type_Point;
                break;
            case "directional":
            default:
                uLight.type = Type_Directional;
                break;
            }

            return uLight;
        }
    }

    const Type_Directional = 0;
    const Type_Point = 1;
    const Type_Spot = 2;

    class UniformLight extends UniformStruct
    {
        constructor()
        {
            super();

            const defaultDirection = glMatrix.vec3.fromValues(-0.7399, -0.6428, -0.1983);
            this.direction = defaultDirection;
            this.range = -1;

            this.color = jsToGl([1, 1, 1]);
            this.intensity = 1;

            this.position = jsToGl([0, 0, 0]);
            this.innerConeCos = 0.0;

            this.outerConeCos = Math.PI / 4;
            this.type = Type_Directional;
        }
    }

    class gltfRenderer
    {
        constructor(context)
        {
            this.shader = undefined; // current shader

            this.currentWidth = 0;
            this.currentHeight = 0;

            this.webGl = new gltfWebGl(context);
            this.initialized = false;
            this.samples = 4;

            // create render target for non transmission materials
            this.opaqueRenderTexture = 0;
            this.opaqueFramebuffer = 0;
            this.opaqueDepthTexture = 0;
            this.opaqueFramebufferWidth = 1024;
            this.opaqueFramebufferHeight = 1024;

            const shaderSources = new Map();
            shaderSources.set("primitive.vert", primitiveShader);
            shaderSources.set("pbr.frag", pbrShader);
            shaderSources.set("material_info.glsl", materialInfoShader);
            shaderSources.set("brdf.glsl", brdfShader);
            shaderSources.set("iridescence.glsl", iridescenceShader);
            shaderSources.set("ibl.glsl", iblShader);
            shaderSources.set("punctual.glsl", punctualShader);
            shaderSources.set("tonemapping.glsl", tonemappingShader);
            shaderSources.set("textures.glsl", texturesShader);
            shaderSources.set("functions.glsl", shaderFunctions);
            shaderSources.set("animation.glsl", animationShader);
            shaderSources.set("cubemap.vert", cubemapVertShader);
            shaderSources.set("cubemap.frag", cubemapFragShader);

            this.shaderCache = new ShaderCache(shaderSources, this.webGl);

            let requiredWebglExtensions = [
                "EXT_texture_filter_anisotropic",
                "OES_texture_float_linear"
            ];

            this.webGl.loadWebGlExtensions(requiredWebglExtensions);

            this.visibleLights = [];

            this.viewMatrix = glMatrix.mat4.create();
            this.projMatrix = glMatrix.mat4.create();
            this.viewProjectionMatrix = glMatrix.mat4.create();

            this.currentCameraPosition = glMatrix.vec3.create();

            this.lightKey = new gltfLight();
            this.lightFill = new gltfLight();
            this.lightFill.intensity = 0.5;
            const quatKey = glMatrix.quat.fromValues(
                -0.3535534,
                -0.353553385,
                -0.146446586,
                0.8535534);
            const quatFill = glMatrix.quat.fromValues(
                -0.8535534,
                0.146446645,
                -0.353553325,
                -0.353553444);
            this.lightKey.direction = glMatrix.vec3.create();
            this.lightFill.direction = glMatrix.vec3.create();
            glMatrix.vec3.transformQuat(this.lightKey.direction, [0, 0, -1], quatKey);
            glMatrix.vec3.transformQuat(this.lightFill.direction, [0, 0, -1], quatFill);
        }

        /////////////////////////////////////////////////////////////////////
        // Render glTF scene graph
        /////////////////////////////////////////////////////////////////////

        // app state
        init(state)
        {
            const context = this.webGl.context;
            const maxSamples = context.getParameter(context.MAX_SAMPLES);
            const samples = state.internalMSAA < maxSamples ? state.internalMSAA : maxSamples;
            if (!this.initialized){

                context.pixelStorei(GL.UNPACK_COLORSPACE_CONVERSION_WEBGL, GL.NONE);
                context.enable(GL.DEPTH_TEST);
                context.depthFunc(GL.LEQUAL);
                context.colorMask(true, true, true, true);
                context.clearDepth(1.0);

                this.opaqueRenderTexture = context.createTexture();
                context.bindTexture(context.TEXTURE_2D, this.opaqueRenderTexture);
                context.texParameteri(context.TEXTURE_2D, context.TEXTURE_MIN_FILTER, context.LINEAR_MIPMAP_LINEAR);
                context.texParameteri(context.TEXTURE_2D, context.TEXTURE_WRAP_S, context.CLAMP_TO_EDGE);
                context.texParameteri(context.TEXTURE_2D, context.TEXTURE_WRAP_T, context.CLAMP_TO_EDGE);
                context.texParameteri(context.TEXTURE_2D, context.TEXTURE_MAG_FILTER, context.NEAREST);
                context.texImage2D( context.TEXTURE_2D,
                                    0,
                                    context.RGBA,
                                    this.opaqueFramebufferWidth,
                                    this.opaqueFramebufferHeight,
                                    0,
                                    context.RGBA,
                                    context.UNSIGNED_BYTE,
                                    null);
                context.bindTexture(context.TEXTURE_2D, null);

                this.opaqueDepthTexture = context.createTexture();
                context.bindTexture(context.TEXTURE_2D, this.opaqueDepthTexture);
                context.texParameteri(context.TEXTURE_2D, context.TEXTURE_MIN_FILTER, context.NEAREST);
                context.texParameteri(context.TEXTURE_2D, context.TEXTURE_WRAP_S, context.CLAMP_TO_EDGE);
                context.texParameteri(context.TEXTURE_2D, context.TEXTURE_WRAP_T, context.CLAMP_TO_EDGE);
                context.texParameteri(context.TEXTURE_2D, context.TEXTURE_MAG_FILTER, context.NEAREST);
                context.texImage2D( context.TEXTURE_2D,
                                    0,
                                    context.DEPTH_COMPONENT16,
                                    this.opaqueFramebufferWidth,
                                    this.opaqueFramebufferHeight,
                                    0,
                                    context.DEPTH_COMPONENT,
                                    context.UNSIGNED_SHORT,
                                    null);
                context.bindTexture(context.TEXTURE_2D, null);


                this.colorRenderBuffer = context.createRenderbuffer();
                context.bindRenderbuffer(context.RENDERBUFFER, this.colorRenderBuffer);
                context.renderbufferStorageMultisample( context.RENDERBUFFER,
                                                        samples,
                                                        context.RGBA8, 
                                                        this.opaqueFramebufferWidth,
                                                        this.opaqueFramebufferHeight);

                this.depthRenderBuffer = context.createRenderbuffer();
                context.bindRenderbuffer(context.RENDERBUFFER, this.depthRenderBuffer);
                context.renderbufferStorageMultisample( context.RENDERBUFFER,
                    samples,
                    context.DEPTH_COMPONENT16, 
                    this.opaqueFramebufferWidth,
                    this.opaqueFramebufferHeight);

                this.samples = samples;

                this.opaqueFramebufferMSAA = context.createFramebuffer();
                context.bindFramebuffer(context.FRAMEBUFFER, this.opaqueFramebufferMSAA);
                context.framebufferRenderbuffer(context.FRAMEBUFFER, context.COLOR_ATTACHMENT0, context.RENDERBUFFER, this.colorRenderBuffer);
                context.framebufferRenderbuffer(context.FRAMEBUFFER, context.DEPTH_ATTACHMENT, context.RENDERBUFFER, this.depthRenderBuffer);


                this.opaqueFramebuffer = context.createFramebuffer();
                context.bindFramebuffer(context.FRAMEBUFFER, this.opaqueFramebuffer);
                context.framebufferTexture2D(context.FRAMEBUFFER, context.COLOR_ATTACHMENT0, context.TEXTURE_2D, this.opaqueRenderTexture, 0);
                context.framebufferTexture2D(context.FRAMEBUFFER, context.DEPTH_ATTACHMENT, context.TEXTURE_2D, this.opaqueDepthTexture, 0);
                context.viewport(0, 0, this.opaqueFramebufferWidth, this.opaqueFramebufferHeight);
                context.bindFramebuffer(context.FRAMEBUFFER, null);

                this.initialized = true;

                this.environmentRenderer = new EnvironmentRenderer(this.webGl);
            }
            else {
                if (this.samples != samples)
                {
                    this.samples = samples;
                    context.bindRenderbuffer(context.RENDERBUFFER, this.colorRenderBuffer);
                    context.renderbufferStorageMultisample( context.RENDERBUFFER,
                        samples,
                        context.RGBA8, 
                        this.opaqueFramebufferWidth,
                        this.opaqueFramebufferHeight);
                    
                    context.bindRenderbuffer(context.RENDERBUFFER, this.depthRenderBuffer);
                    context.renderbufferStorageMultisample( context.RENDERBUFFER,
                        samples,
                        context.DEPTH_COMPONENT16, 
                        this.opaqueFramebufferWidth,
                        this.opaqueFramebufferHeight);
                }
            }
        }

        resize(width, height)
        {
            if (this.currentWidth !== width || this.currentHeight !== height)
            {
                this.currentHeight = height;
                this.currentWidth = width;
                this.webGl.context.viewport(0, 0, width, height);
            }
        }

        // frame state
        clearFrame(clearColor)
        {
            this.webGl.context.bindFramebuffer(this.webGl.context.FRAMEBUFFER, null);
            this.webGl.context.clearColor(clearColor[0] / 255.0, clearColor[1] / 255.0, clearColor[2] / 255.0, clearColor[3] / 255.0);
            this.webGl.context.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);
            this.webGl.context.bindFramebuffer(this.webGl.context.FRAMEBUFFER, this.opaqueFramebuffer);
            this.webGl.context.clearColor(clearColor[0] / 255.0, clearColor[1] / 255.0, clearColor[2] / 255.0, clearColor[3] / 255.0);
            this.webGl.context.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);
            this.webGl.context.bindFramebuffer(this.webGl.context.FRAMEBUFFER, null);
            this.webGl.context.bindFramebuffer(this.webGl.context.FRAMEBUFFER, this.opaqueFramebufferMSAA);
            this.webGl.context.clearColor(clearColor[0] / 255.0, clearColor[1] / 255.0, clearColor[2] / 255.0, clearColor[3] / 255.0);
            this.webGl.context.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);
            this.webGl.context.bindFramebuffer(this.webGl.context.FRAMEBUFFER, null);
        }

        prepareScene(state, scene) {
            this.nodes = scene.gatherNodes(state.gltf);

            // collect drawables by essentially zipping primitives (for geometry and material)
            // and nodes for the transform
            const drawables = this.nodes
                .filter(node => node.mesh !== undefined)
                .reduce((acc, node) => acc.concat(state.gltf.meshes[node.mesh].primitives.map( primitive => {
                    return  {node: node, primitive: primitive};
                })), [])
                .filter(({node, primitive}) => primitive.material !== undefined);

            // opaque drawables don't need sorting
            this.opaqueDrawables = drawables
                .filter(({node, primitive}) => state.gltf.materials[primitive.material].alphaMode !== "BLEND"
                    && (state.gltf.materials[primitive.material].extensions === undefined
                        || state.gltf.materials[primitive.material].extensions.KHR_materials_transmission === undefined));

            // transparent drawables need sorting before they can be drawn
            this.transparentDrawables = drawables
                .filter(({node, primitive}) => state.gltf.materials[primitive.material].alphaMode === "BLEND"
                    && (state.gltf.materials[primitive.material].extensions === undefined
                        || state.gltf.materials[primitive.material].extensions.KHR_materials_transmission === undefined));

            this.transmissionDrawables = drawables
                .filter(({node, primitive}) => state.gltf.materials[primitive.material].extensions !== undefined
                    && state.gltf.materials[primitive.material].extensions.KHR_materials_transmission !== undefined);
        }

        // render complete gltf scene with given camera
        drawScene(state, scene)
        {
            if (this.preparedScene !== scene) {
                this.prepareScene(state, scene);
                this.preparedScene = scene;
            }

            let currentCamera = undefined;

            if (state.cameraIndex === undefined)
            {
                currentCamera = state.userCamera;
            }
            else
            {
                currentCamera = state.gltf.cameras[state.cameraIndex].clone();
            }

            currentCamera.aspectRatio = this.currentWidth / this.currentHeight;

            this.projMatrix = currentCamera.getProjectionMatrix();
            this.viewMatrix = currentCamera.getViewMatrix(state.gltf);
            this.currentCameraPosition = currentCamera.getPosition(state.gltf);

            this.visibleLights = this.getVisibleLights(state.gltf, scene);
            if (this.visibleLights.length === 0 && !state.renderingParameters.useIBL &&
                state.renderingParameters.useDirectionalLightsWithDisabledIBL)
            {
                this.visibleLights.push(this.lightKey);
                this.visibleLights.push(this.lightFill);
            }

            glMatrix.mat4.multiply(this.viewProjectionMatrix, this.projMatrix, this.viewMatrix);

            // Update skins.
            for (const node of this.nodes)
            {
                if (node.mesh !== undefined && node.skin !== undefined)
                {
                    this.updateSkin(state, node);
                }
            }

            // If any transmissive drawables are present, render all opaque and transparent drawables into a separate framebuffer.
            if (this.transmissionDrawables.length > 0) {
                // Render transmission sample texture
                this.webGl.context.bindFramebuffer(this.webGl.context.FRAMEBUFFER, this.opaqueFramebufferMSAA);
                this.webGl.context.viewport(0, 0, this.opaqueFramebufferWidth, this.opaqueFramebufferHeight);

                // Render environment for the transmission background
                this.environmentRenderer.drawEnvironmentMap(this.webGl, this.viewProjectionMatrix, state, this.shaderCache, ["LINEAR_OUTPUT 1"]);

                for (const drawable of this.opaqueDrawables)
                {
                    var renderpassConfiguration = {};
                    renderpassConfiguration.linearOutput = true;
                    this.drawPrimitive(state, renderpassConfiguration, drawable.primitive, drawable.node, this.viewProjectionMatrix);
                }

                this.transparentDrawables = currentCamera.sortPrimitivesByDepth(state.gltf, this.transparentDrawables);
                for (const drawable of this.transparentDrawables)
                {
                    var renderpassConfiguration = {};
                    renderpassConfiguration.linearOutput = true;
                    this.drawPrimitive(state, renderpassConfiguration, drawable.primitive, drawable.node, this.viewProjectionMatrix);
                }

                // "blit" the multisampled opaque texture into the color buffer, which adds antialiasing
                this.webGl.context.bindFramebuffer(this.webGl.context.READ_FRAMEBUFFER, this.opaqueFramebufferMSAA);
                this.webGl.context.bindFramebuffer(this.webGl.context.DRAW_FRAMEBUFFER, this.opaqueFramebuffer);
                this.webGl.context.blitFramebuffer(0, 0, this.opaqueFramebufferWidth, this.opaqueFramebufferHeight,
                                    0, 0, this.opaqueFramebufferWidth, this.opaqueFramebufferHeight,
                                    this.webGl.context.COLOR_BUFFER_BIT, this.webGl.context.NEAREST);

                // Create Framebuffer Mipmaps
                this.webGl.context.bindTexture(this.webGl.context.TEXTURE_2D, this.opaqueRenderTexture);

                this.webGl.context.generateMipmap(this.webGl.context.TEXTURE_2D);
            }

            // Render to canvas
            this.webGl.context.bindFramebuffer(this.webGl.context.FRAMEBUFFER, null);
            this.webGl.context.viewport(0, 0,  this.currentWidth, this.currentHeight);

            // Render environment
            const fragDefines = [];
            this.pushFragParameterDefines(fragDefines, state);
            this.environmentRenderer.drawEnvironmentMap(this.webGl, this.viewProjectionMatrix, state, this.shaderCache, fragDefines);

            for (const drawable of this.opaqueDrawables)
            {  
                var renderpassConfiguration = {};
                renderpassConfiguration.linearOutput = false;
                this.drawPrimitive(state, renderpassConfiguration, drawable.primitive, drawable.node, this.viewProjectionMatrix);
            }

            // filter materials with transmission extension
            this.transmissionDrawables = currentCamera.sortPrimitivesByDepth(state.gltf, this.transmissionDrawables);
            for (const drawable of this.transmissionDrawables)
            {
                var renderpassConfiguration = {};
                renderpassConfiguration.linearOutput = false;
                this.drawPrimitive(state, renderpassConfiguration, drawable.primitive, drawable.node, this.viewProjectionMatrix, this.opaqueRenderTexture);
            }

            for (const drawable of this.transparentDrawables)
            {
                var renderpassConfiguration = {};
                renderpassConfiguration.linearOutput = false;
                this.drawPrimitive(state, renderpassConfiguration, drawable.primitive, drawable.node, this.viewProjectionMatrix);
            }
        }

        // vertices with given material
        drawPrimitive(state, renderpassConfiguration, primitive, node, viewProjectionMatrix, transmissionSampleTexture)
        {
            if (primitive.skip) return;

            let material;
            if(primitive.mappings !== undefined && state.variant != "default")
            {
                const names = state.gltf.variants.map(obj => obj.name);
                const idx = names.indexOf(state.variant);
                let materialIdx = primitive.material;
                primitive.mappings.forEach(element => {
                    if(element.variants.indexOf(idx) >= 0)
                    {
                        materialIdx = element.material;
                    }
                });
                material = state.gltf.materials[materialIdx];
            }
            else
            {
                material = state.gltf.materials[primitive.material];
            }

            //select shader permutation, compile and link program.

            let vertDefines = [];
            this.pushVertParameterDefines(vertDefines, state.renderingParameters, state.gltf, node, primitive);
            vertDefines = primitive.getDefines().concat(vertDefines);

            let fragDefines = material.getDefines(state.renderingParameters).concat(vertDefines);
            if(renderpassConfiguration.linearOutput === true)
            {
               fragDefines.push("LINEAR_OUTPUT 1");
            }
            this.pushFragParameterDefines(fragDefines, state);
            
            const fragmentHash = this.shaderCache.selectShader(material.getShaderIdentifier(), fragDefines);
            const vertexHash = this.shaderCache.selectShader(primitive.getShaderIdentifier(), vertDefines);

            if (fragmentHash && vertexHash)
            {
                this.shader = this.shaderCache.getShaderProgram(fragmentHash, vertexHash);
            }

            if (this.shader === undefined)
            {
                return;
            }

            this.webGl.context.useProgram(this.shader.program);

            if (state.renderingParameters.usePunctual)
            {
                this.applyLights(state.gltf);
            }

            // update model dependant matrices once per node
            this.shader.updateUniform("u_ViewProjectionMatrix", viewProjectionMatrix);
            this.shader.updateUniform("u_ModelMatrix", node.worldTransform);
            this.shader.updateUniform("u_NormalMatrix", node.normalMatrix, false);
            this.shader.updateUniform("u_Exposure", state.renderingParameters.exposure, false);
            this.shader.updateUniform("u_Camera", this.currentCameraPosition, false);

            this.updateAnimationUniforms(state, node, primitive);

            if (glMatrix.mat4.determinant(node.worldTransform) < 0.0)
            {
                this.webGl.context.frontFace(GL.CW);
            }
            else
            {
                this.webGl.context.frontFace(GL.CCW);
            }

            if (material.doubleSided)
            {
                this.webGl.context.disable(GL.CULL_FACE);
            }
            else
            {
                this.webGl.context.enable(GL.CULL_FACE);
            }

            if (material.alphaMode === 'BLEND')
            {
                this.webGl.context.enable(GL.BLEND);
                this.webGl.context.blendFuncSeparate(GL.SRC_ALPHA, GL.ONE_MINUS_SRC_ALPHA, GL.ONE, GL.ONE_MINUS_SRC_ALPHA);
                this.webGl.context.blendEquation(GL.FUNC_ADD);
            }
            else
            {
                this.webGl.context.disable(GL.BLEND);
            }

            const drawIndexed = primitive.indices !== undefined;
            if (drawIndexed)
            {
                if (!this.webGl.setIndices(state.gltf, primitive.indices))
                {
                    return;
                }
            }

            let vertexCount = 0;
            for (const attribute of primitive.glAttributes)
            {
                const gltfAccessor = state.gltf.accessors[attribute.accessor];
                vertexCount = gltfAccessor.count;

                const location = this.shader.getAttributeLocation(attribute.name);
                if (location < 0)
                {
                    continue; // only skip this attribute
                }
                if (!this.webGl.enableAttribute(state.gltf, location, gltfAccessor))
                {
                    return; // skip this primitive
                }
            }

            for (let [uniform, val] of material.getProperties().entries())
            {
                this.shader.updateUniform(uniform, val, false);
            }

            let textureIndex = 0;
            for (; textureIndex < material.textures.length; ++textureIndex)
            {
                let info = material.textures[textureIndex];
                const location = this.shader.getUniformLocation(info.samplerName);

                if (location < 0)
                {
                    console.log("Unable to find uniform location of "+info.samplerName);
                    continue; // only skip this texture
                }
                if (!this.webGl.setTexture(location, state.gltf, info, textureIndex)) // binds texture and sampler
                {
                    return; // skip this material
                }
            }

            // set the morph target texture
            if (primitive.morphTargetTextureInfo !== undefined) 
            {
                const location = this.shader.getUniformLocation(primitive.morphTargetTextureInfo.samplerName);
                if (location < 0)
                {
                    console.log("Unable to find uniform location of " + primitive.morphTargetTextureInfo.samplerName);
                }

                this.webGl.setTexture(location, state.gltf, primitive.morphTargetTextureInfo, textureIndex); // binds texture and sampler
                textureIndex++;
            }

            // set the joints texture
            if (state.renderingParameters.skinning && node.skin !== undefined && primitive.hasWeights && primitive.hasJoints) 
            {
                const skin = state.gltf.skins[node.skin];
                const location = this.shader.getUniformLocation(skin.jointTextureInfo.samplerName);
                if (location < 0)
                {
                    console.log("Unable to find uniform location of " + skin.jointTextureInfo.samplerName);
                }

                this.webGl.setTexture(location, state.gltf, skin.jointTextureInfo, textureIndex); // binds texture and sampler
                textureIndex++;
            }

            let textureCount = textureIndex;
            if (state.renderingParameters.useIBL && state.environment !== undefined)
            {
                textureCount = this.applyEnvironmentMap(state, textureCount);
            }

            if (state.renderingParameters.usePunctual && state.environment !== undefined)
            {
                this.webGl.setTexture(this.shader.getUniformLocation("u_SheenELUT"), state.environment, state.environment.sheenELUT, textureCount++);
            }

            if(transmissionSampleTexture !== undefined && (state.renderingParameters.useIBL || state.renderingParameters.usePunctual)
                        && state.environment && state.renderingParameters.enabledExtensions.KHR_materials_transmission)
            {
                this.webGl.context.activeTexture(GL.TEXTURE0 + textureCount);
                this.webGl.context.bindTexture(this.webGl.context.TEXTURE_2D, this.opaqueRenderTexture);
                this.webGl.context.uniform1i(this.shader.getUniformLocation("u_TransmissionFramebufferSampler"), textureCount);
                textureCount++;

                this.webGl.context.uniform2i(this.shader.getUniformLocation("u_TransmissionFramebufferSize"), this.opaqueFramebufferWidth, this.opaqueFramebufferHeight);

                this.webGl.context.uniformMatrix4fv(this.shader.getUniformLocation("u_ModelMatrix"),false, node.worldTransform);
                this.webGl.context.uniformMatrix4fv(this.shader.getUniformLocation("u_ViewMatrix"),false, this.viewMatrix);
                this.webGl.context.uniformMatrix4fv(this.shader.getUniformLocation("u_ProjectionMatrix"),false, this.projMatrix);
            }

            if (drawIndexed)
            {
                const indexAccessor = state.gltf.accessors[primitive.indices];
                this.webGl.context.drawElements(primitive.mode, indexAccessor.count, indexAccessor.componentType, 0);
            }
            else
            {
                this.webGl.context.drawArrays(primitive.mode, 0, vertexCount);
            }

            for (const attribute of primitive.glAttributes)
            {
                const location = this.shader.getAttributeLocation(attribute.name);
                if (location < 0)
                {
                    continue; // skip this attribute
                }
                this.webGl.context.disableVertexAttribArray(location);
            }
        }

        // returns all lights that are relevant for rendering or the default light if there are none
        getVisibleLights(gltf, scene)
        {
            let lights = [];
            for (let light of gltf.lights)
            {
                if (light.node !== undefined)
                {
                    if (scene.includesNode(gltf, light.node))
                    {
                        lights.push(light);
                    }
                }
            }
            return lights;
        }

        updateSkin(state, node)
        {
            if (state.renderingParameters.skinning && state.gltf.skins !== undefined)
            {
                const skin = state.gltf.skins[node.skin];
                skin.computeJoints(state.gltf, node, this.webGl.context);
            }
        }

        pushVertParameterDefines(vertDefines, parameters, gltf, node, primitive)
        {
            // skinning
            if (parameters.skinning && node.skin !== undefined && primitive.hasWeights && primitive.hasJoints)
            {
                vertDefines.push("USE_SKINNING 1");
            }

            // morphing
            if (parameters.morphing && node.mesh !== undefined && primitive.targets.length > 0)
            {
                const mesh = gltf.meshes[node.mesh];
                if (mesh.getWeightsAnimated() !== undefined && mesh.getWeightsAnimated().length > 0)
                {
                    vertDefines.push("USE_MORPHING 1");
                    vertDefines.push("WEIGHT_COUNT " + mesh.getWeightsAnimated().length);
                }
            }
        }

        updateAnimationUniforms(state, node, primitive)
        {
            if (state.renderingParameters.morphing && node.mesh !== undefined && primitive.targets.length > 0)
            {
                const mesh = state.gltf.meshes[node.mesh];
                const weightsAnimated = mesh.getWeightsAnimated();
                if (weightsAnimated !== undefined && weightsAnimated.length > 0)
                {
                    this.shader.updateUniformArray("u_morphWeights", weightsAnimated);
                }
            }
        }

        pushFragParameterDefines(fragDefines, state)
        {
            if (state.renderingParameters.usePunctual)
            {
                fragDefines.push("USE_PUNCTUAL 1");
                fragDefines.push("LIGHT_COUNT " + this.visibleLights.length);
            }

            if (state.renderingParameters.useIBL && state.environment)
            {
                fragDefines.push("USE_IBL 1");
            }

            switch (state.renderingParameters.toneMap)
            {
            case (GltfState.ToneMaps.ACES_NARKOWICZ):
                fragDefines.push("TONEMAP_ACES_NARKOWICZ 1");
                break;
            case (GltfState.ToneMaps.ACES_HILL):
                fragDefines.push("TONEMAP_ACES_HILL 1");
                break;
            case (GltfState.ToneMaps.ACES_HILL_EXPOSURE_BOOST):
                fragDefines.push("TONEMAP_ACES_HILL_EXPOSURE_BOOST 1");
                break;
            case (GltfState.ToneMaps.NONE):
            }

            let debugOutputMapping = [
                {debugOutput: GltfState.DebugOutput.NONE, shaderDefine: "DEBUG_NONE"},
                
                {debugOutput: GltfState.DebugOutput.generic.WORLDSPACENORMAL, shaderDefine: "DEBUG_NORMAL_SHADING"},
                {debugOutput: GltfState.DebugOutput.generic.NORMAL, shaderDefine: "DEBUG_NORMAL_TEXTURE"},
                {debugOutput: GltfState.DebugOutput.generic.GEOMETRYNORMAL, shaderDefine: "DEBUG_NORMAL_GEOMETRY"},
                {debugOutput: GltfState.DebugOutput.generic.TANGENT, shaderDefine: "DEBUG_TANGENT"},
                {debugOutput: GltfState.DebugOutput.generic.BITANGENT, shaderDefine: "DEBUG_BITANGENT"},
                {debugOutput: GltfState.DebugOutput.generic.ALPHA, shaderDefine: "DEBUG_ALPHA"},
                {debugOutput: GltfState.DebugOutput.generic.UV_COORDS_0, shaderDefine: "DEBUG_UV_0"},
                {debugOutput: GltfState.DebugOutput.generic.UV_COORDS_1, shaderDefine: "DEBUG_UV_1"},
                {debugOutput: GltfState.DebugOutput.generic.OCCLUSION, shaderDefine: "DEBUG_OCCLUSION"},
                {debugOutput: GltfState.DebugOutput.generic.EMISSIVE, shaderDefine: "DEBUG_EMISSIVE"},

                {debugOutput: GltfState.DebugOutput.mr.METALLIC_ROUGHNESS, shaderDefine: "DEBUG_METALLIC_ROUGHNESS"},
                {debugOutput: GltfState.DebugOutput.mr.BASECOLOR, shaderDefine: "DEBUG_BASE_COLOR"},
                {debugOutput: GltfState.DebugOutput.mr.ROUGHNESS, shaderDefine: "DEBUG_ROUGHNESS"},
                {debugOutput: GltfState.DebugOutput.mr.METALLIC, shaderDefine: "DEBUG_METALLIC"},
                
                {debugOutput: GltfState.DebugOutput.clearcoat.CLEARCOAT, shaderDefine: "DEBUG_CLEARCOAT"},
                {debugOutput: GltfState.DebugOutput.clearcoat.CLEARCOAT_FACTOR, shaderDefine: "DEBUG_CLEARCOAT_FACTOR"},
                {debugOutput: GltfState.DebugOutput.clearcoat.CLEARCOAT_ROUGHNESS, shaderDefine: "DEBUG_CLEARCOAT_ROUGHNESS"},
                {debugOutput: GltfState.DebugOutput.clearcoat.CLEARCOAT_NORMAL, shaderDefine: "DEBUG_CLEARCOAT_NORMAL"},
                
                {debugOutput: GltfState.DebugOutput.sheen.SHEEN, shaderDefine: "DEBUG_SHEEN"},
                {debugOutput: GltfState.DebugOutput.sheen.SHEEN_COLOR, shaderDefine: "DEBUG_SHEEN_COLOR"},
                {debugOutput: GltfState.DebugOutput.sheen.SHEEN_ROUGHNESS, shaderDefine: "DEBUG_SHEEN_ROUGHNESS"},

                {debugOutput: GltfState.DebugOutput.specular.SPECULAR, shaderDefine: "DEBUG_SPECULAR"},
                {debugOutput: GltfState.DebugOutput.specular.SPECULAR_FACTOR, shaderDefine: "DEBUG_SPECULAR_FACTOR"},
                {debugOutput: GltfState.DebugOutput.specular.SPECULAR_COLOR, shaderDefine: "DEBUG_SPECULAR_COLOR"},

                {debugOutput: GltfState.DebugOutput.transmission.TRANSMISSION_VOLUME, shaderDefine: "DEBUG_TRANSMISSION_VOLUME"},
                {debugOutput: GltfState.DebugOutput.transmission.TRANSMISSION_FACTOR, shaderDefine: "DEBUG_TRANSMISSION_FACTOR"},
                {debugOutput: GltfState.DebugOutput.transmission.VOLUME_THICKNESS, shaderDefine: "DEBUG_VOLUME_THICKNESS"},

                {debugOutput: GltfState.DebugOutput.iridescence.IRIDESCENCE, shaderDefine: "DEBUG_IRIDESCENCE"},
                {debugOutput: GltfState.DebugOutput.iridescence.IRIDESCENCE_FACTOR, shaderDefine: "DEBUG_IRIDESCENCE_FACTOR"},
                {debugOutput: GltfState.DebugOutput.iridescence.IRIDESCENCE_THICKNESS, shaderDefine: "DEBUG_IRIDESCENCE_THICKNESS"},
            ];

            let mappingCount = 0;
            let mappingFound = false;
            for (let mapping of debugOutputMapping) {
                fragDefines.push(mapping.shaderDefine+" "+mappingCount++);
                if(state.renderingParameters.debugOutput == mapping.debugOutput){
                    fragDefines.push("DEBUG "+mapping.shaderDefine);
                    mappingFound = true;
                }
            }

            if(mappingFound == false) { // fallback
                fragDefines.push("DEBUG DEBUG_NONE");
            }

        }

        applyLights(gltf)
        {
            let uniformLights = [];
            for (let light of this.visibleLights)
            {
                uniformLights.push(light.toUniform(gltf));
            }

            if (uniformLights.length > 0)
            {
                this.shader.updateUniform("u_Lights", uniformLights);
            }
        }

        applyEnvironmentMap(state, texSlotOffset)
        {
            const environment = state.environment;
            this.webGl.setTexture(this.shader.getUniformLocation("u_LambertianEnvSampler"), environment, environment.diffuseEnvMap, texSlotOffset++);

            this.webGl.setTexture(this.shader.getUniformLocation("u_GGXEnvSampler"), environment, environment.specularEnvMap, texSlotOffset++);
            this.webGl.setTexture(this.shader.getUniformLocation("u_GGXLUT"), environment, environment.lut, texSlotOffset++);

            this.webGl.setTexture(this.shader.getUniformLocation("u_CharlieEnvSampler"), environment, environment.sheenEnvMap, texSlotOffset++);
            this.webGl.setTexture(this.shader.getUniformLocation("u_CharlieLUT"), environment, environment.sheenLUT, texSlotOffset++);

            this.shader.updateUniform("u_MipCount", environment.mipCount);

            let rotMatrix4 = glMatrix.mat4.create();
            glMatrix.mat4.rotateY(rotMatrix4, rotMatrix4,  state.renderingParameters.environmentRotation / 180.0 * Math.PI);
            let rotMatrix3 = glMatrix.mat3.create();
            glMatrix.mat3.fromMat4(rotMatrix3, rotMatrix4);
            this.shader.updateUniform("u_EnvRotation", rotMatrix3);

            this.shader.updateUniform("u_EnvIntensity", state.renderingParameters.iblIntensity);

            return texSlotOffset;
        }

        destroy()
        {
            this.shaderCache.destroy();
        }
    }

    class gltfAccessor extends GltfObject
    {
        constructor()
        {
            super();
            this.bufferView = undefined;
            this.byteOffset = 0;
            this.componentType = undefined;
            this.normalized = false;
            this.count = undefined;
            this.type = undefined;
            this.max = undefined;
            this.min = undefined;
            this.sparse = undefined;
            this.name = undefined;

            // non gltf
            this.glBuffer = undefined;
            this.typedView = undefined;
            this.filteredView = undefined;
            this.normalizedFilteredView = undefined;
            this.normalizedTypedView = undefined;
        }

        // getTypedView provides a view to the accessors data in form of
        // a TypedArray. This data can directly be passed to vertexAttribPointer
        getTypedView(gltf)
        {
            if (this.typedView !== undefined)
            {
                return this.typedView;
            }

            if (this.bufferView !== undefined)
            {
                const bufferView = gltf.bufferViews[this.bufferView];
                const buffer = gltf.buffers[bufferView.buffer];
                const byteOffset = this.byteOffset + bufferView.byteOffset;

                const componentSize = this.getComponentSize(this.componentType);
                let componentCount = this.getComponentCount(this.type);

                let arrayLength = 0;
                if(bufferView.byteStride !== 0)
                {
                    if (componentSize !== 0)
                    {
                        arrayLength = bufferView.byteStride / componentSize * (this.count - 1) + componentCount;
                    }
                    else
                    {
                        console.warn("Invalid component type in accessor '" + (this.name ? this.name : "") + "'");
                    }
                }
                else
                {
                    arrayLength = this.count * componentCount;
                }

                if (arrayLength * componentSize > buffer.buffer.byteLength - byteOffset)
                {
                    arrayLength = (buffer.buffer.byteLength - byteOffset) / componentSize;
                    console.warn("Count in accessor '" + (this.name ? this.name : "") + "' is too large.");
                }

                switch (this.componentType)
                {
                case GL.BYTE:
                    this.typedView = new Int8Array(buffer.buffer, byteOffset, arrayLength);
                    break;
                case GL.UNSIGNED_BYTE:
                    this.typedView = new Uint8Array(buffer.buffer, byteOffset, arrayLength);
                    break;
                case GL.SHORT:
                    this.typedView = new Int16Array(buffer.buffer, byteOffset, arrayLength);
                    break;
                case GL.UNSIGNED_SHORT:
                    this.typedView = new Uint16Array(buffer.buffer, byteOffset, arrayLength);
                    break;
                case GL.UNSIGNED_INT:
                    this.typedView = new Uint32Array(buffer.buffer, byteOffset, arrayLength);
                    break;
                case GL.FLOAT:
                    this.typedView = new Float32Array(buffer.buffer, byteOffset, arrayLength);
                    break;
                }
            }

            if (this.typedView === undefined)
            {
                console.warn("Failed to convert buffer view to typed view!: " + this.bufferView);
            }
            else if (this.sparse !== undefined)
            {
                this.applySparse(gltf, this.typedView);
            }

            return this.typedView;
        }

        // getNormalizedTypedView provides an alternative view to the accessors data,
        // where quantized data is already normalized. This is useful if the data is not passed
        // to vertexAttribPointer but used immediately (like e.g. animations)
        getNormalizedTypedView(gltf)
        {
            if(this.normalizedTypedView !== undefined)
            {
                return this.normalizedTypedView;
            }

            const typedView = this.getTypedView(gltf);
            this.normalizedTypedView = this.normalized ? gltfAccessor.dequantize(typedView, this.componentType) : typedView;
            return this.normalizedTypedView;
        }

        // getDeinterlacedView provides a view to the accessors data in form of
        // a TypedArray. In contrast to getTypedView, getDeinterlacedView deinterlaces
        // data, i.e. stripping padding and unrelated components from the array. It then
        // only contains the data of the accessor
        getDeinterlacedView(gltf)
        {
            if (this.filteredView !== undefined)
            {
                return this.filteredView;
            }

            if (this.bufferView !== undefined)
            {
                const bufferView = gltf.bufferViews[this.bufferView];
                const buffer = gltf.buffers[bufferView.buffer];
                const byteOffset = this.byteOffset + bufferView.byteOffset;

                const componentSize = this.getComponentSize(this.componentType);
                const componentCount = this.getComponentCount(this.type);
                const arrayLength = this.count * componentCount;

                let stride = bufferView.byteStride !== 0 ? bufferView.byteStride : componentCount * componentSize;
                let dv = new DataView(buffer.buffer, byteOffset, this.count * stride);

                let func = 'getFloat32';
                switch (this.componentType)
                {
                case GL.BYTE:
                    this.filteredView = new Int8Array(arrayLength);
                    func = 'getInt8';
                    break;
                case GL.UNSIGNED_BYTE:
                    this.filteredView = new Uint8Array(arrayLength);
                    func = 'getUint8';
                    break;
                case GL.SHORT:
                    this.filteredView = new Int16Array(arrayLength);
                    func = 'getInt16';
                    break;
                case GL.UNSIGNED_SHORT:
                    this.filteredView = new Uint16Array(arrayLength);
                    func = 'getUint16';
                    break;
                case GL.UNSIGNED_INT:
                    this.filteredView = new Uint32Array(arrayLength);
                    func = 'getUint32';
                    break;
                case GL.FLOAT:
                    this.filteredView = new Float32Array(arrayLength);
                    func = 'getFloat32';
                    break;
                }

                for(let i = 0; i < arrayLength; ++i)
                {
                    let offset = Math.floor(i/componentCount) * stride + (i % componentCount) * componentSize;
                    this.filteredView[i] = dv[func](offset, true);
                }
            }

            if (this.filteredView === undefined)
            {
                console.warn("Failed to convert buffer view to filtered view!: " + this.bufferView);
            }
            else if (this.sparse !== undefined)
            {
                this.applySparse(gltf, this.filteredView);
            }

            return this.filteredView;
        }

        // getNormalizedDeinterlacedView provides an alternative view to the accessors data,
        // where quantized data is already normalized. This is useful if the data is not passed
        // to vertexAttribPointer but used immediately (like e.g. animations)
        getNormalizedDeinterlacedView(gltf)
        {
            if(this.normalizedFilteredView !== undefined)
            {
                return this.normalizedFilteredView;
            }

            const filteredView = this.getDeinterlacedView(gltf);
            this.normalizedFilteredView = this.normalized ? gltfAccessor.dequantize(filteredView, this.componentType) : filteredView;
            return this.normalizedFilteredView;
        }

        applySparse(gltf, view)
        {
            // Gather indices.

            const indicesBufferView = gltf.bufferViews[this.sparse.indices.bufferView];
            const indicesBuffer = gltf.buffers[indicesBufferView.buffer];
            const indicesByteOffset = this.sparse.indices.byteOffset + indicesBufferView.byteOffset;

            const indicesComponentSize = this.getComponentSize(this.sparse.indices.componentType);
            let indicesComponentCount = 1;

            if(indicesBufferView.byteStride !== 0)
            {
                indicesComponentCount = indicesBufferView.byteStride / indicesComponentSize;
            }

            const indicesArrayLength = this.sparse.count * indicesComponentCount;

            let indicesTypedView;
            switch (this.sparse.indices.componentType)
            {
            case GL.UNSIGNED_BYTE:
                indicesTypedView = new Uint8Array(indicesBuffer.buffer, indicesByteOffset, indicesArrayLength);
                break;
            case GL.UNSIGNED_SHORT:
                indicesTypedView = new Uint16Array(indicesBuffer.buffer, indicesByteOffset, indicesArrayLength);
                break;
            case GL.UNSIGNED_INT:
                indicesTypedView = new Uint32Array(indicesBuffer.buffer, indicesByteOffset, indicesArrayLength);
                break;
            }

            // Gather values.

            const valuesBufferView = gltf.bufferViews[this.sparse.values.bufferView];
            const valuesBuffer = gltf.buffers[valuesBufferView.buffer];
            const valuesByteOffset = this.sparse.values.byteOffset + valuesBufferView.byteOffset;

            const valuesComponentSize = this.getComponentSize(this.componentType);
            let valuesComponentCount = this.getComponentCount(this.type);

            if(valuesBufferView.byteStride !== 0)
            {
                valuesComponentCount = valuesBufferView.byteStride / valuesComponentSize;
            }

            const valuesArrayLength = this.sparse.count * valuesComponentCount;

            let valuesTypedView;
            switch (this.componentType)
            {
            case GL.BYTE:
                valuesTypedView = new Int8Array(valuesBuffer.buffer, valuesByteOffset, valuesArrayLength);
                break;
            case GL.UNSIGNED_BYTE:
                valuesTypedView = new Uint8Array(valuesBuffer.buffer, valuesByteOffset, valuesArrayLength);
                break;
            case GL.SHORT:
                valuesTypedView = new Int16Array(valuesBuffer.buffer, valuesByteOffset, valuesArrayLength);
                break;
            case GL.UNSIGNED_SHORT:
                valuesTypedView = new Uint16Array(valuesBuffer.buffer, valuesByteOffset, valuesArrayLength);
                break;
            case GL.UNSIGNED_INT:
                valuesTypedView = new Uint32Array(valuesBuffer.buffer, valuesByteOffset, valuesArrayLength);
                break;
            case GL.FLOAT:
                valuesTypedView = new Float32Array(valuesBuffer.buffer, valuesByteOffset, valuesArrayLength);
                break;
            }

            // Overwrite values.

            for(let i = 0; i < this.sparse.count; ++i)
            {
                for(let k = 0; k < valuesComponentCount; ++k)
                {
                    view[indicesTypedView[i] * valuesComponentCount + k] = valuesTypedView[i * valuesComponentCount + k];
                }
            }
        }

        // dequantize can be used to perform the normalization from WebGL2 vertexAttribPointer explicitly
        static dequantize(typedArray, componentType)
        {
            switch (componentType)
            {
            case GL.BYTE:
                return new Float32Array(typedArray).map(c => Math.max(c / 127.0, -1.0));
            case GL.UNSIGNED_BYTE:
                return new Float32Array(typedArray).map(c => c / 255.0);
            case GL.SHORT:
                return new Float32Array(typedArray).map(c => Math.max(c / 32767.0, -1.0));
            case GL.UNSIGNED_SHORT:
                return new Float32Array(typedArray).map(c => c / 65535.0);
            default:
                return typedArray;
            }
        }

        getComponentCount(type)
        {
            return CompononentCount.get(type);
        }

        getComponentSize(componentType)
        {
            switch (componentType)
            {
            case GL.BYTE:
            case GL.UNSIGNED_BYTE:
                return 1;
            case GL.SHORT:
            case GL.UNSIGNED_SHORT:
                return 2;
            case GL.UNSIGNED_INT:
            case GL.FLOAT:
                return 4;
            default:
                return 0;
            }
        }

        destroy()
        {
            if (this.glBuffer !== undefined)
            {
                // TODO: this breaks the dependency direction
                WebGl.context.deleteBuffer(this.glBuffer);
            }

            this.glBuffer = undefined;
        }
    }

    const CompononentCount = new Map(
        [
            ["SCALAR", 1],
            ["VEC2", 2],
            ["VEC3", 3],
            ["VEC4", 4],
            ["MAT2", 4],
            ["MAT3", 9],
            ["MAT4", 16]
        ]
    );

    class gltfBuffer extends GltfObject
    {
        constructor()
        {
            super();
            this.uri = undefined;
            this.byteLength = undefined;
            this.name = undefined;

            // non gltf
            this.buffer = undefined; // raw data blob
        }

        load(gltf, additionalFiles = undefined)
        {
            if (this.buffer !== undefined)
            {
                console.error("buffer has already been loaded");
                return;
            }

            const self = this;
            return new Promise(function(resolve)
            {
                if (!self.setBufferFromFiles(additionalFiles, resolve) &&
                    !self.setBufferFromUri(gltf, resolve))
                {
                    console.error("Was not able to resolve buffer with uri '%s'", self.uri);
                    resolve();
                }
            });
        }

        setBufferFromUri(gltf, callback)
        {
            if (this.uri === undefined)
            {
                return false;
            }

            const self = this;
            axios$2.get(getContainingFolder(gltf.path) + this.uri, { responseType: 'arraybuffer'})
                .then(function(response)
                {
                    self.buffer = response.data;
                    callback();
                });
            return true;
        }

        setBufferFromFiles(files, callback)
        {
            if (this.uri === undefined || files === undefined)
            {
                return false;
            }

            const foundFile = files.find(function(file)
            {
                if (file.name === this.uri || file.fullPath === this.uri)
                {
                    return true;
                }
            }, this);

            if (foundFile === undefined)
            {
                return false;
            }

            const self = this;
            const reader = new FileReader();
            reader.onloadend = function(event)
            {
                self.buffer = event.target.result;
                callback();
            };
            reader.readAsArrayBuffer(foundFile);

            return true;
        }
    }

    class gltfBufferView extends GltfObject
    {
        constructor()
        {
            super();
            this.buffer = undefined;
            this.byteOffset = 0;
            this.byteLength = undefined;
            this.byteStride = 0;
            this.target = undefined;
            this.name = undefined;
        }
    }

    class AsyncFileReader
    {
        static async readAsArrayBuffer(path) {
            return new Promise( (resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsArrayBuffer(path);
            });
        }

        static async readAsText(path) {
            return new Promise( (resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsText(path);
            });
        }

        static async readAsDataURL(path) {
            return new Promise( (resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(path);
            });
        }
    }

    class gltfImage extends GltfObject
    {
        constructor(
            uri = undefined,
            type = GL.TEXTURE_2D,
            miplevel = 0,
            bufferView = undefined,
            name = undefined,
            mimeType = ImageMimeType.JPEG,
            image = undefined)
        {
            super();
            this.uri = uri;
            this.bufferView = bufferView;
            this.mimeType = mimeType;
            this.image = image; // javascript image
            this.name = name;
            this.type = type; // nonstandard
            this.miplevel = miplevel; // nonstandard
        }

        resolveRelativePath(basePath)
        {
            if (typeof this.uri === 'string' || this.uri instanceof String)
            {
                if (this.uri.startsWith('./'))
                {
                    // Remove preceding './' from URI.
                    this.uri = this.uri.substr(2);
                }
                this.uri = basePath + this.uri;
            }
        }

        async load(gltf, additionalFiles = undefined)
        {
            if (this.image !== undefined)
            {
                if (this.mimeType !== ImageMimeType.GLTEXTURE)
                {
                    console.error("image has already been loaded");
                }
                return;
            }

            if (!await this.setImageFromBufferView(gltf) &&
                !await this.setImageFromFiles(additionalFiles, gltf) &&
                !await this.setImageFromUri(gltf))
            {
                console.error("Was not able to resolve image with uri '%s'", this.uri);
                return;
            }

            return;
        }

        static loadHTMLImage(url)
        {
            return new Promise( (resolve, reject) => {
                const image = new Image();
                image.addEventListener('load', () => resolve(image) );
                image.addEventListener('error', reject);
                image.src = url;
                image.crossOrigin = "";
            });
        }

        async setImageFromUri(gltf)
        {
            if (this.uri === undefined)
            {
                return false;
            }

            if(this.mimeType === ImageMimeType.KTX2)
            {
                if (gltf.ktxDecoder !== undefined)
                {
                    this.image = await gltf.ktxDecoder.loadKtxFromUri(this.uri);
                }
                else
                {
                    console.warn('Loading of ktx images failed: KtxDecoder not initalized');
                }
            }
            else if (typeof(Image) !== 'undefined' && (this.mimeType === ImageMimeType.JPEG || this.mimeType === ImageMimeType.PNG))
            {
                this.image = await gltfImage.loadHTMLImage(this.uri).catch( (error) => {
                    console.error(error);
                });
            }
            else if(this.mimeType === ImageMimeType.JPEG && this.uri instanceof ArrayBuffer)
            {
                this.image = jpeg.decode(this.uri, {useTArray: true});
            }
            else if(this.mimeType === ImageMimeType.PNG && this.uri instanceof ArrayBuffer)
            {
                this.image = png.decode(this.uri);
            }
            else
            {
                console.error("Unsupported image type " + this.mimeType);
                return false;
            }

            return true;
        }

        async setImageFromBufferView(gltf)
        {
            const view = gltf.bufferViews[this.bufferView];
            if (view === undefined)
            {
                return false;
            }

            const buffer = gltf.buffers[view.buffer].buffer;
            const array = new Uint8Array(buffer, view.byteOffset, view.byteLength);
            if (this.mimeType === ImageMimeType.KTX2)
            {
                if (gltf.ktxDecoder !== undefined)
                {
                    this.image = await gltf.ktxDecoder.loadKtxFromBuffer(array);
                }
                else
                {
                    console.warn('Loading of ktx images failed: KtxDecoder not initalized');
                }
            }
            else if(typeof(Image) !== 'undefined' && (this.mimeType === ImageMimeType.JPEG || this.mimeType === ImageMimeType.PNG))
            {
                const blob = new Blob([array], { "type": this.mimeType });
                const objectURL = URL.createObjectURL(blob);
                this.image = await gltfImage.loadHTMLImage(objectURL).catch( () => {
                    console.error("Could not load image from buffer view");
                });
            }
            else if(this.mimeType === ImageMimeType.JPEG)
            {
                this.image = jpeg.decode(array, {useTArray: true});
            }
            else if(this.mimeType === ImageMimeType.PNG)
            {
                this.image = png.decode(array);
            }
            else
            {
                console.error("Unsupported image type " + this.mimeType);
                return false;
            }

            return true;
        }

        async setImageFromFiles(files, gltf)
        {
            if (this.uri === undefined || files === undefined)
            {
                return false;
            }

            let foundFile = files.find(function(file)
            {
                const uriName = this.uri.split('\\').pop().split('/').pop();
                if (file.name === uriName)
                {
                    return true;
                }
            }, this);

            if (foundFile === undefined)
            {
                return false;
            }

            if(this.mimeType === ImageMimeType.KTX2)
            {
                if (gltf.ktxDecoder !== undefined)
                {
                    const data = new Uint8Array(await foundFile.arrayBuffer());
                    this.image = await gltf.ktxDecoder.loadKtxFromBuffer(data);
                }
                else
                {
                    console.warn('Loading of ktx images failed: KtxDecoder not initalized');
                }
            }
            else if (typeof(Image) !== 'undefined' && (this.mimeType === ImageMimeType.JPEG || this.mimeType === ImageMimeType.PNG))
            {
                const imageData = await AsyncFileReader.readAsDataURL(foundFile).catch( () => {
                    console.error("Could not load image with FileReader");
                });
                this.image = await gltfImage.loadHTMLImage(imageData).catch( () => {
                    console.error("Could not create image from FileReader image data");
                });
            }
            else
            {
                console.error("Unsupported image type " + this.mimeType);
                return false;
            }


            return true;
        }
    }

    // https://github.com/KhronosGroup/glTF/blob/khr_ktx2_ibl/extensions/2.0/Khronos/KHR_lights_image_based/schema/imageBasedLight.schema.json

    class ImageBasedLight extends GltfObject
    {
        constructor()
        {
            super();
            this.rotation = jsToGl([0, 0, 0, 1]);
            this.brightnessFactor = 1;
            this.brightnessOffset = 0;
            this.specularEnvironmentTexture = undefined;
            this.diffuseEnvironmentTexture = undefined;
            this.sheenEnvironmentTexture = undefined;

            // non-gltf
            this.levelCount = 1;
        }

        fromJson(jsonIBL)
        {
            super.fromJson(jsonIBL);

            if(jsonIBL.extensions !== undefined)
            {
                this.fromJsonExtensions(jsonIBL.extensions);
            }
        }

        fromJsonExtensions(extensions)
        {
            if (extensions.KHR_materials_sheen !== undefined)
            {
                this.sheenEnvironmentTexture = extensions.KHR_materials_sheen.sheenEnvironmentTexture;
            }
        }

        initGl(gltf, webGlContext)
        {
            if (this.diffuseEnvironmentTexture !== undefined)
            {
                const textureObject = gltf.textures[this.diffuseEnvironmentTexture];
                textureObject.type = GL.TEXTURE_CUBE_MAP;
            }
            if (this.specularEnvironmentTexture !== undefined)
            {
                const textureObject = gltf.textures[this.specularEnvironmentTexture];
                textureObject.type = GL.TEXTURE_CUBE_MAP;

                const imageObject = gltf.images[textureObject.source];
                this.levelCount = imageObject.image.levelCount;
            }
            if(this.sheenEnvironmentTexture !== undefined)
            {
                const textureObject = gltf.textures[this.sheenEnvironmentTexture];
                textureObject.type = GL.TEXTURE_CUBE_MAP;

                const imageObject = gltf.images[textureObject.source];
                if (this.levelCount !== imageObject.image.levelCount)
                {
                    console.error("Specular and sheen do not have same level count");
                }
            }
        }
    }

    class gltfTexture extends GltfObject
    {
        constructor(sampler = undefined, source = undefined, type = GL.TEXTURE_2D)
        {
            super();
            this.sampler = sampler; // index to gltfSampler, default sampler ?
            this.source = source; // index to gltfImage

            // non gltf
            this.glTexture = undefined;
            this.type = type;
            this.initialized = false;
            this.mipLevelCount = 0;
        }

        initGl(gltf, webGlContext)
        {
            if (this.sampler === undefined)
            {
                this.sampler = gltf.samplers.length - 1;
            }

            initGlForMembers(this, gltf, webGlContext);
        }

        fromJson(jsonTexture)
        {
            super.fromJson(jsonTexture);
            if (jsonTexture.extensions !== undefined &&
                jsonTexture.extensions.KHR_texture_basisu !== undefined &&
                jsonTexture.extensions.KHR_texture_basisu.source !== undefined)
            {
                this.source = jsonTexture.extensions.KHR_texture_basisu.source;
            }
        }

        destroy()
        {
            if (this.glTexture !== undefined)
            {
                // TODO: this breaks the dependency direction
                WebGl.context.deleteTexture(this.glTexture);
            }

            this.glTexture = undefined;
        }
    }

    class gltfTextureInfo
    {
        constructor(index = undefined, texCoord = 0, linear = true, samplerName = "", generateMips = true) // linear by default
        {
            this.index = index; // reference to gltfTexture
            this.texCoord = texCoord; // which UV set to use
            this.linear = linear;
            this.samplerName = samplerName;
            this.strength = 1.0; // occlusion
            this.scale = 1.0; // normal
            this.generateMips = generateMips;

            this.extensions = undefined;
        }

        initGl(gltf, webGlContext)
        {
            initGlForMembers(this, gltf, webGlContext);
        }

        fromJson(jsonTextureInfo)
        {
            fromKeys(this, jsonTextureInfo);
        }
    }

    class gltfMaterial extends GltfObject
    {
        constructor()
        {
            super();
            this.name = undefined;
            this.pbrMetallicRoughness = undefined;
            this.normalTexture = undefined;
            this.occlusionTexture = undefined;
            this.emissiveTexture = undefined;
            this.emissiveFactor = glMatrix.vec3.fromValues(0, 0, 0);
            this.alphaMode = "OPAQUE";
            this.alphaCutoff = 0.5;
            this.doubleSided = false;

            // pbr next extension toggles
            this.hasClearcoat = false;
            this.hasSheen = false;
            this.hasTransmission = false;
            this.hasIOR = false;
            this.hasEmissiveStrength = false;
            this.hasVolume = false;
            this.hasIridescence = false;

            // non gltf properties
            this.type = "unlit";
            this.textures = [];
            this.properties = new Map();
            this.defines = [];
        }

        static createDefault()
        {
            const defaultMaterial = new gltfMaterial();
            defaultMaterial.type = "MR";
            defaultMaterial.name = "Default Material";
            defaultMaterial.defines.push("MATERIAL_METALLICROUGHNESS 1");
            const baseColorFactor = glMatrix.vec4.fromValues(1, 1, 1, 1);
            const metallicFactor = 1;
            const roughnessFactor = 1;
            defaultMaterial.properties.set("u_BaseColorFactor", baseColorFactor);
            defaultMaterial.properties.set("u_MetallicFactor", metallicFactor);
            defaultMaterial.properties.set("u_RoughnessFactor", roughnessFactor);

            return defaultMaterial;
        }

        getShaderIdentifier()
        {
            switch (this.type)
            {
            default:
            case "SG": // fall through till we sparate shaders
            case "MR": return "pbr.frag";
                //case "SG": return "specular-glossiness.frag" ;
            }
        }

        getDefines(renderingParameters)
        {
            const defines = Array.from(this.defines);

            if (this.hasClearcoat && renderingParameters.enabledExtensions.KHR_materials_clearcoat)
            {
                defines.push("MATERIAL_CLEARCOAT 1");
            }
            if (this.hasSheen && renderingParameters.enabledExtensions.KHR_materials_sheen)
            {
                defines.push("MATERIAL_SHEEN 1");
            }
            if (this.hasTransmission && renderingParameters.enabledExtensions.KHR_materials_transmission)
            {
                defines.push("MATERIAL_TRANSMISSION 1");
            }
            if (this.hasVolume && renderingParameters.enabledExtensions.KHR_materials_volume)
            {
                defines.push("MATERIAL_VOLUME 1");
            }
            if(this.hasIOR && renderingParameters.enabledExtensions.KHR_materials_ior)
            {
                defines.push("MATERIAL_IOR 1");
            }
            if(this.hasSpecular && renderingParameters.enabledExtensions.KHR_materials_specular)
            {
                defines.push("MATERIAL_SPECULAR 1");
            }
            if(this.hasIridescence && renderingParameters.enabledExtensions.KHR_materials_iridescence)
            {
                defines.push("MATERIAL_IRIDESCENCE 1");
            }
            if(this.hasEmissiveStrength && renderingParameters.enabledExtensions.KHR_materials_emissive_strength)
            {
                defines.push("MATERIAL_EMISSIVE_STRENGTH 1");
            }

            return defines;
        }

        getProperties()
        {
            return this.properties;
        }

        getTextures()
        {
            return this.textures;
        }

        parseTextureInfoExtensions(textureInfo, textureKey)
        {
            if(textureInfo.extensions === undefined)
            {
                return;
            }

            if(textureInfo.extensions.KHR_texture_transform !== undefined)
            {
                const uvTransform = textureInfo.extensions.KHR_texture_transform;

                // override uvset
                if(uvTransform.texCoord !== undefined)
                {
                    textureInfo.texCoord = uvTransform.texCoord;
                }

                let rotation = glMatrix.mat3.create();
                let scale = glMatrix.mat3.create();
                let translation = glMatrix.mat3.create();

                if(uvTransform.rotation !== undefined)
                {
                    const s =  Math.sin(uvTransform.rotation);
                    const c =  Math.cos(uvTransform.rotation);

                    rotation = jsToGl([
                        c, -s, 0.0,
                        s, c, 0.0,
                        0.0, 0.0, 1.0]);
                }

                if(uvTransform.scale !== undefined)
                {
                    scale = jsToGl([
                        uvTransform.scale[0], 0, 0, 
                        0, uvTransform.scale[1], 0, 
                        0, 0, 1
                    ]);
                }

                if(uvTransform.offset !== undefined)
                {
                    translation = jsToGl([
                        1, 0, 0, 
                        0, 1, 0, 
                        uvTransform.offset[0], uvTransform.offset[1], 1
                    ]);
                }

                let uvMatrix = glMatrix.mat3.create();
                glMatrix.mat3.multiply(uvMatrix, translation, rotation);
                glMatrix.mat3.multiply(uvMatrix, uvMatrix, scale);

                this.defines.push("HAS_" + textureKey.toUpperCase() + "_UV_TRANSFORM 1");
                this.properties.set("u_" + textureKey + "UVTransform", uvMatrix);
            }
        }

        initGl(gltf, webGlContext)
        {
            if (this.normalTexture !== undefined)
            {
                this.normalTexture.samplerName = "u_NormalSampler";
                this.parseTextureInfoExtensions(this.normalTexture, "Normal");
                this.textures.push(this.normalTexture);
                this.defines.push("HAS_NORMAL_MAP 1");
                this.properties.set("u_NormalScale", this.normalTexture.scale);
                this.properties.set("u_NormalUVSet", this.normalTexture.texCoord);
            }

            if (this.occlusionTexture !== undefined)
            {
                this.occlusionTexture.samplerName = "u_OcclusionSampler";
                this.parseTextureInfoExtensions(this.occlusionTexture, "Occlusion");
                this.textures.push(this.occlusionTexture);
                this.defines.push("HAS_OCCLUSION_MAP 1");
                this.properties.set("u_OcclusionStrength", this.occlusionTexture.strength);
                this.properties.set("u_OcclusionUVSet", this.occlusionTexture.texCoord);
            }

            this.properties.set("u_EmissiveFactor", this.emissiveFactor);
            if (this.emissiveTexture !== undefined)
            {
                this.emissiveTexture.samplerName = "u_EmissiveSampler";
                this.parseTextureInfoExtensions(this.emissiveTexture, "Emissive");
                this.textures.push(this.emissiveTexture);
                this.defines.push("HAS_EMISSIVE_MAP 1");
                this.properties.set("u_EmissiveUVSet", this.emissiveTexture.texCoord);
            }

            if (this.baseColorTexture !== undefined)
            {
                this.baseColorTexture.samplerName = "u_BaseColorSampler";
                this.parseTextureInfoExtensions(this.baseColorTexture, "BaseColor");
                this.textures.push(this.baseColorTexture);
                this.defines.push("HAS_BASE_COLOR_MAP 1");
                this.properties.set("u_BaseColorUVSet", this.baseColorTexture.texCoord);
            }

            if (this.metallicRoughnessTexture !== undefined)
            {
                this.metallicRoughnessTexture.samplerName = "u_MetallicRoughnessSampler";
                this.parseTextureInfoExtensions(this.metallicRoughnessTexture, "MetallicRoughness");
                this.textures.push(this.metallicRoughnessTexture);
                this.defines.push("HAS_METALLIC_ROUGHNESS_MAP 1");
                this.properties.set("u_MetallicRoughnessUVSet", this.metallicRoughnessTexture.texCoord);
            }

            if (this.diffuseTexture !== undefined)
            {
                this.diffuseTexture.samplerName = "u_DiffuseSampler";
                this.parseTextureInfoExtensions(this.diffuseTexture, "Diffuse");
                this.textures.push(this.diffuseTexture);
                this.defines.push("HAS_DIFFUSE_MAP 1");
                this.properties.set("u_DiffuseUVSet", this.diffuseTexture.texCoord);
            }

            if (this.specularGlossinessTexture !== undefined)
            {
                this.specularGlossinessTexture.samplerName = "u_SpecularGlossinessSampler";
                this.parseTextureInfoExtensions(this.specularGlossinessTexture, "SpecularGlossiness");
                this.textures.push(this.specularGlossinessTexture);
                this.defines.push("HAS_SPECULAR_GLOSSINESS_MAP 1");
                this.properties.set("u_SpecularGlossinessUVSet", this.specularGlossinessTexture.texCoord);
            }

            this.defines.push("ALPHAMODE_OPAQUE 0");
            this.defines.push("ALPHAMODE_MASK 1");
            this.defines.push("ALPHAMODE_BLEND 2");
            if(this.alphaMode === 'MASK') // only set cutoff value for mask material
            {
                this.defines.push("ALPHAMODE ALPHAMODE_MASK");
                this.properties.set("u_AlphaCutoff", this.alphaCutoff);
            }
            else if (this.alphaMode === 'OPAQUE')
            {
                this.defines.push("ALPHAMODE ALPHAMODE_OPAQUE");
            }
            else
            {
                this.defines.push("ALPHAMODE ALPHAMODE_BLEND");
            }

            // if we have SG, we prefer SG (best practice) but if we have neither objects we use MR default values
            if(this.type !== "SG" )
            {
                this.defines.push("MATERIAL_METALLICROUGHNESS 1");
                this.properties.set("u_BaseColorFactor", glMatrix.vec4.fromValues(1, 1, 1, 1));
                this.properties.set("u_MetallicFactor", 1);
                this.properties.set("u_RoughnessFactor", 1);
            }

            if (this.pbrMetallicRoughness !== undefined && this.type !== "SG")
            {
                if (this.pbrMetallicRoughness.baseColorFactor !== undefined)
                {
                    let baseColorFactor = jsToGl(this.pbrMetallicRoughness.baseColorFactor);
                    this.properties.set("u_BaseColorFactor", baseColorFactor);
                }

                if (this.pbrMetallicRoughness.metallicFactor !== undefined)
                {
                    let metallicFactor = this.pbrMetallicRoughness.metallicFactor;
                    this.properties.set("u_MetallicFactor", metallicFactor);
                }

                if (this.pbrMetallicRoughness.roughnessFactor !== undefined)
                {
                    let roughnessFactor = this.pbrMetallicRoughness.roughnessFactor;
                    this.properties.set("u_RoughnessFactor", roughnessFactor);
                }

            }

            if (this.extensions !== undefined)
            {
                if (this.extensions.KHR_materials_unlit !== undefined)
                {
                    this.defines.push("MATERIAL_UNLIT 1");
                }

                if (this.extensions.KHR_materials_pbrSpecularGlossiness !== undefined)
                {
                    this.defines.push("MATERIAL_SPECULARGLOSSINESS 1");

                    let diffuseFactor = glMatrix.vec4.fromValues(1, 1, 1, 1);
                    let specularFactor = glMatrix.vec3.fromValues(1, 1, 1);
                    let glossinessFactor = 1;

                    if (this.extensions.KHR_materials_pbrSpecularGlossiness.diffuseFactor !== undefined)
                    {
                        diffuseFactor = jsToGl(this.extensions.KHR_materials_pbrSpecularGlossiness.diffuseFactor);
                    }

                    if (this.extensions.KHR_materials_pbrSpecularGlossiness.specularFactor !== undefined)
                    {
                        specularFactor = jsToGl(this.extensions.KHR_materials_pbrSpecularGlossiness.specularFactor);
                    }

                    if (this.extensions.KHR_materials_pbrSpecularGlossiness.glossinessFactor !== undefined)
                    {
                        glossinessFactor = this.extensions.KHR_materials_pbrSpecularGlossiness.glossinessFactor;
                    }

                    this.properties.set("u_DiffuseFactor", diffuseFactor);
                    this.properties.set("u_SpecularFactor", specularFactor);
                    this.properties.set("u_GlossinessFactor", glossinessFactor);
                }

                // Clearcoat is part of the default metallic-roughness shader
                if(this.extensions.KHR_materials_clearcoat !== undefined)
                {
                    let clearcoatFactor = 0.0;
                    let clearcoatRoughnessFactor = 0.0;

                    this.hasClearcoat = true;

                    if(this.extensions.KHR_materials_clearcoat.clearcoatFactor !== undefined)
                    {
                        clearcoatFactor = this.extensions.KHR_materials_clearcoat.clearcoatFactor;
                    }
                    if(this.extensions.KHR_materials_clearcoat.clearcoatRoughnessFactor !== undefined)
                    {
                        clearcoatRoughnessFactor = this.extensions.KHR_materials_clearcoat.clearcoatRoughnessFactor;
                    }

                    if (this.clearcoatTexture !== undefined)
                    {
                        this.clearcoatTexture.samplerName = "u_ClearcoatSampler";
                        this.parseTextureInfoExtensions(this.clearcoatTexture, "Clearcoat");
                        this.textures.push(this.clearcoatTexture);
                        this.defines.push("HAS_CLEARCOAT_MAP 1");
                        this.properties.set("u_ClearcoatUVSet", this.clearcoatTexture.texCoord);
                    }
                    if (this.clearcoatRoughnessTexture !== undefined)
                    {
                        this.clearcoatRoughnessTexture.samplerName = "u_ClearcoatRoughnessSampler";
                        this.parseTextureInfoExtensions(this.clearcoatRoughnessTexture, "ClearcoatRoughness");
                        this.textures.push(this.clearcoatRoughnessTexture);
                        this.defines.push("HAS_CLEARCOAT_ROUGHNESS_MAP 1");
                        this.properties.set("u_ClearcoatRoughnessUVSet", this.clearcoatRoughnessTexture.texCoord);
                    }
                    if (this.clearcoatNormalTexture !== undefined)
                    {
                        this.clearcoatNormalTexture.samplerName = "u_ClearcoatNormalSampler";
                        this.parseTextureInfoExtensions(this.clearcoatNormalTexture, "ClearcoatNormal");
                        this.textures.push(this.clearcoatNormalTexture);
                        this.defines.push("HAS_CLEARCOAT_NORMAL_MAP 1");
                        this.properties.set("u_ClearcoatNormalUVSet", this.clearcoatNormalTexture.texCoord);
                        this.properties.set("u_ClearcoatNormalScale", this.clearcoatNormalTexture.scale);

                    }
                    this.properties.set("u_ClearcoatFactor", clearcoatFactor);
                    this.properties.set("u_ClearcoatRoughnessFactor", clearcoatRoughnessFactor);
                }

                // Sheen material extension
                // https://github.com/sebavan/glTF/tree/KHR_materials_sheen/extensions/2.0/Khronos/KHR_materials_sheen
                if(this.extensions.KHR_materials_sheen !== undefined)
                {
                    let sheenRoughnessFactor = 0.0;
                    let sheenColorFactor =  glMatrix.vec3.fromValues(1.0, 1.0, 1.0);

                    this.hasSheen = true;

                    if(this.extensions.KHR_materials_sheen.sheenRoughnessFactor !== undefined)
                    {
                        sheenRoughnessFactor = this.extensions.KHR_materials_sheen.sheenRoughnessFactor;
                    }
                    if(this.extensions.KHR_materials_sheen.sheenColorFactor !== undefined)
                    {
                        sheenColorFactor = jsToGl(this.extensions.KHR_materials_sheen.sheenColorFactor);
                    }
                    if (this.sheenRoughnessTexture !== undefined)
                    {
                        this.sheenRoughnessTexture.samplerName = "u_sheenRoughnessSampler";
                        this.parseTextureInfoExtensions(this.sheenRoughnessTexture, "SheenRoughness");
                        this.textures.push(this.sheenRoughnessTexture);
                        this.defines.push("HAS_SHEEN_ROUGHNESS_MAP 1");
                        this.properties.set("u_SheenRoughnessUVSet", this.sheenRoughnessTexture.texCoord);
                    }
                    if (this.sheenColorTexture !== undefined)
                    {
                        this.sheenColorTexture.samplerName = "u_SheenColorSampler";
                        this.parseTextureInfoExtensions(this.sheenColorTexture, "SheenColor");
                        this.sheenColorTexture.linear = false;
                        this.textures.push(this.sheenColorTexture);
                        this.defines.push("HAS_SHEEN_COLOR_MAP 1");
                        this.properties.set("u_SheenColorUVSet", this.sheenColorTexture.texCoord);
                    }

                    this.properties.set("u_SheenRoughnessFactor", sheenRoughnessFactor);
                    this.properties.set("u_SheenColorFactor", sheenColorFactor);
                }

                // KHR Extension: Specular
                if (this.extensions.KHR_materials_specular !== undefined)
                {
                    this.hasSpecular = true;

                    if (this.specularTexture !== undefined)
                    {
                        this.specularTexture.samplerName = "u_SpecularSampler";
                        this.parseTextureInfoExtensions(this.specularTexture, "Specular");
                        this.textures.push(this.specularTexture);
                        this.defines.push("HAS_SPECULAR_MAP 1");
                        this.properties.set("u_SpecularUVSet", this.specularTexture.texCoord);
                    }

                    if (this.specularColorTexture !== undefined)
                    {
                        this.specularColorTexture.samplerName = "u_SpecularColorSampler";
                        this.parseTextureInfoExtensions(this.specularColorTexture, "SpecularColor");
                        this.specularColorTexture.linear = false;
                        this.textures.push(this.specularColorTexture);
                        this.defines.push("HAS_SPECULAR_COLOR_MAP 1");
                        this.properties.set("u_SpecularColorUVSet", this.specularColorTexture.texCoord);
                    }

                    let specularColorFactor = jsToGl(this.extensions.KHR_materials_specular.specularColorFactor ?? [1.0, 1.0, 1.0]);
                    let specularFactor = this.extensions.KHR_materials_specular.specularFactor ?? 1.0;

                    this.properties.set("u_KHR_materials_specular_specularColorFactor", specularColorFactor);
                    this.properties.set("u_KHR_materials_specular_specularFactor", specularFactor);
                }

                // KHR Extension: Emissive strength
                if (this.extensions.KHR_materials_emissive_strength !== undefined)
                {
                    this.hasEmissiveStrength = true;

                    let emissiveStrength = this.extensions.KHR_materials_emissive_strength.emissiveStrength ?? 1.0;

                    this.properties.set("u_EmissiveStrength", emissiveStrength);
                }

                // KHR Extension: Transmission
                if (this.extensions.KHR_materials_transmission !== undefined)
                {
                    let transmissionFactor = 0.0;

                    this.hasTransmission = true;

                    if (transmissionFactor !== undefined)
                    {
                        transmissionFactor = this.extensions.KHR_materials_transmission.transmissionFactor;
                    }
                    if (this.transmissionTexture !== undefined)
                    {
                        this.transmissionTexture.samplerName = "u_TransmissionSampler";
                        this.parseTextureInfoExtensions(this.transmissionTexture, "Transmission");
                        this.textures.push(this.transmissionTexture);
                        this.defines.push("HAS_TRANSMISSION_MAP 1");
                        this.properties.set("u_TransmissionUVSet", this.transmissionTexture.texCoord);
                    }

                    this.properties.set("u_TransmissionFactor", transmissionFactor);
                }

                // KHR Extension: IOR
                //https://github.com/DassaultSystemes-Technology/glTF/tree/KHR_materials_ior/extensions/2.0/Khronos/KHR_materials_ior
                if (this.extensions.KHR_materials_ior !== undefined)
                {
                    let ior = 1.5;

                    this.hasIOR = true;
                    
                    if(this.extensions.KHR_materials_ior.ior !== undefined)
                    {
                        ior = this.extensions.KHR_materials_ior.ior;
                    }

                    this.properties.set("u_Ior", ior);
                }

                // KHR Extension: Volume
                if (this.extensions.KHR_materials_volume !== undefined)
                {
                    this.hasVolume = true;

                    if (this.thicknessTexture !== undefined)
                    {
                        this.thicknessTexture.samplerName = "u_ThicknessSampler";
                        this.parseTextureInfoExtensions(this.thicknessTexture, "Thickness");
                        this.textures.push(this.thicknessTexture);
                        this.defines.push("HAS_THICKNESS_MAP 1");
                        this.properties.set("u_ThicknessUVSet", this.thicknessTexture.texCoord);
                    }

                    let attenuationColor = jsToGl(this.extensions.KHR_materials_volume.attenuationColor ?? [1.0, 1.0, 1.0]);
                    let attenuationDistance = this.extensions.KHR_materials_volume.attenuationDistance ?? 0.0;
                    let thicknessFactor = this.extensions.KHR_materials_volume.thicknessFactor ?? 0.0;

                    this.properties.set("u_AttenuationColor", attenuationColor);
                    this.properties.set("u_AttenuationDistance", attenuationDistance);
                    this.properties.set("u_ThicknessFactor", thicknessFactor);
                }

                // KHR Extension: Iridescence
                // See https://github.com/ux3d/glTF/tree/extensions/KHR_materials_iridescence/extensions/2.0/Khronos/KHR_materials_iridescence
                if(this.extensions.KHR_materials_iridescence !== undefined)
                {
                    this.hasIridescence = true;

                    let factor = this.extensions.KHR_materials_iridescence.iridescenceFactor;
                    let iridescenceIor = this.extensions.KHR_materials_iridescence.iridescenceIor;
                    let thicknessMinimum = this.extensions.KHR_materials_iridescence.iridescenceThicknessMinimum;
                    let thicknessMaximum = this.extensions.KHR_materials_iridescence.iridescenceThicknessMaximum;

                    if (factor === undefined)
                    {
                        factor = 0.0;
                    }
                    if (iridescenceIor === undefined)
                    {
                        iridescenceIor = 1.3;
                    }
                    if (thicknessMinimum === undefined)
                    {
                        thicknessMinimum = 100.0;
                    }
                    if (thicknessMaximum === undefined)
                    {
                        thicknessMaximum = 400.0;
                    }

                    if (this.iridescenceTexture !== undefined)
                    {
                        this.iridescenceTexture.samplerName = "u_IridescenceSampler";
                        this.parseTextureInfoExtensions(this.iridescenceTexture, "Iridescence");
                        this.textures.push(this.iridescenceTexture);
                        this.defines.push("HAS_IRIDESCENCE_MAP 1");
                        this.properties.set("u_IridescenceUVSet", this.iridescenceTexture.texCoord);
                    }

                    if (this.iridescenceThicknessTexture !== undefined)
                    {
                        this.iridescenceThicknessTexture.samplerName = "u_IridescenceThicknessSampler";
                        this.parseTextureInfoExtensions(this.iridescenceThicknessTexture, "IridescenceThickness");
                        this.textures.push(this.iridescenceThicknessTexture);
                        this.defines.push("HAS_IRIDESCENCE_THICKNESS_MAP 1");
                        this.properties.set("u_IridescenceThicknessUVSet", this.iridescenceThicknessTexture.texCoord);

                        // The thickness minimum is only required when there is a thickness texture present.
                        // Because 1.0 is the default value for the thickness, no texture implies that only the
                        // maximum thickness is ever read in the shader.
                        this.properties.set("u_IridescenceThicknessMinimum", thicknessMinimum);
                    }

                    this.properties.set("u_IridescenceFactor", factor);
                    this.properties.set("u_IridescenceIor", iridescenceIor);
                    this.properties.set("u_IridescenceThicknessMaximum", thicknessMaximum);
                }
            }

            initGlForMembers(this, gltf, webGlContext);
        }

        fromJson(jsonMaterial)
        {
            super.fromJson(jsonMaterial);

            if (jsonMaterial.emissiveFactor !== undefined)
            {
                this.emissiveFactor = jsToGl(jsonMaterial.emissiveFactor);
            }

            if (jsonMaterial.normalTexture !== undefined)
            {
                const normalTexture = new gltfTextureInfo();
                normalTexture.fromJson(jsonMaterial.normalTexture);
                this.normalTexture = normalTexture;
            }

            if (jsonMaterial.occlusionTexture !== undefined)
            {
                const occlusionTexture = new gltfTextureInfo();
                occlusionTexture.fromJson(jsonMaterial.occlusionTexture);
                this.occlusionTexture = occlusionTexture;
            }

            if (jsonMaterial.emissiveTexture !== undefined)
            {
                const emissiveTexture = new gltfTextureInfo(undefined, 0, false);
                emissiveTexture.fromJson(jsonMaterial.emissiveTexture);
                this.emissiveTexture = emissiveTexture;
            }

            if(jsonMaterial.extensions !== undefined)
            {
                this.fromJsonMaterialExtensions(jsonMaterial.extensions);
            }

            if (jsonMaterial.pbrMetallicRoughness !== undefined && this.type !== "SG")
            {
                this.type = "MR";
                this.fromJsonMetallicRoughness(jsonMaterial.pbrMetallicRoughness);
            }
        }

        fromJsonMaterialExtensions(jsonExtensions)
        {
            if (jsonExtensions.KHR_materials_pbrSpecularGlossiness !== undefined)
            {
                this.type = "SG";
                this.fromJsonSpecularGlossiness(jsonExtensions.KHR_materials_pbrSpecularGlossiness);
            }

            if(jsonExtensions.KHR_materials_unlit !== undefined)
            {
                this.type = "unlit";
            }

            if(jsonExtensions.KHR_materials_clearcoat !== undefined)
            {
                this.fromJsonClearcoat(jsonExtensions.KHR_materials_clearcoat);
            }

            if(jsonExtensions.KHR_materials_sheen !== undefined)
            {
                this.fromJsonSheen(jsonExtensions.KHR_materials_sheen);
            }

            if(jsonExtensions.KHR_materials_transmission !== undefined)
            {
                this.fromJsonTransmission(jsonExtensions.KHR_materials_transmission);
            }

            if(jsonExtensions.KHR_materials_specular !== undefined)
            {
                this.fromJsonSpecular(jsonExtensions.KHR_materials_specular);
            }

            if(jsonExtensions.KHR_materials_volume !== undefined)
            {
                this.fromJsonVolume(jsonExtensions.KHR_materials_volume);
            }

            if(jsonExtensions.KHR_materials_iridescence !== undefined)
            {
                this.fromJsonIridescence(jsonExtensions.KHR_materials_iridescence);
            }
        }

        fromJsonMetallicRoughness(jsonMetallicRoughness)
        {
            if (jsonMetallicRoughness.baseColorTexture !== undefined)
            {
                const baseColorTexture = new gltfTextureInfo(undefined, 0, false);
                baseColorTexture.fromJson(jsonMetallicRoughness.baseColorTexture);
                this.baseColorTexture = baseColorTexture;
            }

            if (jsonMetallicRoughness.metallicRoughnessTexture !== undefined)
            {
                const metallicRoughnessTexture = new gltfTextureInfo();
                metallicRoughnessTexture.fromJson(jsonMetallicRoughness.metallicRoughnessTexture);
                this.metallicRoughnessTexture = metallicRoughnessTexture;
            }
        }

        fromJsonSpecularGlossiness(jsonSpecularGlossiness)
        {
            if (jsonSpecularGlossiness.diffuseTexture !== undefined)
            {
                const diffuseTexture = new gltfTextureInfo(undefined, 0, false);
                diffuseTexture.fromJson(jsonSpecularGlossiness.diffuseTexture);
                this.diffuseTexture = diffuseTexture;
            }

            if (jsonSpecularGlossiness.specularGlossinessTexture !== undefined)
            {
                const specularGlossinessTexture = new gltfTextureInfo(undefined, 0, false);
                specularGlossinessTexture.fromJson(jsonSpecularGlossiness.specularGlossinessTexture);
                this.specularGlossinessTexture = specularGlossinessTexture;
            }
        }

        fromJsonClearcoat(jsonClearcoat)
        {
            if(jsonClearcoat.clearcoatTexture !== undefined)
            {
                const clearcoatTexture = new gltfTextureInfo();
                clearcoatTexture.fromJson(jsonClearcoat.clearcoatTexture);
                this.clearcoatTexture = clearcoatTexture;
            }

            if(jsonClearcoat.clearcoatRoughnessTexture !== undefined)
            {
                const clearcoatRoughnessTexture =  new gltfTextureInfo();
                clearcoatRoughnessTexture.fromJson(jsonClearcoat.clearcoatRoughnessTexture);
                this.clearcoatRoughnessTexture = clearcoatRoughnessTexture;
            }

            if(jsonClearcoat.clearcoatNormalTexture !== undefined)
            {
                const clearcoatNormalTexture =  new gltfTextureInfo();
                clearcoatNormalTexture.fromJson(jsonClearcoat.clearcoatNormalTexture);
                this.clearcoatNormalTexture = clearcoatNormalTexture;
            }
        }

        fromJsonSheen(jsonSheen)
        {
            if(jsonSheen.sheenColorTexture !== undefined)
            {
                const sheenColorTexture = new gltfTextureInfo(undefined, 0, false);
                sheenColorTexture.fromJson(jsonSheen.sheenColorTexture);
                this.sheenColorTexture = sheenColorTexture;
            }
            if(jsonSheen.sheenRoughnessTexture !== undefined)
            {
                const sheenRoughnessTexture = new gltfTextureInfo();
                sheenRoughnessTexture.fromJson(jsonSheen.sheenRoughnessTexture);
                this.sheenRoughnessTexture = sheenRoughnessTexture;
            }
        }

        fromJsonTransmission(jsonTransmission)
        {
            if(jsonTransmission.transmissionTexture !== undefined)
            {
                const transmissionTexture = new gltfTextureInfo();
                transmissionTexture.fromJson(jsonTransmission.transmissionTexture);
                this.transmissionTexture = transmissionTexture;
            }
        }

        fromJsonSpecular(jsonSpecular)
        {
            if(jsonSpecular.specularTexture !== undefined)
            {
                const specularTexture = new gltfTextureInfo();
                specularTexture.fromJson(jsonSpecular.specularTexture);
                this.specularTexture = specularTexture;
            }

            if(jsonSpecular.specularColorTexture !== undefined)
            {
                const specularColorTexture = new gltfTextureInfo();
                specularColorTexture.fromJson(jsonSpecular.specularColorTexture);
                this.specularColorTexture = specularColorTexture;
            }
        }

        fromJsonVolume(jsonVolume)
        {
            if(jsonVolume.thicknessTexture !== undefined)
            {
                const thicknessTexture = new gltfTextureInfo();
                thicknessTexture.fromJson(jsonVolume.thicknessTexture);
                this.thicknessTexture = thicknessTexture;
            }
        }

        fromJsonIridescence(jsonIridescence)
        {
            if(jsonIridescence.iridescenceTexture !== undefined)
            {
                const iridescenceTexture = new gltfTextureInfo();
                iridescenceTexture.fromJson(jsonIridescence.iridescenceTexture);
                this.iridescenceTexture = iridescenceTexture;
            }

            if(jsonIridescence.iridescenceThicknessTexture !== undefined)
            {
                const iridescenceThicknessTexture = new gltfTextureInfo();
                iridescenceThicknessTexture.fromJson(jsonIridescence.iridescenceThicknessTexture);
                this.iridescenceThicknessTexture = iridescenceThicknessTexture;
            }
        }
    }

    class gltfSampler extends GltfObject
    {
        constructor(
            magFilter = GL.LINEAR,
            minFilter = GL.LINEAR_MIPMAP_LINEAR,
            wrapS = GL.REPEAT,
            wrapT = GL.REPEAT)
        {
            super();
            this.magFilter = magFilter;
            this.minFilter = minFilter;
            this.wrapS = wrapS;
            this.wrapT = wrapT;
            this.name = undefined;
        }

        static createDefault()
        {
            return new gltfSampler();
        }
    }

    class DracoDecoder {

        constructor(dracoLib) {
            if (!DracoDecoder.instance && dracoLib === undefined)
            {
                if (DracoDecoderModule === undefined)
                {
                    console.error('Failed to initalize DracoDecoder: draco library undefined');
                    return undefined;
                }
                else
                {
                    dracoLib = DracoDecoderModule;
                }
            }
            if (!DracoDecoder.instance)
            {
                DracoDecoder.instance = this;
                this.module = null;

                this.initializingPromise = new Promise(resolve => {
                    let dracoDecoderType = {};
                    dracoDecoderType['onModuleLoaded'] = dracoDecoderModule => {
                        this.module = dracoDecoderModule;
                        resolve();
                    };
                    dracoLib(dracoDecoderType);
                });
            }
            return DracoDecoder.instance;
        }

        async ready() {
            await this.initializingPromise;
            Object.freeze(DracoDecoder.instance);
        }

    }

    class gltfPrimitive extends GltfObject
    {
        constructor()
        {
            super();
            this.attributes = [];
            this.targets = [];
            this.indices = undefined;
            this.material = undefined;
            this.mode = GL.TRIANGLES;

            // non gltf
            this.glAttributes = [];
            this.morphTargetTextureInfo = undefined;
            this.defines = [];
            this.skip = true;
            this.hasWeights = false;
            this.hasJoints = false;
            this.hasNormals = false;
            this.hasTangents = false;
            this.hasTexcoord = false;
            this.hasColor = false;

            // The primitive centroid is used for depth sorting.
            this.centroid = undefined;
        }

        initGl(gltf, webGlContext)
        {
            // Use the default glTF material.
            if (this.material === undefined)
            {
                this.material = gltf.materials.length - 1;
            }

            initGlForMembers(this, gltf, webGlContext);

            const maxAttributes = webGlContext.getParameter(GL.MAX_VERTEX_ATTRIBS);

            // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes

            if (this.extensions !== undefined)
            {
                if (this.extensions.KHR_draco_mesh_compression !== undefined)
                {
                    const dracoDecoder = new DracoDecoder();
                    if (dracoDecoder !== undefined && Object.isFrozen(dracoDecoder))
                    {
                        let dracoGeometry = this.decodeDracoBufferToIntermediate(
                            this.extensions.KHR_draco_mesh_compression, gltf);
                        this.copyDataFromDecodedGeometry(gltf, dracoGeometry, this.attributes);
                    }
                    else
                    {
                        console.warn('Failed to load draco compressed mesh: DracoDecoder not initialized');
                    }
                }
            }

            // VERTEX ATTRIBUTES
            for (const attribute of Object.keys(this.attributes))
            {
                if(this.glAttributes.length >= maxAttributes)
                {
                    console.error("To many vertex attributes for this primitive, skipping " + attribute);
                    break;
                }

                const idx = this.attributes[attribute];
                this.glAttributes.push({ attribute: attribute, name: "a_" + attribute.toLowerCase(), accessor: idx });
                this.defines.push(`HAS_${attribute}_${gltf.accessors[idx].type} 1`);
                switch (attribute)
                {
                case "POSITION":
                    this.skip = false;
                    break;
                case "NORMAL":
                    this.hasNormals = true;
                    break;
                case "TANGENT":
                    this.hasTangents = true;
                    break;
                case "TEXCOORD_0":
                    this.hasTexcoord = true;
                    break;
                case "TEXCOORD_1":
                    this.hasTexcoord = true;
                    break;
                case "COLOR_0":
                    this.hasColor = true;
                    break;
                case "JOINTS_0":
                    this.hasJoints = true;
                    break;
                case "WEIGHTS_0":
                    this.hasWeights = true;
                    break;
                case "JOINTS_1":
                    this.hasJoints = true;
                    break;
                case "WEIGHTS_1":
                    this.hasWeights = true;
                    break;
                default:
                    console.log("Unknown attribute: " + attribute);
                }
            }

            // MORPH TARGETS
            if (this.targets !== undefined && this.targets.length > 0)
            {
                const max2DTextureSize = Math.pow(webGlContext.getParameter(GL.MAX_TEXTURE_SIZE), 2);
                const maxTextureArraySize = webGlContext.getParameter(GL.MAX_ARRAY_TEXTURE_LAYERS);
                // Check which attributes are affected by morph targets and 
                // define offsets for the attributes in the morph target texture.
                const attributeOffsets = {};
                let attributeOffset = 0;

                // Gather used attributes from all targets (some targets might
                // use more attributes than others)
                const attributes = Array.from(this.targets.reduce((acc, target) => {
                    Object.keys(target).map(val => acc.add(val));
                    return acc;
                }, new Set()));

                const vertexCount = gltf.accessors[this.attributes[attributes[0]]].count;
                this.defines.push(`NUM_VERTICIES ${vertexCount}`);
                let targetCount = this.targets.length;
                if (targetCount * attributes.length > maxTextureArraySize)
                {
                    targetCount = Math.floor(maxTextureArraySize / attributes.length);
                    console.warn(`Morph targets exceed texture size limit. Only ${targetCount} of ${this.targets.length} are used.`);
                }

                for (const attribute of attributes)
                {
                    // Add morph target defines
                    this.defines.push(`HAS_MORPH_TARGET_${attribute} 1`);
                    this.defines.push(`MORPH_TARGET_${attribute}_OFFSET ${attributeOffset}`);
                    // Store the attribute offset so that later the 
                    // morph target texture can be assembled.
                    attributeOffsets[attribute] = attributeOffset;
                    attributeOffset += targetCount;
                }
                this.defines.push("HAS_MORPH_TARGETS 1");

                if (vertexCount <= max2DTextureSize) {
                    // Allocate the texture buffer. Note that all target attributes must be vec3 types and
                    // all must have the same vertex count as the primitives other attributes.
                    const width = Math.ceil(Math.sqrt(vertexCount));
                    const singleTextureSize = Math.pow(width, 2) * 4;
                    const morphTargetTextureArray = new Float32Array(singleTextureSize * targetCount * attributes.length);

                    // Now assemble the texture from the accessors.
                    for (let i = 0; i < targetCount; ++i)
                    {
                        let target = this.targets[i];
                        for (let [attributeName, offsetRef] of Object.entries(attributeOffsets)){
                            if (target[attributeName] != undefined) {
                                const accessor = gltf.accessors[target[attributeName]];
                                const offset = offsetRef * singleTextureSize;
                                if (accessor.componentType != GL.FLOAT && accessor.normalized == false){
                                    console.warn("Unsupported component type for morph targets");
                                    attributeOffsets[attributeName] = offsetRef + 1;
                                    continue;
                                }
                                const data = accessor.getNormalizedDeinterlacedView(gltf);
                                switch(accessor.type)
                                {
                                case "VEC2":
                                case "VEC3":
                                {
                                    // Add padding to fit vec2/vec3 into rgba
                                    let paddingOffset = 0;
                                    let accessorOffset = 0;
                                    const componentCount = accessor.getComponentCount(accessor.type);
                                    for (let j = 0; j < accessor.count; ++j) {
                                        morphTargetTextureArray.set(data.subarray(accessorOffset, accessorOffset + componentCount), offset + paddingOffset);
                                        paddingOffset += 4;
                                        accessorOffset += componentCount;
                                    }
                                    break;
                                }
                                case "VEC4":
                                    morphTargetTextureArray.set(data, offset);
                                    break;
                                default:
                                    console.warn("Unsupported attribute type for morph targets");
                                    break;
                                }
                            }
                            attributeOffsets[attributeName] = offsetRef + 1;
                        }
                    }


                    // Add the morph target texture.
                    // We have to create a WebGL2 texture as the format of the
                    // morph target texture has to be explicitly specified 
                    // (gltf image would assume uint8).
                    let texture = webGlContext.createTexture();
                    webGlContext.bindTexture( webGlContext.TEXTURE_2D_ARRAY, texture);
                    // Set texture format and upload data.
                    let internalFormat = webGlContext.RGBA32F;
                    let format = webGlContext.RGBA;
                    let type = webGlContext.FLOAT;
                    let data = morphTargetTextureArray;
                    webGlContext.texImage3D(
                        webGlContext.TEXTURE_2D_ARRAY,
                        0, //level
                        internalFormat,
                        width,
                        width,
                        targetCount * attributes.length, //Layer count
                        0, //border
                        format,
                        type,
                        data);
                    // Ensure mipmapping is disabled and the sampler is configured correctly.
                    webGlContext.texParameteri( GL.TEXTURE_2D_ARRAY,  GL.TEXTURE_WRAP_S,  GL.CLAMP_TO_EDGE);
                    webGlContext.texParameteri( GL.TEXTURE_2D_ARRAY,  GL.TEXTURE_WRAP_T,  GL.CLAMP_TO_EDGE);
                    webGlContext.texParameteri( GL.TEXTURE_2D_ARRAY,  GL.TEXTURE_MIN_FILTER,  GL.NEAREST);
                    webGlContext.texParameteri( GL.TEXTURE_2D_ARRAY,  GL.TEXTURE_MAG_FILTER,  GL.NEAREST);
                    
                    // Now we add the morph target texture as a gltf texture info resource, so that 
                    // we can just call webGl.setTexture(..., gltfTextureInfo, ...) in the renderer.
                    const morphTargetImage = new gltfImage(
                        undefined, // uri
                        GL.TEXTURE_2D_ARRAY, // type
                        0, // mip level
                        undefined, // buffer view
                        undefined, // name
                        ImageMimeType.GLTEXTURE, // mimeType
                        texture // image
                    );
                    gltf.images.push(morphTargetImage);

                    gltf.samplers.push(new gltfSampler(GL.NEAREST, GL.NEAREST, GL.CLAMP_TO_EDGE, GL.CLAMP_TO_EDGE, undefined));

                    const morphTargetTexture = new gltfTexture(
                        gltf.samplers.length - 1,
                        gltf.images.length - 1,
                        GL.TEXTURE_2D_ARRAY);
                    // The webgl texture is already initialized -> this flag informs
                    // webgl.setTexture about this.
                    morphTargetTexture.initialized = true;

                    gltf.textures.push(morphTargetTexture);

                    this.morphTargetTextureInfo = new gltfTextureInfo(gltf.textures.length - 1, 0, true);
                    this.morphTargetTextureInfo.samplerName = "u_MorphTargetsSampler";
                    this.morphTargetTextureInfo.generateMips = false;
                } else {
                    console.warn("Mesh of Morph targets too big. Cannot apply morphing.");
                }         
            }

            this.computeCentroid(gltf);
        }

        computeCentroid(gltf)
        {
            const positionsAccessor = gltf.accessors[this.attributes.POSITION];
            const positions = positionsAccessor.getNormalizedTypedView(gltf);

            if(this.indices !== undefined)
            {
                // Primitive has indices.

                const indicesAccessor = gltf.accessors[this.indices];

                const indices = indicesAccessor.getTypedView(gltf);

                const acc = new Float32Array(3);

                for(let i = 0; i < indices.length; i++) {
                    const offset = 3 * indices[i];
                    acc[0] += positions[offset];
                    acc[1] += positions[offset + 1];
                    acc[2] += positions[offset + 2];
                }

                const centroid = new Float32Array([
                    acc[0] / indices.length,
                    acc[1] / indices.length,
                    acc[2] / indices.length,
                ]);

                this.centroid = centroid;
            }
            else
            {
                // Primitive does not have indices.

                const acc = new Float32Array(3);

                for(let i = 0; i < positions.length; i += 3) {
                    acc[0] += positions[i];
                    acc[1] += positions[i + 1];
                    acc[2] += positions[i + 2];
                }

                const positionVectors = positions.length / 3;

                const centroid = new Float32Array([
                    acc[0] / positionVectors,
                    acc[1] / positionVectors,
                    acc[2] / positionVectors,
                ]);

                this.centroid = centroid;
            }
        }

        getShaderIdentifier()
        {
            return "primitive.vert";
        }

        getDefines()
        {
            return this.defines;
        }

        fromJson(jsonPrimitive)
        {
            super.fromJson(jsonPrimitive);

            if(jsonPrimitive.extensions !== undefined)
            {
                this.fromJsonPrimitiveExtensions(jsonPrimitive.extensions);
            }
        }

        fromJsonPrimitiveExtensions(jsonExtensions)
        {
            if(jsonExtensions.KHR_materials_variants !== undefined)
            {
                this.fromJsonVariants(jsonExtensions.KHR_materials_variants);
            }
        }

        fromJsonVariants(jsonVariants)
        {
            if(jsonVariants.mappings !== undefined)
            {
                this.mappings = jsonVariants.mappings;
            }
        }

        copyDataFromDecodedGeometry(gltf, dracoGeometry, primitiveAttributes)
        {
            // indices
            let indexBuffer = dracoGeometry.index.array;
            if (this.indices !== undefined){
                this.loadBufferIntoGltf(indexBuffer, gltf, this.indices, 34963,
                    "index buffer view");
            }

            // Position
            if(dracoGeometry.attributes.POSITION !== undefined)
            {
                let positionBuffer = this.loadArrayIntoArrayBuffer(dracoGeometry.attributes.POSITION.array,
                    dracoGeometry.attributes.POSITION.componentType);
                this.loadBufferIntoGltf(positionBuffer, gltf, primitiveAttributes["POSITION"], 34962,
                    "position buffer view");
            }

            // Normal
            if(dracoGeometry.attributes.NORMAL !== undefined)
            {
                let normalBuffer = this.loadArrayIntoArrayBuffer(dracoGeometry.attributes.NORMAL.array,
                    dracoGeometry.attributes.NORMAL.componentType);
                this.loadBufferIntoGltf(normalBuffer, gltf, primitiveAttributes["NORMAL"], 34962,
                    "normal buffer view");
            }

            // TEXCOORD_0
            if(dracoGeometry.attributes.TEXCOORD_0 !== undefined)
            {
                let uvBuffer = this.loadArrayIntoArrayBuffer(dracoGeometry.attributes.TEXCOORD_0.array,
                    dracoGeometry.attributes.TEXCOORD_0.componentType);
                this.loadBufferIntoGltf(uvBuffer, gltf, primitiveAttributes["TEXCOORD_0"], 34962,
                    "TEXCOORD_0 buffer view");
            }

            // TEXCOORD_1
            if(dracoGeometry.attributes.TEXCOORD_1 !== undefined)
            {
                let uvBuffer = this.loadArrayIntoArrayBuffer(dracoGeometry.attributes.TEXCOORD_1.array,
                    dracoGeometry.attributes.TEXCOORD_1.componentType);
                this.loadBufferIntoGltf(uvBuffer, gltf, primitiveAttributes["TEXCOORD_1"], 34962,
                    "TEXCOORD_1 buffer view");
            }

            // Tangent
            if(dracoGeometry.attributes.TANGENT !== undefined)
            {
                let tangentBuffer = this.loadArrayIntoArrayBuffer(dracoGeometry.attributes.TANGENT.array,
                    dracoGeometry.attributes.TANGENT.componentType);
                this.loadBufferIntoGltf(tangentBuffer, gltf, primitiveAttributes["TANGENT"], 34962,
                    "Tangent buffer view");
            }

            // Color
            if(dracoGeometry.attributes.COLOR_0 !== undefined)
            {
                let colorBuffer = this.loadArrayIntoArrayBuffer(dracoGeometry.attributes.COLOR_0.array,
                    dracoGeometry.attributes.COLOR_0.componentType);
                this.loadBufferIntoGltf(colorBuffer, gltf, primitiveAttributes["COLOR_0"], 34962,
                    "color buffer view");
            }

            // JOINTS_0
            if(dracoGeometry.attributes.JOINTS_0 !== undefined)
            {
                let jointsBuffer = this.loadArrayIntoArrayBuffer(dracoGeometry.attributes.JOINTS_0.array,
                    dracoGeometry.attributes.JOINTS_0.componentType);
                this.loadBufferIntoGltf(jointsBuffer, gltf, primitiveAttributes["JOINTS_0"], 34963,
                    "JOINTS_0 buffer view");
            }

            // WEIGHTS_0
            if(dracoGeometry.attributes.WEIGHTS_0 !== undefined)
            {
                let weightsBuffer = this.loadArrayIntoArrayBuffer(dracoGeometry.attributes.WEIGHTS_0.array,
                    dracoGeometry.attributes.WEIGHTS_0.componentType);
                this.loadBufferIntoGltf(weightsBuffer, gltf, primitiveAttributes["WEIGHTS_0"], 34963,
                    "WEIGHTS_0 buffer view");
            }

            // JOINTS_1
            if(dracoGeometry.attributes.JOINTS_1 !== undefined)
            {
                let jointsBuffer = this.loadArrayIntoArrayBuffer(dracoGeometry.attributes.JOINTS_1.array,
                    dracoGeometry.attributes.JOINTS_1.componentType);
                this.loadBufferIntoGltf(jointsBuffer, gltf, primitiveAttributes["JOINTS_1"], 34963,
                    "JOINTS_1 buffer view");
            }

            // WEIGHTS_1
            if(dracoGeometry.attributes.WEIGHTS_1 !== undefined)
            {
                let weightsBuffer = this.loadArrayIntoArrayBuffer(dracoGeometry.attributes.WEIGHTS_1.array,
                    dracoGeometry.attributes.WEIGHTS_1.componentType);
                this.loadBufferIntoGltf(weightsBuffer, gltf, primitiveAttributes["WEIGHTS_1"], 34963,
                    "WEIGHTS_1 buffer view");
            }
        }

        loadBufferIntoGltf(buffer, gltf, gltfAccessorIndex, gltfBufferViewTarget, gltfBufferViewName)
        {
            const gltfBufferObj = new gltfBuffer();
            gltfBufferObj.byteLength = buffer.byteLength;
            gltfBufferObj.buffer = buffer;
            gltf.buffers.push(gltfBufferObj);

            const gltfBufferViewObj = new gltfBufferView();
            gltfBufferViewObj.buffer = gltf.buffers.length - 1;
            gltfBufferViewObj.byteLength = buffer.byteLength;
            if(gltfBufferViewName !== undefined)
            {
                gltfBufferViewObj.name = gltfBufferViewName;
            }
            gltfBufferViewObj.target = gltfBufferViewTarget;
            gltf.bufferViews.push(gltfBufferViewObj);

            gltf.accessors[gltfAccessorIndex].byteOffset = 0;
            gltf.accessors[gltfAccessorIndex].bufferView = gltf.bufferViews.length - 1;
        }

        loadArrayIntoArrayBuffer(arrayData, componentType)
        {
            let arrayBuffer;
            switch (componentType)
            {
            case "Int8Array":
                arrayBuffer = new ArrayBuffer(arrayData.length);
                let int8Array = new Int8Array(arrayBuffer);
                int8Array.set(arrayData);
                break;
            case "Uint8Array":
                arrayBuffer = new ArrayBuffer(arrayData.length);
                let uint8Array = new Uint8Array(arrayBuffer);
                uint8Array.set(arrayData);
                break;
            case "Int16Array":
                arrayBuffer = new ArrayBuffer(arrayData.length * 2);
                let int16Array = new Int16Array(arrayBuffer);
                int16Array.set(arrayData);
                break;
            case "Uint16Array":
                arrayBuffer = new ArrayBuffer(arrayData.length * 2);
                let uint16Array = new Uint16Array(arrayBuffer);
                uint16Array.set(arrayData);
                break;
            case "Int32Array":
                arrayBuffer = new ArrayBuffer(arrayData.length * 4);
                let int32Array = new Int32Array(arrayBuffer);
                int32Array.set(arrayData);
                break;
            case "Uint32Array":
                arrayBuffer = new ArrayBuffer(arrayData.length * 4);
                let uint32Array = new Uint32Array(arrayBuffer);
                uint32Array.set(arrayData);
                break;
            default:
            case "Float32Array":
                arrayBuffer = new ArrayBuffer(arrayData.length * 4);
                let floatArray = new Float32Array(arrayBuffer);
                floatArray.set(arrayData);
                break;
            }


            return arrayBuffer;
        }

        decodeDracoBufferToIntermediate(dracoExtension, gltf)
        {
            let dracoBufferViewIDX = dracoExtension.bufferView;

            const origGltfDrBufViewObj = gltf.bufferViews[dracoBufferViewIDX];
            const origGltfDracoBuffer = gltf.buffers[origGltfDrBufViewObj.buffer];

            const totalBuffer = new Int8Array( origGltfDracoBuffer.buffer );
            const actualBuffer = totalBuffer.slice(origGltfDrBufViewObj.byteOffset,
                origGltfDrBufViewObj.byteOffset + origGltfDrBufViewObj.byteLength);

            // decode draco buffer to geometry intermediate
            let dracoDecoder = new DracoDecoder();
            let draco = dracoDecoder.module;
            let decoder = new draco.Decoder();
            let decoderBuffer = new draco.DecoderBuffer();
            decoderBuffer.Init(actualBuffer, origGltfDrBufViewObj.byteLength);
            let geometry = this.decodeGeometry( draco, decoder, decoderBuffer, dracoExtension.attributes, gltf );

            draco.destroy( decoderBuffer );

            return geometry;
        }

        getDracoArrayTypeFromComponentType(componentType)
        {
            switch (componentType)
            {
            case GL.BYTE:
                return "Int8Array";
            case GL.UNSIGNED_BYTE:
                return "Uint8Array";
            case GL.SHORT:
                return "Int16Array";
            case GL.UNSIGNED_SHORT:
                return "Uint16Array";
            case GL.INT:
                return "Int32Array";
            case GL.UNSIGNED_INT:
                return "Uint32Array";
            case GL.FLOAT:
                return "Float32Array";
            default:
                return "Float32Array";
            }
        }

        decodeGeometry(draco, decoder, decoderBuffer, gltfDracoAttributes, gltf) {
            let dracoGeometry;
            let decodingStatus;

            // decode mesh in draco decoder
            let geometryType = decoder.GetEncodedGeometryType( decoderBuffer );
            if ( geometryType === draco.TRIANGULAR_MESH ) {
                dracoGeometry = new draco.Mesh();
                decodingStatus = decoder.DecodeBufferToMesh( decoderBuffer, dracoGeometry );
            }
            else
            {
                throw new Error( 'DRACOLoader: Unexpected geometry type.' );
            }

            if ( ! decodingStatus.ok() || dracoGeometry.ptr === 0 ) {
                throw new Error( 'DRACOLoader: Decoding failed: ' + decodingStatus.error_msg() );
            }

            let geometry = { index: null, attributes: {} };
            let vertexCount = dracoGeometry.num_points();

            // Gather all vertex attributes.
            for(let dracoAttr in gltfDracoAttributes)
            {
                let componentType = GL.BYTE;
                let accessotVertexCount;
                // find gltf accessor for this draco attribute
                for (const [key, value] of Object.entries(this.attributes))
                {
                    if(key === dracoAttr)
                    {
                        componentType = gltf.accessors[value].componentType;
                        accessotVertexCount = gltf.accessors[value].count;
                        break;
                    }
                }

                // check if vertex count matches
                if(vertexCount !== accessotVertexCount)
                {
                    throw new Error(`DRACOLoader: Accessor vertex count ${accessotVertexCount} does not match draco decoder vertex count  ${vertexCount}`);
                }
                componentType = this.getDracoArrayTypeFromComponentType(componentType);

                let dracoAttribute = decoder.GetAttributeByUniqueId( dracoGeometry, gltfDracoAttributes[dracoAttr]);
                var tmpObj = this.decodeAttribute( draco, decoder,
                    dracoGeometry, dracoAttr, dracoAttribute, componentType);
                geometry.attributes[tmpObj.name] = tmpObj;
            }

            // Add index buffer
            if ( geometryType === draco.TRIANGULAR_MESH ) {

                // Generate mesh faces.
                let numFaces = dracoGeometry.num_faces();
                let numIndices = numFaces * 3;
                let dataSize = numIndices * 4;
                let ptr = draco._malloc( dataSize );
                decoder.GetTrianglesUInt32Array( dracoGeometry, dataSize, ptr );
                let index = new Uint32Array( draco.HEAPU32.buffer, ptr, numIndices ).slice();
                draco._free( ptr );

                geometry.index = { array: index, itemSize: 1 };

            }

            draco.destroy( dracoGeometry );
            return geometry;
        }

        decodeAttribute( draco, decoder, dracoGeometry, attributeName, attribute, attributeType) {
            let numComponents = attribute.num_components();
            let numPoints = dracoGeometry.num_points();
            let numValues = numPoints * numComponents;

            let ptr;
            let array;

            let dataSize;
            switch ( attributeType ) {
            case "Float32Array":
                dataSize = numValues * 4;
                ptr = draco._malloc( dataSize );
                decoder.GetAttributeDataArrayForAllPoints( dracoGeometry, attribute, draco.DT_FLOAT32, dataSize, ptr );
                array = new Float32Array( draco.HEAPF32.buffer, ptr, numValues ).slice();
                draco._free( ptr );
                break;

            case "Int8Array":
                ptr = draco._malloc( numValues );
                decoder.GetAttributeDataArrayForAllPoints( dracoGeometry, attribute, draco.DT_INT8, numValues, ptr );
                array = new Int8Array( draco.HEAP8.buffer, ptr, numValues ).slice();
                draco._free( ptr );
                break;

            case "Int16Array":
                dataSize = numValues * 2;
                ptr = draco._malloc( dataSize );
                decoder.GetAttributeDataArrayForAllPoints( dracoGeometry, attribute, draco.DT_INT16, dataSize, ptr );
                array = new Int16Array( draco.HEAP16.buffer, ptr, numValues ).slice();
                draco._free( ptr );
                break;

            case "Int32Array":
                dataSize = numValues * 4;
                ptr = draco._malloc( dataSize );
                decoder.GetAttributeDataArrayForAllPoints( dracoGeometry, attribute, draco.DT_INT32, dataSize, ptr );
                array = new Int32Array( draco.HEAP32.buffer, ptr, numValues ).slice();
                draco._free( ptr );
                break;

            case "Uint8Array":
                ptr = draco._malloc( numValues );
                decoder.GetAttributeDataArrayForAllPoints( dracoGeometry, attribute, draco.DT_UINT8, numValues, ptr );
                array = new Uint8Array( draco.HEAPU8.buffer, ptr, numValues ).slice();
                draco._free( ptr );
                break;

            case "Uint16Array":
                dataSize = numValues * 2;
                ptr = draco._malloc( dataSize );
                decoder.GetAttributeDataArrayForAllPoints( dracoGeometry, attribute, draco.DT_UINT16, dataSize, ptr );
                array = new Uint16Array( draco.HEAPU16.buffer, ptr, numValues ).slice();
                draco._free( ptr );
                break;

            case "Uint32Array":
                dataSize = numValues * 4;
                ptr = draco._malloc( dataSize );
                decoder.GetAttributeDataArrayForAllPoints( dracoGeometry, attribute, draco.DT_UINT32, dataSize, ptr );
                array = new Uint32Array( draco.HEAPU32.buffer, ptr, numValues ).slice();
                draco._free( ptr );
                break;

            default:
                throw new Error( 'DRACOLoader: Unexpected attribute type.' );
            }

            return {
                name: attributeName,
                array: array,
                itemSize: numComponents,
                componentType: attributeType
            };

        }
    }

    class gltfMesh extends GltfObject
    {
        constructor()
        {
            super();
            this.primitives = [];
            this.name = undefined;
            this.weights = [];

            // non gltf
            this.weightsAnimated = undefined;
        }

        fromJson(jsonMesh)
        {
            super.fromJson(jsonMesh);

            if (jsonMesh.name !== undefined)
            {
                this.name = jsonMesh.name;
            }

            this.primitives = objectsFromJsons(jsonMesh.primitives, gltfPrimitive);

            if(jsonMesh.weights !== undefined)
            {
                this.weights = jsonMesh.weights;
            }
        }

        getWeightsAnimated()
        {
            return this.weightsAnimated !== undefined ? this.weightsAnimated : this.weights;
        }
    }

    // contain:
    // transform
    // child indices (reference to scene array of nodes)

    class gltfNode extends GltfObject
    {
        constructor()
        {
            super();
            this.camera = undefined;
            this.children = [];
            this.matrix = undefined;
            this.rotation = jsToGl([0, 0, 0, 1]);
            this.scale = jsToGl([1, 1, 1]);
            this.translation = jsToGl([0, 0, 0]);
            this.name = undefined;
            this.mesh = undefined;
            this.skin = undefined;

            // non gltf
            this.worldTransform = glMatrix.mat4.create();
            this.inverseWorldTransform = glMatrix.mat4.create();
            this.normalMatrix = glMatrix.mat4.create();
            this.light = undefined;
            this.changed = true;

            this.animationRotation = undefined;
            this.animationTranslation = undefined;
            this.animationScale = undefined;
        }

        initGl()
        {
            if (this.matrix !== undefined)
            {
                this.applyMatrix(this.matrix);
            }
            else
            {
                if (this.scale !== undefined)
                {
                    this.scale = jsToGl(this.scale);
                }

                if (this.rotation !== undefined)
                {
                    this.rotation = jsToGl(this.rotation);
                }

                if (this.translation !== undefined)
                {
                    this.translation = jsToGl(this.translation);
                }
            }
            this.changed = true;
        }

        applyMatrix(matrixData)
        {
            this.matrix = jsToGl(matrixData);

            glMatrix.mat4.getScaling(this.scale, this.matrix);

            // To extract a correct rotation, the scaling component must be eliminated.
            const mn = glMatrix.mat4.create();
            for(const col of [0, 1, 2])
            {
                mn[col] = this.matrix[col] / this.scale[0];
                mn[col + 4] = this.matrix[col + 4] / this.scale[1];
                mn[col + 8] = this.matrix[col + 8] / this.scale[2];
            }
            glMatrix.mat4.getRotation(this.rotation, mn);
            glMatrix.quat.normalize(this.rotation, this.rotation);

            glMatrix.mat4.getTranslation(this.translation, this.matrix);

            this.changed = true;
        }

        // vec3
        applyTranslationAnimation(translation)
        {
            this.animationTranslation = translation;
            this.changed = true;
        }

        // quat
        applyRotationAnimation(rotation)
        {
            this.animationRotation = rotation;
            this.changed = true;
        }

        // vec3
        applyScaleAnimation(scale)
        {
            this.animationScale = scale;
            this.changed = true;
        }

        resetTransform()
        {
            this.rotation = jsToGl([0, 0, 0, 1]);
            this.scale = jsToGl([1, 1, 1]);
            this.translation = jsToGl([0, 0, 0]);
            this.changed = true;
        }

        getLocalTransform()
        {
            if(this.transform === undefined || this.changed)
            {
                // if no animation is applied and the transform matrix is present use it directly
                if(this.animationTranslation === undefined && this.animationRotation === undefined && this.animationScale === undefined && this.matrix !== undefined) {
                    this.transform = glMatrix.mat4.clone(this.matrix);
                } else {
                    this.transform = glMatrix.mat4.create();
                    const translation = this.animationTranslation !== undefined ? this.animationTranslation : this.translation;
                    const rotation = this.animationRotation !== undefined ? this.animationRotation : this.rotation;
                    const scale = this.animationScale !== undefined ? this.animationScale : this.scale;
                    glMatrix.mat4.fromRotationTranslationScale(this.transform, rotation, translation, scale);
                }
                this.changed = false;
            }

            return glMatrix.mat4.clone(this.transform);
        }
    }

    class gltfScene extends GltfObject
    {
        constructor(nodes = [], name = undefined)
        {
            super();
            this.nodes = nodes;
            this.name = name;

            // non gltf
            this.imageBasedLight = undefined;
        }

        initGl(gltf, webGlContext)
        {
            super.initGl(gltf, webGlContext);

            if (this.extensions !== undefined &&
                this.extensions.KHR_lights_image_based !== undefined)
            {
                const index = this.extensions.KHR_lights_image_based.imageBasedLight;
                this.imageBasedLight = gltf.imageBasedLights[index];
            }
        }

        applyTransformHierarchy(gltf, rootTransform = glMatrix.mat4.create())
        {
            function applyTransform(gltf, node, parentTransform)
            {
                glMatrix.mat4.multiply(node.worldTransform, parentTransform, node.getLocalTransform());
                glMatrix.mat4.invert(node.inverseWorldTransform, node.worldTransform);
                glMatrix.mat4.transpose(node.normalMatrix, node.inverseWorldTransform);

                for (const child of node.children)
                {
                    applyTransform(gltf, gltf.nodes[child], node.worldTransform);
                }
            }

            for (const node of this.nodes)
            {
                applyTransform(gltf, gltf.nodes[node], rootTransform);
            }
        }

        gatherNodes(gltf)
        {
            const nodes = [];

            function gatherNode(nodeIndex)
            {
                const node = gltf.nodes[nodeIndex];
                nodes.push(node);

                // recurse into children
                for(const child of node.children)
                {
                    gatherNode(child);
                }
            }

            for (const node of this.nodes)
            {
                gatherNode(node);
            }

            return nodes;
        }

        includesNode(gltf, nodeIndex)
        {
            let children = [...this.nodes];
            while(children.length > 0)
            {
                const childIndex = children.pop();

                if (childIndex === nodeIndex)
                {
                    return true;
                }

                children = children.concat(gltf.nodes[childIndex].children);
            }

            return false;
        }
    }

    class gltfAsset extends GltfObject
    {
        constructor()
        {
            super();
            this.copyright = undefined;
            this.generator = undefined;
            this.version = undefined;
            this.minVersion = undefined;
        }
    }

    class gltfAnimationChannel extends GltfObject
    {
        constructor()
        {
            super();
            this.target = {node: undefined, path: undefined};
            this.sampler = undefined;
        }
    }

    const InterpolationPath =
    {
        TRANSLATION: "translation",
        ROTATION: "rotation",
        SCALE: "scale",
        WEIGHTS: "weights"
    };

    class gltfAnimationSampler extends GltfObject
    {
        constructor()
        {
            super();
            this.input = undefined;
            this.interpolation = undefined;
            this.output = undefined;
        }
    }

    const InterpolationModes =
    {
        LINEAR: "LINEAR",
        STEP: "STEP",
        CUBICSPLINE: "CUBICSPLINE"
    };

    class gltfInterpolator
    {
        constructor()
        {
            this.prevKey = 0;
            this.prevT = 0.0;
        }

        slerpQuat(q1, q2, t)
        {
            const qn1 = glMatrix.quat.create();
            const qn2 = glMatrix.quat.create();

            glMatrix.quat.normalize(qn1, q1);
            glMatrix.quat.normalize(qn2, q2);

            const quatResult = glMatrix.quat.create();

            glMatrix.quat.slerp(quatResult, qn1, qn2, t);
            glMatrix.quat.normalize(quatResult, quatResult);

            return quatResult;
        }

        step(prevKey, output, stride)
        {
            const result = new glMatrix.glMatrix.ARRAY_TYPE(stride);

            for(let i = 0; i < stride; ++i)
            {
                result[i] = output[prevKey * stride + i];
            }

            return result;
        }

        linear(prevKey, nextKey, output, t, stride)
        {
            const result = new glMatrix.glMatrix.ARRAY_TYPE(stride);

            for(let i = 0; i < stride; ++i)
            {
                result[i] = output[prevKey * stride + i] * (1-t) + output[nextKey * stride + i] * t;
            }

            return result;
        }

        cubicSpline(prevKey, nextKey, output, keyDelta, t, stride)
        {
            // stride: Count of components (4 in a quaternion).
            // Scale by 3, because each output entry consist of two tangents and one data-point.
            const prevIndex = prevKey * stride * 3;
            const nextIndex = nextKey * stride * 3;
            const A = 0;
            const V = 1 * stride;
            const B = 2 * stride;

            const result = new glMatrix.glMatrix.ARRAY_TYPE(stride);
            const tSq = t ** 2;
            const tCub = t ** 3;

            // We assume that the components in output are laid out like this: in-tangent, point, out-tangent.
            // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#appendix-c-spline-interpolation
            for(let i = 0; i < stride; ++i)
            {
                const v0 = output[prevIndex + i + V];
                const a = keyDelta * output[nextIndex + i + A];
                const b = keyDelta * output[prevIndex + i + B];
                const v1 = output[nextIndex + i + V];

                result[i] = ((2*tCub - 3*tSq + 1) * v0) + ((tCub - 2*tSq + t) * b) + ((-2*tCub + 3*tSq) * v1) + ((tCub - tSq) * a);
            }

            return result;
        }

        resetKey()
        {
            this.prevKey = 0;
        }

        interpolate(gltf, channel, sampler, t, stride, maxTime)
        {
            if(t === undefined)
            {
                return undefined;
            }

            const input = gltf.accessors[sampler.input].getNormalizedDeinterlacedView(gltf);
            const output = gltf.accessors[sampler.output].getNormalizedDeinterlacedView(gltf);

            if(output.length === stride) // no interpolation for single keyFrame animations
            {
                return jsToGlSlice(output, 0, stride);
            }

            // Wrap t around, so the animation loops.
            // Make sure that t is never earlier than the first keyframe and never later then the last keyframe.
            t = t % maxTime;
            t = clamp(t, input[0], input[input.length - 1]);

            if (this.prevT > t)
            {
                this.prevKey = 0;
            }

            this.prevT = t;

            // Find next keyframe: min{ t of input | t > prevKey }
            let nextKey = null;
            for (let i = this.prevKey; i < input.length; ++i)
            {
                if (t <= input[i])
                {
                    nextKey = clamp(i, 1, input.length - 1);
                    break;
                }
            }
            this.prevKey = clamp(nextKey - 1, 0, nextKey);

            const keyDelta = input[nextKey] - input[this.prevKey];

            // Normalize t: [t0, t1] -> [0, 1]
            const tn = (t - input[this.prevKey]) / keyDelta;

            if(channel.target.path === InterpolationPath.ROTATION)
            {

                if(InterpolationModes.CUBICSPLINE === sampler.interpolation)
                {
                    // GLTF requires cubic spline interpolation for quaternions.
                    // https://github.com/KhronosGroup/glTF/issues/1386
                    const result = this.cubicSpline(this.prevKey, nextKey, output, keyDelta, tn, 4);
                    glMatrix.quat.normalize(result, result);
                    return result;
                }
                else if(sampler.interpolation === InterpolationModes.LINEAR)
                {
                    const q0 = this.getQuat(output, this.prevKey);
                    const q1 = this.getQuat(output, nextKey);
                    return this.slerpQuat(q0, q1, tn);
                }
                else if(sampler.interpolation === InterpolationModes.STEP)
                {
                    return this.getQuat(output, this.prevKey);
                }

            }

            switch(sampler.interpolation)
            {
            case InterpolationModes.STEP:
                return this.step(this.prevKey, output, stride);
            case InterpolationModes.CUBICSPLINE:
                return this.cubicSpline(this.prevKey, nextKey, output, keyDelta, tn, stride);
            default:
                return this.linear(this.prevKey, nextKey, output, tn, stride);
            }
        }

        getQuat(output, index)
        {
            const x = output[4 * index];
            const y = output[4 * index + 1];
            const z = output[4 * index + 2];
            const w = output[4 * index + 3];
            return glMatrix.quat.fromValues(x, y, z, w);
        }
    }

    class gltfAnimation extends GltfObject
    {
        constructor()
        {
            super();
            this.channels = [];
            this.samplers = [];
            this.name = '';

            // not gltf
            this.interpolators = [];
            this.maxTime = 0;
            this.disjointAnimations = [];
        }

        fromJson(jsonAnimation)
        {
            super.fromJson(jsonAnimation);

            this.channels = objectsFromJsons(jsonAnimation.channels, gltfAnimationChannel);
            this.samplers = objectsFromJsons(jsonAnimation.samplers, gltfAnimationSampler);
            this.name = jsonAnimation.name;

            if(this.channels === undefined)
            {
                console.error("No channel data found for skin");
                return;
            }

            for(let i = 0; i < this.channels.length; ++i)
            {
                this.interpolators.push(new gltfInterpolator());
            }
        }

        // advance the animation, if totalTime is undefined, the animation is deactivated
        advance(gltf, totalTime)
        {
            if(this.channels === undefined)
            {
                return;
            }

            if(this.maxTime == 0)
            {
                for(let i = 0; i < this.channels.length; ++i)
                {
                    const channel = this.channels[i];
                    const sampler = this.samplers[channel.sampler];
                    const input = gltf.accessors[sampler.input].getDeinterlacedView(gltf);
                    const max = input[input.length - 1];
                    if(max > this.maxTime)
                    {
                        this.maxTime = max;
                    }
                }
            }

            for(let i = 0; i < this.interpolators.length; ++i)
            {
                const channel = this.channels[i];
                const sampler = this.samplers[channel.sampler];
                const interpolator = this.interpolators[i];

                const node = gltf.nodes[channel.target.node];

                switch(channel.target.path)
                {
                case InterpolationPath.TRANSLATION:
                    node.applyTranslationAnimation(interpolator.interpolate(gltf, channel, sampler, totalTime, 3, this.maxTime));
                    break;
                case InterpolationPath.ROTATION:
                    node.applyRotationAnimation(interpolator.interpolate(gltf, channel, sampler, totalTime, 4, this.maxTime));
                    break;
                case InterpolationPath.SCALE:
                    node.applyScaleAnimation(interpolator.interpolate(gltf, channel, sampler, totalTime, 3, this.maxTime));
                    break;
                case InterpolationPath.WEIGHTS:
                {
                    const mesh = gltf.meshes[node.mesh];
                    mesh.weightsAnimated = interpolator.interpolate(gltf, channel, sampler, totalTime, mesh.weights.length, this.maxTime);
                    break;
                }
                }
            }
        }
    }

    class gltfSkin extends GltfObject
    {
        constructor()
        {
            super();

            this.name = "";
            this.inverseBindMatrices = undefined;
            this.joints = [];
            this.skeleton = undefined;

            // not gltf
            this.jointTextureInfo = undefined;
            this.jointWebGlTexture = undefined;
        }

        initGl(gltf, webGlContext)
        {
            this.jointWebGlTexture = webGlContext.createTexture();
            webGlContext.bindTexture( webGlContext.TEXTURE_2D, this.jointWebGlTexture);

            // Ensure mipmapping is disabled and the sampler is configured correctly.
            webGlContext.texParameteri( GL.TEXTURE_2D,  GL.TEXTURE_WRAP_S,  GL.CLAMP_TO_EDGE);
            webGlContext.texParameteri( GL.TEXTURE_2D,  GL.TEXTURE_WRAP_T,  GL.CLAMP_TO_EDGE);
            webGlContext.texParameteri( GL.TEXTURE_2D,  GL.TEXTURE_WRAP_R,  GL.CLAMP_TO_EDGE);
            webGlContext.texParameteri( GL.TEXTURE_2D,  GL.TEXTURE_MIN_FILTER,  GL.NEAREST);
            webGlContext.texParameteri( GL.TEXTURE_2D,  GL.TEXTURE_MAG_FILTER,  GL.NEAREST);
            
            // Now we add the joints texture as a gltf texture info resource, so that 
            // we can just call webGl.setTexture(..., gltfTextureInfo, ...) in the renderer.
            const jointsImage = new gltfImage(
                undefined, // uri
                GL.TEXTURE_2D, // type
                0, // mip level
                undefined, // buffer view
                undefined, // name
                ImageMimeType.GLTEXTURE, // mimeType
                this.jointWebGlTexture // image
            );
            gltf.images.push(jointsImage);

            gltf.samplers.push(new gltfSampler(GL.NEAREST, GL.NEAREST, GL.CLAMP_TO_EDGE, GL.CLAMP_TO_EDGE, undefined));

            const jointsTexture = new gltfTexture(
                gltf.samplers.length - 1,
                gltf.images.length - 1,
                GL.TEXTURE_2D);
            // The webgl texture is already initialized -> this flag informs
            // webgl.setTexture about this.
            jointsTexture.initialized = true;

            gltf.textures.push(jointsTexture);

            this.jointTextureInfo = new gltfTextureInfo(gltf.textures.length - 1, 0, true);
            this.jointTextureInfo.samplerName = "u_jointsSampler";
            this.jointTextureInfo.generateMips = false;
        }

        computeJoints(gltf, parentNode, webGlContext)
        {
            const ibmAccessor = gltf.accessors[this.inverseBindMatrices].getDeinterlacedView(gltf);
            this.jointMatrices = [];
            this.jointNormalMatrices = [];

            const width = Math.ceil(Math.sqrt(this.joints.length * 8));
            let textureData = new Float32Array(Math.pow(width, 2) * 4);

            let i = 0;
            for(const joint of this.joints)
            {
                const node = gltf.nodes[joint];

                let jointMatrix = glMatrix.mat4.create();
                let ibm = jsToGlSlice(ibmAccessor, i * 16, 16);
                glMatrix.mat4.mul(jointMatrix, node.worldTransform, ibm);
                glMatrix.mat4.mul(jointMatrix, parentNode.inverseWorldTransform, jointMatrix);

                let normalMatrix = glMatrix.mat4.create();
                glMatrix.mat4.invert(normalMatrix, jointMatrix);
                glMatrix.mat4.transpose(normalMatrix, normalMatrix);
                
                textureData.set(jointMatrix, i * 32);
                textureData.set(normalMatrix, i * 32 + 16);
                ++i;
            }

            webGlContext.bindTexture( webGlContext.TEXTURE_2D, this.jointWebGlTexture);
            // Set texture format and upload data.
            let internalFormat = webGlContext.RGBA32F;
            let format = webGlContext.RGBA;
            let type = webGlContext.FLOAT;
            let data = textureData;
            webGlContext.texImage2D(
                webGlContext.TEXTURE_2D,
                0, //level
                internalFormat,
                width,
                width,
                0, //border
                format,
                type,
                data);
        }
    }

    class gltfVariant extends GltfObject
    {
        constructor()
        {
            super();
            this.name = undefined;
        }

        fromJson(jsonVariant)
        {
            if(jsonVariant.name !== undefined)
            {
                this.name = jsonVariant.name;
            }
        }
    }

    class glTF extends GltfObject
    {
        constructor(file)
        {
            super();
            this.asset = undefined;
            this.accessors = [];
            this.nodes = [];
            this.scene = undefined; // the default scene to show.
            this.scenes = [];
            this.cameras = [];
            this.lights = [];
            this.imageBasedLights = [];
            this.textures = [];
            this.images = [];
            this.samplers = [];
            this.meshes = [];
            this.buffers = [];
            this.bufferViews = [];
            this.materials = [];
            this.animations = [];
            this.skins = [];
            this.path = file;
        }

        initGl(webGlContext)
        {
            initGlForMembers(this, this, webGlContext);
        }

        fromJson(json)
        {
            super.fromJson(json);

            this.asset = objectFromJson(json.asset, gltfAsset);
            this.cameras = objectsFromJsons(json.cameras, gltfCamera);
            this.accessors = objectsFromJsons(json.accessors, gltfAccessor);
            this.meshes = objectsFromJsons(json.meshes, gltfMesh);
            this.samplers = objectsFromJsons(json.samplers, gltfSampler);
            this.materials = objectsFromJsons(json.materials, gltfMaterial);
            this.buffers = objectsFromJsons(json.buffers, gltfBuffer);
            this.bufferViews = objectsFromJsons(json.bufferViews, gltfBufferView);
            this.scenes = objectsFromJsons(json.scenes, gltfScene);
            this.textures = objectsFromJsons(json.textures, gltfTexture);
            this.nodes = objectsFromJsons(json.nodes, gltfNode);
            this.lights = objectsFromJsons(getJsonLightsFromExtensions(json.extensions), gltfLight);
            this.imageBasedLights = objectsFromJsons(getJsonIBLsFromExtensions(json.extensions), ImageBasedLight);
            this.images = objectsFromJsons(json.images, gltfImage);
            this.animations = objectsFromJsons(json.animations, gltfAnimation);
            this.skins = objectsFromJsons(json.skins, gltfSkin);
            this.variants = objectsFromJsons(getJsonVariantsFromExtension(json.extensions), gltfVariant);
            this.variants = enforceVariantsUniqueness(this.variants);

            this.materials.push(gltfMaterial.createDefault());
            this.samplers.push(gltfSampler.createDefault());

            if (json.scenes !== undefined)
            {
                if (json.scene === undefined && json.scenes.length > 0)
                {
                    this.scene = 0;
                }
                else
                {
                    this.scene = json.scene;
                }
            }

            this.computeDisjointAnimations();
        }

        // Computes indices of animations which are disjoint and can be played simultaneously.
        computeDisjointAnimations()
        {
            for (let i = 0; i < this.animations.length; i++)
            {
                this.animations[i].disjointAnimations = [];

                for (let k = 0; k < this.animations.length; k++)
                {
                    if (i == k)
                    {
                        continue;
                    }

                    let isDisjoint = true;

                    for (const iChannel of this.animations[i].channels)
                    {
                        for (const kChannel of this.animations[k].channels)
                        {
                            if (iChannel.target.node === kChannel.target.node
                                && iChannel.target.path === kChannel.target.path)
                            {
                                isDisjoint = false;
                                break;
                            }
                        }
                    }

                    if (isDisjoint)
                    {
                        this.animations[i].disjointAnimations.push(k);
                    }
                }
            }
        }

        nonDisjointAnimations(animationIndices)
        {
            const animations = this.animations;
            const nonDisjointAnimations = [];

            for (let i = 0; i < animations.length; i++)
            {
                let isDisjoint = true;
                for (const k of animationIndices)
                {
                    if (i == k)
                    {
                        continue;
                    }

                    if (!animations[k].disjointAnimations.includes(i))
                    {
                        isDisjoint = false;
                    }
                }

                if (!isDisjoint)
                {
                    nonDisjointAnimations.push(i);
                }
            }

            return nonDisjointAnimations;
        }
    }

    function getJsonLightsFromExtensions(extensions)
    {
        if (extensions === undefined)
        {
            return [];
        }
        if (extensions.KHR_lights_punctual === undefined)
        {
            return [];
        }
        return extensions.KHR_lights_punctual.lights;
    }

    function getJsonIBLsFromExtensions(extensions)
    {
        if (extensions === undefined)
        {
            return [];
        }
        if (extensions.KHR_lights_image_based === undefined)
        {
            return [];
        }
        return extensions.KHR_lights_image_based.imageBasedLights;
    }

    function getJsonVariantsFromExtension(extensions)
    {
        if (extensions === undefined)
        {
            return [];
        }
        if (extensions.KHR_materials_variants === undefined)
        {
            return [];
        }
        return extensions.KHR_materials_variants.variants;
    }

    function enforceVariantsUniqueness(variants)
    {
        for(let i=0;i<variants.length;i++)
        {
            const name = variants[i].name;
            for(let j=i+1;j<variants.length;j++)
            {
                if(variants[j].name == name)
                {
                    variants[j].name += "0";  // Add random character to duplicates
                }
            }
        }


        return variants;
    }

    class GlbParser
    {
        constructor(data)
        {
            this.data = data;
            this.glbHeaderInts = 3;
            this.glbChunkHeaderInts = 2;
            this.glbMagic = 0x46546C67;
            this.glbVersion = 2;
            this.jsonChunkType = 0x4E4F534A;
            this.binaryChunkType = 0x004E4942;
        }

        extractGlbData()
        {
            const glbInfo = this.getCheckedGlbInfo();
            if (glbInfo === undefined)
            {
                return undefined;
            }

            let json = undefined;
            let buffers = [];
            const chunkInfos = this.getAllChunkInfos();
            for (let chunkInfo of chunkInfos)
            {
                if (chunkInfo.type == this.jsonChunkType && !json)
                {
                    json = this.getJsonFromChunk(chunkInfo);
                }
                else if (chunkInfo.type == this.binaryChunkType)
                {
                    buffers.push(this.getBufferFromChunk(chunkInfo));
                }
            }

            return { json: json, buffers: buffers };
        }

        getCheckedGlbInfo()
        {
            const header = new Uint32Array(this.data, 0, this.glbHeaderInts);
            const magic = header[0];
            const version = header[1];
            const length = header[2];

            if (!this.checkEquality(magic, this.glbMagic, "glb magic") ||
                !this.checkEquality(version, this.glbVersion, "glb header version") ||
                !this.checkEquality(length, this.data.byteLength, "glb byte length"))
            {
                return undefined;
            }

            return { "magic": magic, "version": version, "length": length };
        }

        getAllChunkInfos()
        {
            let infos = [];
            let chunkStart = this.glbHeaderInts * 4;
            while (chunkStart < this.data.byteLength)
            {
                const chunkInfo = this.getChunkInfo(chunkStart);
                infos.push(chunkInfo);
                chunkStart += chunkInfo.length + this.glbChunkHeaderInts * 4;
            }
            return infos;
        }

        getChunkInfo(headerStart)
        {
            const header = new Uint32Array(this.data, headerStart, this.glbChunkHeaderInts);
            const chunkStart = headerStart + this.glbChunkHeaderInts * 4;
            const chunkLength = header[0];
            const chunkType = header[1];
            return { "start": chunkStart, "length": chunkLength, "type": chunkType };
        }

        getJsonFromChunk(chunkInfo)
        {
            const chunkLength = chunkInfo.length;
            const jsonStart = (this.glbHeaderInts + this.glbChunkHeaderInts) * 4;
            const jsonSlice = new Uint8Array(this.data, jsonStart, chunkLength);
            const stringBuffer = new TextDecoder("utf-8").decode(jsonSlice);
            return JSON.parse(stringBuffer);
        }

        getBufferFromChunk(chunkInfo)
        {
            return this.data.slice(chunkInfo.start, chunkInfo.start + chunkInfo.length);
        }

        checkEquality(actual, expected, name)
        {
            if (actual == expected)
            {
                return true;
            }

            console.error("Found invalid/unsupported " + name + ", expected: " + expected + ", but was: " + actual);
            return false;
        }
    }

    class gltfLoader
    {
        static async load(gltf, webGlContext, appendix = undefined)
        {
            const buffers = gltfLoader.getBuffers(appendix);
            const additionalFiles = gltfLoader.getAdditionalFiles(appendix);

            const buffersPromise = gltfLoader.loadBuffers(gltf, buffers, additionalFiles);

            await buffersPromise; // images might be stored in the buffers
            const imagesPromise = gltfLoader.loadImages(gltf, additionalFiles);

            return await Promise.all([buffersPromise, imagesPromise])
                .then(() => gltf.initGl(webGlContext));
        }

        static unload(gltf)
        {
            for (let image of gltf.images)
            {
                image.image = undefined;
            }
            gltf.images = [];

            for (let texture of gltf.textures)
            {
                texture.destroy();
            }
            gltf.textures = [];

            for (let accessor of gltf.accessors)
            {
                accessor.destroy();
            }
            gltf.accessors = [];
        }

        static getBuffers(appendix)
        {
            return gltfLoader.getTypedAppendix(appendix, ArrayBuffer);
        }

        static getAdditionalFiles(appendix)
        {
            if(typeof(File) !== 'undefined')
            {
                return gltfLoader.getTypedAppendix(appendix, File);
            }
            else
            {
                return;
            }
        }

        static getTypedAppendix(appendix, Type)
        {
            if (appendix && appendix.length > 0)
            {
                if (appendix[0] instanceof Type)
                {
                    return appendix;
                }
            }
        }

        static loadBuffers(gltf, buffers, additionalFiles)
        {
            const promises = [];

            if (buffers !== undefined && buffers[0] !== undefined) //GLB
            {
                //There is only one buffer for the glb binary data 
                //see https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#glb-file-format-specification
                if (buffers.length > 1)
                {
                    console.warn("Too many buffer chunks in GLB file. Only one or zero allowed");
                }

                gltf.buffers[0].buffer = buffers[0];
                for (let i = 1; i < gltf.buffers.length; ++i)
                {
                    promises.push(gltf.buffers[i].load(gltf, additionalFiles));
                }
            }
            else
            {
                for (const buffer of gltf.buffers)
                {
                    promises.push(buffer.load(gltf, additionalFiles));
                }
            }
            return Promise.all(promises);
        }

        static loadImages(gltf, additionalFiles)
        {
            const imagePromises = [];
            for (let image of gltf.images)
            {
                imagePromises.push(image.load(gltf, additionalFiles));
            }
            return Promise.all(imagePromises);
        }
    }

    var iblFiltering = "//#version 450\n//#extension GL_ARB_separate_shader_objects : enable\n\nprecision mediump float;\n#define GLSLIFY 1\n#define MATH_PI 3.1415926535897932384626433832795\n//#define MATH_INV_PI (1.0 / MATH_PI)\n\nuniform samplerCube uCubeMap;\n\n// enum\nconst int cLambertian = 0;\nconst int cGGX = 1;\nconst int cCharlie = 2;\n\n//layout(push_constant) uniform FilterParameters {\nuniform  float u_roughness;\nuniform  int u_sampleCount;\nuniform  int u_width;\nuniform  float u_lodBias;\nuniform  int u_distribution; // enum\nuniform int u_currentFace;\nuniform int u_isGeneratingLUT;\n\n//layout (location = 0) in vec2 inUV;\nin vec2 texCoord;\n\nout vec4 fragmentColor;\n\n//layout(location = 6) out vec3 outLUT;\n\nvec3 uvToXYZ(int face, vec2 uv)\n{\n    if(face == 0)\n        return vec3(     1.f,   uv.y,    -uv.x);\n\n    else if(face == 1)\n        return vec3(    -1.f,   uv.y,     uv.x);\n\n    else if(face == 2)\n        return vec3(   +uv.x,   -1.f,    +uv.y);\n\n    else if(face == 3)\n        return vec3(   +uv.x,    1.f,    -uv.y);\n\n    else if(face == 4)\n        return vec3(   +uv.x,   uv.y,      1.f);\n\n    else {//if(face == 5)\n        return vec3(    -uv.x,  +uv.y,     -1.f);}\n}\n\nvec2 dirToUV(vec3 dir)\n{\n    return vec2(\n            0.5f + 0.5f * atan(dir.z, dir.x) / MATH_PI,\n            1.f - acos(dir.y) / MATH_PI);\n}\n\nfloat saturate(float v)\n{\n    return clamp(v, 0.0f, 1.0f);\n}\n\n// Hammersley Points on the Hemisphere\n// CC BY 3.0 (Holger Dammertz)\n// http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html\n// with adapted interface\nfloat radicalInverse_VdC(uint bits)\n{\n    bits = (bits << 16u) | (bits >> 16u);\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n\n// hammersley2d describes a sequence of points in the 2d unit square [0,1)^2\n// that can be used for quasi Monte Carlo integration\nvec2 hammersley2d(int i, int N) {\n    return vec2(float(i)/float(N), radicalInverse_VdC(uint(i)));\n}\n\n// Hemisphere Sample\n\n// TBN generates a tangent bitangent normal coordinate frame from the normal\n// (the normal must be normalized)\nmat3 generateTBN(vec3 normal)\n{\n    vec3 bitangent = vec3(0.0, 1.0, 0.0);\n\n    float NdotUp = dot(normal, vec3(0.0, 1.0, 0.0));\n    float epsilon = 0.0000001;\n    if (1.0 - abs(NdotUp) <= epsilon)\n    {\n        // Sampling +Y or -Y, so we need a more robust bitangent.\n        if (NdotUp > 0.0)\n        {\n            bitangent = vec3(0.0, 0.0, 1.0);\n        }\n        else\n        {\n            bitangent = vec3(0.0, 0.0, -1.0);\n        }\n    }\n\n    vec3 tangent = normalize(cross(bitangent, normal));\n    bitangent = cross(normal, tangent);\n\n    return mat3(tangent, bitangent, normal);\n}\n\nstruct MicrofacetDistributionSample\n{\n    float pdf;\n    float cosTheta;\n    float sinTheta;\n    float phi;\n};\n\nfloat D_GGX(float NdotH, float roughness) {\n    float a = NdotH * roughness;\n    float k = roughness / (1.0 - NdotH * NdotH + a * a);\n    return k * k * (1.0 / MATH_PI);\n}\n\n// GGX microfacet distribution\n// https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.html\n// This implementation is based on https://bruop.github.io/ibl/,\n//  https://www.tobias-franke.eu/log/2014/03/30/notes_on_importance_sampling.html\n// and https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch20.html\nMicrofacetDistributionSample GGX(vec2 xi, float roughness)\n{\n    MicrofacetDistributionSample ggx;\n\n    // evaluate sampling equations\n    float alpha = roughness * roughness;\n    ggx.cosTheta = saturate(sqrt((1.0 - xi.y) / (1.0 + (alpha * alpha - 1.0) * xi.y)));\n    ggx.sinTheta = sqrt(1.0 - ggx.cosTheta * ggx.cosTheta);\n    ggx.phi = 2.0 * MATH_PI * xi.x;\n\n    // evaluate GGX pdf (for half vector)\n    ggx.pdf = D_GGX(ggx.cosTheta, alpha);\n\n    // Apply the Jacobian to obtain a pdf that is parameterized by l\n    // see https://bruop.github.io/ibl/\n    // Typically you'd have the following:\n    // float pdf = D_GGX(NoH, roughness) * NoH / (4.0 * VoH);\n    // but since V = N => VoH == NoH\n    ggx.pdf /= 4.0;\n\n    return ggx;\n}\n\n// NDF\nfloat D_Ashikhmin(float NdotH, float roughness)\n{\n    float alpha = roughness * roughness;\n    // Ashikhmin 2007, \"Distribution-based BRDFs\"\n    float a2 = alpha * alpha;\n    float cos2h = NdotH * NdotH;\n    float sin2h = 1.0 - cos2h;\n    float sin4h = sin2h * sin2h;\n    float cot2 = -cos2h / (a2 * sin2h);\n    return 1.0 / (MATH_PI * (4.0 * a2 + 1.0) * sin4h) * (4.0 * exp(cot2) + sin4h);\n}\n\n// NDF\nfloat D_Charlie(float sheenRoughness, float NdotH)\n{\n    sheenRoughness = max(sheenRoughness, 0.000001); //clamp (0,1]\n    float invR = 1.0 / sheenRoughness;\n    float cos2h = NdotH * NdotH;\n    float sin2h = 1.0 - cos2h;\n    return (2.0 + invR) * pow(sin2h, invR * 0.5) / (2.0 * MATH_PI);\n}\n\nMicrofacetDistributionSample Charlie(vec2 xi, float roughness)\n{\n    MicrofacetDistributionSample charlie;\n\n    float alpha = roughness * roughness;\n    charlie.sinTheta = pow(xi.y, alpha / (2.0*alpha + 1.0));\n    charlie.cosTheta = sqrt(1.0 - charlie.sinTheta * charlie.sinTheta);\n    charlie.phi = 2.0 * MATH_PI * xi.x;\n\n    // evaluate Charlie pdf (for half vector)\n    charlie.pdf = D_Charlie(alpha, charlie.cosTheta);\n\n    // Apply the Jacobian to obtain a pdf that is parameterized by l\n    charlie.pdf /= 4.0;\n\n    return charlie;\n}\n\nMicrofacetDistributionSample Lambertian(vec2 xi, float roughness)\n{\n    MicrofacetDistributionSample lambertian;\n\n    // Cosine weighted hemisphere sampling\n    // http://www.pbr-book.org/3ed-2018/Monte_Carlo_Integration/2D_Sampling_with_Multidimensional_Transformations.html#Cosine-WeightedHemisphereSampling\n    lambertian.cosTheta = sqrt(1.0 - xi.y);\n    lambertian.sinTheta = sqrt(xi.y); // equivalent to `sqrt(1.0 - cosTheta*cosTheta)`;\n    lambertian.phi = 2.0 * MATH_PI * xi.x;\n\n    lambertian.pdf = lambertian.cosTheta / MATH_PI; // evaluation for solid angle, therefore drop the sinTheta\n\n    return lambertian;\n}\n\n// getImportanceSample returns an importance sample direction with pdf in the .w component\nvec4 getImportanceSample(int sampleIndex, vec3 N, float roughness)\n{\n    // generate a quasi monte carlo point in the unit square [0.1)^2\n    vec2 xi = hammersley2d(sampleIndex, u_sampleCount);\n\n    MicrofacetDistributionSample importanceSample;\n\n    // generate the points on the hemisphere with a fitting mapping for\n    // the distribution (e.g. lambertian uses a cosine importance)\n    if(u_distribution == cLambertian)\n    {\n        importanceSample = Lambertian(xi, roughness);\n    }\n    else if(u_distribution == cGGX)\n    {\n        // Trowbridge-Reitz / GGX microfacet model (Walter et al)\n        // https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.html\n        importanceSample = GGX(xi, roughness);\n    }\n    else if(u_distribution == cCharlie)\n    {\n        importanceSample = Charlie(xi, roughness);\n    }\n\n    // transform the hemisphere sample to the normal coordinate frame\n    // i.e. rotate the hemisphere to the normal direction\n    vec3 localSpaceDirection = normalize(vec3(\n        importanceSample.sinTheta * cos(importanceSample.phi), \n        importanceSample.sinTheta * sin(importanceSample.phi), \n        importanceSample.cosTheta\n    ));\n    mat3 TBN = generateTBN(N);\n    vec3 direction = TBN * localSpaceDirection;\n\n    return vec4(direction, importanceSample.pdf);\n}\n\n// Mipmap Filtered Samples (GPU Gems 3, 20.4)\n// https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-20-gpu-based-importance-sampling\n// https://cgg.mff.cuni.cz/~jaroslav/papers/2007-sketch-fis/Final_sap_0073.pdf\nfloat computeLod(float pdf)\n{\n    // // Solid angle of current sample -- bigger for less likely samples\n    // float omegaS = 1.0 / (float(u_sampleCount) * pdf);\n    // // Solid angle of texel\n    // // note: the factor of 4.0 * MATH_PI \n    // float omegaP = 4.0 * MATH_PI / (6.0 * float(u_width) * float(u_width));\n    // // Mip level is determined by the ratio of our sample's solid angle to a texel's solid angle \n    // // note that 0.5 * log2 is equivalent to log4\n    // float lod = 0.5 * log2(omegaS / omegaP);\n\n    // babylon introduces a factor of K (=4) to the solid angle ratio\n    // this helps to avoid undersampling the environment map\n    // this does not appear in the original formulation by Jaroslav Krivanek and Mark Colbert\n    // log4(4) == 1\n    // lod += 1.0;\n\n    // We achieved good results by using the original formulation from Krivanek & Colbert adapted to cubemaps\n\n    // https://cgg.mff.cuni.cz/~jaroslav/papers/2007-sketch-fis/Final_sap_0073.pdf\n    float lod = 0.5 * log2( 6.0 * float(u_width) * float(u_width) / (float(u_sampleCount) * pdf));\n\n    return lod;\n}\n\nvec3 filterColor(vec3 N)\n{\n    //return  textureLod(uCubeMap, N, 3.0).rgb;\n    vec3 color = vec3(0.f);\n    float weight = 0.0f;\n\n    for(int i = 0; i < u_sampleCount; ++i)\n    {\n        vec4 importanceSample = getImportanceSample(i, N, u_roughness);\n\n        vec3 H = vec3(importanceSample.xyz);\n        float pdf = importanceSample.w;\n\n        // mipmap filtered samples (GPU Gems 3, 20.4)\n        float lod = computeLod(pdf);\n\n        // apply the bias to the lod\n        lod += u_lodBias;\n\n        if(u_distribution == cLambertian)\n        {\n            // sample lambertian at a lower resolution to avoid fireflies\n            vec3 lambertian = textureLod(uCubeMap, H, lod).rgb;\n\n            //// the below operations cancel each other out\n            // lambertian *= NdotH; // lamberts law\n            // lambertian /= pdf; // invert bias from importance sampling\n            // lambertian /= MATH_PI; // convert irradiance to radiance https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/\n\n            color += lambertian;\n        }\n        else if(u_distribution == cGGX || u_distribution == cCharlie)\n        {\n            // Note: reflect takes incident vector.\n            vec3 V = N;\n            vec3 L = normalize(reflect(-V, H));\n            float NdotL = dot(N, L);\n\n            if (NdotL > 0.0)\n            {\n                if(u_roughness == 0.0)\n                {\n                    // without this the roughness=0 lod is too high\n                    lod = u_lodBias;\n                }\n                vec3 sampleColor = textureLod(uCubeMap, L, lod).rgb;\n                color += sampleColor * NdotL;\n                weight += NdotL;\n            }\n        }\n    }\n\n    if(weight != 0.0f)\n    {\n        color /= weight;\n    }\n    else\n    {\n        color /= float(u_sampleCount);\n    }\n\n    return color.rgb ;\n}\n\n// From the filament docs. Geometric Shadowing function\n// https://google.github.io/filament/Filament.html#toc4.4.2\nfloat V_SmithGGXCorrelated(float NoV, float NoL, float roughness) {\n    float a2 = pow(roughness, 4.0);\n    float GGXV = NoL * sqrt(NoV * NoV * (1.0 - a2) + a2);\n    float GGXL = NoV * sqrt(NoL * NoL * (1.0 - a2) + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\n// https://github.com/google/filament/blob/master/shaders/src/brdf.fs#L136\nfloat V_Ashikhmin(float NdotL, float NdotV)\n{\n    return clamp(1.0 / (4.0 * (NdotL + NdotV - NdotL * NdotV)), 0.0, 1.0);\n}\n\n// Compute LUT for GGX distribution.\n// See https://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\nvec3 LUT(float NdotV, float roughness)\n{\n    // Compute spherical view vector: (sin(phi), 0, cos(phi))\n    vec3 V = vec3(sqrt(1.0 - NdotV * NdotV), 0.0, NdotV);\n\n    // The macro surface normal just points up.\n    vec3 N = vec3(0.0, 0.0, 1.0);\n\n    // To make the LUT independant from the material's F0, which is part of the Fresnel term\n    // when substituted by Schlick's approximation, we factor it out of the integral,\n    // yielding to the form: F0 * I1 + I2\n    // I1 and I2 are slighlty different in the Fresnel term, but both only depend on\n    // NoL and roughness, so they are both numerically integrated and written into two channels.\n    float A = 0.0;\n    float B = 0.0;\n    float C = 0.0;\n\n    for(int i = 0; i < u_sampleCount; ++i)\n    {\n        // Importance sampling, depending on the distribution.\n        vec4 importanceSample = getImportanceSample(i, N, roughness);\n        vec3 H = importanceSample.xyz;\n        // float pdf = importanceSample.w;\n        vec3 L = normalize(reflect(-V, H));\n\n        float NdotL = saturate(L.z);\n        float NdotH = saturate(H.z);\n        float VdotH = saturate(dot(V, H));\n        if (NdotL > 0.0)\n        {\n            if (u_distribution == cGGX)\n            {\n                // LUT for GGX distribution.\n\n                // Taken from: https://bruop.github.io/ibl\n                // Shadertoy: https://www.shadertoy.com/view/3lXXDB\n                // Terms besides V are from the GGX PDF we're dividing by.\n                float V_pdf = V_SmithGGXCorrelated(NdotV, NdotL, roughness) * VdotH * NdotL / NdotH;\n                float Fc = pow(1.0 - VdotH, 5.0);\n                A += (1.0 - Fc) * V_pdf;\n                B += Fc * V_pdf;\n                C += 0.0;\n            }\n\n            if (u_distribution == cCharlie)\n            {\n                // LUT for Charlie distribution.\n                float sheenDistribution = D_Charlie(roughness, NdotH);\n                float sheenVisibility = V_Ashikhmin(NdotL, NdotV);\n\n                A += 0.0;\n                B += 0.0;\n                C += sheenVisibility * sheenDistribution * NdotL * VdotH;\n            }\n        }\n    }\n\n    // The PDF is simply pdf(v, h) -> NDF * <nh>.\n    // To parametrize the PDF over l, use the Jacobian transform, yielding to: pdf(v, l) -> NDF * <nh> / 4<vh>\n    // Since the BRDF divide through the PDF to be normalized, the 4 can be pulled out of the integral.\n    return vec3(4.0 * A, 4.0 * B, 4.0 * 2.0 * MATH_PI * C) / float(u_sampleCount);\n}\n\n// entry point\nvoid main()\n{\n    vec3 color = vec3(0);\n\n    if(u_isGeneratingLUT == 0)\n    {\n        vec2 newUV = texCoord ;\n\n        newUV = newUV*2.0-1.0;\n\n        vec3 scan = uvToXYZ(u_currentFace, newUV);\n\n        vec3 direction = normalize(scan);\n        direction.y = -direction.y;\n    \n        color = filterColor(direction);\n    }\n    else\n    {\n        color = LUT(texCoord.x, texCoord.y);\n    }\n    \n    fragmentColor = vec4(color,1.0);\n}\n\n"; // eslint-disable-line

    var panoramaToCubeMap = "#define MATH_PI 3.1415926535897932384626433832795\n#define MATH_INV_PI (1.0 / MATH_PI)\n\nprecision highp float;\n#define GLSLIFY 1\n\nin vec2 texCoord;\nout vec4 fragmentColor;\n\nuniform int u_currentFace;\n\nuniform sampler2D u_inputTexture;\nuniform sampler2D u_panorama;\n\nvec3 uvToXYZ(int face, vec2 uv)\n{\n\tif(face == 0)\n\t\treturn vec3(     1.f,   uv.y,    -uv.x);\n\n\telse if(face == 1)\n\t\treturn vec3(    -1.f,   uv.y,     uv.x);\n\n\telse if(face == 2)\n\t\treturn vec3(   +uv.x,   -1.f,    +uv.y);\n\n\telse if(face == 3)\n\t\treturn vec3(   +uv.x,    1.f,    -uv.y);\n\n\telse if(face == 4)\n\t\treturn vec3(   +uv.x,   uv.y,      1.f);\n\n\telse //if(face == 5)\n\t{\treturn vec3(    -uv.x,  +uv.y,     -1.f);}\n}\n\nvec2 dirToUV(vec3 dir)\n{\n\treturn vec2(\n\t\t0.5f + 0.5f * atan(dir.z, dir.x) / MATH_PI,\n\t\t1.f - acos(dir.y) / MATH_PI);\n}\n\nvec3 panoramaToCubeMap(int face, vec2 texCoord)\n{\n\tvec2 texCoordNew = texCoord*2.0-1.0;\n\tvec3 scan = uvToXYZ(face, texCoordNew);\n\tvec3 direction = normalize(scan);\n\tvec2 src = dirToUV(direction);\n\n\treturn  texture(u_panorama, src).rgb;\n}\n\nvoid main(void)\n{\n    fragmentColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n\tfragmentColor.rgb = panoramaToCubeMap(u_currentFace, texCoord);\n}\n"; // eslint-disable-line

    var debugOutput = "\nprecision highp float;\n#define GLSLIFY 1\n\nin vec2 texCoord;\nout vec4 fragmentColor;\n\nuniform int u_currentFace;\n\nuniform samplerCube u_inputTexture;\n\nvec3 uvToXYZ(int face, vec2 uv)\n{\n\tif(face == 0)\n\t\treturn vec3(     1.f,   uv.y,    -uv.x);\n\t\t\n\telse if(face == 1)\n\t\treturn vec3(    -1.f,   uv.y,     uv.x);\n\t\t\n\telse if(face == 2)\n\t\treturn vec3(   +uv.x,   -1.f,    +uv.y);\t\t\n\t\n\telse if(face == 3)\n\t\treturn vec3(   +uv.x,    1.f,    -uv.y);\n\t\t\n\telse if(face == 4)\n\t\treturn vec3(   +uv.x,   uv.y,      1.f);\n\t\t\n\telse //if(face == 5)\n\t{\treturn vec3(    -uv.x,  +uv.y,     -1.f);}\n}\n\nvoid main(void)   \n{\n\n    fragmentColor = vec4(texCoord.x*10.0, 0.0, texCoord.y*10.0, 1.0);\n\t\n\n\tvec2 newUV =texCoord;\n\tnewUV = newUV*2.0-1.0;\n\n\tvec4 textureColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n\tvec3 direction = normalize(uvToXYZ(u_currentFace, newUV.xy));\n \n    textureColor = textureLod(u_inputTexture, direction,1.0);\n\t//textureColor = texture(u_inputTexture, texCoord);\n\t\n\tif(texCoord.x>0.1)\n\t{\n\t\tfragmentColor = textureColor;\n\t}\n\n\tif(texCoord.y>0.1)\n\t{\n\t\tfragmentColor = textureColor;\n\t}\n\n}"; // eslint-disable-line

    var fullscreenShader = "precision highp float;\n#define GLSLIFY 1\n\nout vec2 texCoord;\n\nvoid main(void) \n{\n    float x = float((gl_VertexID & 1) << 2);\n    float y = float((gl_VertexID & 2) << 1);\n    texCoord.x = x * 0.5;\n    texCoord.y = y * 0.5;\n    gl_Position = vec4(x - 1.0, y - 1.0, 0, 1);\n}"; // eslint-disable-line

    // How to use:
    // set canvas/context in constructor
    // init(input: panorama image)
    // filterAll()
    // fetch texture IDs

    class iblSampler
    {
        constructor(view)
        {

            this.gl = view.context;

            this.textureSize = 256;
            this.ggxSampleCount = 1024;
            this.lambertianSampleCount = 2048;
            this.sheenSamplCount = 64;
            this.lodBias = 0.0;
            this.lowestMipLevel = 4;
            this.lutResolution = 1024;

            this.mipmapCount = undefined;

            this.lambertianTextureID = undefined;
            this.ggxTextureID = undefined;
            this.sheenTextureID = undefined;

            this.ggxLutTextureID = undefined;
            this.charlieLutTextureID = undefined;

            this.inputTextureID = undefined;
            this.cubemapTextureID = undefined;
            this.framebuffer = undefined;

            const shaderSources = new Map();

            shaderSources.set("fullscreen.vert", fullscreenShader);
            shaderSources.set("panorama_to_cubemap.frag", panoramaToCubeMap);
            shaderSources.set("ibl_filtering.frag", iblFiltering);
            shaderSources.set("debug.frag", debugOutput);

            this.shaderCache = new ShaderCache(shaderSources, view.renderer.webGl);


        }

        /////////////////////////////////////////////////////////////////////


        loadTextureHDR(image)
        {

            var texture = this.gl.createTexture();

            this.gl.bindTexture( this.gl.TEXTURE_2D,  texture);

            var internalFormat = this.gl.RGB32F;
            var format = this.gl.RGB;
            var type = this.gl.FLOAT;
            var data = undefined;

            if (image.dataFloat instanceof Float32Array && typeof(this.gl.RGB32F) !== 'undefined')
            {
                internalFormat = this.gl.RGB32F;
                format = this.gl.RGB;
                type = this.gl.FLOAT;
                data = image.dataFloat;
            }
            else if(image.dataFloat instanceof Float32Array)
            {
                // workaround for node-gles not supporting RGB32F
                internalFormat = this.gl.RGBA32F;
                format = this.gl.RGBA;
                type = this.gl.FLOAT;

                const numPixels = image.dataFloat.length / 3;
                data = new Float32Array(numPixels * 4);
                for(let i = 0, src = 0, dst = 0; i < numPixels; ++i, src += 3, dst += 4)
                {
                    // copy the pixels and pad the alpha channel
                    data[dst] = image.dataFloat[src];
                    data[dst+1] = image.dataFloat[src+1];
                    data[dst+2] = image.dataFloat[src+2];
                    data[dst+3] = 0;
                }
            }
            else if (typeof(Image) !== 'undefined' && image instanceof Image)
            {
                internalFormat = this.gl.RGBA;
                format = this.gl.RGBA;
                type = this.gl.UNSIGNED_BYTE;
                data = image;
            }
            else
            {
                console.error("loadTextureHDR failed, unsupported HDR image");
                return;
            }


            this.gl.texImage2D(
                this.gl.TEXTURE_2D,
                0, //level
                internalFormat,
                image.width,
                image.height,
                0, //border
                format,
                type,
                data);

            this.gl.texParameteri( this.gl.TEXTURE_2D,  this.gl.TEXTURE_WRAP_S,  this.gl.MIRRORED_REPEAT);
            this.gl.texParameteri( this.gl.TEXTURE_2D,  this.gl.TEXTURE_WRAP_T,  this.gl.MIRRORED_REPEAT);
            this.gl.texParameteri( this.gl.TEXTURE_2D,  this.gl.TEXTURE_MIN_FILTER,  this.gl.LINEAR);
            this.gl.texParameteri( this.gl.TEXTURE_2D,  this.gl.TEXTURE_MAG_FILTER,  this.gl.LINEAR);

            return texture;
        }



        createCubemapTexture(withMipmaps)
        {
            var targetTexture =  this.gl.createTexture();
            this.gl.bindTexture( this.gl.TEXTURE_CUBE_MAP, targetTexture);


            // define size and format of level 0
            const level = 0;
            const internalFormat = this.use8bit ? this.gl.RGBA8 : this.gl.RGBA32F;
            const border = 0;
            const format = this.gl.RGBA;
            const type = this.use8bit ? this.gl.UNSIGNED_BYTE : this.gl.FLOAT;
            const data = null;

            for(var i = 0; i < 6; ++i)
            {
                this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, level, internalFormat,
                    this.textureSize, this.textureSize, border,
                    format, type, data);

            }

            if(withMipmaps)
            {
                this.gl.texParameteri( this.gl.TEXTURE_CUBE_MAP,  this.gl.TEXTURE_MIN_FILTER,  this.gl.LINEAR_MIPMAP_LINEAR);
            }
            else
            {
                this.gl.texParameteri( this.gl.TEXTURE_CUBE_MAP,  this.gl.TEXTURE_MIN_FILTER,  this.gl.LINEAR);
            }

            this.gl.texParameteri( this.gl.TEXTURE_CUBE_MAP,  this.gl.TEXTURE_MAG_FILTER,  this.gl.LINEAR);
            this.gl.texParameteri( this.gl.TEXTURE_CUBE_MAP,  this.gl.TEXTURE_WRAP_S,  this.gl.CLAMP_TO_EDGE);
            this.gl.texParameteri( this.gl.TEXTURE_CUBE_MAP,  this.gl.TEXTURE_WRAP_T,  this.gl.CLAMP_TO_EDGE);

            return targetTexture;
        }

        createLutTexture()
        {
            const targetTexture = this.gl.createTexture();
            this.gl.bindTexture(this.gl.TEXTURE_2D, targetTexture);

            // define size and format of level 0
            const level = 0;
            const internalFormat = this.use8bit ? this.gl.RGBA8 : this.gl.RGBA32F;
            const border = 0;
            const format = this.gl.RGBA;
            const type = this.use8bit ? this.gl.UNSIGNED_BYTE : this.gl.FLOAT;
            const data = null;

            this.gl.texImage2D(this.gl.TEXTURE_2D, level, internalFormat,
                this.lutResolution, this.lutResolution, border,
                format, type, data);

            this.gl.texParameteri( this.gl.TEXTURE_2D,  this.gl.TEXTURE_MIN_FILTER,  this.gl.LINEAR);
            this.gl.texParameteri( this.gl.TEXTURE_2D,  this.gl.TEXTURE_MAG_FILTER,  this.gl.LINEAR);
            this.gl.texParameteri( this.gl.TEXTURE_2D,  this.gl.TEXTURE_WRAP_S,  this.gl.CLAMP_TO_EDGE);
            this.gl.texParameteri( this.gl.TEXTURE_2D,  this.gl.TEXTURE_WRAP_T,  this.gl.CLAMP_TO_EDGE);

            return targetTexture;
        }

        init(panoramaImage)
        {
            if (!this.gl.getExtension('EXT_color_buffer_float'))
            {
                this.use8bit = true;
            }

            this.inputTextureID = this.loadTextureHDR(panoramaImage);

            this.cubemapTextureID = this.createCubemapTexture(true);

            this.framebuffer = this.gl.createFramebuffer();

            this.lambertianTextureID = this.createCubemapTexture(false);
            this.ggxTextureID = this.createCubemapTexture(true);
            this.sheenTextureID = this.createCubemapTexture(true);


            this.gl.bindTexture(this.gl.TEXTURE_CUBE_MAP, this.ggxTextureID);
            this.gl.generateMipmap(this.gl.TEXTURE_CUBE_MAP);

            this.gl.bindTexture(this.gl.TEXTURE_CUBE_MAP, this.sheenTextureID);
            this.gl.generateMipmap(this.gl.TEXTURE_CUBE_MAP);

            this.mipmapLevels = Math.floor(Math.log2(this.textureSize))+1 - this.lowestMipLevel;
        }

        filterAll()
        {
            this.panoramaToCubeMap();
            this.cubeMapToLambertian();
            this.cubeMapToGGX();
            this.cubeMapToSheen();

            this.sampleGGXLut();
            this.sampleCharlieLut();

            this.gl.bindFramebuffer(  this.gl.FRAMEBUFFER, null);
        }

        panoramaToCubeMap()
        {
            for(var i = 0; i < 6; ++i)
            {
                this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.framebuffer);
                var side = i;
                this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_CUBE_MAP_POSITIVE_X+side, this.cubemapTextureID, 0);

                this.gl.bindTexture(this.gl.TEXTURE_CUBE_MAP, this.cubemapTextureID);

                this.gl.viewport(0, 0,  this.textureSize,  this.textureSize);

                this.gl.clearColor(1.0, 0.0, 0.0, 0.0);
                this.gl.clear(this.gl.COLOR_BUFFER_BIT| this.gl.DEPTH_BUFFER_BIT);

                const vertexHash = this.shaderCache.selectShader("fullscreen.vert", []);
                const fragmentHash = this.shaderCache.selectShader("panorama_to_cubemap.frag", []);

                var shader = this.shaderCache.getShaderProgram(fragmentHash, vertexHash);
                this.gl.useProgram(shader.program);

                //  TEXTURE0 = active.
                this.gl.activeTexture(this.gl.TEXTURE0+0);

                // Bind texture ID to active texture
                this.gl.bindTexture(this.gl.TEXTURE_2D, this.inputTextureID);

                // map shader uniform to texture unit (TEXTURE0)
                const location = this.gl.getUniformLocation(shader.program,"u_panorama");
                this.gl.uniform1i(location, 0); // texture unit 0 (TEXTURE0)

                shader.updateUniform("u_currentFace", i);

                //fullscreen triangle
                this.gl.drawArrays(this.gl.TRIANGLES, 0, 3);
            }

            this.gl.bindTexture(this.gl.TEXTURE_CUBE_MAP, this.cubemapTextureID);
            this.gl.generateMipmap(this.gl.TEXTURE_CUBE_MAP);

        }


        applyFilter(
            distribution,
            roughness,
            targetMipLevel,
            targetTexture,
            sampleCount,
            lodBias = 0.0)
        {
            var currentTextureSize =  this.textureSize>>(targetMipLevel);

            for(var i = 0; i < 6; ++i)
            {

                this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.framebuffer);
                var side = i;
                this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_CUBE_MAP_POSITIVE_X+side, targetTexture, targetMipLevel);

                this.gl.bindTexture(this.gl.TEXTURE_CUBE_MAP, targetTexture);

                this.gl.viewport(0, 0, currentTextureSize, currentTextureSize);

                this.gl.clearColor(1.0, 0.0, 0.0, 0.0);
                this.gl.clear(this.gl.COLOR_BUFFER_BIT| this.gl.DEPTH_BUFFER_BIT);


                const vertexHash = this.shaderCache.selectShader("fullscreen.vert", []);
                const fragmentHash = this.shaderCache.selectShader("ibl_filtering.frag", []);

                var shader = this.shaderCache.getShaderProgram(fragmentHash, vertexHash);
                this.gl.useProgram(shader.program);


                //  TEXTURE0 = active.
                this.gl.activeTexture(this.gl.TEXTURE0+0);

                // Bind texture ID to active texture
                this.gl.bindTexture(this.gl.TEXTURE_CUBE_MAP, this.cubemapTextureID);

                // map shader uniform to texture unit (TEXTURE0)
                const location = this.gl.getUniformLocation(shader.program,"u_cubemapTexture");
                this.gl.uniform1i(location, 0); // texture unit 0


                shader.updateUniform("u_roughness", roughness);
                shader.updateUniform("u_sampleCount", sampleCount);
                shader.updateUniform("u_width", this.textureSize);
                shader.updateUniform("u_lodBias", lodBias);
                shader.updateUniform("u_distribution", distribution);
                shader.updateUniform("u_currentFace", i);
                shader.updateUniform("u_isGeneratingLUT", 0);


                //fullscreen triangle
                this.gl.drawArrays(this.gl.TRIANGLES, 0, 3);

            }

        }

        cubeMapToLambertian()
        {
            this.applyFilter(
                0,
                0.0,
                0,
                this.lambertianTextureID,
                this.lambertianSampleCount);
        }


        cubeMapToGGX()
        {
            for(var currentMipLevel = 0; currentMipLevel <= this.mipmapLevels; ++currentMipLevel)
            {
                const roughness =  (currentMipLevel) /  (this.mipmapLevels - 1);
                this.applyFilter(
                    1,
                    roughness,
                    currentMipLevel,
                    this.ggxTextureID,
                    this.ggxSampleCount);
            }
        }

        cubeMapToSheen()
        {
            for(var currentMipLevel = 0; currentMipLevel <= this.mipmapLevels; ++currentMipLevel)
            {
                const roughness =  (currentMipLevel) /  (this.mipmapLevels - 1);
                this.applyFilter(
                    2,
                    roughness,
                    currentMipLevel,
                    this.sheenTextureID,
                    this.sheenSamplCount);
            }
        }

        sampleLut(distribution, targetTexture, currentTextureSize)
        {
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.framebuffer);
            this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, targetTexture, 0);

            this.gl.bindTexture(this.gl.TEXTURE_2D, targetTexture);

            this.gl.viewport(0, 0, currentTextureSize, currentTextureSize);

            this.gl.clearColor(1.0, 0.0, 0.0, 0.0);
            this.gl.clear(this.gl.COLOR_BUFFER_BIT| this.gl.DEPTH_BUFFER_BIT);


            const vertexHash = this.shaderCache.selectShader("fullscreen.vert", []);
            const fragmentHash = this.shaderCache.selectShader("ibl_filtering.frag", []);

            var shader = this.shaderCache.getShaderProgram(fragmentHash, vertexHash);
            this.gl.useProgram(shader.program);


            //  TEXTURE0 = active.
            this.gl.activeTexture(this.gl.TEXTURE0+0);

            // Bind texture ID to active texture
            this.gl.bindTexture(this.gl.TEXTURE_CUBE_MAP, this.cubemapTextureID);

            // map shader uniform to texture unit (TEXTURE0)
            const location = this.gl.getUniformLocation(shader.program,"u_cubemapTexture");
            this.gl.uniform1i(location, 0); // texture unit 0


            shader.updateUniform("u_roughness", 0.0);
            shader.updateUniform("u_sampleCount", 512);
            shader.updateUniform("u_width", 0.0);
            shader.updateUniform("u_lodBias", 0.0);
            shader.updateUniform("u_distribution", distribution);
            shader.updateUniform("u_currentFace", 0);
            shader.updateUniform("u_isGeneratingLUT", 1);

            //fullscreen triangle
            this.gl.drawArrays(this.gl.TRIANGLES, 0, 3);
        }

        sampleGGXLut()
        {
            this.ggxLutTextureID = this.createLutTexture();
            this.sampleLut(1, this.ggxLutTextureID, this.lutResolution);
        }

        sampleCharlieLut()
        {
            this.charlieLutTextureID = this.createLutTexture();
            this.sampleLut(2, this.charlieLutTextureID, this.lutResolution);
        }

        destroy()
        {
            this.shaderCache.destroy();
        }
    }

    class KtxDecoder {

        constructor (context, externalKtxlib) {
            this.gl = context;
            this.libktx = null;
            if (context !== undefined)
            {
                if (externalKtxlib === undefined && LIBKTX !== undefined)
                {
                    externalKtxlib = LIBKTX;
                }
                if (externalKtxlib !== undefined)
                {
                    this.initializied = this.init(context, externalKtxlib);
                }
                else
                {
                    console.error('Failed to initalize KTXDecoder: ktx library undefined');
                    return undefined;
                }
            }
            else
            {
                console.error('Failed to initalize KTXDecoder: WebGL context undefined');
                return undefined;
            }
        }

        async init(context, externalKtxlib) {
            this.libktx = await externalKtxlib({preinitializedWebGLContext: context});
            this.libktx.GL.makeContextCurrent(this.libktx.GL.createContext(null, { majorVersion: 2.0 }));
        }

        transcode(ktexture) {
            if (ktexture.needsTranscoding) {
                let format;

                let astcSupported = false;
                let etcSupported = false;
                let dxtSupported = false;
                let bptcSupported = false;
                let pvrtcSupported = false;

                astcSupported = !!this.gl.getExtension('WEBGL_compressed_texture_astc');
                etcSupported = !!this.gl.getExtension('WEBGL_compressed_texture_etc1');
                dxtSupported = !!this.gl.getExtension('WEBGL_compressed_texture_s3tc');
                bptcSupported = !!this.gl.getExtension('EXT_texture_compression_bptc');

                pvrtcSupported = !!(this.gl.getExtension('WEBGL_compressed_texture_pvrtc')) || !!(this.gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc'));

                if (astcSupported) {
                    format = this.libktx.TranscodeTarget.ASTC_4x4_RGBA;
                } else if (bptcSupported) {
                    format = this.libktx.TranscodeTarget.BC7_RGBA;
                } else if (dxtSupported) {
                    format = this.libktx.TranscodeTarget.BC1_OR_3;
                } else if (pvrtcSupported) {
                    format = this.libktx.TranscodeTarget.PVRTC1_4_RGBA;
                } else if (etcSupported) {
                    format = this.libktx.TranscodeTarget.ETC;
                } else {
                    format = this.libktx.TranscodeTarget.RGBA8888;
                }
                if (ktexture.transcodeBasis(format, 0) != this.libktx.ErrorCode.SUCCESS) {
                    console.warn('Texture transcode failed. See console for details.');
                }
            }
        }

        async loadKtxFromUri(uri) {
            await this.initializied;
            const response = await fetch(uri);
            const data = new Uint8Array(await response.arrayBuffer());
            const texture = new this.libktx.ktxTexture(data);
            this.transcode(texture);
            let uploadResult = texture.glUpload();
            if (uploadResult.texture == null)
            {
                console.error("Could not load KTX data");
                return undefined;
            }
            uploadResult.texture.levels = Math.log2(texture.baseWidth);
            return uploadResult.texture;
        }

        async loadKtxFromBuffer(data) {
            await this.initializied;
            const texture = new this.libktx.ktxTexture(data);
            this.transcode(texture);
            const uploadResult = texture.glUpload();
            if (uploadResult.texture == null)
            {
                console.error("Could not load KTX data");
                return undefined;
            }
            return uploadResult.texture;
        }
    }

    /**
     * hdrpng.js - Original code from Enki https://enkimute.github.io/hdrpng.js/
     *
     * Refactored and simplified.
     */

    function _rgbeToFloat(buffer)
    {
        const length = buffer.byteLength >> 2;
        const result = new Float32Array(length * 3);

        for (let i = 0; i < length; i++)
        {
            const s = Math.pow(2, buffer[i * 4 + 3] - (128 + 8));

            result[i * 3] = buffer[i * 4] * s;
            result[i * 3 + 1] = buffer[i * 4 + 1] * s;
            result[i * 3 + 2] = buffer[i * 4 + 2] * s;
        }
        return result;
    }

    async function loadHDR(buffer)
    {
        let header = '';
        let pos = 0;
        const d8 = buffer;
        let format = undefined;
        // read header.
        while (!header.match(/\n\n[^\n]+\n/g)) header += String.fromCharCode(d8[pos++]);
        // check format.
        format = header.match(/FORMAT=(.*)$/m);
        if (format.length < 2)
        {
            return undefined;
        }
        format = format[1];
        if (format != '32-bit_rle_rgbe') return console.warn('unknown format : ' + format), this.onerror();
        // parse resolution
        let rez = header.split(/\n/).reverse();
        if (rez.length < 2)
        {
            return undefined;
        }
        rez = rez[1].split(' ');
        if (rez.length < 4)
        {
            return undefined;
        }
        const width = rez[3] * 1, height = rez[1] * 1;
        // Create image.
        const img = new Uint8Array(width * height * 4);
        let ipos = 0;
        // Read all scanlines
        for (let j = 0; j < height; j++)
        {
            const scanline = [];

            let rgbe = d8.slice(pos, pos += 4);
            const isNewRLE = (rgbe[0] == 2 && rgbe[1] == 2 && rgbe[2] == ((width >> 8) & 0xFF) && rgbe[3] == (width & 0xFF));

            if (isNewRLE && (width >= 8) && (width < 32768))
            {
                for (let i = 0; i < 4; i++)
                {
                    let ptr = i * width;
                    const ptr_end = (i + 1) * width;
                    let buf = undefined;
                    let count = undefined;
                    while (ptr < ptr_end)
                    {
                        buf = d8.slice(pos, pos += 2);
                        if (buf[0] > 128)
                        {
                            count = buf[0] - 128;
                            while (count-- > 0) scanline[ptr++] = buf[1];
                        }
                        else
                        {
                            count = buf[0] - 1;
                            scanline[ptr++] = buf[1];
                            while (count-- > 0) scanline[ptr++] = d8[pos++];
                        }
                    }
                }

                for (let i = 0; i < width; i++)
                {
                    img[ipos++] = scanline[i + 0 * width];
                    img[ipos++] = scanline[i + 1 * width];
                    img[ipos++] = scanline[i + 2 * width];
                    img[ipos++] = scanline[i + 3 * width];
                }
            }
            else
            {
                pos -= 4;

                for (let i = 0; i < width; i++)
                {
                    rgbe = d8.slice(pos, pos += 4);

                    img[ipos++] = rgbe[0];
                    img[ipos++] = rgbe[1];
                    img[ipos++] = rgbe[2];
                    img[ipos++] = rgbe[3];
                }
            }
        }

        const imageFloatBuffer = _rgbeToFloat(img);

        return {
            dataFloat: imageFloatBuffer,
            width: width,
            height: height
        };
    }

    /**
     * ResourceLoader can be used to load resources for the GltfState
     * that are then used to display the loaded data with GltfView
     */
    class ResourceLoader
    {
        /**
         * ResourceLoader class that provides an interface to load resources into
         * the view. Typically this is created with GltfView.createResourceLoader()
         * You cannot share resource loaders between GltfViews as some of the resources
         * are allocated directly on the WebGl2 Context
         * @param {Object} view the GltfView for which the resources are loaded
         */
        constructor(view)
        {
            this.view = view;
        }

        /**
         * loadGltf asynchroneously and create resources for rendering
         * @param {(String | ArrayBuffer | File)} gltfFile the .gltf or .glb file either as path or as preloaded resource. In node.js environments, only ArrayBuffer types are accepted.
         * @param {File[]} [externalFiles] additional files containing resources that are referenced in the gltf
         * @returns {Promise} a promise that fulfills when the gltf file was loaded
         */
        async loadGltf(gltfFile, externalFiles)
        {
            let isGlb = undefined;
            let buffers = undefined;
            let json = undefined;
            let data = undefined;
            let filename = "";
            if (typeof gltfFile === "string")
            {
                isGlb = getIsGlb(gltfFile);
                let response = await axios$2.get(gltfFile, { responseType: isGlb ? "arraybuffer" : "json" });
                json = response.data;
                data = response.data;
                filename = gltfFile;
            }
            else if (gltfFile instanceof ArrayBuffer)
            {
                isGlb = externalFiles === undefined;
                if (isGlb)
                {
                    data = gltfFile;
                }
                else
                {
                    console.error("Only .glb files can be loaded from an array buffer");
                }
            }
            else if (typeof (File) !== 'undefined' && gltfFile instanceof File)
            {
                let fileContent = gltfFile;
                filename = gltfFile.name;
                isGlb = getIsGlb(filename);
                if (isGlb)
                {
                    data = await AsyncFileReader.readAsArrayBuffer(fileContent);
                }
                else
                {
                    data = await AsyncFileReader.readAsText(fileContent);
                    json = JSON.parse(data);
                    buffers = externalFiles;
                }
            }
            else
            {
                console.error("Passed invalid type to loadGltf " + typeof (gltfFile));
            }

            if (isGlb)
            {
                const glbParser = new GlbParser(data);
                const glb = glbParser.extractGlbData();
                json = glb.json;
                buffers = glb.buffers;
            }

            const gltf = new glTF(filename);
            gltf.ktxDecoder = this.view.ktxDecoder;
            //Make sure draco decoder instance is ready
            gltf.fromJson(json);

            // because the gltf image paths are not relative
            // to the gltf, we have to resolve all image paths before that
            for (const image of gltf.images)
            {
                image.resolveRelativePath(getContainingFolder(gltf.path));
            }

            await gltfLoader.load(gltf, this.view.context, buffers);

            return gltf;
        }

        /**
         * loadEnvironment asynchroneously, run IBL sampling and create resources for rendering
         * @param {(String | ArrayBuffer | File)} environmentFile the .hdr file either as path or resource
         * @param {Object} [lutFiles] object containing paths or resources for the environment look up textures. Keys are lut_ggx_file, lut_charlie_file and lut_sheen_E_file
         * @returns {Promise} a promise that fulfills when the environment file was loaded
         */
        async loadEnvironment(environmentFile, lutFiles)
        {
            let image = undefined;
            if (typeof environmentFile === "string")
            {
                let response = await axios$2.get(environmentFile, { responseType: "arraybuffer" });

                image = await loadHDR(new Uint8Array(response.data));
            }
            else if (environmentFile instanceof ArrayBuffer)
            {
                image = await loadHDR(new Uint8Array(environmentFile));
            }
            else if (typeof (File) !== 'undefined' && environmentFile instanceof File)
            {
                const imageData = await AsyncFileReader.readAsArrayBuffer(environmentFile).catch(() =>
                {
                    console.error("Could not load image with FileReader");
                });
                image = await loadHDR(new Uint8Array(imageData));
            }
            else
            {
                console.error("Passed invalid type to loadEnvironment " + typeof (gltfFile));
            }
            if (image === undefined)
            {
                return undefined;
            }
            return _loadEnvironmentFromPanorama(image, this.view, lutFiles);
        }

        /**
         * initKtxLib must be called before loading gltf files with ktx2 assets
         * @param {Object} [externalKtxLib] external ktx library (for example from a CDN)
         */
        initKtxLib(externalKtxLib)
        {
            this.view.ktxDecoder = new KtxDecoder(this.view.context, externalKtxLib);
        }

        /**
         * initDracoLib must be called before loading gltf files with draco meshes
         * @param {*} [externalDracoLib] external draco library (for example from a CDN)
         */
        async initDracoLib(externalDracoLib)
        {
            const dracoDecoder = new DracoDecoder(externalDracoLib);
            if (dracoDecoder !== undefined)
            {
                await dracoDecoder.ready();
            }
        }
    }

    async function _loadEnvironmentFromPanorama(imageHDR, view, luts)
    {
        // The environment uses the same type of samplers, textures and images as used in the glTF class
        // so we just use it as a template
        const environment = new glTF();

        //
        // Prepare samplers.
        //

        let samplerIdx = environment.samplers.length;

        environment.samplers.push(new gltfSampler(GL.LINEAR, GL.LINEAR, GL.CLAMP_TO_EDGE, GL.CLAMP_TO_EDGE, "DiffuseCubeMapSampler"));
        const diffuseCubeSamplerIdx = samplerIdx++;

        environment.samplers.push(new gltfSampler(GL.LINEAR, GL.LINEAR_MIPMAP_LINEAR, GL.CLAMP_TO_EDGE, GL.CLAMP_TO_EDGE, "SpecularCubeMapSampler"));
        const specularCubeSamplerIdx = samplerIdx++;

        environment.samplers.push(new gltfSampler(GL.LINEAR, GL.LINEAR_MIPMAP_LINEAR, GL.CLAMP_TO_EDGE, GL.CLAMP_TO_EDGE, "SheenCubeMapSampler"));
        const sheenCubeSamplerIdx = samplerIdx++;

        environment.samplers.push(new gltfSampler(GL.LINEAR, GL.LINEAR, GL.CLAMP_TO_EDGE, GL.CLAMP_TO_EDGE, "LUTSampler"));
        const lutSamplerIdx = samplerIdx++;

        //
        // Prepare images and textures.
        //

        let imageIdx = environment.images.length;

        let environmentFiltering = new iblSampler(view);

        environmentFiltering.init(imageHDR);
        environmentFiltering.filterAll();

        // Diffuse

        const diffuseGltfImage = new gltfImage(
            undefined,
            GL.TEXTURE_CUBE_MAP,
            0,
            undefined,
            "Diffuse",
            ImageMimeType.GLTEXTURE,
            environmentFiltering.lambertianTextureID
        );

        environment.images.push(diffuseGltfImage);

        const diffuseTexture = new gltfTexture(
            diffuseCubeSamplerIdx,
            [imageIdx++],
            GL.TEXTURE_CUBE_MAP);
        diffuseTexture.initialized = true; // iblsampler has already initialized the texture

        environment.textures.push(diffuseTexture);

        environment.diffuseEnvMap = new gltfTextureInfo(environment.textures.length - 1, 0, true);
        environment.diffuseEnvMap.generateMips = false;



        // Specular
        const specularGltfImage = new gltfImage(
            undefined,
            GL.TEXTURE_CUBE_MAP,
            0,
            undefined,
            "Specular",
            ImageMimeType.GLTEXTURE,
            environmentFiltering.ggxTextureID
        );

        environment.images.push(specularGltfImage);

        const specularTexture = new gltfTexture(
            specularCubeSamplerIdx,
            [imageIdx++],
            GL.TEXTURE_CUBE_MAP);
        specularTexture.initialized = true; // iblsampler has already initialized the texture

        environment.textures.push(specularTexture);

        environment.specularEnvMap = new gltfTextureInfo(environment.textures.length - 1, 0, true);
        environment.specularEnvMap.generateMips = false;


        // Sheen
        const sheenGltfImage = new gltfImage(
            undefined,
            GL.TEXTURE_CUBE_MAP,
            0,
            undefined,
            "Sheen",
            ImageMimeType.GLTEXTURE,
            environmentFiltering.sheenTextureID
        );

        environment.images.push(sheenGltfImage);

        const sheenTexture = new gltfTexture(
            sheenCubeSamplerIdx,
            [imageIdx++],
            GL.TEXTURE_CUBE_MAP);
        sheenTexture.initialized = true; // iblsampler has already initialized the texture

        environment.textures.push(sheenTexture);

        environment.sheenEnvMap = new gltfTextureInfo(environment.textures.length - 1, 0, true);
        environment.sheenEnvMap.generateMips = false;

        /*
            // Diffuse

            const lambertian = new gltfImage(filteredEnvironmentsDirectoryPath + "/lambertian/diffuse.ktx2", GL.TEXTURE_CUBE_MAP);
            lambertian.mimeType = ImageMimeType.KTX2;
            environment.images.push(lambertian);
            environment.textures.push(new gltfTexture(diffuseCubeSamplerIdx, [imageIdx++], GL.TEXTURE_CUBE_MAP));
            environment.diffuseEnvMap = new gltfTextureInfo(environment.textures.length - 1, 0, true);
            environment.diffuseEnvMap.generateMips = false;

            // Specular

            const specular = new gltfImage(filteredEnvironmentsDirectoryPath + "/ggx/specular.ktx2", GL.TEXTURE_CUBE_MAP);
            specular.mimeType = ImageMimeType.KTX2;
            environment.images.push(specular);
            environment.textures.push(new gltfTexture(specularCubeSamplerIdx, [imageIdx++], GL.TEXTURE_CUBE_MAP));
            environment.specularEnvMap = new gltfTextureInfo(environment.textures.length - 1, 0, true);
            environment.specularEnvMap.generateMips = false;

            const specularImage = environment.images[environment.textures[environment.textures.length - 1].source];

            // Sheen

            const sheen = new gltfImage(filteredEnvironmentsDirectoryPath + "/charlie/sheen.ktx2", GL.TEXTURE_CUBE_MAP);
            sheen.mimeType = ImageMimeType.KTX2;
            environment.images.push(sheen);
            environment.textures.push(new gltfTexture(sheenCubeSamplerIdx, [imageIdx++], GL.TEXTURE_CUBE_MAP));
            environment.sheenEnvMap = new gltfTextureInfo(environment.textures.length - 1, 0, true);
            environment.sheenEnvMap.generateMips = false;*/

        //
        // Look Up Tables.
        //

        // GGX

        if (luts === undefined)
        {
            luts = {
                lut_sheen_E_file: "assets/images/lut_sheen_E.png",
            };
        }

        environment.images.push(new gltfImage(
            undefined, 
            GL.TEXTURE_2D, 
            0, 
            undefined, 
            undefined, 
            ImageMimeType.GLTEXTURE, 
            environmentFiltering.ggxLutTextureID));
        const lutTexture = new gltfTexture(lutSamplerIdx, [imageIdx++], GL.TEXTURE_2D);
        lutTexture.initialized = true; // iblsampler has already initialized the texture
        environment.textures.push(lutTexture);

        environment.lut = new gltfTextureInfo(environment.textures.length - 1, 0 , true);
        environment.lut.generateMips = false;

        // Sheen
        // Charlie
        environment.images.push(new gltfImage(
            undefined, 
            GL.TEXTURE_2D, 
            0, 
            undefined, 
            undefined, 
            ImageMimeType.GLTEXTURE, 
            environmentFiltering.charlieLutTextureID));
        const charlieLut = new gltfTexture(lutSamplerIdx, [imageIdx++], GL.TEXTURE_2D);
        charlieLut.initialized = true; // iblsampler has already initialized the texture
        environment.textures.push(charlieLut);

        environment.sheenLUT = new gltfTextureInfo(environment.textures.length - 1, 0, true);
        environment.sheenLUT.generateMips = false;

        // Sheen E LUT

        environment.images.push(new gltfImage(luts.lut_sheen_E_file, GL.TEXTURE_2D, 0, undefined, undefined, ImageMimeType.PNG));
        const sheenELut = new gltfTexture(lutSamplerIdx, [imageIdx++], GL.TEXTURE_2D);
        sheenELut.initialized = true; // iblsampler has already initialized the texture
        environment.textures.push(sheenELut);

        environment.sheenELUT = new gltfTextureInfo(environment.textures.length - 1);
        environment.sheenELUT.generateMips = false;

        await gltfLoader.loadImages(environment);

        environment.initGl(view.context);

        environment.mipCount = environmentFiltering.mipmapLevels;

        return environment;
    }

    /**
     * GltfView represents a view on a gltf, e.g. in a canvas
     */
    class GltfView
    {
        /**
         * GltfView representing one WebGl 2.0 context or in other words one
         * 3D rendering of the Gltf.
         * You can create multiple views for example when multiple canvases should
         * be shown on the same webpage.
         * @param {*} context WebGl 2.0 context. Get it from a canvas with `canvas.getContext("webgl2")`
         */
        constructor(context)
        {
            this.context = context;
            this.renderer = new gltfRenderer(this.context);
        }

        /**
         * createState constructs a new GltfState for the GltfView. The resources
         * referenced in a gltf state can directly be stored as resources on the WebGL
         * context of GltfView, therefore GltfStates cannot not be shared between
         * GltfViews.
         * @returns {GltfState} GltfState
         */
        createState()
        {
            return new GltfState(this);
        }

        /**
         * createResourceLoader creates a resource loader with which glTFs and
         * environments can be loaded for the view
         * @param {Object} [externalDracoLib] optional object of an external Draco library, e.g. from a CDN
         * @param {Object} [externalKtxLib] optional object of an external KTX library, e.g. from a CDN
         * @returns {ResourceLoader} ResourceLoader
         */
        createResourceLoader(externalDracoLib = undefined, externalKtxLib = undefined)
        {
            let resourceLoader = new ResourceLoader(this);
            resourceLoader.initKtxLib(externalKtxLib);
            resourceLoader.initDracoLib(externalDracoLib);
            return resourceLoader;
        }

        /**
         * renderFrame to the context's default frame buffer
         * Call this function in the javascript animation update loop for continuous rendering to a canvas
         * @param {*} state GltfState that is be used for rendering
         * @param {*} width of the viewport
         * @param {*} height of the viewport
         */
        renderFrame(state, width, height)
        {
            this.renderer.init(state);
            this._animate(state);

            this.renderer.resize(width, height);

            this.renderer.clearFrame(state.renderingParameters.clearColor);

            if(state.gltf === undefined)
            {
                return;
            }

            const scene = state.gltf.scenes[state.sceneIndex];

            if(scene === undefined)
            {
                return;
            }

            scene.applyTransformHierarchy(state.gltf);

            this.renderer.drawScene(state, scene);
        }

        /**
         * gatherStatistics collects information about the GltfState such as the number of
         * rendered meshes or triangles
         * @param {*} state GltfState about which the statistics should be collected
         * @returns {Object} an object containing statistics information
         */
        gatherStatistics(state)
        {
            if(state.gltf === undefined)
            {
                return;
            }

            // gather information from the active scene
            const scene = state.gltf.scenes[state.sceneIndex];
            if (scene === undefined)
            {
                return {
                    meshCount: 0,
                    faceCount: 0,
                    opaqueMaterialsCount: 0,
                    transparentMaterialsCount: 0};
            }
            const nodes = scene.gatherNodes(state.gltf);
            const activeMeshes = nodes.filter(node => node.mesh !== undefined).map(node => state.gltf.meshes[node.mesh]);
            const activePrimitives = activeMeshes
                .reduce((acc, mesh) => acc.concat(mesh.primitives), [])
                .filter(primitive => primitive.material !== undefined);
            const activeMaterials = [... new Set(activePrimitives.map(primitive => state.gltf.materials[primitive.material]))];
            const opaqueMaterials = activeMaterials.filter(material => material.alphaMode !== "BLEND");
            const transparentMaterials = activeMaterials.filter(material => material.alphaMode === "BLEND");
            const faceCount = activePrimitives
                .map(primitive => {
                    let verticesCount = 0;
                    if(primitive.indices !== undefined)
                    {
                        verticesCount = state.gltf.accessors[primitive.indices].count;
                    }
                    if (verticesCount === 0)
                    {
                        return 0;
                    }

                    // convert vertex count to point, line or triangle count
                    switch (primitive.mode) {
                    case GL.POINTS:
                        return verticesCount;
                    case GL.LINES:
                        return verticesCount / 2;
                    case GL.LINE_LOOP:
                        return verticesCount;
                    case GL.LINE_STRIP:
                        return verticesCount - 1;
                    case GL.TRIANGLES:
                        return verticesCount / 3;
                    case GL.TRIANGLE_STRIP:
                    case GL.TRIANGLE_FAN:
                        return verticesCount - 2;
                    }
                })
                .reduce((acc, faceCount) => acc += faceCount);

            // assemble statistics object
            return {
                meshCount: activeMeshes.length,
                faceCount: faceCount,
                opaqueMaterialsCount: opaqueMaterials.length,
                transparentMaterialsCount: transparentMaterials.length
            };
        }

        _animate(state)
        {
            if(state.gltf === undefined)
            {
                return;
            }

            if(state.gltf.animations !== undefined && state.animationIndices !== undefined)
            {
                const disabledAnimations = state.gltf.animations.filter( (anim, index) => {
                    return false === state.animationIndices.includes(index);
                });

                for(const disabledAnimation of disabledAnimations)
                {
                    disabledAnimation.advance(state.gltf, undefined);
                }

                const t = state.animationTimer.elapsedSec();

                const animations = state.animationIndices.map(index => {
                    return state.gltf.animations[index];
                }).filter(animation => animation !== undefined);

                for(const animation of animations)
                {
                    animation.advance(state.gltf, t);
                }
            }
        }
    }

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    function isFunction(x) {
        return typeof x === 'function';
    }

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    var _enable_super_gross_mode_that_will_cause_bad_things = false;
    var config = {
        Promise: undefined,
        set useDeprecatedSynchronousErrorHandling(value) {
            if (value) {
                var error = /*@__PURE__*/ new Error();
                /*@__PURE__*/ console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack);
            }
            _enable_super_gross_mode_that_will_cause_bad_things = value;
        },
        get useDeprecatedSynchronousErrorHandling() {
            return _enable_super_gross_mode_that_will_cause_bad_things;
        },
    };

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    function hostReportError(err) {
        setTimeout(function () { throw err; }, 0);
    }

    /** PURE_IMPORTS_START _config,_util_hostReportError PURE_IMPORTS_END */
    var empty = {
        closed: true,
        next: function (value) { },
        error: function (err) {
            if (config.useDeprecatedSynchronousErrorHandling) {
                throw err;
            }
            else {
                hostReportError(err);
            }
        },
        complete: function () { }
    };

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    var isArray = /*@__PURE__*/ (function () { return Array.isArray || (function (x) { return x && typeof x.length === 'number'; }); })();

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    function isObject(x) {
        return x !== null && typeof x === 'object';
    }

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    var UnsubscriptionErrorImpl = /*@__PURE__*/ (function () {
        function UnsubscriptionErrorImpl(errors) {
            Error.call(this);
            this.message = errors ?
                errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ') : '';
            this.name = 'UnsubscriptionError';
            this.errors = errors;
            return this;
        }
        UnsubscriptionErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
        return UnsubscriptionErrorImpl;
    })();
    var UnsubscriptionError = UnsubscriptionErrorImpl;

    /** PURE_IMPORTS_START _util_isArray,_util_isObject,_util_isFunction,_util_UnsubscriptionError PURE_IMPORTS_END */
    var Subscription = /*@__PURE__*/ (function () {
        function Subscription(unsubscribe) {
            this.closed = false;
            this._parentOrParents = null;
            this._subscriptions = null;
            if (unsubscribe) {
                this._ctorUnsubscribe = true;
                this._unsubscribe = unsubscribe;
            }
        }
        Subscription.prototype.unsubscribe = function () {
            var errors;
            if (this.closed) {
                return;
            }
            var _a = this, _parentOrParents = _a._parentOrParents, _ctorUnsubscribe = _a._ctorUnsubscribe, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
            this.closed = true;
            this._parentOrParents = null;
            this._subscriptions = null;
            if (_parentOrParents instanceof Subscription) {
                _parentOrParents.remove(this);
            }
            else if (_parentOrParents !== null) {
                for (var index = 0; index < _parentOrParents.length; ++index) {
                    var parent_1 = _parentOrParents[index];
                    parent_1.remove(this);
                }
            }
            if (isFunction(_unsubscribe)) {
                if (_ctorUnsubscribe) {
                    this._unsubscribe = undefined;
                }
                try {
                    _unsubscribe.call(this);
                }
                catch (e) {
                    errors = e instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];
                }
            }
            if (isArray(_subscriptions)) {
                var index = -1;
                var len = _subscriptions.length;
                while (++index < len) {
                    var sub = _subscriptions[index];
                    if (isObject(sub)) {
                        try {
                            sub.unsubscribe();
                        }
                        catch (e) {
                            errors = errors || [];
                            if (e instanceof UnsubscriptionError) {
                                errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
                            }
                            else {
                                errors.push(e);
                            }
                        }
                    }
                }
            }
            if (errors) {
                throw new UnsubscriptionError(errors);
            }
        };
        Subscription.prototype.add = function (teardown) {
            var subscription = teardown;
            if (!teardown) {
                return Subscription.EMPTY;
            }
            switch (typeof teardown) {
                case 'function':
                    subscription = new Subscription(teardown);
                case 'object':
                    if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== 'function') {
                        return subscription;
                    }
                    else if (this.closed) {
                        subscription.unsubscribe();
                        return subscription;
                    }
                    else if (!(subscription instanceof Subscription)) {
                        var tmp = subscription;
                        subscription = new Subscription();
                        subscription._subscriptions = [tmp];
                    }
                    break;
                default: {
                    throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
                }
            }
            var _parentOrParents = subscription._parentOrParents;
            if (_parentOrParents === null) {
                subscription._parentOrParents = this;
            }
            else if (_parentOrParents instanceof Subscription) {
                if (_parentOrParents === this) {
                    return subscription;
                }
                subscription._parentOrParents = [_parentOrParents, this];
            }
            else if (_parentOrParents.indexOf(this) === -1) {
                _parentOrParents.push(this);
            }
            else {
                return subscription;
            }
            var subscriptions = this._subscriptions;
            if (subscriptions === null) {
                this._subscriptions = [subscription];
            }
            else {
                subscriptions.push(subscription);
            }
            return subscription;
        };
        Subscription.prototype.remove = function (subscription) {
            var subscriptions = this._subscriptions;
            if (subscriptions) {
                var subscriptionIndex = subscriptions.indexOf(subscription);
                if (subscriptionIndex !== -1) {
                    subscriptions.splice(subscriptionIndex, 1);
                }
            }
        };
        Subscription.EMPTY = (function (empty) {
            empty.closed = true;
            return empty;
        }(new Subscription()));
        return Subscription;
    }());
    function flattenUnsubscriptionErrors(errors) {
        return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError) ? err.errors : err); }, []);
    }

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    var rxSubscriber = /*@__PURE__*/ (function () {
        return typeof Symbol === 'function'
            ? /*@__PURE__*/ Symbol('rxSubscriber')
            : '@@rxSubscriber_' + /*@__PURE__*/ Math.random();
    })();

    /** PURE_IMPORTS_START tslib,_util_isFunction,_Observer,_Subscription,_internal_symbol_rxSubscriber,_config,_util_hostReportError PURE_IMPORTS_END */
    var Subscriber = /*@__PURE__*/ (function (_super) {
        __extends(Subscriber, _super);
        function Subscriber(destinationOrNext, error, complete) {
            var _this = _super.call(this) || this;
            _this.syncErrorValue = null;
            _this.syncErrorThrown = false;
            _this.syncErrorThrowable = false;
            _this.isStopped = false;
            switch (arguments.length) {
                case 0:
                    _this.destination = empty;
                    break;
                case 1:
                    if (!destinationOrNext) {
                        _this.destination = empty;
                        break;
                    }
                    if (typeof destinationOrNext === 'object') {
                        if (destinationOrNext instanceof Subscriber) {
                            _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
                            _this.destination = destinationOrNext;
                            destinationOrNext.add(_this);
                        }
                        else {
                            _this.syncErrorThrowable = true;
                            _this.destination = new SafeSubscriber(_this, destinationOrNext);
                        }
                        break;
                    }
                default:
                    _this.syncErrorThrowable = true;
                    _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
                    break;
            }
            return _this;
        }
        Subscriber.prototype[rxSubscriber] = function () { return this; };
        Subscriber.create = function (next, error, complete) {
            var subscriber = new Subscriber(next, error, complete);
            subscriber.syncErrorThrowable = false;
            return subscriber;
        };
        Subscriber.prototype.next = function (value) {
            if (!this.isStopped) {
                this._next(value);
            }
        };
        Subscriber.prototype.error = function (err) {
            if (!this.isStopped) {
                this.isStopped = true;
                this._error(err);
            }
        };
        Subscriber.prototype.complete = function () {
            if (!this.isStopped) {
                this.isStopped = true;
                this._complete();
            }
        };
        Subscriber.prototype.unsubscribe = function () {
            if (this.closed) {
                return;
            }
            this.isStopped = true;
            _super.prototype.unsubscribe.call(this);
        };
        Subscriber.prototype._next = function (value) {
            this.destination.next(value);
        };
        Subscriber.prototype._error = function (err) {
            this.destination.error(err);
            this.unsubscribe();
        };
        Subscriber.prototype._complete = function () {
            this.destination.complete();
            this.unsubscribe();
        };
        Subscriber.prototype._unsubscribeAndRecycle = function () {
            var _parentOrParents = this._parentOrParents;
            this._parentOrParents = null;
            this.unsubscribe();
            this.closed = false;
            this.isStopped = false;
            this._parentOrParents = _parentOrParents;
            return this;
        };
        return Subscriber;
    }(Subscription));
    var SafeSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(SafeSubscriber, _super);
        function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
            var _this = _super.call(this) || this;
            _this._parentSubscriber = _parentSubscriber;
            var next;
            var context = _this;
            if (isFunction(observerOrNext)) {
                next = observerOrNext;
            }
            else if (observerOrNext) {
                next = observerOrNext.next;
                error = observerOrNext.error;
                complete = observerOrNext.complete;
                if (observerOrNext !== empty) {
                    context = Object.create(observerOrNext);
                    if (isFunction(context.unsubscribe)) {
                        _this.add(context.unsubscribe.bind(context));
                    }
                    context.unsubscribe = _this.unsubscribe.bind(_this);
                }
            }
            _this._context = context;
            _this._next = next;
            _this._error = error;
            _this._complete = complete;
            return _this;
        }
        SafeSubscriber.prototype.next = function (value) {
            if (!this.isStopped && this._next) {
                var _parentSubscriber = this._parentSubscriber;
                if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._next, value);
                }
                else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                    this.unsubscribe();
                }
            }
        };
        SafeSubscriber.prototype.error = function (err) {
            if (!this.isStopped) {
                var _parentSubscriber = this._parentSubscriber;
                var useDeprecatedSynchronousErrorHandling = config.useDeprecatedSynchronousErrorHandling;
                if (this._error) {
                    if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                        this.__tryOrUnsub(this._error, err);
                        this.unsubscribe();
                    }
                    else {
                        this.__tryOrSetError(_parentSubscriber, this._error, err);
                        this.unsubscribe();
                    }
                }
                else if (!_parentSubscriber.syncErrorThrowable) {
                    this.unsubscribe();
                    if (useDeprecatedSynchronousErrorHandling) {
                        throw err;
                    }
                    hostReportError(err);
                }
                else {
                    if (useDeprecatedSynchronousErrorHandling) {
                        _parentSubscriber.syncErrorValue = err;
                        _parentSubscriber.syncErrorThrown = true;
                    }
                    else {
                        hostReportError(err);
                    }
                    this.unsubscribe();
                }
            }
        };
        SafeSubscriber.prototype.complete = function () {
            var _this = this;
            if (!this.isStopped) {
                var _parentSubscriber = this._parentSubscriber;
                if (this._complete) {
                    var wrappedComplete = function () { return _this._complete.call(_this._context); };
                    if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                        this.__tryOrUnsub(wrappedComplete);
                        this.unsubscribe();
                    }
                    else {
                        this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                        this.unsubscribe();
                    }
                }
                else {
                    this.unsubscribe();
                }
            }
        };
        SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
            try {
                fn.call(this._context, value);
            }
            catch (err) {
                this.unsubscribe();
                if (config.useDeprecatedSynchronousErrorHandling) {
                    throw err;
                }
                else {
                    hostReportError(err);
                }
            }
        };
        SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
            if (!config.useDeprecatedSynchronousErrorHandling) {
                throw new Error('bad call');
            }
            try {
                fn.call(this._context, value);
            }
            catch (err) {
                if (config.useDeprecatedSynchronousErrorHandling) {
                    parent.syncErrorValue = err;
                    parent.syncErrorThrown = true;
                    return true;
                }
                else {
                    hostReportError(err);
                    return true;
                }
            }
            return false;
        };
        SafeSubscriber.prototype._unsubscribe = function () {
            var _parentSubscriber = this._parentSubscriber;
            this._context = null;
            this._parentSubscriber = null;
            _parentSubscriber.unsubscribe();
        };
        return SafeSubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START _Subscriber PURE_IMPORTS_END */
    function canReportError(observer) {
        while (observer) {
            var _a = observer, closed_1 = _a.closed, destination = _a.destination, isStopped = _a.isStopped;
            if (closed_1 || isStopped) {
                return false;
            }
            else if (destination && destination instanceof Subscriber) {
                observer = destination;
            }
            else {
                observer = null;
            }
        }
        return true;
    }

    /** PURE_IMPORTS_START _Subscriber,_symbol_rxSubscriber,_Observer PURE_IMPORTS_END */
    function toSubscriber(nextOrObserver, error, complete) {
        if (nextOrObserver) {
            if (nextOrObserver instanceof Subscriber) {
                return nextOrObserver;
            }
            if (nextOrObserver[rxSubscriber]) {
                return nextOrObserver[rxSubscriber]();
            }
        }
        if (!nextOrObserver && !error && !complete) {
            return new Subscriber(empty);
        }
        return new Subscriber(nextOrObserver, error, complete);
    }

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    var observable = /*@__PURE__*/ (function () { return typeof Symbol === 'function' && Symbol.observable || '@@observable'; })();

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    function identity(x) {
        return x;
    }

    /** PURE_IMPORTS_START _identity PURE_IMPORTS_END */
    function pipeFromArray(fns) {
        if (fns.length === 0) {
            return identity;
        }
        if (fns.length === 1) {
            return fns[0];
        }
        return function piped(input) {
            return fns.reduce(function (prev, fn) { return fn(prev); }, input);
        };
    }

    /** PURE_IMPORTS_START _util_canReportError,_util_toSubscriber,_symbol_observable,_util_pipe,_config PURE_IMPORTS_END */
    var Observable = /*@__PURE__*/ (function () {
        function Observable(subscribe) {
            this._isScalar = false;
            if (subscribe) {
                this._subscribe = subscribe;
            }
        }
        Observable.prototype.lift = function (operator) {
            var observable = new Observable();
            observable.source = this;
            observable.operator = operator;
            return observable;
        };
        Observable.prototype.subscribe = function (observerOrNext, error, complete) {
            var operator = this.operator;
            var sink = toSubscriber(observerOrNext, error, complete);
            if (operator) {
                sink.add(operator.call(sink, this.source));
            }
            else {
                sink.add(this.source || (config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable) ?
                    this._subscribe(sink) :
                    this._trySubscribe(sink));
            }
            if (config.useDeprecatedSynchronousErrorHandling) {
                if (sink.syncErrorThrowable) {
                    sink.syncErrorThrowable = false;
                    if (sink.syncErrorThrown) {
                        throw sink.syncErrorValue;
                    }
                }
            }
            return sink;
        };
        Observable.prototype._trySubscribe = function (sink) {
            try {
                return this._subscribe(sink);
            }
            catch (err) {
                if (config.useDeprecatedSynchronousErrorHandling) {
                    sink.syncErrorThrown = true;
                    sink.syncErrorValue = err;
                }
                if (canReportError(sink)) {
                    sink.error(err);
                }
                else {
                    console.warn(err);
                }
            }
        };
        Observable.prototype.forEach = function (next, promiseCtor) {
            var _this = this;
            promiseCtor = getPromiseCtor(promiseCtor);
            return new promiseCtor(function (resolve, reject) {
                var subscription;
                subscription = _this.subscribe(function (value) {
                    try {
                        next(value);
                    }
                    catch (err) {
                        reject(err);
                        if (subscription) {
                            subscription.unsubscribe();
                        }
                    }
                }, reject, resolve);
            });
        };
        Observable.prototype._subscribe = function (subscriber) {
            var source = this.source;
            return source && source.subscribe(subscriber);
        };
        Observable.prototype[observable] = function () {
            return this;
        };
        Observable.prototype.pipe = function () {
            var operations = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                operations[_i] = arguments[_i];
            }
            if (operations.length === 0) {
                return this;
            }
            return pipeFromArray(operations)(this);
        };
        Observable.prototype.toPromise = function (promiseCtor) {
            var _this = this;
            promiseCtor = getPromiseCtor(promiseCtor);
            return new promiseCtor(function (resolve, reject) {
                var value;
                _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
            });
        };
        Observable.create = function (subscribe) {
            return new Observable(subscribe);
        };
        return Observable;
    }());
    function getPromiseCtor(promiseCtor) {
        if (!promiseCtor) {
            promiseCtor =  Promise;
        }
        if (!promiseCtor) {
            throw new Error('no Promise impl found');
        }
        return promiseCtor;
    }

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    var ObjectUnsubscribedErrorImpl = /*@__PURE__*/ (function () {
        function ObjectUnsubscribedErrorImpl() {
            Error.call(this);
            this.message = 'object unsubscribed';
            this.name = 'ObjectUnsubscribedError';
            return this;
        }
        ObjectUnsubscribedErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
        return ObjectUnsubscribedErrorImpl;
    })();
    var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;

    /** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */
    var SubjectSubscription = /*@__PURE__*/ (function (_super) {
        __extends(SubjectSubscription, _super);
        function SubjectSubscription(subject, subscriber) {
            var _this = _super.call(this) || this;
            _this.subject = subject;
            _this.subscriber = subscriber;
            _this.closed = false;
            return _this;
        }
        SubjectSubscription.prototype.unsubscribe = function () {
            if (this.closed) {
                return;
            }
            this.closed = true;
            var subject = this.subject;
            var observers = subject.observers;
            this.subject = null;
            if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
                return;
            }
            var subscriberIndex = observers.indexOf(this.subscriber);
            if (subscriberIndex !== -1) {
                observers.splice(subscriberIndex, 1);
            }
        };
        return SubjectSubscription;
    }(Subscription));

    /** PURE_IMPORTS_START tslib,_Observable,_Subscriber,_Subscription,_util_ObjectUnsubscribedError,_SubjectSubscription,_internal_symbol_rxSubscriber PURE_IMPORTS_END */
    var SubjectSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(SubjectSubscriber, _super);
        function SubjectSubscriber(destination) {
            var _this = _super.call(this, destination) || this;
            _this.destination = destination;
            return _this;
        }
        return SubjectSubscriber;
    }(Subscriber));
    var Subject = /*@__PURE__*/ (function (_super) {
        __extends(Subject, _super);
        function Subject() {
            var _this = _super.call(this) || this;
            _this.observers = [];
            _this.closed = false;
            _this.isStopped = false;
            _this.hasError = false;
            _this.thrownError = null;
            return _this;
        }
        Subject.prototype[rxSubscriber] = function () {
            return new SubjectSubscriber(this);
        };
        Subject.prototype.lift = function (operator) {
            var subject = new AnonymousSubject(this, this);
            subject.operator = operator;
            return subject;
        };
        Subject.prototype.next = function (value) {
            if (this.closed) {
                throw new ObjectUnsubscribedError();
            }
            if (!this.isStopped) {
                var observers = this.observers;
                var len = observers.length;
                var copy = observers.slice();
                for (var i = 0; i < len; i++) {
                    copy[i].next(value);
                }
            }
        };
        Subject.prototype.error = function (err) {
            if (this.closed) {
                throw new ObjectUnsubscribedError();
            }
            this.hasError = true;
            this.thrownError = err;
            this.isStopped = true;
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].error(err);
            }
            this.observers.length = 0;
        };
        Subject.prototype.complete = function () {
            if (this.closed) {
                throw new ObjectUnsubscribedError();
            }
            this.isStopped = true;
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].complete();
            }
            this.observers.length = 0;
        };
        Subject.prototype.unsubscribe = function () {
            this.isStopped = true;
            this.closed = true;
            this.observers = null;
        };
        Subject.prototype._trySubscribe = function (subscriber) {
            if (this.closed) {
                throw new ObjectUnsubscribedError();
            }
            else {
                return _super.prototype._trySubscribe.call(this, subscriber);
            }
        };
        Subject.prototype._subscribe = function (subscriber) {
            if (this.closed) {
                throw new ObjectUnsubscribedError();
            }
            else if (this.hasError) {
                subscriber.error(this.thrownError);
                return Subscription.EMPTY;
            }
            else if (this.isStopped) {
                subscriber.complete();
                return Subscription.EMPTY;
            }
            else {
                this.observers.push(subscriber);
                return new SubjectSubscription(this, subscriber);
            }
        };
        Subject.prototype.asObservable = function () {
            var observable = new Observable();
            observable.source = this;
            return observable;
        };
        Subject.create = function (destination, source) {
            return new AnonymousSubject(destination, source);
        };
        return Subject;
    }(Observable));
    var AnonymousSubject = /*@__PURE__*/ (function (_super) {
        __extends(AnonymousSubject, _super);
        function AnonymousSubject(destination, source) {
            var _this = _super.call(this) || this;
            _this.destination = destination;
            _this.source = source;
            return _this;
        }
        AnonymousSubject.prototype.next = function (value) {
            var destination = this.destination;
            if (destination && destination.next) {
                destination.next(value);
            }
        };
        AnonymousSubject.prototype.error = function (err) {
            var destination = this.destination;
            if (destination && destination.error) {
                this.destination.error(err);
            }
        };
        AnonymousSubject.prototype.complete = function () {
            var destination = this.destination;
            if (destination && destination.complete) {
                this.destination.complete();
            }
        };
        AnonymousSubject.prototype._subscribe = function (subscriber) {
            var source = this.source;
            if (source) {
                return this.source.subscribe(subscriber);
            }
            else {
                return Subscription.EMPTY;
            }
        };
        return AnonymousSubject;
    }(Subject));

    /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
    function refCount() {
        return function refCountOperatorFunction(source) {
            return source.lift(new RefCountOperator(source));
        };
    }
    var RefCountOperator = /*@__PURE__*/ (function () {
        function RefCountOperator(connectable) {
            this.connectable = connectable;
        }
        RefCountOperator.prototype.call = function (subscriber, source) {
            var connectable = this.connectable;
            connectable._refCount++;
            var refCounter = new RefCountSubscriber(subscriber, connectable);
            var subscription = source.subscribe(refCounter);
            if (!refCounter.closed) {
                refCounter.connection = connectable.connect();
            }
            return subscription;
        };
        return RefCountOperator;
    }());
    var RefCountSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(RefCountSubscriber, _super);
        function RefCountSubscriber(destination, connectable) {
            var _this = _super.call(this, destination) || this;
            _this.connectable = connectable;
            return _this;
        }
        RefCountSubscriber.prototype._unsubscribe = function () {
            var connectable = this.connectable;
            if (!connectable) {
                this.connection = null;
                return;
            }
            this.connectable = null;
            var refCount = connectable._refCount;
            if (refCount <= 0) {
                this.connection = null;
                return;
            }
            connectable._refCount = refCount - 1;
            if (refCount > 1) {
                this.connection = null;
                return;
            }
            var connection = this.connection;
            var sharedConnection = connectable._connection;
            this.connection = null;
            if (sharedConnection && (!connection || sharedConnection === connection)) {
                sharedConnection.unsubscribe();
            }
        };
        return RefCountSubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START tslib,_Subject,_Observable,_Subscriber,_Subscription,_operators_refCount PURE_IMPORTS_END */
    var ConnectableObservable = /*@__PURE__*/ (function (_super) {
        __extends(ConnectableObservable, _super);
        function ConnectableObservable(source, subjectFactory) {
            var _this = _super.call(this) || this;
            _this.source = source;
            _this.subjectFactory = subjectFactory;
            _this._refCount = 0;
            _this._isComplete = false;
            return _this;
        }
        ConnectableObservable.prototype._subscribe = function (subscriber) {
            return this.getSubject().subscribe(subscriber);
        };
        ConnectableObservable.prototype.getSubject = function () {
            var subject = this._subject;
            if (!subject || subject.isStopped) {
                this._subject = this.subjectFactory();
            }
            return this._subject;
        };
        ConnectableObservable.prototype.connect = function () {
            var connection = this._connection;
            if (!connection) {
                this._isComplete = false;
                connection = this._connection = new Subscription();
                connection.add(this.source
                    .subscribe(new ConnectableSubscriber(this.getSubject(), this)));
                if (connection.closed) {
                    this._connection = null;
                    connection = Subscription.EMPTY;
                }
            }
            return connection;
        };
        ConnectableObservable.prototype.refCount = function () {
            return refCount()(this);
        };
        return ConnectableObservable;
    }(Observable));
    var connectableObservableDescriptor = /*@__PURE__*/ (function () {
        var connectableProto = ConnectableObservable.prototype;
        return {
            operator: { value: null },
            _refCount: { value: 0, writable: true },
            _subject: { value: null, writable: true },
            _connection: { value: null, writable: true },
            _subscribe: { value: connectableProto._subscribe },
            _isComplete: { value: connectableProto._isComplete, writable: true },
            getSubject: { value: connectableProto.getSubject },
            connect: { value: connectableProto.connect },
            refCount: { value: connectableProto.refCount }
        };
    })();
    var ConnectableSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(ConnectableSubscriber, _super);
        function ConnectableSubscriber(destination, connectable) {
            var _this = _super.call(this, destination) || this;
            _this.connectable = connectable;
            return _this;
        }
        ConnectableSubscriber.prototype._error = function (err) {
            this._unsubscribe();
            _super.prototype._error.call(this, err);
        };
        ConnectableSubscriber.prototype._complete = function () {
            this.connectable._isComplete = true;
            this._unsubscribe();
            _super.prototype._complete.call(this);
        };
        ConnectableSubscriber.prototype._unsubscribe = function () {
            var connectable = this.connectable;
            if (connectable) {
                this.connectable = null;
                var connection = connectable._connection;
                connectable._refCount = 0;
                connectable._subject = null;
                connectable._connection = null;
                if (connection) {
                    connection.unsubscribe();
                }
            }
        };
        return ConnectableSubscriber;
    }(SubjectSubscriber));

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    function isScheduler(value) {
        return value && typeof value.schedule === 'function';
    }

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    var subscribeToArray = function (array) {
        return function (subscriber) {
            for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {
                subscriber.next(array[i]);
            }
            subscriber.complete();
        };
    };

    /** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */
    function scheduleArray(input, scheduler) {
        return new Observable(function (subscriber) {
            var sub = new Subscription();
            var i = 0;
            sub.add(scheduler.schedule(function () {
                if (i === input.length) {
                    subscriber.complete();
                    return;
                }
                subscriber.next(input[i++]);
                if (!subscriber.closed) {
                    sub.add(this.schedule());
                }
            }));
            return sub;
        });
    }

    /** PURE_IMPORTS_START _Observable,_util_subscribeToArray,_scheduled_scheduleArray PURE_IMPORTS_END */
    function fromArray(input, scheduler) {
        if (!scheduler) {
            return new Observable(subscribeToArray(input));
        }
        else {
            return scheduleArray(input, scheduler);
        }
    }

    /** PURE_IMPORTS_START _util_isScheduler,_fromArray,_scheduled_scheduleArray PURE_IMPORTS_END */
    function of() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var scheduler = args[args.length - 1];
        if (isScheduler(scheduler)) {
            args.pop();
            return scheduleArray(args, scheduler);
        }
        else {
            return fromArray(args);
        }
    }

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    function noop() { }

    /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
    function map(project, thisArg) {
        return function mapOperation(source) {
            if (typeof project !== 'function') {
                throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
            }
            return source.lift(new MapOperator(project, thisArg));
        };
    }
    var MapOperator = /*@__PURE__*/ (function () {
        function MapOperator(project, thisArg) {
            this.project = project;
            this.thisArg = thisArg;
        }
        MapOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
        };
        return MapOperator;
    }());
    var MapSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(MapSubscriber, _super);
        function MapSubscriber(destination, project, thisArg) {
            var _this = _super.call(this, destination) || this;
            _this.project = project;
            _this.count = 0;
            _this.thisArg = thisArg || _this;
            return _this;
        }
        MapSubscriber.prototype._next = function (value) {
            var result;
            try {
                result = this.project.call(this.thisArg, value, this.count++);
            }
            catch (err) {
                this.destination.error(err);
                return;
            }
            this.destination.next(result);
        };
        return MapSubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START _hostReportError PURE_IMPORTS_END */
    var subscribeToPromise = function (promise) {
        return function (subscriber) {
            promise.then(function (value) {
                if (!subscriber.closed) {
                    subscriber.next(value);
                    subscriber.complete();
                }
            }, function (err) { return subscriber.error(err); })
                .then(null, hostReportError);
            return subscriber;
        };
    };

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    function getSymbolIterator() {
        if (typeof Symbol !== 'function' || !Symbol.iterator) {
            return '@@iterator';
        }
        return Symbol.iterator;
    }
    var iterator = /*@__PURE__*/ getSymbolIterator();

    /** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */
    var subscribeToIterable = function (iterable) {
        return function (subscriber) {
            var iterator$1 = iterable[iterator]();
            do {
                var item = void 0;
                try {
                    item = iterator$1.next();
                }
                catch (err) {
                    subscriber.error(err);
                    return subscriber;
                }
                if (item.done) {
                    subscriber.complete();
                    break;
                }
                subscriber.next(item.value);
                if (subscriber.closed) {
                    break;
                }
            } while (true);
            if (typeof iterator$1.return === 'function') {
                subscriber.add(function () {
                    if (iterator$1.return) {
                        iterator$1.return();
                    }
                });
            }
            return subscriber;
        };
    };

    /** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */
    var subscribeToObservable = function (obj) {
        return function (subscriber) {
            var obs = obj[observable]();
            if (typeof obs.subscribe !== 'function') {
                throw new TypeError('Provided object does not correctly implement Symbol.observable');
            }
            else {
                return obs.subscribe(subscriber);
            }
        };
    };

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    var isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    function isPromise(value) {
        return !!value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
    }

    /** PURE_IMPORTS_START _subscribeToArray,_subscribeToPromise,_subscribeToIterable,_subscribeToObservable,_isArrayLike,_isPromise,_isObject,_symbol_iterator,_symbol_observable PURE_IMPORTS_END */
    var subscribeTo = function (result) {
        if (!!result && typeof result[observable] === 'function') {
            return subscribeToObservable(result);
        }
        else if (isArrayLike(result)) {
            return subscribeToArray(result);
        }
        else if (isPromise(result)) {
            return subscribeToPromise(result);
        }
        else if (!!result && typeof result[iterator] === 'function') {
            return subscribeToIterable(result);
        }
        else {
            var value = isObject(result) ? 'an invalid object' : "'" + result + "'";
            var msg = "You provided " + value + " where a stream was expected."
                + ' You can provide an Observable, Promise, Array, or Iterable.';
            throw new TypeError(msg);
        }
    };

    /** PURE_IMPORTS_START _Observable,_Subscription,_symbol_observable PURE_IMPORTS_END */
    function scheduleObservable(input, scheduler) {
        return new Observable(function (subscriber) {
            var sub = new Subscription();
            sub.add(scheduler.schedule(function () {
                var observable$1 = input[observable]();
                sub.add(observable$1.subscribe({
                    next: function (value) { sub.add(scheduler.schedule(function () { return subscriber.next(value); })); },
                    error: function (err) { sub.add(scheduler.schedule(function () { return subscriber.error(err); })); },
                    complete: function () { sub.add(scheduler.schedule(function () { return subscriber.complete(); })); },
                }));
            }));
            return sub;
        });
    }

    /** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */
    function schedulePromise(input, scheduler) {
        return new Observable(function (subscriber) {
            var sub = new Subscription();
            sub.add(scheduler.schedule(function () {
                return input.then(function (value) {
                    sub.add(scheduler.schedule(function () {
                        subscriber.next(value);
                        sub.add(scheduler.schedule(function () { return subscriber.complete(); }));
                    }));
                }, function (err) {
                    sub.add(scheduler.schedule(function () { return subscriber.error(err); }));
                });
            }));
            return sub;
        });
    }

    /** PURE_IMPORTS_START _Observable,_Subscription,_symbol_iterator PURE_IMPORTS_END */
    function scheduleIterable(input, scheduler) {
        if (!input) {
            throw new Error('Iterable cannot be null');
        }
        return new Observable(function (subscriber) {
            var sub = new Subscription();
            var iterator$1;
            sub.add(function () {
                if (iterator$1 && typeof iterator$1.return === 'function') {
                    iterator$1.return();
                }
            });
            sub.add(scheduler.schedule(function () {
                iterator$1 = input[iterator]();
                sub.add(scheduler.schedule(function () {
                    if (subscriber.closed) {
                        return;
                    }
                    var value;
                    var done;
                    try {
                        var result = iterator$1.next();
                        value = result.value;
                        done = result.done;
                    }
                    catch (err) {
                        subscriber.error(err);
                        return;
                    }
                    if (done) {
                        subscriber.complete();
                    }
                    else {
                        subscriber.next(value);
                        this.schedule();
                    }
                }));
            }));
            return sub;
        });
    }

    /** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */
    function isInteropObservable(input) {
        return input && typeof input[observable] === 'function';
    }

    /** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */
    function isIterable(input) {
        return input && typeof input[iterator] === 'function';
    }

    /** PURE_IMPORTS_START _scheduleObservable,_schedulePromise,_scheduleArray,_scheduleIterable,_util_isInteropObservable,_util_isPromise,_util_isArrayLike,_util_isIterable PURE_IMPORTS_END */
    function scheduled(input, scheduler) {
        if (input != null) {
            if (isInteropObservable(input)) {
                return scheduleObservable(input, scheduler);
            }
            else if (isPromise(input)) {
                return schedulePromise(input, scheduler);
            }
            else if (isArrayLike(input)) {
                return scheduleArray(input, scheduler);
            }
            else if (isIterable(input) || typeof input === 'string') {
                return scheduleIterable(input, scheduler);
            }
        }
        throw new TypeError((input !== null && typeof input || input) + ' is not observable');
    }

    /** PURE_IMPORTS_START _Observable,_util_subscribeTo,_scheduled_scheduled PURE_IMPORTS_END */
    function from(input, scheduler) {
        if (!scheduler) {
            if (input instanceof Observable) {
                return input;
            }
            return new Observable(subscribeTo(input));
        }
        else {
            return scheduled(input, scheduler);
        }
    }

    /** PURE_IMPORTS_START tslib,_Subscriber,_Observable,_util_subscribeTo PURE_IMPORTS_END */
    var SimpleInnerSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(SimpleInnerSubscriber, _super);
        function SimpleInnerSubscriber(parent) {
            var _this = _super.call(this) || this;
            _this.parent = parent;
            return _this;
        }
        SimpleInnerSubscriber.prototype._next = function (value) {
            this.parent.notifyNext(value);
        };
        SimpleInnerSubscriber.prototype._error = function (error) {
            this.parent.notifyError(error);
            this.unsubscribe();
        };
        SimpleInnerSubscriber.prototype._complete = function () {
            this.parent.notifyComplete();
            this.unsubscribe();
        };
        return SimpleInnerSubscriber;
    }(Subscriber));
    var SimpleOuterSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(SimpleOuterSubscriber, _super);
        function SimpleOuterSubscriber() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SimpleOuterSubscriber.prototype.notifyNext = function (innerValue) {
            this.destination.next(innerValue);
        };
        SimpleOuterSubscriber.prototype.notifyError = function (err) {
            this.destination.error(err);
        };
        SimpleOuterSubscriber.prototype.notifyComplete = function () {
            this.destination.complete();
        };
        return SimpleOuterSubscriber;
    }(Subscriber));
    function innerSubscribe(result, innerSubscriber) {
        if (innerSubscriber.closed) {
            return undefined;
        }
        if (result instanceof Observable) {
            return result.subscribe(innerSubscriber);
        }
        var subscription;
        try {
            subscription = subscribeTo(result)(innerSubscriber);
        }
        catch (error) {
            innerSubscriber.error(error);
        }
        return subscription;
    }

    /** PURE_IMPORTS_START tslib,_map,_observable_from,_innerSubscribe PURE_IMPORTS_END */
    function mergeMap(project, resultSelector, concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        if (typeof resultSelector === 'function') {
            return function (source) { return source.pipe(mergeMap(function (a, i) { return from(project(a, i)).pipe(map(function (b, ii) { return resultSelector(a, b, i, ii); })); }, concurrent)); };
        }
        else if (typeof resultSelector === 'number') {
            concurrent = resultSelector;
        }
        return function (source) { return source.lift(new MergeMapOperator(project, concurrent)); };
    }
    var MergeMapOperator = /*@__PURE__*/ (function () {
        function MergeMapOperator(project, concurrent) {
            if (concurrent === void 0) {
                concurrent = Number.POSITIVE_INFINITY;
            }
            this.project = project;
            this.concurrent = concurrent;
        }
        MergeMapOperator.prototype.call = function (observer, source) {
            return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
        };
        return MergeMapOperator;
    }());
    var MergeMapSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(MergeMapSubscriber, _super);
        function MergeMapSubscriber(destination, project, concurrent) {
            if (concurrent === void 0) {
                concurrent = Number.POSITIVE_INFINITY;
            }
            var _this = _super.call(this, destination) || this;
            _this.project = project;
            _this.concurrent = concurrent;
            _this.hasCompleted = false;
            _this.buffer = [];
            _this.active = 0;
            _this.index = 0;
            return _this;
        }
        MergeMapSubscriber.prototype._next = function (value) {
            if (this.active < this.concurrent) {
                this._tryNext(value);
            }
            else {
                this.buffer.push(value);
            }
        };
        MergeMapSubscriber.prototype._tryNext = function (value) {
            var result;
            var index = this.index++;
            try {
                result = this.project(value, index);
            }
            catch (err) {
                this.destination.error(err);
                return;
            }
            this.active++;
            this._innerSub(result);
        };
        MergeMapSubscriber.prototype._innerSub = function (ish) {
            var innerSubscriber = new SimpleInnerSubscriber(this);
            var destination = this.destination;
            destination.add(innerSubscriber);
            var innerSubscription = innerSubscribe(ish, innerSubscriber);
            if (innerSubscription !== innerSubscriber) {
                destination.add(innerSubscription);
            }
        };
        MergeMapSubscriber.prototype._complete = function () {
            this.hasCompleted = true;
            if (this.active === 0 && this.buffer.length === 0) {
                this.destination.complete();
            }
            this.unsubscribe();
        };
        MergeMapSubscriber.prototype.notifyNext = function (innerValue) {
            this.destination.next(innerValue);
        };
        MergeMapSubscriber.prototype.notifyComplete = function () {
            var buffer = this.buffer;
            this.active--;
            if (buffer.length > 0) {
                this._next(buffer.shift());
            }
            else if (this.active === 0 && this.hasCompleted) {
                this.destination.complete();
            }
        };
        return MergeMapSubscriber;
    }(SimpleOuterSubscriber));

    /** PURE_IMPORTS_START _mergeMap,_util_identity PURE_IMPORTS_END */
    function mergeAll(concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        return mergeMap(identity, concurrent);
    }

    /** PURE_IMPORTS_START _mergeAll PURE_IMPORTS_END */
    function concatAll() {
        return mergeAll(1);
    }

    /** PURE_IMPORTS_START _of,_operators_concatAll PURE_IMPORTS_END */
    function concat() {
        var observables = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i] = arguments[_i];
        }
        return concatAll()(of.apply(void 0, observables));
    }

    /** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */
    function fromEvent(target, eventName, options, resultSelector) {
        if (isFunction(options)) {
            resultSelector = options;
            options = undefined;
        }
        if (resultSelector) {
            return fromEvent(target, eventName, options).pipe(map(function (args) { return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
        }
        return new Observable(function (subscriber) {
            function handler(e) {
                if (arguments.length > 1) {
                    subscriber.next(Array.prototype.slice.call(arguments));
                }
                else {
                    subscriber.next(e);
                }
            }
            setupSubscription(target, eventName, handler, subscriber, options);
        });
    }
    function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
        var unsubscribe;
        if (isEventTarget(sourceObj)) {
            var source_1 = sourceObj;
            sourceObj.addEventListener(eventName, handler, options);
            unsubscribe = function () { return source_1.removeEventListener(eventName, handler, options); };
        }
        else if (isJQueryStyleEventEmitter(sourceObj)) {
            var source_2 = sourceObj;
            sourceObj.on(eventName, handler);
            unsubscribe = function () { return source_2.off(eventName, handler); };
        }
        else if (isNodeStyleEventEmitter(sourceObj)) {
            var source_3 = sourceObj;
            sourceObj.addListener(eventName, handler);
            unsubscribe = function () { return source_3.removeListener(eventName, handler); };
        }
        else if (sourceObj && sourceObj.length) {
            for (var i = 0, len = sourceObj.length; i < len; i++) {
                setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
            }
        }
        else {
            throw new TypeError('Invalid event target');
        }
        subscriber.add(unsubscribe);
    }
    function isNodeStyleEventEmitter(sourceObj) {
        return sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
    }
    function isJQueryStyleEventEmitter(sourceObj) {
        return sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
    }
    function isEventTarget(sourceObj) {
        return sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
    }

    /** PURE_IMPORTS_START _Observable,_util_isScheduler,_operators_mergeAll,_fromArray PURE_IMPORTS_END */
    function merge() {
        var observables = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i] = arguments[_i];
        }
        var concurrent = Number.POSITIVE_INFINITY;
        var scheduler = null;
        var last = observables[observables.length - 1];
        if (isScheduler(last)) {
            scheduler = observables.pop();
            if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
                concurrent = observables.pop();
            }
        }
        else if (typeof last === 'number') {
            concurrent = observables.pop();
        }
        if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable) {
            return observables[0];
        }
        return mergeAll(concurrent)(fromArray(observables, scheduler));
    }

    /** PURE_IMPORTS_START _Observable,_util_noop PURE_IMPORTS_END */
    var NEVER = /*@__PURE__*/ new Observable(noop);

    /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
    function filter(predicate, thisArg) {
        return function filterOperatorFunction(source) {
            return source.lift(new FilterOperator(predicate, thisArg));
        };
    }
    var FilterOperator = /*@__PURE__*/ (function () {
        function FilterOperator(predicate, thisArg) {
            this.predicate = predicate;
            this.thisArg = thisArg;
        }
        FilterOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
        };
        return FilterOperator;
    }());
    var FilterSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(FilterSubscriber, _super);
        function FilterSubscriber(destination, predicate, thisArg) {
            var _this = _super.call(this, destination) || this;
            _this.predicate = predicate;
            _this.thisArg = thisArg;
            _this.count = 0;
            return _this;
        }
        FilterSubscriber.prototype._next = function (value) {
            var result;
            try {
                result = this.predicate.call(this.thisArg, value, this.count++);
            }
            catch (err) {
                this.destination.error(err);
                return;
            }
            if (result) {
                this.destination.next(value);
            }
        };
        return FilterSubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START _observable_ConnectableObservable PURE_IMPORTS_END */
    function multicast(subjectOrSubjectFactory, selector) {
        return function multicastOperatorFunction(source) {
            var subjectFactory;
            if (typeof subjectOrSubjectFactory === 'function') {
                subjectFactory = subjectOrSubjectFactory;
            }
            else {
                subjectFactory = function subjectFactory() {
                    return subjectOrSubjectFactory;
                };
            }
            if (typeof selector === 'function') {
                return source.lift(new MulticastOperator(subjectFactory, selector));
            }
            var connectable = Object.create(source, connectableObservableDescriptor);
            connectable.source = source;
            connectable.subjectFactory = subjectFactory;
            return connectable;
        };
    }
    var MulticastOperator = /*@__PURE__*/ (function () {
        function MulticastOperator(subjectFactory, selector) {
            this.subjectFactory = subjectFactory;
            this.selector = selector;
        }
        MulticastOperator.prototype.call = function (subscriber, source) {
            var selector = this.selector;
            var subject = this.subjectFactory();
            var subscription = selector(subject).subscribe(subscriber);
            subscription.add(source.subscribe(subject));
            return subscription;
        };
        return MulticastOperator;
    }());

    /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
    function pairwise() {
        return function (source) { return source.lift(new PairwiseOperator()); };
    }
    var PairwiseOperator = /*@__PURE__*/ (function () {
        function PairwiseOperator() {
        }
        PairwiseOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new PairwiseSubscriber(subscriber));
        };
        return PairwiseOperator;
    }());
    var PairwiseSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(PairwiseSubscriber, _super);
        function PairwiseSubscriber(destination) {
            var _this = _super.call(this, destination) || this;
            _this.hasPrev = false;
            return _this;
        }
        PairwiseSubscriber.prototype._next = function (value) {
            var pair;
            if (this.hasPrev) {
                pair = [this.prev, value];
            }
            else {
                this.hasPrev = true;
            }
            this.prev = value;
            if (pair) {
                this.destination.next(pair);
            }
        };
        return PairwiseSubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START _map PURE_IMPORTS_END */
    function pluck() {
        var properties = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            properties[_i] = arguments[_i];
        }
        var length = properties.length;
        if (length === 0) {
            throw new Error('list of properties cannot be empty.');
        }
        return function (source) { return map(plucker(properties, length))(source); };
    }
    function plucker(props, length) {
        var mapper = function (x) {
            var currentProp = x;
            for (var i = 0; i < length; i++) {
                var p = currentProp != null ? currentProp[props[i]] : undefined;
                if (p !== void 0) {
                    currentProp = p;
                }
                else {
                    return undefined;
                }
            }
            return currentProp;
        };
        return mapper;
    }

    /** PURE_IMPORTS_START _multicast,_refCount,_Subject PURE_IMPORTS_END */
    function shareSubjectFactory() {
        return new Subject();
    }
    function share() {
        return function (source) { return refCount()(multicast(shareSubjectFactory)(source)); };
    }

    /** PURE_IMPORTS_START _observable_concat,_util_isScheduler PURE_IMPORTS_END */
    function startWith() {
        var array = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            array[_i] = arguments[_i];
        }
        var scheduler = array[array.length - 1];
        if (isScheduler(scheduler)) {
            array.pop();
            return function (source) { return concat(array, source, scheduler); };
        }
        else {
            return function (source) { return concat(array, source); };
        }
    }

    /** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */
    function takeUntil(notifier) {
        return function (source) { return source.lift(new TakeUntilOperator(notifier)); };
    }
    var TakeUntilOperator = /*@__PURE__*/ (function () {
        function TakeUntilOperator(notifier) {
            this.notifier = notifier;
        }
        TakeUntilOperator.prototype.call = function (subscriber, source) {
            var takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
            var notifierSubscription = innerSubscribe(this.notifier, new SimpleInnerSubscriber(takeUntilSubscriber));
            if (notifierSubscription && !takeUntilSubscriber.seenValue) {
                takeUntilSubscriber.add(notifierSubscription);
                return source.subscribe(takeUntilSubscriber);
            }
            return takeUntilSubscriber;
        };
        return TakeUntilOperator;
    }());
    var TakeUntilSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(TakeUntilSubscriber, _super);
        function TakeUntilSubscriber(destination) {
            var _this = _super.call(this, destination) || this;
            _this.seenValue = false;
            return _this;
        }
        TakeUntilSubscriber.prototype.notifyNext = function () {
            this.seenValue = true;
            this.complete();
        };
        TakeUntilSubscriber.prototype.notifyComplete = function () {
        };
        return TakeUntilSubscriber;
    }(SimpleOuterSubscriber));

    var e=[0,1,2,3,4,4,5,5,6,6,6,6,7,7,7,7,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,9,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,0,0,16,17,18,18,19,19,20,20,20,20,21,21,21,21,22,22,22,22,22,22,22,22,23,23,23,23,23,23,23,23,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29];function t(){var e=this;function t(e,t){var n=0;do{n|=1&e,e>>>=1,n<<=1;}while(--t>0);return n>>>1}e.build_tree=function(n){var i,r,a,o=e.dyn_tree,s=e.stat_desc.static_tree,l=e.stat_desc.elems,f=-1;for(n.heap_len=0,n.heap_max=573,i=0;i<l;i++)0!==o[2*i]?(n.heap[++n.heap_len]=f=i,n.depth[i]=0):o[2*i+1]=0;for(;n.heap_len<2;)o[2*(a=n.heap[++n.heap_len]=f<2?++f:0)]=1,n.depth[a]=0,n.opt_len--,s&&(n.static_len-=s[2*a+1]);for(e.max_code=f,i=Math.floor(n.heap_len/2);i>=1;i--)n.pqdownheap(o,i);a=l;do{i=n.heap[1],n.heap[1]=n.heap[n.heap_len--],n.pqdownheap(o,1),r=n.heap[1],n.heap[--n.heap_max]=i,n.heap[--n.heap_max]=r,o[2*a]=o[2*i]+o[2*r],n.depth[a]=Math.max(n.depth[i],n.depth[r])+1,o[2*i+1]=o[2*r+1]=a,n.heap[1]=a++,n.pqdownheap(o,1);}while(n.heap_len>=2);n.heap[--n.heap_max]=n.heap[1],function(t){var n,i,r,a,o,s,l=e.dyn_tree,f=e.stat_desc.static_tree,u=e.stat_desc.extra_bits,d=e.stat_desc.extra_base,c=e.stat_desc.max_length,_=0;for(a=0;a<=15;a++)t.bl_count[a]=0;for(l[2*t.heap[t.heap_max]+1]=0,n=t.heap_max+1;n<573;n++)(a=l[2*l[2*(i=t.heap[n])+1]+1]+1)>c&&(a=c,_++),l[2*i+1]=a,i>e.max_code||(t.bl_count[a]++,o=0,i>=d&&(o=u[i-d]),t.opt_len+=(s=l[2*i])*(a+o),f&&(t.static_len+=s*(f[2*i+1]+o)));if(0!==_){do{for(a=c-1;0===t.bl_count[a];)a--;t.bl_count[a]--,t.bl_count[a+1]+=2,t.bl_count[c]--,_-=2;}while(_>0);for(a=c;0!==a;a--)for(i=t.bl_count[a];0!==i;)(r=t.heap[--n])>e.max_code||(l[2*r+1]!=a&&(t.opt_len+=(a-l[2*r+1])*l[2*r],l[2*r+1]=a),i--);}}(n),function(e,n,i){var r,a,o,s=[],l=0;for(r=1;r<=15;r++)s[r]=l=l+i[r-1]<<1;for(a=0;a<=n;a++)0!==(o=e[2*a+1])&&(e[2*a]=t(s[o]++,o));}(o,e.max_code,n.bl_count);};}function n(e,t,n,i,r){var a=this;a.static_tree=e,a.extra_bits=t,a.extra_base=n,a.elems=i,a.max_length=r;}function i(e,t,n,i,r){var a=this;a.good_length=e,a.max_lazy=t,a.nice_length=n,a.max_chain=i,a.func=r;}t._length_code=[0,1,2,3,4,5,6,7,8,8,9,9,10,10,11,11,12,12,12,12,13,13,13,13,14,14,14,14,15,15,15,15,16,16,16,16,16,16,16,16,17,17,17,17,17,17,17,17,18,18,18,18,18,18,18,18,19,19,19,19,19,19,19,19,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,28],t.base_length=[0,1,2,3,4,5,6,7,8,10,12,14,16,20,24,28,32,40,48,56,64,80,96,112,128,160,192,224,0],t.base_dist=[0,1,2,3,4,6,8,12,16,24,32,48,64,96,128,192,256,384,512,768,1024,1536,2048,3072,4096,6144,8192,12288,16384,24576],t.d_code=function(t){return t<256?e[t]:e[256+(t>>>7)]},t.extra_lbits=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],t.extra_dbits=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],t.extra_blbits=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],t.bl_order=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],n.static_ltree=[12,8,140,8,76,8,204,8,44,8,172,8,108,8,236,8,28,8,156,8,92,8,220,8,60,8,188,8,124,8,252,8,2,8,130,8,66,8,194,8,34,8,162,8,98,8,226,8,18,8,146,8,82,8,210,8,50,8,178,8,114,8,242,8,10,8,138,8,74,8,202,8,42,8,170,8,106,8,234,8,26,8,154,8,90,8,218,8,58,8,186,8,122,8,250,8,6,8,134,8,70,8,198,8,38,8,166,8,102,8,230,8,22,8,150,8,86,8,214,8,54,8,182,8,118,8,246,8,14,8,142,8,78,8,206,8,46,8,174,8,110,8,238,8,30,8,158,8,94,8,222,8,62,8,190,8,126,8,254,8,1,8,129,8,65,8,193,8,33,8,161,8,97,8,225,8,17,8,145,8,81,8,209,8,49,8,177,8,113,8,241,8,9,8,137,8,73,8,201,8,41,8,169,8,105,8,233,8,25,8,153,8,89,8,217,8,57,8,185,8,121,8,249,8,5,8,133,8,69,8,197,8,37,8,165,8,101,8,229,8,21,8,149,8,85,8,213,8,53,8,181,8,117,8,245,8,13,8,141,8,77,8,205,8,45,8,173,8,109,8,237,8,29,8,157,8,93,8,221,8,61,8,189,8,125,8,253,8,19,9,275,9,147,9,403,9,83,9,339,9,211,9,467,9,51,9,307,9,179,9,435,9,115,9,371,9,243,9,499,9,11,9,267,9,139,9,395,9,75,9,331,9,203,9,459,9,43,9,299,9,171,9,427,9,107,9,363,9,235,9,491,9,27,9,283,9,155,9,411,9,91,9,347,9,219,9,475,9,59,9,315,9,187,9,443,9,123,9,379,9,251,9,507,9,7,9,263,9,135,9,391,9,71,9,327,9,199,9,455,9,39,9,295,9,167,9,423,9,103,9,359,9,231,9,487,9,23,9,279,9,151,9,407,9,87,9,343,9,215,9,471,9,55,9,311,9,183,9,439,9,119,9,375,9,247,9,503,9,15,9,271,9,143,9,399,9,79,9,335,9,207,9,463,9,47,9,303,9,175,9,431,9,111,9,367,9,239,9,495,9,31,9,287,9,159,9,415,9,95,9,351,9,223,9,479,9,63,9,319,9,191,9,447,9,127,9,383,9,255,9,511,9,0,7,64,7,32,7,96,7,16,7,80,7,48,7,112,7,8,7,72,7,40,7,104,7,24,7,88,7,56,7,120,7,4,7,68,7,36,7,100,7,20,7,84,7,52,7,116,7,3,8,131,8,67,8,195,8,35,8,163,8,99,8,227,8],n.static_dtree=[0,5,16,5,8,5,24,5,4,5,20,5,12,5,28,5,2,5,18,5,10,5,26,5,6,5,22,5,14,5,30,5,1,5,17,5,9,5,25,5,5,5,21,5,13,5,29,5,3,5,19,5,11,5,27,5,7,5,23,5],n.static_l_desc=new n(n.static_ltree,t.extra_lbits,257,286,15),n.static_d_desc=new n(n.static_dtree,t.extra_dbits,0,30,15),n.static_bl_desc=new n(null,t.extra_blbits,0,19,7);var r=[new i(0,0,0,0,0),new i(4,4,8,4,1),new i(4,5,16,8,1),new i(4,6,32,32,1),new i(4,4,16,16,2),new i(8,16,32,32,2),new i(8,16,128,128,2),new i(8,32,128,256,2),new i(32,128,258,1024,2),new i(32,258,258,4096,2)],a=["need dictionary","stream end","","","stream error","data error","","buffer error","",""];function o(e,t,n,i){var r=e[2*t],a=e[2*n];return r<a||r==a&&i[t]<=i[n]}function s(){var e,i,s,l,f,u,d,c,_,h,p,w,v,b,x,m,g,y,k,U,z,E,D,A,S,R,F,T,W,M,B,I,C,L,P,Z,N,j,O,V,q,$=this,G=new t,H=new t,Y=new t;function J(){var e;for(e=0;e<286;e++)B[2*e]=0;for(e=0;e<30;e++)I[2*e]=0;for(e=0;e<19;e++)C[2*e]=0;B[512]=1,$.opt_len=$.static_len=0,Z=j=0;}function K(e,t){var n,i,r=-1,a=e[1],o=0,s=7,l=4;for(0===a&&(s=138,l=3),e[2*(t+1)+1]=65535,n=0;n<=t;n++)i=a,a=e[2*(n+1)+1],++o<s&&i==a||(o<l?C[2*i]+=o:0!==i?(i!=r&&C[2*i]++,C[32]++):o<=10?C[34]++:C[36]++,o=0,r=i,0===a?(s=138,l=3):i==a?(s=6,l=3):(s=7,l=4));}function Q(e){$.pending_buf[$.pending++]=e;}function X(e){Q(255&e),Q(e>>>8&255);}function ee(e,t){var n,i=t;q>16-i?(X(V|=(n=e)<<q&65535),V=n>>>16-q,q+=i-16):(V|=e<<q&65535,q+=i);}function te(e,t){var n=2*e;ee(65535&t[n],65535&t[n+1]);}function ne(e,t){var n,i,r=-1,a=e[1],o=0,s=7,l=4;for(0===a&&(s=138,l=3),n=0;n<=t;n++)if(i=a,a=e[2*(n+1)+1],!(++o<s&&i==a)){if(o<l)do{te(i,C);}while(0!=--o);else 0!==i?(i!=r&&(te(i,C),o--),te(16,C),ee(o-3,2)):o<=10?(te(17,C),ee(o-3,3)):(te(18,C),ee(o-11,7));o=0,r=i,0===a?(s=138,l=3):i==a?(s=6,l=3):(s=7,l=4);}}function ie(){16==q?(X(V),V=0,q=0):q>=8&&(Q(255&V),V>>>=8,q-=8);}function re(e,n){var i,r,a;if($.pending_buf[N+2*Z]=e>>>8&255,$.pending_buf[N+2*Z+1]=255&e,$.pending_buf[L+Z]=255&n,Z++,0===e?B[2*n]++:(j++,e--,B[2*(t._length_code[n]+256+1)]++,I[2*t.d_code(e)]++),0==(8191&Z)&&F>2){for(i=8*Z,r=z-g,a=0;a<30;a++)i+=I[2*a]*(5+t.extra_dbits[a]);if(i>>>=3,j<Math.floor(Z/2)&&i<Math.floor(r/2))return !0}return Z==P-1}function ae(e,n){var i,r,a,o,s=0;if(0!==Z)do{i=$.pending_buf[N+2*s]<<8&65280|255&$.pending_buf[N+2*s+1],r=255&$.pending_buf[L+s],s++,0===i?te(r,e):(te((a=t._length_code[r])+256+1,e),0!==(o=t.extra_lbits[a])&&ee(r-=t.base_length[a],o),i--,te(a=t.d_code(i),n),0!==(o=t.extra_dbits[a])&&ee(i-=t.base_dist[a],o));}while(s<Z);te(256,e),O=e[513];}function oe(){q>8?X(V):q>0&&Q(255&V),V=0,q=0;}function se(e,t,n){ee(0+(n?1:0),3),function(e,t,n){oe(),O=8,X(t),X(~t),$.pending_buf.set(c.subarray(e,e+t),$.pending),$.pending+=t;}(e,t);}function le(i){(function(e,i,r){var a,o,s=0;F>0?(G.build_tree($),H.build_tree($),s=function(){var e;for(K(B,G.max_code),K(I,H.max_code),Y.build_tree($),e=18;e>=3&&0===C[2*t.bl_order[e]+1];e--);return $.opt_len+=3*(e+1)+5+5+4,e}(),(o=$.static_len+3+7>>>3)<=(a=$.opt_len+3+7>>>3)&&(a=o)):a=o=i+5,i+4<=a&&-1!=e?se(e,i,r):o==a?(ee(2+(r?1:0),3),ae(n.static_ltree,n.static_dtree)):(ee(4+(r?1:0),3),function(e,n,i){var r;for(ee(e-257,5),ee(n-1,5),ee(i-4,4),r=0;r<i;r++)ee(C[2*t.bl_order[r]+1],3);ne(B,e-1),ne(I,n-1);}(G.max_code+1,H.max_code+1,s+1),ae(B,I)),J(),r&&oe();})(g>=0?g:-1,z-g,i),g=z,e.flush_pending();}function fe(){var t,n,i,r;do{if(0==(r=_-D-z)&&0===z&&0===D)r=f;else if(-1==r)r--;else if(z>=f+f-262){c.set(c.subarray(f,f+f),0),E-=f,z-=f,g-=f,i=t=v;do{n=65535&p[--i],p[i]=n>=f?n-f:0;}while(0!=--t);i=t=f;do{n=65535&h[--i],h[i]=n>=f?n-f:0;}while(0!=--t);r+=f;}if(0===e.avail_in)return;t=e.read_buf(c,z+D,r),(D+=t)>=3&&(w=((w=255&c[z])<<m^255&c[z+1])&x);}while(D<262&&0!==e.avail_in)}function ue(e){var t,n,i=S,r=z,a=A,o=z>f-262?z-(f-262):0,s=M,l=d,u=z+258,_=c[r+a-1],p=c[r+a];A>=W&&(i>>=2),s>D&&(s=D);do{if(c[(t=e)+a]==p&&c[t+a-1]==_&&c[t]==c[r]&&c[++t]==c[r+1]){r+=2,t++;do{}while(c[++r]==c[++t]&&c[++r]==c[++t]&&c[++r]==c[++t]&&c[++r]==c[++t]&&c[++r]==c[++t]&&c[++r]==c[++t]&&c[++r]==c[++t]&&c[++r]==c[++t]&&r<u);if(n=258-(u-r),r=u-258,n>a){if(E=e,a=n,n>=s)break;_=c[r+a-1],p=c[r+a];}}}while((e=65535&h[e&l])>o&&0!=--i);return a<=D?a:D}$.depth=[],$.bl_count=[],$.heap=[],B=[],I=[],C=[],$.pqdownheap=function(e,t){for(var n=$.heap,i=n[t],r=t<<1;r<=$.heap_len&&(r<$.heap_len&&o(e,n[r+1],n[r],$.depth)&&r++,!o(e,i,n[r],$.depth));)n[t]=n[r],t=r,r<<=1;n[t]=i;},$.deflateInit=function(e,t,a,o,k,E){return o||(o=8),k||(k=8),E||(E=0),e.msg=null,-1==t&&(t=6),k<1||k>9||8!=o||a<9||a>15||t<0||t>9||E<0||E>2?-2:(e.dstate=$,d=(f=1<<(u=a))-1,x=(v=1<<(b=k+7))-1,m=Math.floor((b+3-1)/3),c=new Uint8Array(2*f),h=[],p=[],P=1<<k+6,$.pending_buf=new Uint8Array(4*P),s=4*P,N=Math.floor(P/2),L=3*P,F=t,T=E,function(e){return e.total_in=e.total_out=0,e.msg=null,$.pending=0,$.pending_out=0,i=113,l=0,G.dyn_tree=B,G.stat_desc=n.static_l_desc,H.dyn_tree=I,H.stat_desc=n.static_d_desc,Y.dyn_tree=C,Y.stat_desc=n.static_bl_desc,V=0,q=0,O=8,J(),function(){var e;for(_=2*f,p[v-1]=0,e=0;e<v-1;e++)p[e]=0;R=r[F].max_lazy,W=r[F].good_length,M=r[F].nice_length,S=r[F].max_chain,z=0,g=0,D=0,y=A=2,U=0,w=0;}(),0}(e))},$.deflateEnd=function(){return 42!=i&&113!=i&&666!=i?-2:($.pending_buf=null,p=null,h=null,c=null,$.dstate=null,113==i?-3:0)},$.deflateParams=function(e,t,n){var i=0;return -1==t&&(t=6),t<0||t>9||n<0||n>2?-2:(r[F].func!=r[t].func&&0!==e.total_in&&(i=e.deflate(1)),F!=t&&(R=r[F=t].max_lazy,W=r[F].good_length,M=r[F].nice_length,S=r[F].max_chain),T=n,i)},$.deflateSetDictionary=function(e,t,n){var r,a=n,o=0;if(!t||42!=i)return -2;if(a<3)return 0;for(a>f-262&&(o=n-(a=f-262)),c.set(t.subarray(o,o+a),0),z=a,g=a,w=((w=255&c[0])<<m^255&c[1])&x,r=0;r<=a-3;r++)h[r&d]=p[w=(w<<m^255&c[r+2])&x],p[w]=r;return 0},$.deflate=function(t,o){var _,b,S,W,M,B;if(o>4||o<0)return -2;if(!t.next_out||!t.next_in&&0!==t.avail_in||666==i&&4!=o)return t.msg=a[4],-2;if(0===t.avail_out)return t.msg=a[7],-5;if(e=t,W=l,l=o,42==i&&(b=8+(u-8<<4)<<8,(S=(F-1&255)>>1)>3&&(S=3),b|=S<<6,0!==z&&(b|=32),i=113,Q((B=b+=31-b%31)>>8&255),Q(255&B)),0!==$.pending){if(e.flush_pending(),0===e.avail_out)return l=-1,0}else if(0===e.avail_in&&o<=W&&4!=o)return e.msg=a[7],-5;if(666==i&&0!==e.avail_in)return t.msg=a[7],-5;if(0!==e.avail_in||0!==D||0!=o&&666!=i){switch(M=-1,r[F].func){case 0:M=function(t){var n,i=65535;for(i>s-5&&(i=s-5);;){if(D<=1){if(fe(),0===D&&0==t)return 0;if(0===D)break}if(z+=D,D=0,n=g+i,(0===z||z>=n)&&(D=z-n,z=n,le(!1),0===e.avail_out))return 0;if(z-g>=f-262&&(le(!1),0===e.avail_out))return 0}return le(4==t),0===e.avail_out?4==t?2:0:4==t?3:1}(o);break;case 1:M=function(t){for(var n,i=0;;){if(D<262){if(fe(),D<262&&0==t)return 0;if(0===D)break}if(D>=3&&(i=65535&p[w=(w<<m^255&c[z+2])&x],h[z&d]=p[w],p[w]=z),0!==i&&(z-i&65535)<=f-262&&2!=T&&(y=ue(i)),y>=3)if(n=re(z-E,y-3),D-=y,y<=R&&D>=3){y--;do{z++,i=65535&p[w=(w<<m^255&c[z+2])&x],h[z&d]=p[w],p[w]=z;}while(0!=--y);z++;}else z+=y,y=0,w=((w=255&c[z])<<m^255&c[z+1])&x;else n=re(0,255&c[z]),D--,z++;if(n&&(le(!1),0===e.avail_out))return 0}return le(4==t),0===e.avail_out?4==t?2:0:4==t?3:1}(o);break;case 2:M=function(t){for(var n,i,r=0;;){if(D<262){if(fe(),D<262&&0==t)return 0;if(0===D)break}if(D>=3&&(r=65535&p[w=(w<<m^255&c[z+2])&x],h[z&d]=p[w],p[w]=z),A=y,k=E,y=2,0!==r&&A<R&&(z-r&65535)<=f-262&&(2!=T&&(y=ue(r)),y<=5&&(1==T||3==y&&z-E>4096)&&(y=2)),A>=3&&y<=A){i=z+D-3,n=re(z-1-k,A-3),D-=A-1,A-=2;do{++z<=i&&(r=65535&p[w=(w<<m^255&c[z+2])&x],h[z&d]=p[w],p[w]=z);}while(0!=--A);if(U=0,y=2,z++,n&&(le(!1),0===e.avail_out))return 0}else if(0!==U){if((n=re(0,255&c[z-1]))&&le(!1),z++,D--,0===e.avail_out)return 0}else U=1,z++,D--;}return 0!==U&&(n=re(0,255&c[z-1]),U=0),le(4==t),0===e.avail_out?4==t?2:0:4==t?3:1}(o);}if(2!=M&&3!=M||(i=666),0==M||2==M)return 0===e.avail_out&&(l=-1),0;if(1==M){if(1==o)ee(2,3),te(256,n.static_ltree),ie(),1+O+10-q<9&&(ee(2,3),te(256,n.static_ltree),ie()),O=7;else if(se(0,0,!1),3==o)for(_=0;_<v;_++)p[_]=0;if(e.flush_pending(),0===e.avail_out)return l=-1,0}}return 4!=o?0:1};}function l(){var e=this;e.next_in_index=0,e.next_out_index=0,e.avail_in=0,e.total_in=0,e.avail_out=0,e.total_out=0;}function f(e){var t=new l,n=512,i=new Uint8Array(n),r=e?e.level:-1;void 0===r&&(r=-1),t.deflateInit(r),t.next_out=i,this.append=function(e,r){var a,o=[],s=0,l=0,f=0;if(e.length){t.next_in_index=0,t.next_in=e,t.avail_in=e.length;do{if(t.next_out_index=0,t.avail_out=n,0!=t.deflate(0))throw new Error("deflating: "+t.msg);t.next_out_index&&o.push(t.next_out_index==n?new Uint8Array(i):new Uint8Array(i.subarray(0,t.next_out_index))),f+=t.next_out_index,r&&t.next_in_index>0&&t.next_in_index!=s&&(r(t.next_in_index),s=t.next_in_index);}while(t.avail_in>0||0===t.avail_out);return a=new Uint8Array(f),o.forEach(function(e){a.set(e,l),l+=e.length;}),a}},this.flush=function(){var e,r,a=[],o=0,s=0;do{if(t.next_out_index=0,t.avail_out=n,1!=(e=t.deflate(4))&&0!=e)throw new Error("deflating: "+t.msg);n-t.avail_out>0&&a.push(new Uint8Array(i.subarray(0,t.next_out_index))),s+=t.next_out_index;}while(t.avail_in>0||0===t.avail_out);return t.deflateEnd(),r=new Uint8Array(s),a.forEach(function(e){r.set(e,o),o+=e.length;}),r};}l.prototype={deflateInit:function(e,t){var n=this;return n.dstate=new s,t||(t=15),n.dstate.deflateInit(n,e,t)},deflate:function(e){var t=this;return t.dstate?t.dstate.deflate(t,e):-2},deflateEnd:function(){var e=this;if(!e.dstate)return -2;var t=e.dstate.deflateEnd();return e.dstate=null,t},deflateParams:function(e,t){var n=this;return n.dstate?n.dstate.deflateParams(n,e,t):-2},deflateSetDictionary:function(e,t){var n=this;return n.dstate?n.dstate.deflateSetDictionary(n,e,t):-2},read_buf:function(e,t,n){var i=this,r=i.avail_in;return r>n&&(r=n),0===r?0:(i.avail_in-=r,e.set(i.next_in.subarray(i.next_in_index,i.next_in_index+r),t),i.next_in_index+=r,i.total_in+=r,r)},flush_pending:function(){var e=this,t=e.dstate.pending;t>e.avail_out&&(t=e.avail_out),0!==t&&(e.next_out.set(e.dstate.pending_buf.subarray(e.dstate.pending_out,e.dstate.pending_out+t),e.next_out_index),e.next_out_index+=t,e.dstate.pending_out+=t,e.total_out+=t,e.avail_out-=t,e.dstate.pending-=t,0===e.dstate.pending&&(e.dstate.pending_out=0));}},self._zipjs_Deflater=f;var u=[0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535],d=[96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,192,80,7,10,0,8,96,0,8,32,0,9,160,0,8,0,0,8,128,0,8,64,0,9,224,80,7,6,0,8,88,0,8,24,0,9,144,83,7,59,0,8,120,0,8,56,0,9,208,81,7,17,0,8,104,0,8,40,0,9,176,0,8,8,0,8,136,0,8,72,0,9,240,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,200,81,7,13,0,8,100,0,8,36,0,9,168,0,8,4,0,8,132,0,8,68,0,9,232,80,7,8,0,8,92,0,8,28,0,9,152,84,7,83,0,8,124,0,8,60,0,9,216,82,7,23,0,8,108,0,8,44,0,9,184,0,8,12,0,8,140,0,8,76,0,9,248,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,196,81,7,11,0,8,98,0,8,34,0,9,164,0,8,2,0,8,130,0,8,66,0,9,228,80,7,7,0,8,90,0,8,26,0,9,148,84,7,67,0,8,122,0,8,58,0,9,212,82,7,19,0,8,106,0,8,42,0,9,180,0,8,10,0,8,138,0,8,74,0,9,244,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,204,81,7,15,0,8,102,0,8,38,0,9,172,0,8,6,0,8,134,0,8,70,0,9,236,80,7,9,0,8,94,0,8,30,0,9,156,84,7,99,0,8,126,0,8,62,0,9,220,82,7,27,0,8,110,0,8,46,0,9,188,0,8,14,0,8,142,0,8,78,0,9,252,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,194,80,7,10,0,8,97,0,8,33,0,9,162,0,8,1,0,8,129,0,8,65,0,9,226,80,7,6,0,8,89,0,8,25,0,9,146,83,7,59,0,8,121,0,8,57,0,9,210,81,7,17,0,8,105,0,8,41,0,9,178,0,8,9,0,8,137,0,8,73,0,9,242,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,202,81,7,13,0,8,101,0,8,37,0,9,170,0,8,5,0,8,133,0,8,69,0,9,234,80,7,8,0,8,93,0,8,29,0,9,154,84,7,83,0,8,125,0,8,61,0,9,218,82,7,23,0,8,109,0,8,45,0,9,186,0,8,13,0,8,141,0,8,77,0,9,250,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,198,81,7,11,0,8,99,0,8,35,0,9,166,0,8,3,0,8,131,0,8,67,0,9,230,80,7,7,0,8,91,0,8,27,0,9,150,84,7,67,0,8,123,0,8,59,0,9,214,82,7,19,0,8,107,0,8,43,0,9,182,0,8,11,0,8,139,0,8,75,0,9,246,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,206,81,7,15,0,8,103,0,8,39,0,9,174,0,8,7,0,8,135,0,8,71,0,9,238,80,7,9,0,8,95,0,8,31,0,9,158,84,7,99,0,8,127,0,8,63,0,9,222,82,7,27,0,8,111,0,8,47,0,9,190,0,8,15,0,8,143,0,8,79,0,9,254,96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,193,80,7,10,0,8,96,0,8,32,0,9,161,0,8,0,0,8,128,0,8,64,0,9,225,80,7,6,0,8,88,0,8,24,0,9,145,83,7,59,0,8,120,0,8,56,0,9,209,81,7,17,0,8,104,0,8,40,0,9,177,0,8,8,0,8,136,0,8,72,0,9,241,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,201,81,7,13,0,8,100,0,8,36,0,9,169,0,8,4,0,8,132,0,8,68,0,9,233,80,7,8,0,8,92,0,8,28,0,9,153,84,7,83,0,8,124,0,8,60,0,9,217,82,7,23,0,8,108,0,8,44,0,9,185,0,8,12,0,8,140,0,8,76,0,9,249,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,197,81,7,11,0,8,98,0,8,34,0,9,165,0,8,2,0,8,130,0,8,66,0,9,229,80,7,7,0,8,90,0,8,26,0,9,149,84,7,67,0,8,122,0,8,58,0,9,213,82,7,19,0,8,106,0,8,42,0,9,181,0,8,10,0,8,138,0,8,74,0,9,245,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,205,81,7,15,0,8,102,0,8,38,0,9,173,0,8,6,0,8,134,0,8,70,0,9,237,80,7,9,0,8,94,0,8,30,0,9,157,84,7,99,0,8,126,0,8,62,0,9,221,82,7,27,0,8,110,0,8,46,0,9,189,0,8,14,0,8,142,0,8,78,0,9,253,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,195,80,7,10,0,8,97,0,8,33,0,9,163,0,8,1,0,8,129,0,8,65,0,9,227,80,7,6,0,8,89,0,8,25,0,9,147,83,7,59,0,8,121,0,8,57,0,9,211,81,7,17,0,8,105,0,8,41,0,9,179,0,8,9,0,8,137,0,8,73,0,9,243,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,203,81,7,13,0,8,101,0,8,37,0,9,171,0,8,5,0,8,133,0,8,69,0,9,235,80,7,8,0,8,93,0,8,29,0,9,155,84,7,83,0,8,125,0,8,61,0,9,219,82,7,23,0,8,109,0,8,45,0,9,187,0,8,13,0,8,141,0,8,77,0,9,251,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,199,81,7,11,0,8,99,0,8,35,0,9,167,0,8,3,0,8,131,0,8,67,0,9,231,80,7,7,0,8,91,0,8,27,0,9,151,84,7,67,0,8,123,0,8,59,0,9,215,82,7,19,0,8,107,0,8,43,0,9,183,0,8,11,0,8,139,0,8,75,0,9,247,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,207,81,7,15,0,8,103,0,8,39,0,9,175,0,8,7,0,8,135,0,8,71,0,9,239,80,7,9,0,8,95,0,8,31,0,9,159,84,7,99,0,8,127,0,8,63,0,9,223,82,7,27,0,8,111,0,8,47,0,9,191,0,8,15,0,8,143,0,8,79,0,9,255],c=[80,5,1,87,5,257,83,5,17,91,5,4097,81,5,5,89,5,1025,85,5,65,93,5,16385,80,5,3,88,5,513,84,5,33,92,5,8193,82,5,9,90,5,2049,86,5,129,192,5,24577,80,5,2,87,5,385,83,5,25,91,5,6145,81,5,7,89,5,1537,85,5,97,93,5,24577,80,5,4,88,5,769,84,5,49,92,5,12289,82,5,13,90,5,3073,86,5,193,192,5,24577],_=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],h=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,112,112],p=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],w=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];function v(){var e,t,n,i,r,a;function o(e,t,o,s,l,f,u,d,c,_,h){var p,w,v,b,x,m,g,y,k,U,z,E,D,A,S;U=0,x=o;do{n[e[t+U]]++,U++,x--;}while(0!==x);if(n[0]==o)return u[0]=-1,d[0]=0,0;for(y=d[0],m=1;m<=15&&0===n[m];m++);for(g=m,y<m&&(y=m),x=15;0!==x&&0===n[x];x--);for(v=x,y>x&&(y=x),d[0]=y,A=1<<m;m<x;m++,A<<=1)if((A-=n[m])<0)return -3;if((A-=n[x])<0)return -3;for(n[x]+=A,a[1]=m=0,U=1,D=2;0!=--x;)a[D]=m+=n[U],D++,U++;x=0,U=0;do{0!==(m=e[t+U])&&(h[a[m]++]=x),U++;}while(++x<o);for(o=a[v],a[0]=x=0,U=0,b=-1,E=-y,r[0]=0,z=0,S=0;g<=v;g++)for(p=n[g];0!=p--;){for(;g>E+y;){if(b++,S=(S=v-(E+=y))>y?y:S,(w=1<<(m=g-E))>p+1&&(w-=p+1,D=g,m<S))for(;++m<S&&!((w<<=1)<=n[++D]);)w-=n[D];if(_[0]+(S=1<<m)>1440)return -3;r[b]=z=_[0],_[0]+=S,0!==b?(a[b]=x,i[0]=m,i[1]=y,i[2]=z-r[b-1]-(m=x>>>E-y),c.set(i,3*(r[b-1]+m))):u[0]=z;}for(i[1]=g-E,U>=o?i[0]=192:h[U]<s?(i[0]=h[U]<256?0:96,i[2]=h[U++]):(i[0]=f[h[U]-s]+16+64,i[2]=l[h[U++]-s]),w=1<<g-E,m=x>>>E;m<S;m+=w)c.set(i,3*(z+m));for(m=1<<g-1;0!=(x&m);m>>>=1)x^=m;for(x^=m,k=(1<<E)-1;(x&k)!=a[b];)b--,k=(1<<(E-=y))-1;}return 0!==A&&1!=v?-5:0}function s(o){var s;for(e||(e=[],t=[],n=new Int32Array(16),i=[],r=new Int32Array(15),a=new Int32Array(16)),t.length<o&&(t=[]),s=0;s<o;s++)t[s]=0;for(s=0;s<16;s++)n[s]=0;for(s=0;s<3;s++)i[s]=0;r.set(n.subarray(0,15),0),a.set(n.subarray(0,16),0);}this.inflate_trees_bits=function(n,i,r,a,l){var f;return s(19),e[0]=0,-3==(f=o(n,0,19,19,null,null,r,i,a,e,t))?l.msg="oversubscribed dynamic bit lengths tree":-5!=f&&0!==i[0]||(l.msg="incomplete dynamic bit lengths tree",f=-3),f},this.inflate_trees_dynamic=function(n,i,r,a,l,f,u,d,c){var v;return s(288),e[0]=0,0!=(v=o(r,0,n,257,_,h,f,a,d,e,t))||0===a[0]?(-3==v?c.msg="oversubscribed literal/length tree":-4!=v&&(c.msg="incomplete literal/length tree",v=-3),v):(s(288),0!=(v=o(r,n,i,0,p,w,u,l,d,e,t))||0===l[0]&&n>257?(-3==v?c.msg="oversubscribed distance tree":-5==v?(c.msg="incomplete distance tree",v=-3):-4!=v&&(c.msg="empty distance tree with lengths",v=-3),v):0)};}function b(){var e,t,n,i,r=this,a=0,o=0,s=0,l=0,f=0,d=0,c=0,_=0,h=0,p=0;function w(e,t,n,i,r,a,o,s){var l,f,d,c,_,h,p,w,v,b,x,m,g,y,k,U;p=s.next_in_index,w=s.avail_in,_=o.bitb,h=o.bitk,b=(v=o.write)<o.read?o.read-v-1:o.end-v,x=u[e],m=u[t];do{for(;h<20;)w--,_|=(255&s.read_byte(p++))<<h,h+=8;if(0!==(c=(f=n)[U=3*((d=i)+(l=_&x))]))for(;;){if(_>>=f[U+1],h-=f[U+1],0!=(16&c)){for(g=f[U+2]+(_&u[c&=15]),_>>=c,h-=c;h<15;)w--,_|=(255&s.read_byte(p++))<<h,h+=8;for(c=(f=r)[U=3*((d=a)+(l=_&m))];;){if(_>>=f[U+1],h-=f[U+1],0!=(16&c)){for(c&=15;h<c;)w--,_|=(255&s.read_byte(p++))<<h,h+=8;if(y=f[U+2]+(_&u[c]),_>>=c,h-=c,b-=g,v>=y)v-(k=v-y)>0&&2>v-k?(o.window[v++]=o.window[k++],o.window[v++]=o.window[k++],g-=2):(o.window.set(o.window.subarray(k,k+2),v),v+=2,k+=2,g-=2);else {k=v-y;do{k+=o.end;}while(k<0);if(g>(c=o.end-k)){if(g-=c,v-k>0&&c>v-k)do{o.window[v++]=o.window[k++];}while(0!=--c);else o.window.set(o.window.subarray(k,k+c),v),v+=c,k+=c,c=0;k=0;}}if(v-k>0&&g>v-k)do{o.window[v++]=o.window[k++];}while(0!=--g);else o.window.set(o.window.subarray(k,k+g),v),v+=g,k+=g,g=0;break}if(0!=(64&c))return s.msg="invalid distance code",w+=g=h>>3<(g=s.avail_in-w)?h>>3:g,p-=g,h-=g<<3,o.bitb=_,o.bitk=h,s.avail_in=w,s.total_in+=p-s.next_in_index,s.next_in_index=p,o.write=v,-3;l+=f[U+2],c=f[U=3*(d+(l+=_&u[c]))];}break}if(0!=(64&c))return 0!=(32&c)?(w+=g=h>>3<(g=s.avail_in-w)?h>>3:g,p-=g,h-=g<<3,o.bitb=_,o.bitk=h,s.avail_in=w,s.total_in+=p-s.next_in_index,s.next_in_index=p,o.write=v,1):(s.msg="invalid literal/length code",w+=g=h>>3<(g=s.avail_in-w)?h>>3:g,p-=g,h-=g<<3,o.bitb=_,o.bitk=h,s.avail_in=w,s.total_in+=p-s.next_in_index,s.next_in_index=p,o.write=v,-3);if(l+=f[U+2],0===(c=f[U=3*(d+(l+=_&u[c]))])){_>>=f[U+1],h-=f[U+1],o.window[v++]=f[U+2],b--;break}}else _>>=f[U+1],h-=f[U+1],o.window[v++]=f[U+2],b--;}while(b>=258&&w>=10);return w+=g=h>>3<(g=s.avail_in-w)?h>>3:g,p-=g,h-=g<<3,o.bitb=_,o.bitk=h,s.avail_in=w,s.total_in+=p-s.next_in_index,s.next_in_index=p,o.write=v,0}r.init=function(r,a,o,s,l,f){e=0,c=r,_=a,n=o,h=s,i=l,p=f,t=null;},r.proc=function(r,v,b){var x,m,g,y,k,U,z,E=0,D=0,A=0;for(A=v.next_in_index,y=v.avail_in,E=r.bitb,D=r.bitk,U=(k=r.write)<r.read?r.read-k-1:r.end-k;;)switch(e){case 0:if(U>=258&&y>=10&&(r.bitb=E,r.bitk=D,v.avail_in=y,v.total_in+=A-v.next_in_index,v.next_in_index=A,r.write=k,b=w(c,_,n,h,i,p,r,v),A=v.next_in_index,y=v.avail_in,E=r.bitb,D=r.bitk,U=(k=r.write)<r.read?r.read-k-1:r.end-k,0!=b)){e=1==b?7:9;break}s=c,t=n,o=h,e=1;case 1:for(x=s;D<x;){if(0===y)return r.bitb=E,r.bitk=D,v.avail_in=y,v.total_in+=A-v.next_in_index,v.next_in_index=A,r.write=k,r.inflate_flush(v,b);b=0,y--,E|=(255&v.read_byte(A++))<<D,D+=8;}if(E>>>=t[1+(m=3*(o+(E&u[x])))],D-=t[m+1],0===(g=t[m])){l=t[m+2],e=6;break}if(0!=(16&g)){f=15&g,a=t[m+2],e=2;break}if(0==(64&g)){s=g,o=m/3+t[m+2];break}if(0!=(32&g)){e=7;break}return e=9,v.msg="invalid literal/length code",b=-3,r.bitb=E,r.bitk=D,v.avail_in=y,v.total_in+=A-v.next_in_index,v.next_in_index=A,r.write=k,r.inflate_flush(v,b);case 2:for(x=f;D<x;){if(0===y)return r.bitb=E,r.bitk=D,v.avail_in=y,v.total_in+=A-v.next_in_index,v.next_in_index=A,r.write=k,r.inflate_flush(v,b);b=0,y--,E|=(255&v.read_byte(A++))<<D,D+=8;}a+=E&u[x],E>>=x,D-=x,s=_,t=i,o=p,e=3;case 3:for(x=s;D<x;){if(0===y)return r.bitb=E,r.bitk=D,v.avail_in=y,v.total_in+=A-v.next_in_index,v.next_in_index=A,r.write=k,r.inflate_flush(v,b);b=0,y--,E|=(255&v.read_byte(A++))<<D,D+=8;}if(E>>=t[1+(m=3*(o+(E&u[x])))],D-=t[m+1],0!=(16&(g=t[m]))){f=15&g,d=t[m+2],e=4;break}if(0==(64&g)){s=g,o=m/3+t[m+2];break}return e=9,v.msg="invalid distance code",b=-3,r.bitb=E,r.bitk=D,v.avail_in=y,v.total_in+=A-v.next_in_index,v.next_in_index=A,r.write=k,r.inflate_flush(v,b);case 4:for(x=f;D<x;){if(0===y)return r.bitb=E,r.bitk=D,v.avail_in=y,v.total_in+=A-v.next_in_index,v.next_in_index=A,r.write=k,r.inflate_flush(v,b);b=0,y--,E|=(255&v.read_byte(A++))<<D,D+=8;}d+=E&u[x],E>>=x,D-=x,e=5;case 5:for(z=k-d;z<0;)z+=r.end;for(;0!==a;){if(0===U&&(k==r.end&&0!==r.read&&(U=(k=0)<r.read?r.read-k-1:r.end-k),0===U&&(r.write=k,b=r.inflate_flush(v,b),U=(k=r.write)<r.read?r.read-k-1:r.end-k,k==r.end&&0!==r.read&&(U=(k=0)<r.read?r.read-k-1:r.end-k),0===U)))return r.bitb=E,r.bitk=D,v.avail_in=y,v.total_in+=A-v.next_in_index,v.next_in_index=A,r.write=k,r.inflate_flush(v,b);r.window[k++]=r.window[z++],U--,z==r.end&&(z=0),a--;}e=0;break;case 6:if(0===U&&(k==r.end&&0!==r.read&&(U=(k=0)<r.read?r.read-k-1:r.end-k),0===U&&(r.write=k,b=r.inflate_flush(v,b),U=(k=r.write)<r.read?r.read-k-1:r.end-k,k==r.end&&0!==r.read&&(U=(k=0)<r.read?r.read-k-1:r.end-k),0===U)))return r.bitb=E,r.bitk=D,v.avail_in=y,v.total_in+=A-v.next_in_index,v.next_in_index=A,r.write=k,r.inflate_flush(v,b);b=0,r.window[k++]=l,U--,e=0;break;case 7:if(D>7&&(D-=8,y++,A--),r.write=k,b=r.inflate_flush(v,b),U=(k=r.write)<r.read?r.read-k-1:r.end-k,r.read!=r.write)return r.bitb=E,r.bitk=D,v.avail_in=y,v.total_in+=A-v.next_in_index,v.next_in_index=A,r.write=k,r.inflate_flush(v,b);e=8;case 8:return b=1,r.bitb=E,r.bitk=D,v.avail_in=y,v.total_in+=A-v.next_in_index,v.next_in_index=A,r.write=k,r.inflate_flush(v,b);case 9:return b=-3,r.bitb=E,r.bitk=D,v.avail_in=y,v.total_in+=A-v.next_in_index,v.next_in_index=A,r.write=k,r.inflate_flush(v,b);default:return b=-2,r.bitb=E,r.bitk=D,v.avail_in=y,v.total_in+=A-v.next_in_index,v.next_in_index=A,r.write=k,r.inflate_flush(v,b)}},r.free=function(){};}v.inflate_trees_fixed=function(e,t,n,i){return e[0]=9,t[0]=5,n[0]=d,i[0]=c,0};var x=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];function m(e,t){var n,i=this,r=0,a=0,o=0,s=0,l=[0],f=[0],d=new b,c=0,_=new Int32Array(4320),h=new v;i.bitk=0,i.bitb=0,i.window=new Uint8Array(t),i.end=t,i.read=0,i.write=0,i.reset=function(e,t){t&&(t[0]=0),6==r&&d.free(e),r=0,i.bitk=0,i.bitb=0,i.read=i.write=0;},i.reset(e,null),i.inflate_flush=function(e,t){var n,r,a;return r=e.next_out_index,(n=((a=i.read)<=i.write?i.write:i.end)-a)>e.avail_out&&(n=e.avail_out),0!==n&&-5==t&&(t=0),e.avail_out-=n,e.total_out+=n,e.next_out.set(i.window.subarray(a,a+n),r),r+=n,(a+=n)==i.end&&(a=0,i.write==i.end&&(i.write=0),(n=i.write-a)>e.avail_out&&(n=e.avail_out),0!==n&&-5==t&&(t=0),e.avail_out-=n,e.total_out+=n,e.next_out.set(i.window.subarray(a,a+n),r),r+=n,a+=n),e.next_out_index=r,i.read=a,t},i.proc=function(e,t){var p,w,b,m,g,y,k,U;for(m=e.next_in_index,g=e.avail_in,w=i.bitb,b=i.bitk,k=(y=i.write)<i.read?i.read-y-1:i.end-y;;)switch(r){case 0:for(;b<3;){if(0===g)return i.bitb=w,i.bitk=b,e.avail_in=g,e.total_in+=m-e.next_in_index,e.next_in_index=m,i.write=y,i.inflate_flush(e,t);t=0,g--,w|=(255&e.read_byte(m++))<<b,b+=8;}switch(c=1&(p=7&w),p>>>1){case 0:w>>>=3,w>>>=p=7&(b-=3),b-=p,r=1;break;case 1:var z=[],E=[],D=[[]],A=[[]];v.inflate_trees_fixed(z,E,D,A),d.init(z[0],E[0],D[0],0,A[0],0),w>>>=3,b-=3,r=6;break;case 2:w>>>=3,b-=3,r=3;break;case 3:return w>>>=3,b-=3,r=9,e.msg="invalid block type",t=-3,i.bitb=w,i.bitk=b,e.avail_in=g,e.total_in+=m-e.next_in_index,e.next_in_index=m,i.write=y,i.inflate_flush(e,t)}break;case 1:for(;b<32;){if(0===g)return i.bitb=w,i.bitk=b,e.avail_in=g,e.total_in+=m-e.next_in_index,e.next_in_index=m,i.write=y,i.inflate_flush(e,t);t=0,g--,w|=(255&e.read_byte(m++))<<b,b+=8;}if((~w>>>16&65535)!=(65535&w))return r=9,e.msg="invalid stored block lengths",t=-3,i.bitb=w,i.bitk=b,e.avail_in=g,e.total_in+=m-e.next_in_index,e.next_in_index=m,i.write=y,i.inflate_flush(e,t);a=65535&w,w=b=0,r=0!==a?2:0!==c?7:0;break;case 2:if(0===g)return i.bitb=w,i.bitk=b,e.avail_in=g,e.total_in+=m-e.next_in_index,e.next_in_index=m,i.write=y,i.inflate_flush(e,t);if(0===k&&(y==i.end&&0!==i.read&&(k=(y=0)<i.read?i.read-y-1:i.end-y),0===k&&(i.write=y,t=i.inflate_flush(e,t),k=(y=i.write)<i.read?i.read-y-1:i.end-y,y==i.end&&0!==i.read&&(k=(y=0)<i.read?i.read-y-1:i.end-y),0===k)))return i.bitb=w,i.bitk=b,e.avail_in=g,e.total_in+=m-e.next_in_index,e.next_in_index=m,i.write=y,i.inflate_flush(e,t);if(t=0,(p=a)>g&&(p=g),p>k&&(p=k),i.window.set(e.read_buf(m,p),y),m+=p,g-=p,y+=p,k-=p,0!=(a-=p))break;r=0!==c?7:0;break;case 3:for(;b<14;){if(0===g)return i.bitb=w,i.bitk=b,e.avail_in=g,e.total_in+=m-e.next_in_index,e.next_in_index=m,i.write=y,i.inflate_flush(e,t);t=0,g--,w|=(255&e.read_byte(m++))<<b,b+=8;}if(o=p=16383&w,(31&p)>29||(p>>5&31)>29)return r=9,e.msg="too many length or distance symbols",t=-3,i.bitb=w,i.bitk=b,e.avail_in=g,e.total_in+=m-e.next_in_index,e.next_in_index=m,i.write=y,i.inflate_flush(e,t);if(p=258+(31&p)+(p>>5&31),!n||n.length<p)n=[];else for(U=0;U<p;U++)n[U]=0;w>>>=14,b-=14,s=0,r=4;case 4:for(;s<4+(o>>>10);){for(;b<3;){if(0===g)return i.bitb=w,i.bitk=b,e.avail_in=g,e.total_in+=m-e.next_in_index,e.next_in_index=m,i.write=y,i.inflate_flush(e,t);t=0,g--,w|=(255&e.read_byte(m++))<<b,b+=8;}n[x[s++]]=7&w,w>>>=3,b-=3;}for(;s<19;)n[x[s++]]=0;if(l[0]=7,0!=(p=h.inflate_trees_bits(n,l,f,_,e)))return -3==(t=p)&&(n=null,r=9),i.bitb=w,i.bitk=b,e.avail_in=g,e.total_in+=m-e.next_in_index,e.next_in_index=m,i.write=y,i.inflate_flush(e,t);s=0,r=5;case 5:for(;!(s>=258+(31&(p=o))+(p>>5&31));){var S,R;for(p=l[0];b<p;){if(0===g)return i.bitb=w,i.bitk=b,e.avail_in=g,e.total_in+=m-e.next_in_index,e.next_in_index=m,i.write=y,i.inflate_flush(e,t);t=0,g--,w|=(255&e.read_byte(m++))<<b,b+=8;}if((R=_[3*(f[0]+(w&u[p=_[3*(f[0]+(w&u[p]))+1]]))+2])<16)w>>>=p,b-=p,n[s++]=R;else {for(U=18==R?7:R-14,S=18==R?11:3;b<p+U;){if(0===g)return i.bitb=w,i.bitk=b,e.avail_in=g,e.total_in+=m-e.next_in_index,e.next_in_index=m,i.write=y,i.inflate_flush(e,t);t=0,g--,w|=(255&e.read_byte(m++))<<b,b+=8;}if(b-=p,S+=(w>>>=p)&u[U],w>>>=U,b-=U,(U=s)+S>258+(31&(p=o))+(p>>5&31)||16==R&&U<1)return n=null,r=9,e.msg="invalid bit length repeat",t=-3,i.bitb=w,i.bitk=b,e.avail_in=g,e.total_in+=m-e.next_in_index,e.next_in_index=m,i.write=y,i.inflate_flush(e,t);R=16==R?n[U-1]:0;do{n[U++]=R;}while(0!=--S);s=U;}}f[0]=-1;var F=[],T=[],W=[],M=[];if(F[0]=9,T[0]=6,0!=(p=h.inflate_trees_dynamic(257+(31&(p=o)),1+(p>>5&31),n,F,T,W,M,_,e)))return -3==p&&(n=null,r=9),t=p,i.bitb=w,i.bitk=b,e.avail_in=g,e.total_in+=m-e.next_in_index,e.next_in_index=m,i.write=y,i.inflate_flush(e,t);d.init(F[0],T[0],_,W[0],_,M[0]),r=6;case 6:if(i.bitb=w,i.bitk=b,e.avail_in=g,e.total_in+=m-e.next_in_index,e.next_in_index=m,i.write=y,1!=(t=d.proc(i,e,t)))return i.inflate_flush(e,t);if(t=0,d.free(e),m=e.next_in_index,g=e.avail_in,w=i.bitb,b=i.bitk,k=(y=i.write)<i.read?i.read-y-1:i.end-y,0===c){r=0;break}r=7;case 7:if(i.write=y,t=i.inflate_flush(e,t),k=(y=i.write)<i.read?i.read-y-1:i.end-y,i.read!=i.write)return i.bitb=w,i.bitk=b,e.avail_in=g,e.total_in+=m-e.next_in_index,e.next_in_index=m,i.write=y,i.inflate_flush(e,t);r=8;case 8:return t=1,i.bitb=w,i.bitk=b,e.avail_in=g,e.total_in+=m-e.next_in_index,e.next_in_index=m,i.write=y,i.inflate_flush(e,t);case 9:return t=-3,i.bitb=w,i.bitk=b,e.avail_in=g,e.total_in+=m-e.next_in_index,e.next_in_index=m,i.write=y,i.inflate_flush(e,t);default:return t=-2,i.bitb=w,i.bitk=b,e.avail_in=g,e.total_in+=m-e.next_in_index,e.next_in_index=m,i.write=y,i.inflate_flush(e,t)}},i.free=function(e){i.reset(e,null),i.window=null,_=null;},i.set_dictionary=function(e,t,n){i.window.set(e.subarray(t,t+n),0),i.read=i.write=n;},i.sync_point=function(){return 1==r?1:0};}var g=[0,0,255,255];function y(){var e=this;function t(e){return e&&e.istate?(e.total_in=e.total_out=0,e.msg=null,e.istate.mode=7,e.istate.blocks.reset(e,null),0):-2}e.mode=0,e.method=0,e.was=[0],e.need=0,e.marker=0,e.wbits=0,e.inflateEnd=function(t){return e.blocks&&e.blocks.free(t),e.blocks=null,0},e.inflateInit=function(n,i){return n.msg=null,e.blocks=null,i<8||i>15?(e.inflateEnd(n),-2):(e.wbits=i,n.istate.blocks=new m(n,1<<i),t(n),0)},e.inflate=function(e,t){var n,i;if(!e||!e.istate||!e.next_in)return -2;for(t=4==t?-5:0,n=-5;;)switch(e.istate.mode){case 0:if(0===e.avail_in)return n;if(n=t,e.avail_in--,e.total_in++,8!=(15&(e.istate.method=e.read_byte(e.next_in_index++)))){e.istate.mode=13,e.msg="unknown compression method",e.istate.marker=5;break}if(8+(e.istate.method>>4)>e.istate.wbits){e.istate.mode=13,e.msg="invalid window size",e.istate.marker=5;break}e.istate.mode=1;case 1:if(0===e.avail_in)return n;if(n=t,e.avail_in--,e.total_in++,i=255&e.read_byte(e.next_in_index++),((e.istate.method<<8)+i)%31!=0){e.istate.mode=13,e.msg="incorrect header check",e.istate.marker=5;break}if(0==(32&i)){e.istate.mode=7;break}e.istate.mode=2;case 2:if(0===e.avail_in)return n;n=t,e.avail_in--,e.total_in++,e.istate.need=(255&e.read_byte(e.next_in_index++))<<24&4278190080,e.istate.mode=3;case 3:if(0===e.avail_in)return n;n=t,e.avail_in--,e.total_in++,e.istate.need+=(255&e.read_byte(e.next_in_index++))<<16&16711680,e.istate.mode=4;case 4:if(0===e.avail_in)return n;n=t,e.avail_in--,e.total_in++,e.istate.need+=(255&e.read_byte(e.next_in_index++))<<8&65280,e.istate.mode=5;case 5:return 0===e.avail_in?n:(n=t,e.avail_in--,e.total_in++,e.istate.need+=255&e.read_byte(e.next_in_index++),e.istate.mode=6,2);case 6:return e.istate.mode=13,e.msg="need dictionary",e.istate.marker=0,-2;case 7:if(-3==(n=e.istate.blocks.proc(e,n))){e.istate.mode=13,e.istate.marker=0;break}if(0==n&&(n=t),1!=n)return n;n=t,e.istate.blocks.reset(e,e.istate.was),e.istate.mode=12;case 12:return 1;case 13:return -3;default:return -2}},e.inflateSetDictionary=function(e,t,n){var i=0,r=n;return e&&e.istate&&6==e.istate.mode?(r>=1<<e.istate.wbits&&(i=n-(r=(1<<e.istate.wbits)-1)),e.istate.blocks.set_dictionary(t,i,r),e.istate.mode=7,0):-2},e.inflateSync=function(e){var n,i,r,a,o;if(!e||!e.istate)return -2;if(13!=e.istate.mode&&(e.istate.mode=13,e.istate.marker=0),0===(n=e.avail_in))return -5;for(i=e.next_in_index,r=e.istate.marker;0!==n&&r<4;)e.read_byte(i)==g[r]?r++:r=0!==e.read_byte(i)?0:4-r,i++,n--;return e.total_in+=i-e.next_in_index,e.next_in_index=i,e.avail_in=n,e.istate.marker=r,4!=r?-3:(a=e.total_in,o=e.total_out,t(e),e.total_in=a,e.total_out=o,e.istate.mode=7,0)},e.inflateSyncPoint=function(e){return e&&e.istate&&e.istate.blocks?e.istate.blocks.sync_point():-2};}function k(){}function U(){var e=new k,t=new Uint8Array(512),n=!1;e.inflateInit(),e.next_out=t,this.append=function(i,r){var a,o,s=[],l=0,f=0,u=0;if(0!==i.length){e.next_in_index=0,e.next_in=i,e.avail_in=i.length;do{if(e.next_out_index=0,e.avail_out=512,0!==e.avail_in||n||(e.next_in_index=0,n=!0),a=e.inflate(0),n&&-5===a){if(0!==e.avail_in)throw new Error("inflating: bad input")}else if(0!==a&&1!==a)throw new Error("inflating: "+e.msg);if((n||1===a)&&e.avail_in===i.length)throw new Error("inflating: bad input");e.next_out_index&&s.push(512===e.next_out_index?new Uint8Array(t):new Uint8Array(t.subarray(0,e.next_out_index))),u+=e.next_out_index,r&&e.next_in_index>0&&e.next_in_index!=l&&(r(e.next_in_index),l=e.next_in_index);}while(e.avail_in>0||0===e.avail_out);return o=new Uint8Array(u),s.forEach(function(e){o.set(e,f),f+=e.length;}),o}},this.flush=function(){e.inflateEnd();};}k.prototype={inflateInit:function(e){var t=this;return t.istate=new y,e||(e=15),t.istate.inflateInit(t,e)},inflate:function(e){var t=this;return t.istate?t.istate.inflate(t,e):-2},inflateEnd:function(){var e=this;if(!e.istate)return -2;var t=e.istate.inflateEnd(e);return e.istate=null,t},inflateSync:function(){var e=this;return e.istate?e.istate.inflateSync(e):-2},inflateSetDictionary:function(e,t){var n=this;return n.istate?n.istate.inflateSetDictionary(n,e,t):-2},read_byte:function(e){return this.next_in.subarray(e,e+1)[0]},read_buf:function(e,t){return this.next_in.subarray(e,e+t)}},self._zipjs_Inflater=U;var z,E="File format is not recognized.",D="Error while reading zip file.";try{z=0===new Blob([new DataView(new ArrayBuffer(0))]).size;}catch(e){}function A(){this.crc=-1;}function S(){}function R(e,t){var n,i;return n=new ArrayBuffer(e),i=new Uint8Array(n),t&&i.set(t,0),{buffer:n,array:i,view:new DataView(n)}}function F(){}function T(e){var t,n=this;n.size=0,n.init=function(i,r){var a=new Blob([e],{type:"text/plain"});(t=new M(a)).init(function(){n.size=t.size,i();},r);},n.readUint8Array=function(e,n,i,r){t.readUint8Array(e,n,i,r);};}function W(e){var t,n=this;n.size=0,n.init=function(i){for(var r=e.length;"="==e.charAt(r-1);)r--;t=e.indexOf(",")+1,n.size=Math.floor(.75*(r-t)),i();},n.readUint8Array=function(n,i,r){var a,o=R(i),s=4*Math.floor(n/3),l=4*Math.ceil((n+i)/3),f=self.atob(e.substring(s+t,l+t)),u=n-3*Math.floor(s/4);for(a=u;a<u+i;a++)o.array[a-u]=f.charCodeAt(a);r(o.array);};}function M(e){var t=this;t.size=0,t.init=function(n){t.size=e.size,n();},t.readUint8Array=function(t,n,i,r){var a=new FileReader;a.onload=function(e){i(new Uint8Array(e.target.result));},a.onerror=r;try{a.readAsArrayBuffer(function(e,t,n){if(t<0||n<0||t+n>e.size)throw new RangeError("offset:"+t+", length:"+n+", size:"+e.size);return e.slice?e.slice(t,t+n):e.webkitSlice?e.webkitSlice(t,t+n):e.mozSlice?e.mozSlice(t,t+n):e.msSlice?e.msSlice(t,t+n):void 0}(e,t,n));}catch(e){r(e);}};}function B(){}function I(e){var t,n=this;n.init=function(e){t=new Blob([],{type:"text/plain"}),e();},n.writeUint8Array=function(e,n){t=new Blob([t,z?e:e.buffer],{type:"text/plain"}),n();},n.getData=function(n,i){var r=new FileReader;r.onload=function(e){n(e.target.result);},r.onerror=i,r.readAsText(t,e);};}function C(e){var t=this,n="",i="";t.init=function(t){n+="data:"+(e||"")+";base64,",t();},t.writeUint8Array=function(e,t){var r,a=i.length,o=i;for(i="",r=0;r<3*Math.floor((a+e.length)/3)-a;r++)o+=String.fromCharCode(e[r]);for(;r<e.length;r++)i+=String.fromCharCode(e[r]);o.length>2?n+=self.btoa(o):i=o,t();},t.getData=function(e){e(n+self.btoa(i));};}function L(e){var t,n=this;n.init=function(n){t=new Blob([],{type:e}),n();},n.writeUint8Array=function(n,i){t=new Blob([t,z?n:n.buffer],{type:e}),i();},n.getData=function(e){e(t);};}function P(e,t,n,i,r,a,o,s,l,f){var u,d,c,_=0,h=t.sn;function p(){e.removeEventListener("message",w,!1),s(d,c);}function w(t){var n=t.data,r=n.data,s=n.error;if(s)return s.toString=function(){return "Error: "+this.message},void l(s);if(n.sn===h)switch("number"==typeof n.codecTime&&(e.codecTime+=n.codecTime),"number"==typeof n.crcTime&&(e.crcTime+=n.crcTime),n.type){case"append":r?(d+=r.length,i.writeUint8Array(r,function(){v();},f)):v();break;case"flush":c=n.crc,r?(d+=r.length,i.writeUint8Array(r,function(){p();},f)):p();break;case"progress":o&&o(u+n.loaded,a);break;case"importScripts":case"newTask":case"echo":break;default:console.warn("zip.js:launchWorkerProcess: unknown message: ",n);}}function v(){(u=524288*_)<=a?n.readUint8Array(r+u,Math.min(524288,a-u),function(n){o&&o(u,a);var i=0===u?t:{sn:h};i.type="append",i.data=n;try{e.postMessage(i,[n.buffer]);}catch(t){e.postMessage(i);}_++;},l):e.postMessage({sn:h,type:"flush"});}d=0,e.addEventListener("message",w,!1),v();}function Z(e,t,n,i,r,a,o,s,l,f){var u,d=0,c=0,_="input"===a,h="output"===a,p=new A;!function a(){var w;if((u=524288*d)<r)t.readUint8Array(i+u,Math.min(524288,r-u),function(t){var i;try{i=e.append(t,function(e){o&&o(u+e,r);});}catch(e){return void l(e)}i?(c+=i.length,n.writeUint8Array(i,function(){d++,setTimeout(a,1);},f),h&&p.append(i)):(d++,setTimeout(a,1)),_&&p.append(t),o&&o(u,r);},l);else {try{w=e.flush();}catch(e){return void l(e)}w?(h&&p.append(w),c+=w.length,n.writeUint8Array(w,function(){s(c,p.get());},f)):s(c,p.get());}}();}function N(e,t,n,i,r,a,o,s,l,f,u){var d="input";K.useWebWorkers&&o?P(e,{sn:t,codecClass:"_zipjs_NOOP",crcType:d},n,i,r,a,l,s,f,u):Z(new S,n,i,r,a,d,l,s,f,u);}function j(e){var t,n,i="",r=["Ç","ü","é","â","ä","à","å","ç","ê","ë","è","ï","î","ì","Ä","Å","É","æ","Æ","ô","ö","ò","û","ù","ÿ","Ö","Ü","ø","£","Ø","×","ƒ","á","í","ó","ú","ñ","Ñ","ª","º","¿","®","¬","½","¼","¡","«","»","_","_","_","¦","¦","Á","Â","À","©","¦","¦","+","+","¢","¥","+","+","-","-","+","-","+","ã","Ã","+","+","-","-","¦","-","+","¤","ð","Ð","Ê","Ë","È","i","Í","Î","Ï","+","+","_","_","¦","Ì","_","Ó","ß","Ô","Ò","õ","Õ","µ","þ","Þ","Ú","Û","Ù","ý","Ý","¯","´","­","±","_","¾","¶","§","÷","¸","°","¨","·","¹","³","²","_"," "];for(t=0;t<e.length;t++)i+=(n=255&e.charCodeAt(t))>127?r[n-128]:String.fromCharCode(n);return i}function O(e){return decodeURIComponent(escape(e))}function V(e){var t,n="";for(t=0;t<e.length;t++)n+=String.fromCharCode(e[t]);return n}function q(e,t,n,i,r){e.version=t.view.getUint16(n,!0),e.bitFlag=t.view.getUint16(n+2,!0),e.compressionMethod=t.view.getUint16(n+4,!0),e.lastModDateRaw=t.view.getUint32(n+6,!0),e.lastModDate=function(e){var t=(4294901760&e)>>16,n=65535&e;try{return new Date(1980+((65024&t)>>9),((480&t)>>5)-1,31&t,(63488&n)>>11,(2016&n)>>5,2*(31&n),0)}catch(e){}}(e.lastModDateRaw),1!=(1&e.bitFlag)?((i||8!=(8&e.bitFlag))&&(e.crc32=t.view.getUint32(n+10,!0),e.compressedSize=t.view.getUint32(n+14,!0),e.uncompressedSize=t.view.getUint32(n+18,!0)),4294967295!==e.compressedSize&&4294967295!==e.uncompressedSize?(e.filenameLength=t.view.getUint16(n+22,!0),e.extraFieldLength=t.view.getUint16(n+24,!0)):r("File is using Zip64 (4gb+ file size).")):r("File contains encrypted entry.");}function $(e){return unescape(encodeURIComponent(e))}function G(e){var t,n=[];for(t=0;t<e.length;t++)n.push(e.charCodeAt(t));return n}A.prototype.append=function(e){for(var t=0|this.crc,n=this.table,i=0,r=0|e.length;i<r;i++)t=t>>>8^n[255&(t^e[i])];this.crc=t;},A.prototype.get=function(){return ~this.crc},A.prototype.table=function(){var e,t,n,i=[];for(e=0;e<256;e++){for(n=e,t=0;t<8;t++)1&n?n=n>>>1^3988292384:n>>>=1;i[e]=n;}return i}(),S.prototype.append=function(e,t){return e},S.prototype.flush=function(){},(T.prototype=new F).constructor=T,(W.prototype=new F).constructor=W,(M.prototype=new F).constructor=M,B.prototype.getData=function(e){e(this.data);},(I.prototype=new B).constructor=I,(C.prototype=new B).constructor=C,(L.prototype=new B).constructor=L;var H={deflater:["z-worker.js","deflate.js"],inflater:["z-worker.js","inflate.js"]};function Y(e,t,n){if(null===K.workerScripts||null===K.workerScriptsPath){var i,r,a;if(K.workerScripts){if(i=K.workerScripts[e],!Array.isArray(i))return void n(new Error("zip.workerScripts."+e+" is not an array!"));r=i,a=document.createElement("a"),i=r.map(function(e){return a.href=e,a.href});}else (i=H[e].slice(0))[0]=(K.workerScriptsPath||"")+i[0];var o=new Worker(i[0]);o.codecTime=o.crcTime=0,o.postMessage({type:"importScripts",scripts:i.slice(1)}),o.addEventListener("message",function e(i){var r=i.data;if(r.error)return o.terminate(),void n(r.error);"importScripts"===r.type&&(o.removeEventListener("message",e),o.removeEventListener("error",s),t(o));}),o.addEventListener("error",s);}else n(new Error("Either zip.workerScripts or zip.workerScriptsPath may be set, not both."));function s(e){o.terminate(),n(e);}}function J(e){console.error(e);}const K={Reader:F,Writer:B,BlobReader:M,Data64URIReader:W,TextReader:T,BlobWriter:L,Data64URIWriter:C,TextWriter:I,createReader:function(e,t,n){e.init(function(){!function(e,t,n){var i=0;function r(){}r.prototype.getData=function(t,r,a,o){var s=this;function l(e,i){o&&!function(e){var t=R(4);return t.view.setUint32(0,e),s.crc32==t.view.getUint32(0)}(i)?n("CRC failed."):t.getData(function(e){r(e);});}function f(e){n(e||"Error while reading file data.");}function u(e){n(e||"Error while writing file data.");}e.readUint8Array(s.offset,30,function(r){var d,c=R(r.length,r);1347093252==c.view.getUint32(0)?(q(s,c,4,!1,n),d=s.offset+30+s.filenameLength+s.extraFieldLength,t.init(function(){0===s.compressionMethod?N(s._worker,i++,e,t,d,s.compressedSize,o,l,a,f,u):function(e,t,n,i,r,a,o,s,l,f,u){var d=o?"output":"none";K.useWebWorkers?P(e,{sn:t,codecClass:"_zipjs_Inflater",crcType:d},n,i,r,a,l,s,f,u):Z(new U,n,i,r,a,d,l,s,f,u);}(s._worker,i++,e,t,d,s.compressedSize,o,l,a,f,u);},u)):n(E);},f);};var a={getEntries:function(t){var i=this._worker;!function(t){function i(i,r){e.readUint8Array(e.size-i,i,function(e){for(var n=e.length-22;n>=0;n--)if(80===e[n]&&75===e[n+1]&&5===e[n+2]&&6===e[n+3])return void t(new DataView(e.buffer,n,22));r();},function(){n(D);});}e.size<22?n(E):i(22,function(){i(Math.min(65558,e.size),function(){n(E);});});}(function(a){var o,s;o=a.getUint32(16,!0),s=a.getUint16(8,!0),o<0||o>=e.size?n(E):e.readUint8Array(o,e.size-o,function(e){var a,o,l,f,u=0,d=[],c=R(e.length,e);for(a=0;a<s;a++){if((o=new r)._worker=i,1347092738!=c.view.getUint32(u))return void n(E);q(o,c,u+6,!0,n),o.commentLength=c.view.getUint16(u+32,!0),o.directory=16==(16&c.view.getUint8(u+38)),o.offset=c.view.getUint32(u+42,!0),l=V(c.array.subarray(u+46,u+46+o.filenameLength)),o.filename=2048==(2048&o.bitFlag)?O(l):j(l),o.directory||"/"!=o.filename.charAt(o.filename.length-1)||(o.directory=!0),f=V(c.array.subarray(u+46+o.filenameLength+o.extraFieldLength,u+46+o.filenameLength+o.extraFieldLength+o.commentLength)),o.comment=2048==(2048&o.bitFlag)?O(f):j(f),d.push(o),u+=46+o.filenameLength+o.extraFieldLength+o.commentLength;}t(d);},function(){n(D);});});},close:function(e){this._worker&&(this._worker.terminate(),this._worker=null),e&&e();},_worker:null};K.useWebWorkers?Y("inflater",function(e){a._worker=e,t(a);},function(e){n(e);}):t(a);}(e,t,n);},n=n||J);},createWriter:function(e,t,n,i){i=!!i,e.init(function(){!function(e,t,n,i){var r={},a=[],o=0,s=0;function l(e){n(e||"Error while writing zip file.");}function u(e){n(e||"Error while reading file data.");}var d={add:function(t,d,c,_,h){var p,w,v,b=this._worker;function x(t,n){var i=R(16);o+=t||0,i.view.setUint32(0,1347094280),void 0!==n&&(p.view.setUint32(10,n,!0),i.view.setUint32(4,n,!0)),d&&(i.view.setUint32(8,t,!0),p.view.setUint32(14,t,!0),i.view.setUint32(12,d.size,!0),p.view.setUint32(18,d.size,!0)),e.writeUint8Array(i.array,function(){o+=16,c();},l);}function m(){var c;h=h||{},t=t.trim(),h.directory&&"/"!=t.charAt(t.length-1)&&(t+="/"),r.hasOwnProperty(t)?n("File already exists."):(w=G($(t)),a.push(t),v=h.lastModDate||new Date,p=R(26),r[t]={headerArray:p.array,directory:h.directory,filename:w,offset:o,comment:G($(h.comment||""))},p.view.setUint32(0,335546376),h.version&&p.view.setUint8(0,h.version),i||0===h.level||h.directory||p.view.setUint16(4,2048),p.view.setUint16(6,(v.getHours()<<6|v.getMinutes())<<5|v.getSeconds()/2,!0),p.view.setUint16(8,(v.getFullYear()-1980<<4|v.getMonth()+1)<<5|v.getDate(),!0),p.view.setUint16(22,w.length,!0),(c=R(30+w.length)).view.setUint32(0,1347093252),c.array.set(p.array,4),c.array.set(w,30),o+=c.array.length,e.writeUint8Array(c.array,function(){d?i||0===h.level?N(b,s++,d,e,0,d.size,!0,x,_,u,l):function(e,t,n,i,r,a,o,s,l){var u="input";K.useWebWorkers?P(e,{sn:t,options:{level:r},codecClass:"_zipjs_Deflater",crcType:u},n,i,0,n.size,o,a,s,l):Z(new f,n,i,0,n.size,u,o,a,s,l);}(b,s++,d,e,h.level,x,_,u,l):x();},l));}d?d.init(m,u):m();},close:function(t){this._worker&&(this._worker.terminate(),this._worker=null);var n,i,s,f=0,u=0;for(i=0;i<a.length;i++)f+=46+(s=r[a[i]]).filename.length+s.comment.length;for(n=R(f+22),i=0;i<a.length;i++)s=r[a[i]],n.view.setUint32(u,1347092738),n.view.setUint16(u+4,5120),n.array.set(s.headerArray,u+6),n.view.setUint16(u+32,s.comment.length,!0),s.directory&&n.view.setUint8(u+38,16),n.view.setUint32(u+42,s.offset,!0),n.array.set(s.filename,u+46),n.array.set(s.comment,u+46+s.filename.length),u+=46+s.filename.length+s.comment.length;n.view.setUint32(u,1347093766),n.view.setUint16(u+8,a.length,!0),n.view.setUint16(u+10,a.length,!0),n.view.setUint32(u+12,f,!0),n.view.setUint32(u+16,o,!0),e.writeUint8Array(n.array,function(){e.getData(t);},l);},_worker:null};K.useWebWorkers?Y("deflater",function(e){d._worker=e,t(d);},function(e){n(e);}):t(d);}(e,t,n,i);},n=n||J);},useWebWorkers:!0,workerScriptsPath:null,workerScripts:null};var Q,X,ee=K.TextWriter,te=K.BlobWriter,ne=K.Data64URIWriter,ie=K.TextReader,re=K.BlobReader,ae=K.Data64URIReader,oe=K.createReader,se=K.createWriter;function le(e){var t,n=this;n.size=0,n.init=function(t){n.size=e.uncompressedSize,t();},n.readUint8Array=function(i,r,a,o){!function(i){n.data?i():e.getData(new te,function(e){n.data=e,t=new re(e),i();},null,n.checkCrc32);}(function(){t.readUint8Array(i,r,a,o);});};}function fe(e){var t=0;return function e(n){t+=n.uncompressedSize||0,n.children.forEach(e);}(e),t}function ue(e,t,n){var i=0;function r(){++i<e.children.length?a(e.children[i]):t();}function a(e){e.directory?ue(e,r,n):(e.reader=new e.Reader(e.data,n),e.reader.init(function(){e.uncompressedSize=e.reader.size,r();}));}e.children.length?a(e.children[i]):t();}function de(e){var t=e.parent.children;t.forEach(function(n,i){n.id==e.id&&t.splice(i,1);});}function ce(e){e.entries=[],e.root=new we(e);}function _e(e,t,n,i){if(e.directory)return i?new we(e.fs,t,n,e):new pe(e.fs,t,n,e);throw "Parent entry is not a directory."}function he(){}function pe(e,t,n,i){var r=this;he.prototype.init.call(r,e,t,n,i),r.Reader=n.Reader,r.Writer=n.Writer,r.data=n.data,n.getData&&(r.getData=n.getData);}function we(e,t,n,i){he.prototype.init.call(this,e,t,n,i),this.directory=!0;}function ve(){ce(this);}(le.prototype=new(K.Reader)).constructor=le,le.prototype.checkCrc32=!1,(he.prototype={init:function(e,t,n,i){var r=this;if(e.root&&i&&i.getChildByName(t))throw "Entry filename already exists.";n||(n={}),r.fs=e,r.name=t,r.id=e.entries.length,r.parent=i,r.children=[],r.zipVersion=n.zipVersion||20,r.uncompressedSize=0,e.entries.push(r),i&&r.parent.children.push(r);},getFileEntry:function(e,t,n,i,r){var a=this;ue(a,function(){!function(e,t,n,i,r,a,o){var s=0;t.directory?function e(t,n,i,r,a,l){var f=0;!function u(){var d=n.children[f];d?function(n){function i(t){s+=n.uncompressedSize||0,e(t,n,function(){f++,u();},r,a,l);}n.directory?t.getDirectory(n.name,{create:!0},i,a):t.getFile(n.name,{create:!0},function(e){n.getData(new K.FileWriter(e,K.getMimeType(n.name)),i,function(e){r&&r(s+e,l);},o);},a);}(d):i();}();}(e,t,n,i,r,a):t.getData(new K.FileWriter(e,K.getMimeType(t.name)),n,i,o);}(e,a,t,n,i,fe(a),r);},i);},moveTo:function(e){var t=this;if(!e.directory)throw "Target entry is not a directory.";if(e.isDescendantOf(t))throw "Entry is a ancestor of target entry.";if(t!=e){if(e.getChildByName(t.name))throw "Entry filename already exists.";de(t),t.parent=e,e.children.push(t);}},getFullname:function(){for(var e=this.name,t=this.parent;t;)e=(t.name?t.name+"/":"")+e,t=t.parent;return e},isDescendantOf:function(e){for(var t=this.parent;t&&t.id!=e.id;)t=t.parent;return !!t}}).constructor=he,pe.prototype=Q=new he,Q.constructor=pe,Q.getData=function(e,t,n,i){var r=this;!e||e.constructor==r.Writer&&r.data?t(r.data):(r.reader||(r.reader=new r.Reader(r.data,i)),r.reader.init(function(){e.init(function(){!function(e,t,n,i,r){var a=0;!function o(){var s=524288*a;i&&i(s,e.size),s<e.size?e.readUint8Array(s,Math.min(524288,e.size-s),function(e){t.writeUint8Array(new Uint8Array(e),function(){a++,o();});},r):t.getData(n);}();}(r.reader,e,t,n,i);},i);}));},Q.getText=function(e,t,n,i){this.getData(new ee(i),e,t,n);},Q.getBlob=function(e,t,n,i){this.getData(new te(e),t,n,i);},Q.getData64URI=function(e,t,n,i){this.getData(new ne(e),t,n,i);},we.prototype=X=new he,X.constructor=we,X.addDirectory=function(e){return _e(this,e,null,!0)},X.addText=function(e,t){return _e(this,e,{data:t,Reader:ie,Writer:ee})},X.addBlob=function(e,t){return _e(this,e,{data:t,Reader:re,Writer:te})},X.addData64URI=function(e,t){return _e(this,e,{data:t,Reader:ae,Writer:ne})},X.addFileEntry=function(e,t,n){!function(e,t,n,i){t.isDirectory?function e(t,n,r){!function(e,t){e.isDirectory&&e.createReader().readEntries(t),e.isFile&&t([]);}(n,function(n){var a=0;!function o(){var s=n[a];s?function(n){function r(t){e(t,n,function(){a++,o();});}n.isDirectory&&r(t.addDirectory(n.name)),n.isFile&&n.file(function(e){var i=t.addBlob(n.name,e);i.uncompressedSize=e.size,r(i);},i);}(s):r();}();});}(e,t,n):t.file(function(i){e.addBlob(t.name,i),n();},i);}(this,e,t,n);},X.addData=function(e,t){return _e(this,e,t)},X.importBlob=function(e,t,n){this.importZip(new re(e),t,n);},X.importText=function(e,t,n){this.importZip(new ie(e),t,n);},X.importData64URI=function(e,t,n){this.importZip(new ae(e),t,n);},X.exportBlob=function(e,t,n){this.exportZip(new te("application/zip"),e,t,n);},X.exportText=function(e,t,n){this.exportZip(new ee,e,t,n);},X.exportFileEntry=function(e,t,n,i){this.exportZip(new K.FileWriter(e,"application/zip"),t,n,i);},X.exportData64URI=function(e,t,n){this.exportZip(new ne("application/zip"),e,t,n);},X.importZip=function(e,t,n){var i=this;oe(e,function(e){e.getEntries(function(e){e.forEach(function(e){var t=i,n=e.filename.split("/"),r=n.pop();n.forEach(function(e){t=t.getChildByName(e)||new we(i.fs,e,null,t);}),e.directory||_e(t,r,{data:e,Reader:le});}),t();});},n);},X.exportZip=function(e,t,n,i){var r=this;ue(r,function(){se(e,function(e){!function(e,t,n,i,r){var a=0;!function e(t,n,i,r,o){var s=0;!function l(){var f=n.children[s];f?t.add(f.getFullname(),f.reader,function(){a+=f.uncompressedSize||0,e(t,f,function(){s++,l();},r,o);},function(e){r&&r(a+e,o);},{directory:f.directory,version:f.zipVersion}):i();}();}(e,t,n,i,r);}(e,r,function(){e.close(t);},n,fe(r));},i);},i);},X.getChildByName=function(e){var t,n;for(t=0;t<this.children.length;t++)if((n=this.children[t]).name==e)return n},ve.prototype={remove:function(e){de(e),this.entries[e.id]=null;},find:function(e){var t,n=e.split("/"),i=this.root;for(t=0;i&&t<n.length;t++)i=i.getChildByName(n[t]);return i},getById:function(e){return this.entries[e]},importBlob:function(e,t,n){ce(this),this.root.importBlob(e,t,n);},importText:function(e,t,n){ce(this),this.root.importText(e,t,n);},importData64URI:function(e,t,n){ce(this),this.root.importData64URI(e,t,n);},exportBlob:function(e,t,n){this.root.exportBlob(e,t,n);},exportText:function(e,t,n){this.root.exportText(e,t,n);},exportFileEntry:function(e,t,n,i){this.root.exportFileEntry(e,t,n,i);},exportData64URI:function(e,t,n){this.root.exportData64URI(e,t,n);}},K.getMimeType=function(){return "application/octet-stream"};var be={FS:ve,ZipDirectoryEntry:we,ZipFileEntry:pe};K.useWebWorkers=!1;var xe=function(){function e(e,t){this.el=e,this.inputEl=t,this.listeners={drop:[],dropstart:[],droperror:[]},this._onDragover=this._onDragover.bind(this),this._onDrop=this._onDrop.bind(this),this._onSelect=this._onSelect.bind(this),e.addEventListener("dragover",this._onDragover,!1),e.addEventListener("drop",this._onDrop,!1),t.addEventListener("change",this._onSelect);}var t=e.prototype;return t.on=function(e,t){return this.listeners[e].push(t),this},t._emit=function(e,t){return this.listeners[e].forEach(function(e){return e(t)}),this},t.destroy=function(){var e=this.el,t=this.inputEl;e.removeEventListener("dragover",this._onDragover,!1),e.removeEventListener("drop",this._onDrop,!1),t.removeEventListener("change",this._onSelect),delete this.el,delete this.inputEl,delete this.listeners;},t._onDrop=function(e){e.stopPropagation(),e.preventDefault(),this._emit("dropstart");var t=Array.from(e.dataTransfer.files||[]),n=Array.from(e.dataTransfer.items||[]);if(0!==t.length||0!==n.length)if(n.length>0){var i=n.map(function(e){return e.webkitGetAsEntry()});i[0].name.match(/\.zip$/)?this._loadZip(n[0].getAsFile()):this._loadNextEntry(new Map,i);}else 1===t.length&&t[0].name.match(/\.zip$/)&&this._loadZip(t[0]),this._emit("drop",{files:new Map(t.map(function(e){return [e.name,e]}))});else this._fail("Required drag-and-drop APIs are not supported in this browser.");},t._onDragover=function(e){e.stopPropagation(),e.preventDefault(),e.dataTransfer.dropEffect="copy";},t._onSelect=function(e){this._emit("dropstart");var t=[].slice.call(this.inputEl.files);if(1===t.length&&this._isZip(t[0]))this._loadZip(t[0]);else {var n=new Map;t.forEach(function(e){return n.set(e.webkitRelativePath||e.name,e)}),this._emit("drop",{files:n});}},t._loadNextEntry=function(e,t){var n=this,i=t.pop();if(i)if(i.isFile)i.file(function(r){e.set(i.fullPath,r),n._loadNextEntry(e,t);},function(){return console.error("Could not load file: %s",i.fullPath)});else if(i.isDirectory){var r=i.createReader();r.readEntries(function i(a){a.length?(t=t.concat(a),r.readEntries(i)):n._loadNextEntry(e,t);});}else console.warn("Unknown asset type: "+i.fullPath),this._loadNextEntry(e,t);else this._emit("drop",{files:e});},t._loadZip=function(e){var t=this,n=[],i=new Map,r=new be.FS,a=function e(t){t.directory?t.children.forEach(e):"."!==t.name[0]&&n.push(new Promise(function(e){t.getData(new K.BlobWriter,function(n){n.name=t.name,i.set(t.getFullname(),n),e();});}));};r.importBlob(e,function(){a(r.root),Promise.all(n).then(function(){t._emit("drop",{files:i,archive:e});});});},t._isZip=function(e){return "application/zip"===e.type||e.name.match(/\.zip$/)},t._fail=function(e){this._emit("droperror",{message:e});},e}();

    /**
     * Common utilities
     * @module glMatrix
     */
    var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
    if (!Math.hypot) Math.hypot = function () {
      var y = 0,
          i = arguments.length;

      while (i--) {
        y += arguments[i] * arguments[i];
      }

      return Math.sqrt(y);
    };

    /**
     * 2 Dimensional Vector
     * @module vec2
     */

    /**
     * Creates a new, empty vec2
     *
     * @returns {vec2} a new 2D vector
     */

    function create() {
      var out = new ARRAY_TYPE(2);

      if (ARRAY_TYPE != Float32Array) {
        out[0] = 0;
        out[1] = 0;
      }

      return out;
    }
    /**
     * Creates a new vec2 initialized with the given values
     *
     * @param {Number} x X component
     * @param {Number} y Y component
     * @returns {vec2} a new 2D vector
     */

    function fromValues(x, y) {
      var out = new ARRAY_TYPE(2);
      out[0] = x;
      out[1] = y;
      return out;
    }
    /**
     * Calculates the euclidian distance between two vec2's
     *
     * @param {ReadonlyVec2} a the first operand
     * @param {ReadonlyVec2} b the second operand
     * @returns {Number} distance between a and b
     */

    function distance(a, b) {
      var x = b[0] - a[0],
          y = b[1] - a[1];
      return Math.hypot(x, y);
    }
    /**
     * Alias for {@link vec2.distance}
     * @function
     */

    var dist = distance;
    /**
     * Perform some operation over an array of vec2s.
     *
     * @param {Array} a the array of vectors to iterate over
     * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
     * @param {Number} offset Number of elements to skip at the beginning of the array
     * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
     * @param {Function} fn Function to call for each vector in the array
     * @param {Object} [arg] additional argument to pass to fn
     * @returns {Array} a
     * @function
     */

    var forEach = function () {
      var vec = create();
      return function (a, stride, offset, count, fn, arg) {
        var i, l;

        if (!stride) {
          stride = 2;
        }

        if (!offset) {
          offset = 0;
        }

        if (count) {
          l = Math.min(count * stride + offset, a.length);
        } else {
          l = a.length;
        }

        for (i = offset; i < l; i += stride) {
          vec[0] = a[i];
          vec[1] = a[i + 1];
          fn(vec, vec, arg);
          a[i] = vec[0];
          a[i + 1] = vec[1];
        }

        return a;
      };
    }();

    /**
     * Copyright 2004-present Facebook. All Rights Reserved.
     *
     * @providesModule UserAgent_DEPRECATED
     */

    /**
     *  Provides entirely client-side User Agent and OS detection. You should prefer
     *  the non-deprecated UserAgent module when possible, which exposes our
     *  authoritative server-side PHP-based detection to the client.
     *
     *  Usage is straightforward:
     *
     *    if (UserAgent_DEPRECATED.ie()) {
     *      //  IE
     *    }
     *
     *  You can also do version checks:
     *
     *    if (UserAgent_DEPRECATED.ie() >= 7) {
     *      //  IE7 or better
     *    }
     *
     *  The browser functions will return NaN if the browser does not match, so
     *  you can also do version compares the other way:
     *
     *    if (UserAgent_DEPRECATED.ie() < 7) {
     *      //  IE6 or worse
     *    }
     *
     *  Note that the version is a float and may include a minor version number,
     *  so you should always use range operators to perform comparisons, not
     *  strict equality.
     *
     *  **Note:** You should **strongly** prefer capability detection to browser
     *  version detection where it's reasonable:
     *
     *    http://www.quirksmode.org/js/support.html
     *
     *  Further, we have a large number of mature wrapper functions and classes
     *  which abstract away many browser irregularities. Check the documentation,
     *  grep for things, or ask on javascript@lists.facebook.com before writing yet
     *  another copy of "event || window.event".
     *
     */

    var _populated = false;

    // Browsers
    var _ie, _firefox, _opera, _webkit, _chrome;

    // Actual IE browser for compatibility mode
    var _ie_real_version;

    // Platforms
    var _osx, _windows, _linux, _android;

    // Architectures
    var _win64;

    // Devices
    var _iphone, _ipad, _native;

    var _mobile;

    function _populate() {
      if (_populated) {
        return;
      }

      _populated = true;

      // To work around buggy JS libraries that can't handle multi-digit
      // version numbers, Opera 10's user agent string claims it's Opera
      // 9, then later includes a Version/X.Y field:
      //
      // Opera/9.80 (foo) Presto/2.2.15 Version/10.10
      var uas = navigator.userAgent;
      var agent = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(uas);
      var os    = /(Mac OS X)|(Windows)|(Linux)/.exec(uas);

      _iphone = /\b(iPhone|iP[ao]d)/.exec(uas);
      _ipad = /\b(iP[ao]d)/.exec(uas);
      _android = /Android/i.exec(uas);
      _native = /FBAN\/\w+;/i.exec(uas);
      _mobile = /Mobile/i.exec(uas);

      // Note that the IE team blog would have you believe you should be checking
      // for 'Win64; x64'.  But MSDN then reveals that you can actually be coming
      // from either x64 or ia64;  so ultimately, you should just check for Win64
      // as in indicator of whether you're in 64-bit IE.  32-bit IE on 64-bit
      // Windows will send 'WOW64' instead.
      _win64 = !!(/Win64/.exec(uas));

      if (agent) {
        _ie = agent[1] ? parseFloat(agent[1]) : (
              agent[5] ? parseFloat(agent[5]) : NaN);
        // IE compatibility mode
        if (_ie && document && document.documentMode) {
          _ie = document.documentMode;
        }
        // grab the "true" ie version from the trident token if available
        var trident = /(?:Trident\/(\d+.\d+))/.exec(uas);
        _ie_real_version = trident ? parseFloat(trident[1]) + 4 : _ie;

        _firefox = agent[2] ? parseFloat(agent[2]) : NaN;
        _opera   = agent[3] ? parseFloat(agent[3]) : NaN;
        _webkit  = agent[4] ? parseFloat(agent[4]) : NaN;
        if (_webkit) {
          // We do not add the regexp to the above test, because it will always
          // match 'safari' only since 'AppleWebKit' appears before 'Chrome' in
          // the userAgent string.
          agent = /(?:Chrome\/(\d+\.\d+))/.exec(uas);
          _chrome = agent && agent[1] ? parseFloat(agent[1]) : NaN;
        } else {
          _chrome = NaN;
        }
      } else {
        _ie = _firefox = _opera = _chrome = _webkit = NaN;
      }

      if (os) {
        if (os[1]) {
          // Detect OS X version.  If no version number matches, set _osx to true.
          // Version examples:  10, 10_6_1, 10.7
          // Parses version number as a float, taking only first two sets of
          // digits.  If only one set of digits is found, returns just the major
          // version number.
          var ver = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(uas);

          _osx = ver ? parseFloat(ver[1].replace('_', '.')) : true;
        } else {
          _osx = false;
        }
        _windows = !!os[2];
        _linux   = !!os[3];
      } else {
        _osx = _windows = _linux = false;
      }
    }

    var UserAgent_DEPRECATED = {

      /**
       *  Check if the UA is Internet Explorer.
       *
       *
       *  @return float|NaN Version number (if match) or NaN.
       */
      ie: function() {
        return _populate() || _ie;
      },

      /**
       * Check if we're in Internet Explorer compatibility mode.
       *
       * @return bool true if in compatibility mode, false if
       * not compatibility mode or not ie
       */
      ieCompatibilityMode: function() {
        return _populate() || (_ie_real_version > _ie);
      },


      /**
       * Whether the browser is 64-bit IE.  Really, this is kind of weak sauce;  we
       * only need this because Skype can't handle 64-bit IE yet.  We need to remove
       * this when we don't need it -- tracked by #601957.
       */
      ie64: function() {
        return UserAgent_DEPRECATED.ie() && _win64;
      },

      /**
       *  Check if the UA is Firefox.
       *
       *
       *  @return float|NaN Version number (if match) or NaN.
       */
      firefox: function() {
        return _populate() || _firefox;
      },


      /**
       *  Check if the UA is Opera.
       *
       *
       *  @return float|NaN Version number (if match) or NaN.
       */
      opera: function() {
        return _populate() || _opera;
      },


      /**
       *  Check if the UA is WebKit.
       *
       *
       *  @return float|NaN Version number (if match) or NaN.
       */
      webkit: function() {
        return _populate() || _webkit;
      },

      /**
       *  For Push
       *  WILL BE REMOVED VERY SOON. Use UserAgent_DEPRECATED.webkit
       */
      safari: function() {
        return UserAgent_DEPRECATED.webkit();
      },

      /**
       *  Check if the UA is a Chrome browser.
       *
       *
       *  @return float|NaN Version number (if match) or NaN.
       */
      chrome : function() {
        return _populate() || _chrome;
      },


      /**
       *  Check if the user is running Windows.
       *
       *  @return bool `true' if the user's OS is Windows.
       */
      windows: function() {
        return _populate() || _windows;
      },


      /**
       *  Check if the user is running Mac OS X.
       *
       *  @return float|bool   Returns a float if a version number is detected,
       *                       otherwise true/false.
       */
      osx: function() {
        return _populate() || _osx;
      },

      /**
       * Check if the user is running Linux.
       *
       * @return bool `true' if the user's OS is some flavor of Linux.
       */
      linux: function() {
        return _populate() || _linux;
      },

      /**
       * Check if the user is running on an iPhone or iPod platform.
       *
       * @return bool `true' if the user is running some flavor of the
       *    iPhone OS.
       */
      iphone: function() {
        return _populate() || _iphone;
      },

      mobile: function() {
        return _populate() || (_iphone || _ipad || _android || _mobile);
      },

      nativeApp: function() {
        // webviews inside of the native apps
        return _populate() || _native;
      },

      android: function() {
        return _populate() || _android;
      },

      ipad: function() {
        return _populate() || _ipad;
      }
    };

    var UserAgent_DEPRECATED_1 = UserAgent_DEPRECATED;

    /**
     * Copyright (c) 2015, Facebook, Inc.
     * All rights reserved.
     *
     * This source code is licensed under the BSD-style license found in the
     * LICENSE file in the root directory of this source tree. An additional grant
     * of patent rights can be found in the PATENTS file in the same directory.
     *
     * @providesModule ExecutionEnvironment
     */

    var canUseDOM = !!(
      typeof window !== 'undefined' &&
      window.document &&
      window.document.createElement
    );

    /**
     * Simple, lightweight module assisting with the detection and context of
     * Worker. Helps avoid circular dependencies and allows code to reason about
     * whether or not they are in a Worker, even if they never include the main
     * `ReactWorker` dependency.
     */
    var ExecutionEnvironment = {

      canUseDOM: canUseDOM,

      canUseWorkers: typeof Worker !== 'undefined',

      canUseEventListeners:
        canUseDOM && !!(window.addEventListener || window.attachEvent),

      canUseViewport: canUseDOM && !!window.screen,

      isInWorker: !canUseDOM // For now, this is true - might change in the future.

    };

    var ExecutionEnvironment_1 = ExecutionEnvironment;

    var useHasFeature;
    if (ExecutionEnvironment_1.canUseDOM) {
      useHasFeature =
        document.implementation &&
        document.implementation.hasFeature &&
        // always returns true in newer browsers as per the standard.
        // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
        document.implementation.hasFeature('', '') !== true;
    }

    /**
     * Checks if an event is supported in the current execution environment.
     *
     * NOTE: This will not work correctly for non-generic events such as `change`,
     * `reset`, `load`, `error`, and `select`.
     *
     * Borrows from Modernizr.
     *
     * @param {string} eventNameSuffix Event name, e.g. "click".
     * @param {?boolean} capture Check if the capture phase is supported.
     * @return {boolean} True if the event is supported.
     * @internal
     * @license Modernizr 3.0.0pre (Custom Build) | MIT
     */
    function isEventSupported(eventNameSuffix, capture) {
      if (!ExecutionEnvironment_1.canUseDOM ||
          capture && !('addEventListener' in document)) {
        return false;
      }

      var eventName = 'on' + eventNameSuffix;
      var isSupported = eventName in document;

      if (!isSupported) {
        var element = document.createElement('div');
        element.setAttribute(eventName, 'return;');
        isSupported = typeof element[eventName] === 'function';
      }

      if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
        // This is the only way to test support for the `wheel` event in IE9+.
        isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
      }

      return isSupported;
    }

    var isEventSupported_1 = isEventSupported;

    // Reasonable defaults
    var PIXEL_STEP  = 10;
    var LINE_HEIGHT = 40;
    var PAGE_HEIGHT = 800;

    /**
     * Mouse wheel (and 2-finger trackpad) support on the web sucks.  It is
     * complicated, thus this doc is long and (hopefully) detailed enough to answer
     * your questions.
     *
     * If you need to react to the mouse wheel in a predictable way, this code is
     * like your bestest friend. * hugs *
     *
     * As of today, there are 4 DOM event types you can listen to:
     *
     *   'wheel'                -- Chrome(31+), FF(17+), IE(9+)
     *   'mousewheel'           -- Chrome, IE(6+), Opera, Safari
     *   'MozMousePixelScroll'  -- FF(3.5 only!) (2010-2013) -- don't bother!
     *   'DOMMouseScroll'       -- FF(0.9.7+) since 2003
     *
     * So what to do?  The is the best:
     *
     *   normalizeWheel.getEventType();
     *
     * In your event callback, use this code to get sane interpretation of the
     * deltas.  This code will return an object with properties:
     *
     *   spinX   -- normalized spin speed (use for zoom) - x plane
     *   spinY   -- " - y plane
     *   pixelX  -- normalized distance (to pixels) - x plane
     *   pixelY  -- " - y plane
     *
     * Wheel values are provided by the browser assuming you are using the wheel to
     * scroll a web page by a number of lines or pixels (or pages).  Values can vary
     * significantly on different platforms and browsers, forgetting that you can
     * scroll at different speeds.  Some devices (like trackpads) emit more events
     * at smaller increments with fine granularity, and some emit massive jumps with
     * linear speed or acceleration.
     *
     * This code does its best to normalize the deltas for you:
     *
     *   - spin is trying to normalize how far the wheel was spun (or trackpad
     *     dragged).  This is super useful for zoom support where you want to
     *     throw away the chunky scroll steps on the PC and make those equal to
     *     the slow and smooth tiny steps on the Mac. Key data: This code tries to
     *     resolve a single slow step on a wheel to 1.
     *
     *   - pixel is normalizing the desired scroll delta in pixel units.  You'll
     *     get the crazy differences between browsers, but at least it'll be in
     *     pixels!
     *
     *   - positive value indicates scrolling DOWN/RIGHT, negative UP/LEFT.  This
     *     should translate to positive value zooming IN, negative zooming OUT.
     *     This matches the newer 'wheel' event.
     *
     * Why are there spinX, spinY (or pixels)?
     *
     *   - spinX is a 2-finger side drag on the trackpad, and a shift + wheel turn
     *     with a mouse.  It results in side-scrolling in the browser by default.
     *
     *   - spinY is what you expect -- it's the classic axis of a mouse wheel.
     *
     *   - I dropped spinZ/pixelZ.  It is supported by the DOM 3 'wheel' event and
     *     probably is by browsers in conjunction with fancy 3D controllers .. but
     *     you know.
     *
     * Implementation info:
     *
     * Examples of 'wheel' event if you scroll slowly (down) by one step with an
     * average mouse:
     *
     *   OS X + Chrome  (mouse)     -    4   pixel delta  (wheelDelta -120)
     *   OS X + Safari  (mouse)     -  N/A   pixel delta  (wheelDelta  -12)
     *   OS X + Firefox (mouse)     -    0.1 line  delta  (wheelDelta  N/A)
     *   Win8 + Chrome  (mouse)     -  100   pixel delta  (wheelDelta -120)
     *   Win8 + Firefox (mouse)     -    3   line  delta  (wheelDelta -120)
     *
     * On the trackpad:
     *
     *   OS X + Chrome  (trackpad)  -    2   pixel delta  (wheelDelta   -6)
     *   OS X + Firefox (trackpad)  -    1   pixel delta  (wheelDelta  N/A)
     *
     * On other/older browsers.. it's more complicated as there can be multiple and
     * also missing delta values.
     *
     * The 'wheel' event is more standard:
     *
     * http://www.w3.org/TR/DOM-Level-3-Events/#events-wheelevents
     *
     * The basics is that it includes a unit, deltaMode (pixels, lines, pages), and
     * deltaX, deltaY and deltaZ.  Some browsers provide other values to maintain
     * backward compatibility with older events.  Those other values help us
     * better normalize spin speed.  Example of what the browsers provide:
     *
     *                          | event.wheelDelta | event.detail
     *        ------------------+------------------+--------------
     *          Safari v5/OS X  |       -120       |       0
     *          Safari v5/Win7  |       -120       |       0
     *         Chrome v17/OS X  |       -120       |       0
     *         Chrome v17/Win7  |       -120       |       0
     *                IE9/Win7  |       -120       |   undefined
     *         Firefox v4/OS X  |     undefined    |       1
     *         Firefox v4/Win7  |     undefined    |       3
     *
     */
    function normalizeWheel(/*object*/ event) /*object*/ {
      var sX = 0, sY = 0,       // spinX, spinY
          pX = 0, pY = 0;       // pixelX, pixelY

      // Legacy
      if ('detail'      in event) { sY = event.detail; }
      if ('wheelDelta'  in event) { sY = -event.wheelDelta / 120; }
      if ('wheelDeltaY' in event) { sY = -event.wheelDeltaY / 120; }
      if ('wheelDeltaX' in event) { sX = -event.wheelDeltaX / 120; }

      // side scrolling on FF with DOMMouseScroll
      if ( 'axis' in event && event.axis === event.HORIZONTAL_AXIS ) {
        sX = sY;
        sY = 0;
      }

      pX = sX * PIXEL_STEP;
      pY = sY * PIXEL_STEP;

      if ('deltaY' in event) { pY = event.deltaY; }
      if ('deltaX' in event) { pX = event.deltaX; }

      if ((pX || pY) && event.deltaMode) {
        if (event.deltaMode == 1) {          // delta in LINE units
          pX *= LINE_HEIGHT;
          pY *= LINE_HEIGHT;
        } else {                             // delta in PAGE units
          pX *= PAGE_HEIGHT;
          pY *= PAGE_HEIGHT;
        }
      }

      // Fall-back if spin cannot be determined
      if (pX && !sX) { sX = (pX < 1) ? -1 : 1; }
      if (pY && !sY) { sY = (pY < 1) ? -1 : 1; }

      return { spinX  : sX,
               spinY  : sY,
               pixelX : pX,
               pixelY : pY };
    }


    /**
     * The best combination if you prefer spinX + spinY normalization.  It favors
     * the older DOMMouseScroll for Firefox, as FF does not include wheelDelta with
     * 'wheel' event, making spin speed determination impossible.
     */
    normalizeWheel.getEventType = function() /*string*/ {
      return (UserAgent_DEPRECATED_1.firefox())
               ? 'DOMMouseScroll'
               : (isEventSupported_1('wheel'))
                   ? 'wheel'
                   : 'mousewheel';
    };

    var normalizeWheel_1 = normalizeWheel;

    var normalizeWheel$1 = normalizeWheel_1;

    // this class wraps all the observables for the gltf sample viewer state
    // the data streams coming out of this should match the data required in GltfState
    // as close as possible
    class UIModel
    {
        constructor(app, modelPathProvider, environments)
        {
            this.app = app;
            this.pathProvider = modelPathProvider;

            this.app.models = this.pathProvider.getAllKeys();

            const queryString = window.location.search;
            const urlParams = new URLSearchParams(queryString);
            const modelURL = urlParams.get("model");

            let dropdownGltfChanged = undefined;
            if (modelURL === null)
            {
                dropdownGltfChanged = app.modelChanged$.pipe(
                    pluck("event", "msg"),
                    startWith("DamagedHelmet"),
                    map(value => {
                        app.flavours = this.pathProvider.getModelFlavours(value);
                        app.selectedFlavour = "glTF";
                        return this.pathProvider.resolve(value, app.selectedFlavour);
                    }),
                    map( value => ({mainFile: value, additionalFiles: undefined})),
                );
            } else {
                dropdownGltfChanged = app.modelChanged$.pipe(
                    pluck("event", "msg"),
                    map(value => {
                        app.flavours = this.pathProvider.getModelFlavours(value);
                        app.selectedFlavour = "glTF";
                        return this.pathProvider.resolve(value, app.selectedFlavour);
                    }),
                    map( value => ({mainFile: value, additionalFiles: undefined})),
                );
            }       

            const dropdownFlavourChanged = app.flavourChanged$.pipe(
                pluck("event", "msg"),
                map(value => {
                    return this.pathProvider.resolve(app.selectedModel, value);
                }),
                map( value => ({mainFile: value, additionalFiles: undefined})),
            );

            this.scene = app.sceneChanged$.pipe(pluck("event", "msg"));
            this.camera = app.cameraChanged$.pipe(pluck("event", "msg"));
            this.environmentRotation = app.environmentRotationChanged$.pipe(pluck("event", "msg"));
            this.app.environments = environments;
            const selectedEnvironment = app.$watchAsObservable('selectedEnvironment').pipe(
                pluck('newValue'),
                map( environmentName => this.app.environments[environmentName].hdr_path)
            );
            const initialEnvironment = "footprint_court";
            this.app.selectedEnvironment = initialEnvironment;

            this.app.tonemaps = Object.keys(GltfState.ToneMaps).map((key) => {
                return {title: GltfState.ToneMaps[key]};
            });
            this.tonemap = app.tonemapChanged$.pipe(
                pluck("event", "msg"),
                startWith(GltfState.ToneMaps.LINEAR)
            );

            this.app.debugchannels = Object.keys(GltfState.DebugOutput).map((key) => {
                return {title: GltfState.DebugOutput[key]};
            });
            this.debugchannel = app.debugchannelChanged$.pipe(
                pluck("event", "msg"),
                startWith(GltfState.DebugOutput.NONE)
            );

            this.exposure = app.exposureChanged$.pipe(pluck("event", "msg"));
            this.skinningEnabled = app.skinningChanged$.pipe(pluck("event", "msg"));
            this.morphingEnabled = app.morphingChanged$.pipe(pluck("event", "msg"));
            this.clearcoatEnabled = app.clearcoatChanged$.pipe(pluck("event", "msg"));
            this.sheenEnabled = app.sheenChanged$.pipe(pluck("event", "msg"));
            this.transmissionEnabled = app.transmissionChanged$.pipe(pluck("event", "msg"));
            this.volumeEnabled = app.$watchAsObservable('volumeEnabled').pipe(
                                                map( ({ newValue, oldValue }) => newValue));
            this.iorEnabled = app.$watchAsObservable('iorEnabled').pipe(
                                                map( ({ newValue, oldValue }) => newValue));
            this.iridescenceEnabled = app.$watchAsObservable('iridescenceEnabled').pipe(
                                                map( ({ newValue, oldValue }) => newValue));
            this.specularEnabled = app.$watchAsObservable('specularEnabled').pipe(
                                                map( ({ newValue, oldValue }) => newValue));
            this.emissiveStrengthEnabled = app.$watchAsObservable('emissiveStrengthEnabled').pipe(
                                                map( ({ newValue, oldValue }) => newValue));
            this.iblEnabled = app.iblChanged$.pipe(pluck("event", "msg"));
            this.iblIntensity = app.iblIntensityChanged$.pipe(pluck("event", "msg"));
            this.punctualLightsEnabled = app.punctualLightsChanged$.pipe(pluck("event", "msg"));
            this.renderEnvEnabled = app.$watchAsObservable('renderEnv').pipe(
                                                map( ({ newValue, oldValue }) => newValue));
            this.blurEnvEnabled = app.blurEnvChanged$.pipe(pluck("event", "msg"));
            this.addEnvironment = app.$watchAsObservable('uploadedHDR').pipe(
                pluck('newValue')
            );
            this.captureCanvas = app.captureCanvas$.pipe(pluck('event'));
            this.cameraValuesExport = app.cameraExport$.pipe(pluck('event'));

            const initialClearColor = "#303542";
            this.app.clearColor = initialClearColor;
            this.clearColor = app.colorChanged$.pipe(
                filter(value => value.event !== undefined),
                pluck("event", "msg"),
                startWith(initialClearColor),
                map(hex => {
                    // convert hex string to rgb values
                    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                    return result ? [
                        parseInt(result[1], 16),
                        parseInt(result[2], 16),
                        parseInt(result[3], 16),
                        255
                    ] : null;
                })
            );

            this.animationPlay = app.animationPlayChanged$.pipe(pluck("event", "msg"));
            this.activeAnimations = app.$watchAsObservable('selectedAnimations').pipe(
                map( ({ newValue, oldValue }) => newValue)
            );

            const canvas = document.getElementById("canvas");
            this.registerDropZoneUIHandle(canvas);
            const inputObservables = UIModel.getInputObservables(canvas, this.app);
            this.model = merge(dropdownGltfChanged, dropdownFlavourChanged, inputObservables.gltfDropped);
            this.hdr = merge(inputObservables.hdrDropped, selectedEnvironment, this.addEnvironment).pipe(
                startWith(environments[initialEnvironment].hdr_path)
            );

            const hdrUIChange = merge(inputObservables.hdrDropped, this.addEnvironment);
            hdrUIChange.subscribe( hdrPath => {
                this.app.environments[hdrPath.name] = {
                    title: hdrPath.name,
                    hdr_path: hdrPath,
                };
                this.app.selectedEnvironment = hdrPath.name;
            });

            this.variant = app.variantChanged$.pipe(pluck("event", "msg"));

            this.model.subscribe(() => {
                // remove last filename
                if(this.app.models[this.app.models.length -1] === this.lastDroppedFilename)
                {
                    this.app.models.pop();
                    this.lastDroppedFilename = undefined;
                }
            });

            let dropedGLtfFileName = inputObservables.gltfDropped.pipe(
                map( (data) => {
                    return data.mainFile.name;
                })
            );

            if (modelURL !== null){
                let loadFromUrlObservable = new Observable(subscriber => { subscriber.next({mainFile: modelURL, additionalFiles: undefined});});
                dropedGLtfFileName = merge(dropedGLtfFileName, loadFromUrlObservable.pipe(map((data) => {return data.mainFile;} )));
                this.model = merge(this.model, loadFromUrlObservable);
            }

            dropedGLtfFileName.subscribe( (filename) => {
                if(filename !== undefined)
                {
                    filename = filename.split('/').pop();
                    let fileExtension = filename.split('.').pop();                filename = filename.substr(0, filename.lastIndexOf('.'));

                    this.app.models.push(filename);
                    this.app.selectedModel = filename;
                    this.lastDroppedFilename = filename;

                    app.flavours = [fileExtension];
                    app.selectedFlavour = fileExtension;
                }
            });

            this.orbit = inputObservables.orbit;
            this.pan = inputObservables.pan;
            this.zoom = inputObservables.zoom;
        }

        // app has to be the vuejs app instance
        static getInputObservables(inputDomElement, app)
        {
            const observables = {};

            const simpleDropzoneObservabel = new Observable(subscriber => {
                const dropCtrl = new xe(inputDomElement, inputDomElement);
                dropCtrl.on('drop', ({files}) => {
                    app.showDropDownOverlay = false;
                    subscriber.next(files);
                });
                dropCtrl.on('droperror', () => {
                    app.showDropDownOverlay = false;
                    subscriber.error();
                });
            });
            observables.filesDropped = simpleDropzoneObservabel.pipe(
                map(files => Array.from(files.values()))
            );

            observables.gltfDropped = observables.filesDropped.pipe(
                // filter out any non .gltf or .glb files

                map( (files) => {
                    // restructure the data by separating mainFile (gltf/glb) from additionalFiles
                    const mainFile = files.find( (file) => file.name.endsWith(".glb") || file.name.endsWith(".gltf"));
                    const additionalFiles = files.filter( (file) => file !== mainFile);
                    return {mainFile: mainFile, additionalFiles: additionalFiles};
                }),
                filter(files => files.mainFile !== undefined),
            );
            observables.hdrDropped = observables.filesDropped.pipe(
                map( (files) => {
                    // extract only the hdr file from the stream of files
                    return files.find( (file) => file.name.endsWith(".hdr"));
                }),
                filter(file => file !== undefined),
            );

            const move = fromEvent(document, 'mousemove');
            const mousedown = fromEvent(inputDomElement, 'mousedown');
            const cancelMouse = merge(fromEvent(document, 'mouseup'), fromEvent(document, 'mouseleave'));

            const mouseOrbit = mousedown.pipe(
                filter( event => event.button === 0 && event.shiftKey === false),
                mergeMap(() => move.pipe(takeUntil(cancelMouse))),
                map( mouse => ({deltaPhi: mouse.movementX, deltaTheta: mouse.movementY }))
            );

            const mousePan = mousedown.pipe(
                filter( event => event.button === 1 || event.shiftKey === true),
                mergeMap(() => move.pipe(takeUntil(cancelMouse))),
                map( mouse => ({deltaX: mouse.movementX, deltaY: mouse.movementY }))
            );

            const smbZoom = mousedown.pipe(
                filter( event => event.button === 2),
                mergeMap(() => move.pipe(takeUntil(cancelMouse))),
                map( mouse => ({deltaZoom: mouse.movementY }))
            );
            const wheelZoom = fromEvent(inputDomElement, 'wheel').pipe(
                map(wheelEvent => normalizeWheel$1(wheelEvent)),
                map(normalizedZoom => ({deltaZoom: normalizedZoom.spinY }))
            );
            inputDomElement.addEventListener('onscroll', event => event.preventDefault(), false);
            const mouseZoom = merge(smbZoom, wheelZoom);

            const touchmove = fromEvent(document, 'touchmove');
            const touchstart = fromEvent(inputDomElement, 'touchstart');
            const touchend = merge(fromEvent(inputDomElement, 'touchend'), fromEvent(inputDomElement, 'touchcancel'));
            
            const touchOrbit = touchstart.pipe(
                filter( event => event.touches.length === 1),
                mergeMap(() => touchmove.pipe(takeUntil(touchend))),
                map( event => event.touches[0]),
                pairwise(),
                map( ([oldTouch, newTouch]) => {
                    return { 
                        deltaPhi: newTouch.pageX - oldTouch.pageX, 
                        deltaTheta: newTouch.pageY - oldTouch.pageY 
                    };
                })
            );

            const touchZoom = touchstart.pipe(
                filter( event => event.touches.length === 2),
                mergeMap(() => touchmove.pipe(takeUntil(touchend))),
                map( event => {
                    const pos1 = fromValues(event.touches[0].pageX, event.touches[0].pageY);
                    const pos2 = fromValues(event.touches[1].pageX, event.touches[1].pageY);
                    return dist(pos1, pos2);
                }),
                pairwise(),
                map( ([oldDist, newDist]) => ({ deltaZoom: newDist - oldDist }))
            );

            inputDomElement.addEventListener('ontouchmove', event => event.preventDefault(), false);

            observables.orbit = merge(mouseOrbit, touchOrbit);
            observables.pan = mousePan;
            observables.zoom = merge(mouseZoom, touchZoom);

            // disable context menu
            inputDomElement.oncontextmenu = () => false;

            return observables;
        }

        registerDropZoneUIHandle(inputDomElement)
        {
            const self = this;
            inputDomElement.addEventListener('dragenter', function(event) {
                self.app.showDropDownOverlay = true;
            });
            inputDomElement.addEventListener('dragleave', function(event) {
                self.app.showDropDownOverlay = false;
            });
        }

        attachGltfLoaded(glTFLoadedStateObservable)
        {
            const gltfLoadedAndInit = glTFLoadedStateObservable.pipe(
                map( state => state.gltf )
            );

            // update scenes
            const sceneIndices = gltfLoadedAndInit.pipe(
                map( (gltf) => {
                    return gltf.scenes.map( (scene, index) => {
                        let name = scene.name;
                        if(name === "" || name === undefined)
                        {
                            name = index;
                        }
                        return {title: name, index: index};
                    });
                })
            );
            sceneIndices.subscribe( (scenes) => {
                this.app.scenes = scenes;
            });

            const loadedSceneIndex = glTFLoadedStateObservable.pipe(
                map( (state) => state.sceneIndex)
            );
            loadedSceneIndex.subscribe( (scene) => {
                this.app.selectedScene = scene;
            });

            // update cameras
            this.attachCameraChangeObservable(glTFLoadedStateObservable);

            const variants = gltfLoadedAndInit.pipe(
                map( (gltf) => {
                    if(gltf.variants !== undefined)
                    {
                        return gltf.variants.map( (variant, index) => {
                            return {title: variant.name};
                        });
                    }
                    return [];
                }),
                map(variants => {
                    // Add a "None" variant to the beginning
                    variants.unshift({title: "None"});
                    return variants;
                })
            );
            variants.subscribe( (variants) => {
                this.app.materialVariants = variants;
            });

            gltfLoadedAndInit.subscribe(
                (_) => {this.app.setAnimationState(true);
                }
            );

            const xmpData = gltfLoadedAndInit.pipe(
                map( (gltf) => {
                    if(gltf.extensions !== undefined && gltf.extensions.KHR_xmp_json_ld !== undefined)
                    {
                        if(gltf.asset.extensions !== undefined && gltf.asset.extensions.KHR_xmp_json_ld !== undefined)
                        {
                            let xmpPacket = gltf.extensions.KHR_xmp_json_ld.packets[gltf.asset.extensions.KHR_xmp_json_ld.packet];
                            return xmpPacket;
                        }
                    }
                    return [];
                })
            );
            xmpData.subscribe( (xmpData) => {
                this.app.xmp = xmpData;
            });

            const animations = gltfLoadedAndInit.pipe(
                map( gltf =>  gltf.animations.map( (anim, index) => {
                    let name = anim.name;
                    if (name === undefined || name === "")
                    {
                        name = index;
                    }
                    return {
                        title: name,
                        index: index
                    };
                }))
            );
            animations.subscribe( animations => {
                this.app.animations = animations;
            });

            glTFLoadedStateObservable.pipe(
                map( state => state.animationIndices)
            ).subscribe( animationIndices => {
                this.app.selectedAnimations = animationIndices;
            });
        }

        updateStatistics(statisticsUpdateObservable)
        {
            statisticsUpdateObservable.subscribe(
                data => {
                    let statistics = {};
                    statistics["Mesh Count"] = data.meshCount;
                    statistics["Triangle Count"] = data.faceCount;
                    statistics["Opaque Material Count"] = data.opaqueMaterialsCount;
                    statistics["Transparent Material Count"] = data.transparentMaterialsCount;
                    this.app.statistics = statistics;
                }
            );
        }

        disabledAnimations(disabledAnimationsObservable)
        {
            disabledAnimationsObservable.subscribe(
                data => { this.app.disabledAnimations = data; }
            );
        }

        attachCameraChangeObservable(sceneChangeObservable)
        {
            const cameraIndices = sceneChangeObservable.pipe(
                map( (state) => {
                    let gltf = state.gltf;
                    let cameraIndices = [{title: "User Camera", index: -1}];
                    if (gltf.scenes[state.sceneIndex] !== undefined)
                    {
                        cameraIndices.push(...gltf.cameras.map( (camera, index) => {
                            if(gltf.scenes[state.sceneIndex].includesNode(gltf, camera.node))
                            {
                                let name = camera.name;
                                if(name === "" || name === undefined)
                                {
                                    name = index;
                                }
                                return {title: name, index: index};
                            }
                        }));
                    }
                    cameraIndices = cameraIndices.filter(function(el) {
                        return el !== undefined;
                    });
                    return cameraIndices;
                })
            );
            cameraIndices.subscribe( (cameras) => {
                this.app.cameras = cameras;
            });
            const loadedCameraIndex = sceneChangeObservable.pipe(
                map( (state) => {
                    return state.cameraIndex;
                })
            );
            loadedCameraIndex.subscribe( index => {
                if(index ===  undefined)
                {
                    index = -1;
                }
                this.app.selectedCamera = index;
            });
        }

        copyToClipboard(text) {
            var dummy = document.createElement("textarea");
            document.body.appendChild(dummy);
            dummy.value = text;
            dummy.select();
            document.execCommand("copy");
            document.body.removeChild(dummy);
        }

        goToLoadingState() {
            this.app.goToLoadingState();
        }
        exitLoadingState()
        {
            this.app.exitLoadingState();
        }
    }

    /*!
     * Vue.js v2.6.14
     * (c) 2014-2021 Evan You
     * Released under the MIT License.
     */
    /*  */

    var emptyObject = Object.freeze({});

    // These helpers produce better VM code in JS engines due to their
    // explicitness and function inlining.
    function isUndef (v) {
      return v === undefined || v === null
    }

    function isDef (v) {
      return v !== undefined && v !== null
    }

    function isTrue (v) {
      return v === true
    }

    function isFalse (v) {
      return v === false
    }

    /**
     * Check if value is primitive.
     */
    function isPrimitive (value) {
      return (
        typeof value === 'string' ||
        typeof value === 'number' ||
        // $flow-disable-line
        typeof value === 'symbol' ||
        typeof value === 'boolean'
      )
    }

    /**
     * Quick object check - this is primarily used to tell
     * Objects from primitive values when we know the value
     * is a JSON-compliant type.
     */
    function isObject$1 (obj) {
      return obj !== null && typeof obj === 'object'
    }

    /**
     * Get the raw type string of a value, e.g., [object Object].
     */
    var _toString = Object.prototype.toString;

    function toRawType (value) {
      return _toString.call(value).slice(8, -1)
    }

    /**
     * Strict object type check. Only returns true
     * for plain JavaScript objects.
     */
    function isPlainObject (obj) {
      return _toString.call(obj) === '[object Object]'
    }

    function isRegExp (v) {
      return _toString.call(v) === '[object RegExp]'
    }

    /**
     * Check if val is a valid array index.
     */
    function isValidArrayIndex (val) {
      var n = parseFloat(String(val));
      return n >= 0 && Math.floor(n) === n && isFinite(val)
    }

    function isPromise$1 (val) {
      return (
        isDef(val) &&
        typeof val.then === 'function' &&
        typeof val.catch === 'function'
      )
    }

    /**
     * Convert a value to a string that is actually rendered.
     */
    function toString (val) {
      return val == null
        ? ''
        : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)
          ? JSON.stringify(val, null, 2)
          : String(val)
    }

    /**
     * Convert an input value to a number for persistence.
     * If the conversion fails, return original string.
     */
    function toNumber (val) {
      var n = parseFloat(val);
      return isNaN(n) ? val : n
    }

    /**
     * Make a map and return a function for checking if a key
     * is in that map.
     */
    function makeMap (
      str,
      expectsLowerCase
    ) {
      var map = Object.create(null);
      var list = str.split(',');
      for (var i = 0; i < list.length; i++) {
        map[list[i]] = true;
      }
      return expectsLowerCase
        ? function (val) { return map[val.toLowerCase()]; }
        : function (val) { return map[val]; }
    }

    /**
     * Check if a tag is a built-in tag.
     */
    var isBuiltInTag = makeMap('slot,component', true);

    /**
     * Check if an attribute is a reserved attribute.
     */
    var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');

    /**
     * Remove an item from an array.
     */
    function remove (arr, item) {
      if (arr.length) {
        var index = arr.indexOf(item);
        if (index > -1) {
          return arr.splice(index, 1)
        }
      }
    }

    /**
     * Check whether an object has the property.
     */
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function hasOwn (obj, key) {
      return hasOwnProperty.call(obj, key)
    }

    /**
     * Create a cached version of a pure function.
     */
    function cached (fn) {
      var cache = Object.create(null);
      return (function cachedFn (str) {
        var hit = cache[str];
        return hit || (cache[str] = fn(str))
      })
    }

    /**
     * Camelize a hyphen-delimited string.
     */
    var camelizeRE = /-(\w)/g;
    var camelize = cached(function (str) {
      return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })
    });

    /**
     * Capitalize a string.
     */
    var capitalize = cached(function (str) {
      return str.charAt(0).toUpperCase() + str.slice(1)
    });

    /**
     * Hyphenate a camelCase string.
     */
    var hyphenateRE = /\B([A-Z])/g;
    var hyphenate = cached(function (str) {
      return str.replace(hyphenateRE, '-$1').toLowerCase()
    });

    /**
     * Simple bind polyfill for environments that do not support it,
     * e.g., PhantomJS 1.x. Technically, we don't need this anymore
     * since native bind is now performant enough in most browsers.
     * But removing it would mean breaking code that was able to run in
     * PhantomJS 1.x, so this must be kept for backward compatibility.
     */

    /* istanbul ignore next */
    function polyfillBind (fn, ctx) {
      function boundFn (a) {
        var l = arguments.length;
        return l
          ? l > 1
            ? fn.apply(ctx, arguments)
            : fn.call(ctx, a)
          : fn.call(ctx)
      }

      boundFn._length = fn.length;
      return boundFn
    }

    function nativeBind (fn, ctx) {
      return fn.bind(ctx)
    }

    var bind = Function.prototype.bind
      ? nativeBind
      : polyfillBind;

    /**
     * Convert an Array-like object to a real Array.
     */
    function toArray (list, start) {
      start = start || 0;
      var i = list.length - start;
      var ret = new Array(i);
      while (i--) {
        ret[i] = list[i + start];
      }
      return ret
    }

    /**
     * Mix properties into target object.
     */
    function extend (to, _from) {
      for (var key in _from) {
        to[key] = _from[key];
      }
      return to
    }

    /**
     * Merge an Array of Objects into a single Object.
     */
    function toObject (arr) {
      var res = {};
      for (var i = 0; i < arr.length; i++) {
        if (arr[i]) {
          extend(res, arr[i]);
        }
      }
      return res
    }

    /* eslint-disable no-unused-vars */

    /**
     * Perform no operation.
     * Stubbing args to make Flow happy without leaving useless transpiled code
     * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
     */
    function noop$1 (a, b, c) {}

    /**
     * Always return false.
     */
    var no = function (a, b, c) { return false; };

    /* eslint-enable no-unused-vars */

    /**
     * Return the same value.
     */
    var identity$1 = function (_) { return _; };

    /**
     * Generate a string containing static keys from compiler modules.
     */
    function genStaticKeys (modules) {
      return modules.reduce(function (keys, m) {
        return keys.concat(m.staticKeys || [])
      }, []).join(',')
    }

    /**
     * Check if two values are loosely equal - that is,
     * if they are plain objects, do they have the same shape?
     */
    function looseEqual (a, b) {
      if (a === b) { return true }
      var isObjectA = isObject$1(a);
      var isObjectB = isObject$1(b);
      if (isObjectA && isObjectB) {
        try {
          var isArrayA = Array.isArray(a);
          var isArrayB = Array.isArray(b);
          if (isArrayA && isArrayB) {
            return a.length === b.length && a.every(function (e, i) {
              return looseEqual(e, b[i])
            })
          } else if (a instanceof Date && b instanceof Date) {
            return a.getTime() === b.getTime()
          } else if (!isArrayA && !isArrayB) {
            var keysA = Object.keys(a);
            var keysB = Object.keys(b);
            return keysA.length === keysB.length && keysA.every(function (key) {
              return looseEqual(a[key], b[key])
            })
          } else {
            /* istanbul ignore next */
            return false
          }
        } catch (e) {
          /* istanbul ignore next */
          return false
        }
      } else if (!isObjectA && !isObjectB) {
        return String(a) === String(b)
      } else {
        return false
      }
    }

    /**
     * Return the first index at which a loosely equal value can be
     * found in the array (if value is a plain object, the array must
     * contain an object of the same shape), or -1 if it is not present.
     */
    function looseIndexOf (arr, val) {
      for (var i = 0; i < arr.length; i++) {
        if (looseEqual(arr[i], val)) { return i }
      }
      return -1
    }

    /**
     * Ensure a function is called only once.
     */
    function once (fn) {
      var called = false;
      return function () {
        if (!called) {
          called = true;
          fn.apply(this, arguments);
        }
      }
    }

    var SSR_ATTR = 'data-server-rendered';

    var ASSET_TYPES = [
      'component',
      'directive',
      'filter'
    ];

    var LIFECYCLE_HOOKS = [
      'beforeCreate',
      'created',
      'beforeMount',
      'mounted',
      'beforeUpdate',
      'updated',
      'beforeDestroy',
      'destroyed',
      'activated',
      'deactivated',
      'errorCaptured',
      'serverPrefetch'
    ];

    /*  */



    var config$1 = ({
      /**
       * Option merge strategies (used in core/util/options)
       */
      // $flow-disable-line
      optionMergeStrategies: Object.create(null),

      /**
       * Whether to suppress warnings.
       */
      silent: false,

      /**
       * Show production mode tip message on boot?
       */
      productionTip: "production" !== 'production',

      /**
       * Whether to enable devtools
       */
      devtools: "production" !== 'production',

      /**
       * Whether to record perf
       */
      performance: false,

      /**
       * Error handler for watcher errors
       */
      errorHandler: null,

      /**
       * Warn handler for watcher warns
       */
      warnHandler: null,

      /**
       * Ignore certain custom elements
       */
      ignoredElements: [],

      /**
       * Custom user key aliases for v-on
       */
      // $flow-disable-line
      keyCodes: Object.create(null),

      /**
       * Check if a tag is reserved so that it cannot be registered as a
       * component. This is platform-dependent and may be overwritten.
       */
      isReservedTag: no,

      /**
       * Check if an attribute is reserved so that it cannot be used as a component
       * prop. This is platform-dependent and may be overwritten.
       */
      isReservedAttr: no,

      /**
       * Check if a tag is an unknown element.
       * Platform-dependent.
       */
      isUnknownElement: no,

      /**
       * Get the namespace of an element
       */
      getTagNamespace: noop$1,

      /**
       * Parse the real tag name for the specific platform.
       */
      parsePlatformTagName: identity$1,

      /**
       * Check if an attribute must be bound using property, e.g. value
       * Platform-dependent.
       */
      mustUseProp: no,

      /**
       * Perform updates asynchronously. Intended to be used by Vue Test Utils
       * This will significantly reduce performance if set to false.
       */
      async: true,

      /**
       * Exposed for legacy reasons
       */
      _lifecycleHooks: LIFECYCLE_HOOKS
    });

    /*  */

    /**
     * unicode letters used for parsing html tags, component names and property paths.
     * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
     * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
     */
    var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;

    /**
     * Check if a string starts with $ or _
     */
    function isReserved (str) {
      var c = (str + '').charCodeAt(0);
      return c === 0x24 || c === 0x5F
    }

    /**
     * Define a property.
     */
    function def (obj, key, val, enumerable) {
      Object.defineProperty(obj, key, {
        value: val,
        enumerable: !!enumerable,
        writable: true,
        configurable: true
      });
    }

    /**
     * Parse simple path.
     */
    var bailRE = new RegExp(("[^" + (unicodeRegExp.source) + ".$_\\d]"));
    function parsePath (path) {
      if (bailRE.test(path)) {
        return
      }
      var segments = path.split('.');
      return function (obj) {
        for (var i = 0; i < segments.length; i++) {
          if (!obj) { return }
          obj = obj[segments[i]];
        }
        return obj
      }
    }

    /*  */

    // can we use __proto__?
    var hasProto = '__proto__' in {};

    // Browser environment sniffing
    var inBrowser = typeof window !== 'undefined';
    var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
    var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
    var UA = inBrowser && window.navigator.userAgent.toLowerCase();
    var isIE = UA && /msie|trident/.test(UA);
    var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
    var isEdge = UA && UA.indexOf('edge/') > 0;
    var isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');
    var isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');
    var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
    var isPhantomJS = UA && /phantomjs/.test(UA);
    var isFF = UA && UA.match(/firefox\/(\d+)/);

    // Firefox has a "watch" function on Object.prototype...
    var nativeWatch = ({}).watch;

    var supportsPassive = false;
    if (inBrowser) {
      try {
        var opts = {};
        Object.defineProperty(opts, 'passive', ({
          get: function get () {
            /* istanbul ignore next */
            supportsPassive = true;
          }
        })); // https://github.com/facebook/flow/issues/285
        window.addEventListener('test-passive', null, opts);
      } catch (e) {}
    }

    // this needs to be lazy-evaled because vue may be required before
    // vue-server-renderer can set VUE_ENV
    var _isServer;
    var isServerRendering = function () {
      if (_isServer === undefined) {
        /* istanbul ignore if */
        if (!inBrowser && !inWeex && typeof global !== 'undefined') {
          // detect presence of vue-server-renderer and avoid
          // Webpack shimming the process
          _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';
        } else {
          _isServer = false;
        }
      }
      return _isServer
    };

    // detect devtools
    var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

    /* istanbul ignore next */
    function isNative (Ctor) {
      return typeof Ctor === 'function' && /native code/.test(Ctor.toString())
    }

    var hasSymbol =
      typeof Symbol !== 'undefined' && isNative(Symbol) &&
      typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

    var _Set;
    /* istanbul ignore if */ // $flow-disable-line
    if (typeof Set !== 'undefined' && isNative(Set)) {
      // use native Set when available.
      _Set = Set;
    } else {
      // a non-standard Set polyfill that only works with primitive keys.
      _Set = /*@__PURE__*/(function () {
        function Set () {
          this.set = Object.create(null);
        }
        Set.prototype.has = function has (key) {
          return this.set[key] === true
        };
        Set.prototype.add = function add (key) {
          this.set[key] = true;
        };
        Set.prototype.clear = function clear () {
          this.set = Object.create(null);
        };

        return Set;
      }());
    }

    /*  */

    var warn = noop$1;

    /*  */

    var uid = 0;

    /**
     * A dep is an observable that can have multiple
     * directives subscribing to it.
     */
    var Dep = function Dep () {
      this.id = uid++;
      this.subs = [];
    };

    Dep.prototype.addSub = function addSub (sub) {
      this.subs.push(sub);
    };

    Dep.prototype.removeSub = function removeSub (sub) {
      remove(this.subs, sub);
    };

    Dep.prototype.depend = function depend () {
      if (Dep.target) {
        Dep.target.addDep(this);
      }
    };

    Dep.prototype.notify = function notify () {
      // stabilize the subscriber list first
      var subs = this.subs.slice();
      for (var i = 0, l = subs.length; i < l; i++) {
        subs[i].update();
      }
    };

    // The current target watcher being evaluated.
    // This is globally unique because only one watcher
    // can be evaluated at a time.
    Dep.target = null;
    var targetStack = [];

    function pushTarget (target) {
      targetStack.push(target);
      Dep.target = target;
    }

    function popTarget () {
      targetStack.pop();
      Dep.target = targetStack[targetStack.length - 1];
    }

    /*  */

    var VNode = function VNode (
      tag,
      data,
      children,
      text,
      elm,
      context,
      componentOptions,
      asyncFactory
    ) {
      this.tag = tag;
      this.data = data;
      this.children = children;
      this.text = text;
      this.elm = elm;
      this.ns = undefined;
      this.context = context;
      this.fnContext = undefined;
      this.fnOptions = undefined;
      this.fnScopeId = undefined;
      this.key = data && data.key;
      this.componentOptions = componentOptions;
      this.componentInstance = undefined;
      this.parent = undefined;
      this.raw = false;
      this.isStatic = false;
      this.isRootInsert = true;
      this.isComment = false;
      this.isCloned = false;
      this.isOnce = false;
      this.asyncFactory = asyncFactory;
      this.asyncMeta = undefined;
      this.isAsyncPlaceholder = false;
    };

    var prototypeAccessors = { child: { configurable: true } };

    // DEPRECATED: alias for componentInstance for backwards compat.
    /* istanbul ignore next */
    prototypeAccessors.child.get = function () {
      return this.componentInstance
    };

    Object.defineProperties( VNode.prototype, prototypeAccessors );

    var createEmptyVNode = function (text) {
      if ( text === void 0 ) text = '';

      var node = new VNode();
      node.text = text;
      node.isComment = true;
      return node
    };

    function createTextVNode (val) {
      return new VNode(undefined, undefined, undefined, String(val))
    }

    // optimized shallow clone
    // used for static nodes and slot nodes because they may be reused across
    // multiple renders, cloning them avoids errors when DOM manipulations rely
    // on their elm reference.
    function cloneVNode (vnode) {
      var cloned = new VNode(
        vnode.tag,
        vnode.data,
        // #7975
        // clone children array to avoid mutating original in case of cloning
        // a child.
        vnode.children && vnode.children.slice(),
        vnode.text,
        vnode.elm,
        vnode.context,
        vnode.componentOptions,
        vnode.asyncFactory
      );
      cloned.ns = vnode.ns;
      cloned.isStatic = vnode.isStatic;
      cloned.key = vnode.key;
      cloned.isComment = vnode.isComment;
      cloned.fnContext = vnode.fnContext;
      cloned.fnOptions = vnode.fnOptions;
      cloned.fnScopeId = vnode.fnScopeId;
      cloned.asyncMeta = vnode.asyncMeta;
      cloned.isCloned = true;
      return cloned
    }

    /*
     * not type checking this file because flow doesn't play well with
     * dynamically accessing methods on Array prototype
     */

    var arrayProto = Array.prototype;
    var arrayMethods = Object.create(arrayProto);

    var methodsToPatch = [
      'push',
      'pop',
      'shift',
      'unshift',
      'splice',
      'sort',
      'reverse'
    ];

    /**
     * Intercept mutating methods and emit events
     */
    methodsToPatch.forEach(function (method) {
      // cache original method
      var original = arrayProto[method];
      def(arrayMethods, method, function mutator () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var result = original.apply(this, args);
        var ob = this.__ob__;
        var inserted;
        switch (method) {
          case 'push':
          case 'unshift':
            inserted = args;
            break
          case 'splice':
            inserted = args.slice(2);
            break
        }
        if (inserted) { ob.observeArray(inserted); }
        // notify change
        ob.dep.notify();
        return result
      });
    });

    /*  */

    var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

    /**
     * In some cases we may want to disable observation inside a component's
     * update computation.
     */
    var shouldObserve = true;

    function toggleObserving (value) {
      shouldObserve = value;
    }

    /**
     * Observer class that is attached to each observed
     * object. Once attached, the observer converts the target
     * object's property keys into getter/setters that
     * collect dependencies and dispatch updates.
     */
    var Observer = function Observer (value) {
      this.value = value;
      this.dep = new Dep();
      this.vmCount = 0;
      def(value, '__ob__', this);
      if (Array.isArray(value)) {
        if (hasProto) {
          protoAugment(value, arrayMethods);
        } else {
          copyAugment(value, arrayMethods, arrayKeys);
        }
        this.observeArray(value);
      } else {
        this.walk(value);
      }
    };

    /**
     * Walk through all properties and convert them into
     * getter/setters. This method should only be called when
     * value type is Object.
     */
    Observer.prototype.walk = function walk (obj) {
      var keys = Object.keys(obj);
      for (var i = 0; i < keys.length; i++) {
        defineReactive$$1(obj, keys[i]);
      }
    };

    /**
     * Observe a list of Array items.
     */
    Observer.prototype.observeArray = function observeArray (items) {
      for (var i = 0, l = items.length; i < l; i++) {
        observe(items[i]);
      }
    };

    // helpers

    /**
     * Augment a target Object or Array by intercepting
     * the prototype chain using __proto__
     */
    function protoAugment (target, src) {
      /* eslint-disable no-proto */
      target.__proto__ = src;
      /* eslint-enable no-proto */
    }

    /**
     * Augment a target Object or Array by defining
     * hidden properties.
     */
    /* istanbul ignore next */
    function copyAugment (target, src, keys) {
      for (var i = 0, l = keys.length; i < l; i++) {
        var key = keys[i];
        def(target, key, src[key]);
      }
    }

    /**
     * Attempt to create an observer instance for a value,
     * returns the new observer if successfully observed,
     * or the existing observer if the value already has one.
     */
    function observe (value, asRootData) {
      if (!isObject$1(value) || value instanceof VNode) {
        return
      }
      var ob;
      if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
        ob = value.__ob__;
      } else if (
        shouldObserve &&
        !isServerRendering() &&
        (Array.isArray(value) || isPlainObject(value)) &&
        Object.isExtensible(value) &&
        !value._isVue
      ) {
        ob = new Observer(value);
      }
      if (asRootData && ob) {
        ob.vmCount++;
      }
      return ob
    }

    /**
     * Define a reactive property on an Object.
     */
    function defineReactive$$1 (
      obj,
      key,
      val,
      customSetter,
      shallow
    ) {
      var dep = new Dep();

      var property = Object.getOwnPropertyDescriptor(obj, key);
      if (property && property.configurable === false) {
        return
      }

      // cater for pre-defined getter/setters
      var getter = property && property.get;
      var setter = property && property.set;
      if ((!getter || setter) && arguments.length === 2) {
        val = obj[key];
      }

      var childOb = !shallow && observe(val);
      Object.defineProperty(obj, key, {
        enumerable: true,
        configurable: true,
        get: function reactiveGetter () {
          var value = getter ? getter.call(obj) : val;
          if (Dep.target) {
            dep.depend();
            if (childOb) {
              childOb.dep.depend();
              if (Array.isArray(value)) {
                dependArray(value);
              }
            }
          }
          return value
        },
        set: function reactiveSetter (newVal) {
          var value = getter ? getter.call(obj) : val;
          /* eslint-disable no-self-compare */
          if (newVal === value || (newVal !== newVal && value !== value)) {
            return
          }
          // #7981: for accessor properties without setter
          if (getter && !setter) { return }
          if (setter) {
            setter.call(obj, newVal);
          } else {
            val = newVal;
          }
          childOb = !shallow && observe(newVal);
          dep.notify();
        }
      });
    }

    /**
     * Set a property on an object. Adds the new property and
     * triggers change notification if the property doesn't
     * already exist.
     */
    function set (target, key, val) {
      if (Array.isArray(target) && isValidArrayIndex(key)) {
        target.length = Math.max(target.length, key);
        target.splice(key, 1, val);
        return val
      }
      if (key in target && !(key in Object.prototype)) {
        target[key] = val;
        return val
      }
      var ob = (target).__ob__;
      if (target._isVue || (ob && ob.vmCount)) {
        return val
      }
      if (!ob) {
        target[key] = val;
        return val
      }
      defineReactive$$1(ob.value, key, val);
      ob.dep.notify();
      return val
    }

    /**
     * Delete a property and trigger change if necessary.
     */
    function del (target, key) {
      if (Array.isArray(target) && isValidArrayIndex(key)) {
        target.splice(key, 1);
        return
      }
      var ob = (target).__ob__;
      if (target._isVue || (ob && ob.vmCount)) {
        return
      }
      if (!hasOwn(target, key)) {
        return
      }
      delete target[key];
      if (!ob) {
        return
      }
      ob.dep.notify();
    }

    /**
     * Collect dependencies on array elements when the array is touched, since
     * we cannot intercept array element access like property getters.
     */
    function dependArray (value) {
      for (var e = (void 0), i = 0, l = value.length; i < l; i++) {
        e = value[i];
        e && e.__ob__ && e.__ob__.dep.depend();
        if (Array.isArray(e)) {
          dependArray(e);
        }
      }
    }

    /*  */

    /**
     * Option overwriting strategies are functions that handle
     * how to merge a parent option value and a child option
     * value into the final value.
     */
    var strats = config$1.optionMergeStrategies;

    /**
     * Helper that recursively merges two data objects together.
     */
    function mergeData (to, from) {
      if (!from) { return to }
      var key, toVal, fromVal;

      var keys = hasSymbol
        ? Reflect.ownKeys(from)
        : Object.keys(from);

      for (var i = 0; i < keys.length; i++) {
        key = keys[i];
        // in case the object is already observed...
        if (key === '__ob__') { continue }
        toVal = to[key];
        fromVal = from[key];
        if (!hasOwn(to, key)) {
          set(to, key, fromVal);
        } else if (
          toVal !== fromVal &&
          isPlainObject(toVal) &&
          isPlainObject(fromVal)
        ) {
          mergeData(toVal, fromVal);
        }
      }
      return to
    }

    /**
     * Data
     */
    function mergeDataOrFn (
      parentVal,
      childVal,
      vm
    ) {
      if (!vm) {
        // in a Vue.extend merge, both should be functions
        if (!childVal) {
          return parentVal
        }
        if (!parentVal) {
          return childVal
        }
        // when parentVal & childVal are both present,
        // we need to return a function that returns the
        // merged result of both functions... no need to
        // check if parentVal is a function here because
        // it has to be a function to pass previous merges.
        return function mergedDataFn () {
          return mergeData(
            typeof childVal === 'function' ? childVal.call(this, this) : childVal,
            typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal
          )
        }
      } else {
        return function mergedInstanceDataFn () {
          // instance merge
          var instanceData = typeof childVal === 'function'
            ? childVal.call(vm, vm)
            : childVal;
          var defaultData = typeof parentVal === 'function'
            ? parentVal.call(vm, vm)
            : parentVal;
          if (instanceData) {
            return mergeData(instanceData, defaultData)
          } else {
            return defaultData
          }
        }
      }
    }

    strats.data = function (
      parentVal,
      childVal,
      vm
    ) {
      if (!vm) {
        if (childVal && typeof childVal !== 'function') {

          return parentVal
        }
        return mergeDataOrFn(parentVal, childVal)
      }

      return mergeDataOrFn(parentVal, childVal, vm)
    };

    /**
     * Hooks and props are merged as arrays.
     */
    function mergeHook (
      parentVal,
      childVal
    ) {
      var res = childVal
        ? parentVal
          ? parentVal.concat(childVal)
          : Array.isArray(childVal)
            ? childVal
            : [childVal]
        : parentVal;
      return res
        ? dedupeHooks(res)
        : res
    }

    function dedupeHooks (hooks) {
      var res = [];
      for (var i = 0; i < hooks.length; i++) {
        if (res.indexOf(hooks[i]) === -1) {
          res.push(hooks[i]);
        }
      }
      return res
    }

    LIFECYCLE_HOOKS.forEach(function (hook) {
      strats[hook] = mergeHook;
    });

    /**
     * Assets
     *
     * When a vm is present (instance creation), we need to do
     * a three-way merge between constructor options, instance
     * options and parent options.
     */
    function mergeAssets (
      parentVal,
      childVal,
      vm,
      key
    ) {
      var res = Object.create(parentVal || null);
      if (childVal) {
        return extend(res, childVal)
      } else {
        return res
      }
    }

    ASSET_TYPES.forEach(function (type) {
      strats[type + 's'] = mergeAssets;
    });

    /**
     * Watchers.
     *
     * Watchers hashes should not overwrite one
     * another, so we merge them as arrays.
     */
    strats.watch = function (
      parentVal,
      childVal,
      vm,
      key
    ) {
      // work around Firefox's Object.prototype.watch...
      if (parentVal === nativeWatch) { parentVal = undefined; }
      if (childVal === nativeWatch) { childVal = undefined; }
      /* istanbul ignore if */
      if (!childVal) { return Object.create(parentVal || null) }
      if (!parentVal) { return childVal }
      var ret = {};
      extend(ret, parentVal);
      for (var key$1 in childVal) {
        var parent = ret[key$1];
        var child = childVal[key$1];
        if (parent && !Array.isArray(parent)) {
          parent = [parent];
        }
        ret[key$1] = parent
          ? parent.concat(child)
          : Array.isArray(child) ? child : [child];
      }
      return ret
    };

    /**
     * Other object hashes.
     */
    strats.props =
    strats.methods =
    strats.inject =
    strats.computed = function (
      parentVal,
      childVal,
      vm,
      key
    ) {
      if (childVal && "production" !== 'production') {
        assertObjectType(key, childVal);
      }
      if (!parentVal) { return childVal }
      var ret = Object.create(null);
      extend(ret, parentVal);
      if (childVal) { extend(ret, childVal); }
      return ret
    };
    strats.provide = mergeDataOrFn;

    /**
     * Default strategy.
     */
    var defaultStrat = function (parentVal, childVal) {
      return childVal === undefined
        ? parentVal
        : childVal
    };

    /**
     * Ensure all props option syntax are normalized into the
     * Object-based format.
     */
    function normalizeProps (options, vm) {
      var props = options.props;
      if (!props) { return }
      var res = {};
      var i, val, name;
      if (Array.isArray(props)) {
        i = props.length;
        while (i--) {
          val = props[i];
          if (typeof val === 'string') {
            name = camelize(val);
            res[name] = { type: null };
          }
        }
      } else if (isPlainObject(props)) {
        for (var key in props) {
          val = props[key];
          name = camelize(key);
          res[name] = isPlainObject(val)
            ? val
            : { type: val };
        }
      }
      options.props = res;
    }

    /**
     * Normalize all injections into Object-based format
     */
    function normalizeInject (options, vm) {
      var inject = options.inject;
      if (!inject) { return }
      var normalized = options.inject = {};
      if (Array.isArray(inject)) {
        for (var i = 0; i < inject.length; i++) {
          normalized[inject[i]] = { from: inject[i] };
        }
      } else if (isPlainObject(inject)) {
        for (var key in inject) {
          var val = inject[key];
          normalized[key] = isPlainObject(val)
            ? extend({ from: key }, val)
            : { from: val };
        }
      }
    }

    /**
     * Normalize raw function directives into object format.
     */
    function normalizeDirectives (options) {
      var dirs = options.directives;
      if (dirs) {
        for (var key in dirs) {
          var def$$1 = dirs[key];
          if (typeof def$$1 === 'function') {
            dirs[key] = { bind: def$$1, update: def$$1 };
          }
        }
      }
    }

    function assertObjectType (name, value, vm) {
      if (!isPlainObject(value)) {
        warn(
          "Invalid value for option \"" + name + "\": expected an Object, " +
          "but got " + (toRawType(value)) + ".");
      }
    }

    /**
     * Merge two option objects into a new one.
     * Core utility used in both instantiation and inheritance.
     */
    function mergeOptions (
      parent,
      child,
      vm
    ) {

      if (typeof child === 'function') {
        child = child.options;
      }

      normalizeProps(child);
      normalizeInject(child);
      normalizeDirectives(child);

      // Apply extends and mixins on the child options,
      // but only if it is a raw options object that isn't
      // the result of another mergeOptions call.
      // Only merged options has the _base property.
      if (!child._base) {
        if (child.extends) {
          parent = mergeOptions(parent, child.extends, vm);
        }
        if (child.mixins) {
          for (var i = 0, l = child.mixins.length; i < l; i++) {
            parent = mergeOptions(parent, child.mixins[i], vm);
          }
        }
      }

      var options = {};
      var key;
      for (key in parent) {
        mergeField(key);
      }
      for (key in child) {
        if (!hasOwn(parent, key)) {
          mergeField(key);
        }
      }
      function mergeField (key) {
        var strat = strats[key] || defaultStrat;
        options[key] = strat(parent[key], child[key], vm, key);
      }
      return options
    }

    /**
     * Resolve an asset.
     * This function is used because child instances need access
     * to assets defined in its ancestor chain.
     */
    function resolveAsset (
      options,
      type,
      id,
      warnMissing
    ) {
      /* istanbul ignore if */
      if (typeof id !== 'string') {
        return
      }
      var assets = options[type];
      // check local registration variations first
      if (hasOwn(assets, id)) { return assets[id] }
      var camelizedId = camelize(id);
      if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }
      var PascalCaseId = capitalize(camelizedId);
      if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }
      // fallback to prototype chain
      var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
      return res
    }

    /*  */



    function validateProp (
      key,
      propOptions,
      propsData,
      vm
    ) {
      var prop = propOptions[key];
      var absent = !hasOwn(propsData, key);
      var value = propsData[key];
      // boolean casting
      var booleanIndex = getTypeIndex(Boolean, prop.type);
      if (booleanIndex > -1) {
        if (absent && !hasOwn(prop, 'default')) {
          value = false;
        } else if (value === '' || value === hyphenate(key)) {
          // only cast empty string / same name to boolean if
          // boolean has higher priority
          var stringIndex = getTypeIndex(String, prop.type);
          if (stringIndex < 0 || booleanIndex < stringIndex) {
            value = true;
          }
        }
      }
      // check default value
      if (value === undefined) {
        value = getPropDefaultValue(vm, prop, key);
        // since the default value is a fresh copy,
        // make sure to observe it.
        var prevShouldObserve = shouldObserve;
        toggleObserving(true);
        observe(value);
        toggleObserving(prevShouldObserve);
      }
      return value
    }

    /**
     * Get the default value of a prop.
     */
    function getPropDefaultValue (vm, prop, key) {
      // no default, return undefined
      if (!hasOwn(prop, 'default')) {
        return undefined
      }
      var def = prop.default;
      // the raw prop value was also undefined from previous render,
      // return previous default value to avoid unnecessary watcher trigger
      if (vm && vm.$options.propsData &&
        vm.$options.propsData[key] === undefined &&
        vm._props[key] !== undefined
      ) {
        return vm._props[key]
      }
      // call factory function for non-Function types
      // a value is Function if its prototype is function even across different execution context
      return typeof def === 'function' && getType(prop.type) !== 'Function'
        ? def.call(vm)
        : def
    }

    var functionTypeCheckRE = /^\s*function (\w+)/;

    /**
     * Use function string name to check built-in types,
     * because a simple equality check will fail when running
     * across different vms / iframes.
     */
    function getType (fn) {
      var match = fn && fn.toString().match(functionTypeCheckRE);
      return match ? match[1] : ''
    }

    function isSameType (a, b) {
      return getType(a) === getType(b)
    }

    function getTypeIndex (type, expectedTypes) {
      if (!Array.isArray(expectedTypes)) {
        return isSameType(expectedTypes, type) ? 0 : -1
      }
      for (var i = 0, len = expectedTypes.length; i < len; i++) {
        if (isSameType(expectedTypes[i], type)) {
          return i
        }
      }
      return -1
    }

    /*  */

    function handleError (err, vm, info) {
      // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.
      // See: https://github.com/vuejs/vuex/issues/1505
      pushTarget();
      try {
        if (vm) {
          var cur = vm;
          while ((cur = cur.$parent)) {
            var hooks = cur.$options.errorCaptured;
            if (hooks) {
              for (var i = 0; i < hooks.length; i++) {
                try {
                  var capture = hooks[i].call(cur, err, vm, info) === false;
                  if (capture) { return }
                } catch (e) {
                  globalHandleError(e, cur, 'errorCaptured hook');
                }
              }
            }
          }
        }
        globalHandleError(err, vm, info);
      } finally {
        popTarget();
      }
    }

    function invokeWithErrorHandling (
      handler,
      context,
      args,
      vm,
      info
    ) {
      var res;
      try {
        res = args ? handler.apply(context, args) : handler.call(context);
        if (res && !res._isVue && isPromise$1(res) && !res._handled) {
          res.catch(function (e) { return handleError(e, vm, info + " (Promise/async)"); });
          // issue #9511
          // avoid catch triggering multiple times when nested calls
          res._handled = true;
        }
      } catch (e) {
        handleError(e, vm, info);
      }
      return res
    }

    function globalHandleError (err, vm, info) {
      if (config$1.errorHandler) {
        try {
          return config$1.errorHandler.call(null, err, vm, info)
        } catch (e) {
          // if the user intentionally throws the original error in the handler,
          // do not log it twice
          if (e !== err) {
            logError(e);
          }
        }
      }
      logError(err);
    }

    function logError (err, vm, info) {
      /* istanbul ignore else */
      if ((inBrowser || inWeex) && typeof console !== 'undefined') {
        console.error(err);
      } else {
        throw err
      }
    }

    /*  */

    var isUsingMicroTask = false;

    var callbacks = [];
    var pending = false;

    function flushCallbacks () {
      pending = false;
      var copies = callbacks.slice(0);
      callbacks.length = 0;
      for (var i = 0; i < copies.length; i++) {
        copies[i]();
      }
    }

    // Here we have async deferring wrappers using microtasks.
    // In 2.5 we used (macro) tasks (in combination with microtasks).
    // However, it has subtle problems when state is changed right before repaint
    // (e.g. #6813, out-in transitions).
    // Also, using (macro) tasks in event handler would cause some weird behaviors
    // that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).
    // So we now use microtasks everywhere, again.
    // A major drawback of this tradeoff is that there are some scenarios
    // where microtasks have too high a priority and fire in between supposedly
    // sequential events (e.g. #4521, #6690, which have workarounds)
    // or even between bubbling of the same event (#6566).
    var timerFunc;

    // The nextTick behavior leverages the microtask queue, which can be accessed
    // via either native Promise.then or MutationObserver.
    // MutationObserver has wider support, however it is seriously bugged in
    // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
    // completely stops working after triggering a few times... so, if native
    // Promise is available, we will use it:
    /* istanbul ignore next, $flow-disable-line */
    if (typeof Promise !== 'undefined' && isNative(Promise)) {
      var p$1 = Promise.resolve();
      timerFunc = function () {
        p$1.then(flushCallbacks);
        // In problematic UIWebViews, Promise.then doesn't completely break, but
        // it can get stuck in a weird state where callbacks are pushed into the
        // microtask queue but the queue isn't being flushed, until the browser
        // needs to do some other work, e.g. handle a timer. Therefore we can
        // "force" the microtask queue to be flushed by adding an empty timer.
        if (isIOS) { setTimeout(noop$1); }
      };
      isUsingMicroTask = true;
    } else if (!isIE && typeof MutationObserver !== 'undefined' && (
      isNative(MutationObserver) ||
      // PhantomJS and iOS 7.x
      MutationObserver.toString() === '[object MutationObserverConstructor]'
    )) {
      // Use MutationObserver where native Promise is not available,
      // e.g. PhantomJS, iOS7, Android 4.4
      // (#6466 MutationObserver is unreliable in IE11)
      var counter = 1;
      var observer = new MutationObserver(flushCallbacks);
      var textNode = document.createTextNode(String(counter));
      observer.observe(textNode, {
        characterData: true
      });
      timerFunc = function () {
        counter = (counter + 1) % 2;
        textNode.data = String(counter);
      };
      isUsingMicroTask = true;
    } else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
      // Fallback to setImmediate.
      // Technically it leverages the (macro) task queue,
      // but it is still a better choice than setTimeout.
      timerFunc = function () {
        setImmediate(flushCallbacks);
      };
    } else {
      // Fallback to setTimeout.
      timerFunc = function () {
        setTimeout(flushCallbacks, 0);
      };
    }

    function nextTick (cb, ctx) {
      var _resolve;
      callbacks.push(function () {
        if (cb) {
          try {
            cb.call(ctx);
          } catch (e) {
            handleError(e, ctx, 'nextTick');
          }
        } else if (_resolve) {
          _resolve(ctx);
        }
      });
      if (!pending) {
        pending = true;
        timerFunc();
      }
      // $flow-disable-line
      if (!cb && typeof Promise !== 'undefined') {
        return new Promise(function (resolve) {
          _resolve = resolve;
        })
      }
    }

    /*  */

    var seenObjects = new _Set();

    /**
     * Recursively traverse an object to evoke all converted
     * getters, so that every nested property inside the object
     * is collected as a "deep" dependency.
     */
    function traverse (val) {
      _traverse(val, seenObjects);
      seenObjects.clear();
    }

    function _traverse (val, seen) {
      var i, keys;
      var isA = Array.isArray(val);
      if ((!isA && !isObject$1(val)) || Object.isFrozen(val) || val instanceof VNode) {
        return
      }
      if (val.__ob__) {
        var depId = val.__ob__.dep.id;
        if (seen.has(depId)) {
          return
        }
        seen.add(depId);
      }
      if (isA) {
        i = val.length;
        while (i--) { _traverse(val[i], seen); }
      } else {
        keys = Object.keys(val);
        i = keys.length;
        while (i--) { _traverse(val[keys[i]], seen); }
      }
    }

    /*  */

    var normalizeEvent = cached(function (name) {
      var passive = name.charAt(0) === '&';
      name = passive ? name.slice(1) : name;
      var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
      name = once$$1 ? name.slice(1) : name;
      var capture = name.charAt(0) === '!';
      name = capture ? name.slice(1) : name;
      return {
        name: name,
        once: once$$1,
        capture: capture,
        passive: passive
      }
    });

    function createFnInvoker (fns, vm) {
      function invoker () {
        var arguments$1 = arguments;

        var fns = invoker.fns;
        if (Array.isArray(fns)) {
          var cloned = fns.slice();
          for (var i = 0; i < cloned.length; i++) {
            invokeWithErrorHandling(cloned[i], null, arguments$1, vm, "v-on handler");
          }
        } else {
          // return handler return value for single handlers
          return invokeWithErrorHandling(fns, null, arguments, vm, "v-on handler")
        }
      }
      invoker.fns = fns;
      return invoker
    }

    function updateListeners (
      on,
      oldOn,
      add,
      remove$$1,
      createOnceHandler,
      vm
    ) {
      var name, def$$1, cur, old, event;
      for (name in on) {
        def$$1 = cur = on[name];
        old = oldOn[name];
        event = normalizeEvent(name);
        if (isUndef(cur)) ; else if (isUndef(old)) {
          if (isUndef(cur.fns)) {
            cur = on[name] = createFnInvoker(cur, vm);
          }
          if (isTrue(event.once)) {
            cur = on[name] = createOnceHandler(event.name, cur, event.capture);
          }
          add(event.name, cur, event.capture, event.passive, event.params);
        } else if (cur !== old) {
          old.fns = cur;
          on[name] = old;
        }
      }
      for (name in oldOn) {
        if (isUndef(on[name])) {
          event = normalizeEvent(name);
          remove$$1(event.name, oldOn[name], event.capture);
        }
      }
    }

    /*  */

    function mergeVNodeHook (def, hookKey, hook) {
      if (def instanceof VNode) {
        def = def.data.hook || (def.data.hook = {});
      }
      var invoker;
      var oldHook = def[hookKey];

      function wrappedHook () {
        hook.apply(this, arguments);
        // important: remove merged hook to ensure it's called only once
        // and prevent memory leak
        remove(invoker.fns, wrappedHook);
      }

      if (isUndef(oldHook)) {
        // no existing hook
        invoker = createFnInvoker([wrappedHook]);
      } else {
        /* istanbul ignore if */
        if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
          // already a merged invoker
          invoker = oldHook;
          invoker.fns.push(wrappedHook);
        } else {
          // existing plain hook
          invoker = createFnInvoker([oldHook, wrappedHook]);
        }
      }

      invoker.merged = true;
      def[hookKey] = invoker;
    }

    /*  */

    function extractPropsFromVNodeData (
      data,
      Ctor,
      tag
    ) {
      // we are only extracting raw values here.
      // validation and default values are handled in the child
      // component itself.
      var propOptions = Ctor.options.props;
      if (isUndef(propOptions)) {
        return
      }
      var res = {};
      var attrs = data.attrs;
      var props = data.props;
      if (isDef(attrs) || isDef(props)) {
        for (var key in propOptions) {
          var altKey = hyphenate(key);
          checkProp(res, props, key, altKey, true) ||
          checkProp(res, attrs, key, altKey, false);
        }
      }
      return res
    }

    function checkProp (
      res,
      hash,
      key,
      altKey,
      preserve
    ) {
      if (isDef(hash)) {
        if (hasOwn(hash, key)) {
          res[key] = hash[key];
          if (!preserve) {
            delete hash[key];
          }
          return true
        } else if (hasOwn(hash, altKey)) {
          res[key] = hash[altKey];
          if (!preserve) {
            delete hash[altKey];
          }
          return true
        }
      }
      return false
    }

    /*  */

    // The template compiler attempts to minimize the need for normalization by
    // statically analyzing the template at compile time.
    //
    // For plain HTML markup, normalization can be completely skipped because the
    // generated render function is guaranteed to return Array<VNode>. There are
    // two cases where extra normalization is needed:

    // 1. When the children contains components - because a functional component
    // may return an Array instead of a single root. In this case, just a simple
    // normalization is needed - if any child is an Array, we flatten the whole
    // thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
    // because functional components already normalize their own children.
    function simpleNormalizeChildren (children) {
      for (var i = 0; i < children.length; i++) {
        if (Array.isArray(children[i])) {
          return Array.prototype.concat.apply([], children)
        }
      }
      return children
    }

    // 2. When the children contains constructs that always generated nested Arrays,
    // e.g. <template>, <slot>, v-for, or when the children is provided by user
    // with hand-written render functions / JSX. In such cases a full normalization
    // is needed to cater to all possible types of children values.
    function normalizeChildren (children) {
      return isPrimitive(children)
        ? [createTextVNode(children)]
        : Array.isArray(children)
          ? normalizeArrayChildren(children)
          : undefined
    }

    function isTextNode (node) {
      return isDef(node) && isDef(node.text) && isFalse(node.isComment)
    }

    function normalizeArrayChildren (children, nestedIndex) {
      var res = [];
      var i, c, lastIndex, last;
      for (i = 0; i < children.length; i++) {
        c = children[i];
        if (isUndef(c) || typeof c === 'boolean') { continue }
        lastIndex = res.length - 1;
        last = res[lastIndex];
        //  nested
        if (Array.isArray(c)) {
          if (c.length > 0) {
            c = normalizeArrayChildren(c, ((nestedIndex || '') + "_" + i));
            // merge adjacent text nodes
            if (isTextNode(c[0]) && isTextNode(last)) {
              res[lastIndex] = createTextVNode(last.text + (c[0]).text);
              c.shift();
            }
            res.push.apply(res, c);
          }
        } else if (isPrimitive(c)) {
          if (isTextNode(last)) {
            // merge adjacent text nodes
            // this is necessary for SSR hydration because text nodes are
            // essentially merged when rendered to HTML strings
            res[lastIndex] = createTextVNode(last.text + c);
          } else if (c !== '') {
            // convert primitive to vnode
            res.push(createTextVNode(c));
          }
        } else {
          if (isTextNode(c) && isTextNode(last)) {
            // merge adjacent text nodes
            res[lastIndex] = createTextVNode(last.text + c.text);
          } else {
            // default key for nested array children (likely generated by v-for)
            if (isTrue(children._isVList) &&
              isDef(c.tag) &&
              isUndef(c.key) &&
              isDef(nestedIndex)) {
              c.key = "__vlist" + nestedIndex + "_" + i + "__";
            }
            res.push(c);
          }
        }
      }
      return res
    }

    /*  */

    function initProvide (vm) {
      var provide = vm.$options.provide;
      if (provide) {
        vm._provided = typeof provide === 'function'
          ? provide.call(vm)
          : provide;
      }
    }

    function initInjections (vm) {
      var result = resolveInject(vm.$options.inject, vm);
      if (result) {
        toggleObserving(false);
        Object.keys(result).forEach(function (key) {
          /* istanbul ignore else */
          {
            defineReactive$$1(vm, key, result[key]);
          }
        });
        toggleObserving(true);
      }
    }

    function resolveInject (inject, vm) {
      if (inject) {
        // inject is :any because flow is not smart enough to figure out cached
        var result = Object.create(null);
        var keys = hasSymbol
          ? Reflect.ownKeys(inject)
          : Object.keys(inject);

        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          // #6574 in case the inject object is observed...
          if (key === '__ob__') { continue }
          var provideKey = inject[key].from;
          var source = vm;
          while (source) {
            if (source._provided && hasOwn(source._provided, provideKey)) {
              result[key] = source._provided[provideKey];
              break
            }
            source = source.$parent;
          }
          if (!source) {
            if ('default' in inject[key]) {
              var provideDefault = inject[key].default;
              result[key] = typeof provideDefault === 'function'
                ? provideDefault.call(vm)
                : provideDefault;
            }
          }
        }
        return result
      }
    }

    /*  */



    /**
     * Runtime helper for resolving raw children VNodes into a slot object.
     */
    function resolveSlots (
      children,
      context
    ) {
      if (!children || !children.length) {
        return {}
      }
      var slots = {};
      for (var i = 0, l = children.length; i < l; i++) {
        var child = children[i];
        var data = child.data;
        // remove slot attribute if the node is resolved as a Vue slot node
        if (data && data.attrs && data.attrs.slot) {
          delete data.attrs.slot;
        }
        // named slots should only be respected if the vnode was rendered in the
        // same context.
        if ((child.context === context || child.fnContext === context) &&
          data && data.slot != null
        ) {
          var name = data.slot;
          var slot = (slots[name] || (slots[name] = []));
          if (child.tag === 'template') {
            slot.push.apply(slot, child.children || []);
          } else {
            slot.push(child);
          }
        } else {
          (slots.default || (slots.default = [])).push(child);
        }
      }
      // ignore slots that contains only whitespace
      for (var name$1 in slots) {
        if (slots[name$1].every(isWhitespace)) {
          delete slots[name$1];
        }
      }
      return slots
    }

    function isWhitespace (node) {
      return (node.isComment && !node.asyncFactory) || node.text === ' '
    }

    /*  */

    function isAsyncPlaceholder (node) {
      return node.isComment && node.asyncFactory
    }

    /*  */

    function normalizeScopedSlots (
      slots,
      normalSlots,
      prevSlots
    ) {
      var res;
      var hasNormalSlots = Object.keys(normalSlots).length > 0;
      var isStable = slots ? !!slots.$stable : !hasNormalSlots;
      var key = slots && slots.$key;
      if (!slots) {
        res = {};
      } else if (slots._normalized) {
        // fast path 1: child component re-render only, parent did not change
        return slots._normalized
      } else if (
        isStable &&
        prevSlots &&
        prevSlots !== emptyObject &&
        key === prevSlots.$key &&
        !hasNormalSlots &&
        !prevSlots.$hasNormal
      ) {
        // fast path 2: stable scoped slots w/ no normal slots to proxy,
        // only need to normalize once
        return prevSlots
      } else {
        res = {};
        for (var key$1 in slots) {
          if (slots[key$1] && key$1[0] !== '$') {
            res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);
          }
        }
      }
      // expose normal slots on scopedSlots
      for (var key$2 in normalSlots) {
        if (!(key$2 in res)) {
          res[key$2] = proxyNormalSlot(normalSlots, key$2);
        }
      }
      // avoriaz seems to mock a non-extensible $scopedSlots object
      // and when that is passed down this would cause an error
      if (slots && Object.isExtensible(slots)) {
        (slots)._normalized = res;
      }
      def(res, '$stable', isStable);
      def(res, '$key', key);
      def(res, '$hasNormal', hasNormalSlots);
      return res
    }

    function normalizeScopedSlot(normalSlots, key, fn) {
      var normalized = function () {
        var res = arguments.length ? fn.apply(null, arguments) : fn({});
        res = res && typeof res === 'object' && !Array.isArray(res)
          ? [res] // single vnode
          : normalizeChildren(res);
        var vnode = res && res[0];
        return res && (
          !vnode ||
          (res.length === 1 && vnode.isComment && !isAsyncPlaceholder(vnode)) // #9658, #10391
        ) ? undefined
          : res
      };
      // this is a slot using the new v-slot syntax without scope. although it is
      // compiled as a scoped slot, render fn users would expect it to be present
      // on this.$slots because the usage is semantically a normal slot.
      if (fn.proxy) {
        Object.defineProperty(normalSlots, key, {
          get: normalized,
          enumerable: true,
          configurable: true
        });
      }
      return normalized
    }

    function proxyNormalSlot(slots, key) {
      return function () { return slots[key]; }
    }

    /*  */

    /**
     * Runtime helper for rendering v-for lists.
     */
    function renderList (
      val,
      render
    ) {
      var ret, i, l, keys, key;
      if (Array.isArray(val) || typeof val === 'string') {
        ret = new Array(val.length);
        for (i = 0, l = val.length; i < l; i++) {
          ret[i] = render(val[i], i);
        }
      } else if (typeof val === 'number') {
        ret = new Array(val);
        for (i = 0; i < val; i++) {
          ret[i] = render(i + 1, i);
        }
      } else if (isObject$1(val)) {
        if (hasSymbol && val[Symbol.iterator]) {
          ret = [];
          var iterator = val[Symbol.iterator]();
          var result = iterator.next();
          while (!result.done) {
            ret.push(render(result.value, ret.length));
            result = iterator.next();
          }
        } else {
          keys = Object.keys(val);
          ret = new Array(keys.length);
          for (i = 0, l = keys.length; i < l; i++) {
            key = keys[i];
            ret[i] = render(val[key], key, i);
          }
        }
      }
      if (!isDef(ret)) {
        ret = [];
      }
      (ret)._isVList = true;
      return ret
    }

    /*  */

    /**
     * Runtime helper for rendering <slot>
     */
    function renderSlot (
      name,
      fallbackRender,
      props,
      bindObject
    ) {
      var scopedSlotFn = this.$scopedSlots[name];
      var nodes;
      if (scopedSlotFn) {
        // scoped slot
        props = props || {};
        if (bindObject) {
          props = extend(extend({}, bindObject), props);
        }
        nodes =
          scopedSlotFn(props) ||
          (typeof fallbackRender === 'function' ? fallbackRender() : fallbackRender);
      } else {
        nodes =
          this.$slots[name] ||
          (typeof fallbackRender === 'function' ? fallbackRender() : fallbackRender);
      }

      var target = props && props.slot;
      if (target) {
        return this.$createElement('template', { slot: target }, nodes)
      } else {
        return nodes
      }
    }

    /*  */

    /**
     * Runtime helper for resolving filters
     */
    function resolveFilter (id) {
      return resolveAsset(this.$options, 'filters', id) || identity$1
    }

    /*  */

    function isKeyNotMatch (expect, actual) {
      if (Array.isArray(expect)) {
        return expect.indexOf(actual) === -1
      } else {
        return expect !== actual
      }
    }

    /**
     * Runtime helper for checking keyCodes from config.
     * exposed as Vue.prototype._k
     * passing in eventKeyName as last argument separately for backwards compat
     */
    function checkKeyCodes (
      eventKeyCode,
      key,
      builtInKeyCode,
      eventKeyName,
      builtInKeyName
    ) {
      var mappedKeyCode = config$1.keyCodes[key] || builtInKeyCode;
      if (builtInKeyName && eventKeyName && !config$1.keyCodes[key]) {
        return isKeyNotMatch(builtInKeyName, eventKeyName)
      } else if (mappedKeyCode) {
        return isKeyNotMatch(mappedKeyCode, eventKeyCode)
      } else if (eventKeyName) {
        return hyphenate(eventKeyName) !== key
      }
      return eventKeyCode === undefined
    }

    /*  */

    /**
     * Runtime helper for merging v-bind="object" into a VNode's data.
     */
    function bindObjectProps (
      data,
      tag,
      value,
      asProp,
      isSync
    ) {
      if (value) {
        if (!isObject$1(value)) ; else {
          if (Array.isArray(value)) {
            value = toObject(value);
          }
          var hash;
          var loop = function ( key ) {
            if (
              key === 'class' ||
              key === 'style' ||
              isReservedAttribute(key)
            ) {
              hash = data;
            } else {
              var type = data.attrs && data.attrs.type;
              hash = asProp || config$1.mustUseProp(tag, type, key)
                ? data.domProps || (data.domProps = {})
                : data.attrs || (data.attrs = {});
            }
            var camelizedKey = camelize(key);
            var hyphenatedKey = hyphenate(key);
            if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {
              hash[key] = value[key];

              if (isSync) {
                var on = data.on || (data.on = {});
                on[("update:" + key)] = function ($event) {
                  value[key] = $event;
                };
              }
            }
          };

          for (var key in value) loop( key );
        }
      }
      return data
    }

    /*  */

    /**
     * Runtime helper for rendering static trees.
     */
    function renderStatic (
      index,
      isInFor
    ) {
      var cached = this._staticTrees || (this._staticTrees = []);
      var tree = cached[index];
      // if has already-rendered static tree and not inside v-for,
      // we can reuse the same tree.
      if (tree && !isInFor) {
        return tree
      }
      // otherwise, render a fresh tree.
      tree = cached[index] = this.$options.staticRenderFns[index].call(
        this._renderProxy,
        null,
        this // for render fns generated for functional component templates
      );
      markStatic(tree, ("__static__" + index), false);
      return tree
    }

    /**
     * Runtime helper for v-once.
     * Effectively it means marking the node as static with a unique key.
     */
    function markOnce (
      tree,
      index,
      key
    ) {
      markStatic(tree, ("__once__" + index + (key ? ("_" + key) : "")), true);
      return tree
    }

    function markStatic (
      tree,
      key,
      isOnce
    ) {
      if (Array.isArray(tree)) {
        for (var i = 0; i < tree.length; i++) {
          if (tree[i] && typeof tree[i] !== 'string') {
            markStaticNode(tree[i], (key + "_" + i), isOnce);
          }
        }
      } else {
        markStaticNode(tree, key, isOnce);
      }
    }

    function markStaticNode (node, key, isOnce) {
      node.isStatic = true;
      node.key = key;
      node.isOnce = isOnce;
    }

    /*  */

    function bindObjectListeners (data, value) {
      if (value) {
        if (!isPlainObject(value)) ; else {
          var on = data.on = data.on ? extend({}, data.on) : {};
          for (var key in value) {
            var existing = on[key];
            var ours = value[key];
            on[key] = existing ? [].concat(existing, ours) : ours;
          }
        }
      }
      return data
    }

    /*  */

    function resolveScopedSlots (
      fns, // see flow/vnode
      res,
      // the following are added in 2.6
      hasDynamicKeys,
      contentHashKey
    ) {
      res = res || { $stable: !hasDynamicKeys };
      for (var i = 0; i < fns.length; i++) {
        var slot = fns[i];
        if (Array.isArray(slot)) {
          resolveScopedSlots(slot, res, hasDynamicKeys);
        } else if (slot) {
          // marker for reverse proxying v-slot without scope on this.$slots
          if (slot.proxy) {
            slot.fn.proxy = true;
          }
          res[slot.key] = slot.fn;
        }
      }
      if (contentHashKey) {
        (res).$key = contentHashKey;
      }
      return res
    }

    /*  */

    function bindDynamicKeys (baseObj, values) {
      for (var i = 0; i < values.length; i += 2) {
        var key = values[i];
        if (typeof key === 'string' && key) {
          baseObj[values[i]] = values[i + 1];
        }
      }
      return baseObj
    }

    // helper to dynamically append modifier runtime markers to event names.
    // ensure only append when value is already string, otherwise it will be cast
    // to string and cause the type check to miss.
    function prependModifier (value, symbol) {
      return typeof value === 'string' ? symbol + value : value
    }

    /*  */

    function installRenderHelpers (target) {
      target._o = markOnce;
      target._n = toNumber;
      target._s = toString;
      target._l = renderList;
      target._t = renderSlot;
      target._q = looseEqual;
      target._i = looseIndexOf;
      target._m = renderStatic;
      target._f = resolveFilter;
      target._k = checkKeyCodes;
      target._b = bindObjectProps;
      target._v = createTextVNode;
      target._e = createEmptyVNode;
      target._u = resolveScopedSlots;
      target._g = bindObjectListeners;
      target._d = bindDynamicKeys;
      target._p = prependModifier;
    }

    /*  */

    function FunctionalRenderContext (
      data,
      props,
      children,
      parent,
      Ctor
    ) {
      var this$1 = this;

      var options = Ctor.options;
      // ensure the createElement function in functional components
      // gets a unique context - this is necessary for correct named slot check
      var contextVm;
      if (hasOwn(parent, '_uid')) {
        contextVm = Object.create(parent);
        // $flow-disable-line
        contextVm._original = parent;
      } else {
        // the context vm passed in is a functional context as well.
        // in this case we want to make sure we are able to get a hold to the
        // real context instance.
        contextVm = parent;
        // $flow-disable-line
        parent = parent._original;
      }
      var isCompiled = isTrue(options._compiled);
      var needNormalization = !isCompiled;

      this.data = data;
      this.props = props;
      this.children = children;
      this.parent = parent;
      this.listeners = data.on || emptyObject;
      this.injections = resolveInject(options.inject, parent);
      this.slots = function () {
        if (!this$1.$slots) {
          normalizeScopedSlots(
            data.scopedSlots,
            this$1.$slots = resolveSlots(children, parent)
          );
        }
        return this$1.$slots
      };

      Object.defineProperty(this, 'scopedSlots', ({
        enumerable: true,
        get: function get () {
          return normalizeScopedSlots(data.scopedSlots, this.slots())
        }
      }));

      // support for compiled functional template
      if (isCompiled) {
        // exposing $options for renderStatic()
        this.$options = options;
        // pre-resolve slots for renderSlot()
        this.$slots = this.slots();
        this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);
      }

      if (options._scopeId) {
        this._c = function (a, b, c, d) {
          var vnode = createElement(contextVm, a, b, c, d, needNormalization);
          if (vnode && !Array.isArray(vnode)) {
            vnode.fnScopeId = options._scopeId;
            vnode.fnContext = parent;
          }
          return vnode
        };
      } else {
        this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };
      }
    }

    installRenderHelpers(FunctionalRenderContext.prototype);

    function createFunctionalComponent (
      Ctor,
      propsData,
      data,
      contextVm,
      children
    ) {
      var options = Ctor.options;
      var props = {};
      var propOptions = options.props;
      if (isDef(propOptions)) {
        for (var key in propOptions) {
          props[key] = validateProp(key, propOptions, propsData || emptyObject);
        }
      } else {
        if (isDef(data.attrs)) { mergeProps(props, data.attrs); }
        if (isDef(data.props)) { mergeProps(props, data.props); }
      }

      var renderContext = new FunctionalRenderContext(
        data,
        props,
        children,
        contextVm,
        Ctor
      );

      var vnode = options.render.call(null, renderContext._c, renderContext);

      if (vnode instanceof VNode) {
        return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options)
      } else if (Array.isArray(vnode)) {
        var vnodes = normalizeChildren(vnode) || [];
        var res = new Array(vnodes.length);
        for (var i = 0; i < vnodes.length; i++) {
          res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options);
        }
        return res
      }
    }

    function cloneAndMarkFunctionalResult (vnode, data, contextVm, options, renderContext) {
      // #7817 clone node before setting fnContext, otherwise if the node is reused
      // (e.g. it was from a cached normal slot) the fnContext causes named slots
      // that should not be matched to match.
      var clone = cloneVNode(vnode);
      clone.fnContext = contextVm;
      clone.fnOptions = options;
      if (data.slot) {
        (clone.data || (clone.data = {})).slot = data.slot;
      }
      return clone
    }

    function mergeProps (to, from) {
      for (var key in from) {
        to[camelize(key)] = from[key];
      }
    }

    /*  */

    /*  */

    /*  */

    /*  */

    // inline hooks to be invoked on component VNodes during patch
    var componentVNodeHooks = {
      init: function init (vnode, hydrating) {
        if (
          vnode.componentInstance &&
          !vnode.componentInstance._isDestroyed &&
          vnode.data.keepAlive
        ) {
          // kept-alive components, treat as a patch
          var mountedNode = vnode; // work around flow
          componentVNodeHooks.prepatch(mountedNode, mountedNode);
        } else {
          var child = vnode.componentInstance = createComponentInstanceForVnode(
            vnode,
            activeInstance
          );
          child.$mount(hydrating ? vnode.elm : undefined, hydrating);
        }
      },

      prepatch: function prepatch (oldVnode, vnode) {
        var options = vnode.componentOptions;
        var child = vnode.componentInstance = oldVnode.componentInstance;
        updateChildComponent(
          child,
          options.propsData, // updated props
          options.listeners, // updated listeners
          vnode, // new parent vnode
          options.children // new children
        );
      },

      insert: function insert (vnode) {
        var context = vnode.context;
        var componentInstance = vnode.componentInstance;
        if (!componentInstance._isMounted) {
          componentInstance._isMounted = true;
          callHook(componentInstance, 'mounted');
        }
        if (vnode.data.keepAlive) {
          if (context._isMounted) {
            // vue-router#1212
            // During updates, a kept-alive component's child components may
            // change, so directly walking the tree here may call activated hooks
            // on incorrect children. Instead we push them into a queue which will
            // be processed after the whole patch process ended.
            queueActivatedComponent(componentInstance);
          } else {
            activateChildComponent(componentInstance, true /* direct */);
          }
        }
      },

      destroy: function destroy (vnode) {
        var componentInstance = vnode.componentInstance;
        if (!componentInstance._isDestroyed) {
          if (!vnode.data.keepAlive) {
            componentInstance.$destroy();
          } else {
            deactivateChildComponent(componentInstance, true /* direct */);
          }
        }
      }
    };

    var hooksToMerge = Object.keys(componentVNodeHooks);

    function createComponent (
      Ctor,
      data,
      context,
      children,
      tag
    ) {
      if (isUndef(Ctor)) {
        return
      }

      var baseCtor = context.$options._base;

      // plain options object: turn it into a constructor
      if (isObject$1(Ctor)) {
        Ctor = baseCtor.extend(Ctor);
      }

      // if at this stage it's not a constructor or an async component factory,
      // reject.
      if (typeof Ctor !== 'function') {
        return
      }

      // async component
      var asyncFactory;
      if (isUndef(Ctor.cid)) {
        asyncFactory = Ctor;
        Ctor = resolveAsyncComponent(asyncFactory, baseCtor);
        if (Ctor === undefined) {
          // return a placeholder node for async component, which is rendered
          // as a comment node but preserves all the raw information for the node.
          // the information will be used for async server-rendering and hydration.
          return createAsyncPlaceholder(
            asyncFactory,
            data,
            context,
            children,
            tag
          )
        }
      }

      data = data || {};

      // resolve constructor options in case global mixins are applied after
      // component constructor creation
      resolveConstructorOptions(Ctor);

      // transform component v-model data into props & events
      if (isDef(data.model)) {
        transformModel(Ctor.options, data);
      }

      // extract props
      var propsData = extractPropsFromVNodeData(data, Ctor);

      // functional component
      if (isTrue(Ctor.options.functional)) {
        return createFunctionalComponent(Ctor, propsData, data, context, children)
      }

      // extract listeners, since these needs to be treated as
      // child component listeners instead of DOM listeners
      var listeners = data.on;
      // replace with listeners with .native modifier
      // so it gets processed during parent component patch.
      data.on = data.nativeOn;

      if (isTrue(Ctor.options.abstract)) {
        // abstract components do not keep anything
        // other than props & listeners & slot

        // work around flow
        var slot = data.slot;
        data = {};
        if (slot) {
          data.slot = slot;
        }
      }

      // install component management hooks onto the placeholder node
      installComponentHooks(data);

      // return a placeholder vnode
      var name = Ctor.options.name || tag;
      var vnode = new VNode(
        ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
        data, undefined, undefined, undefined, context,
        { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },
        asyncFactory
      );

      return vnode
    }

    function createComponentInstanceForVnode (
      // we know it's MountedComponentVNode but flow doesn't
      vnode,
      // activeInstance in lifecycle state
      parent
    ) {
      var options = {
        _isComponent: true,
        _parentVnode: vnode,
        parent: parent
      };
      // check inline-template render functions
      var inlineTemplate = vnode.data.inlineTemplate;
      if (isDef(inlineTemplate)) {
        options.render = inlineTemplate.render;
        options.staticRenderFns = inlineTemplate.staticRenderFns;
      }
      return new vnode.componentOptions.Ctor(options)
    }

    function installComponentHooks (data) {
      var hooks = data.hook || (data.hook = {});
      for (var i = 0; i < hooksToMerge.length; i++) {
        var key = hooksToMerge[i];
        var existing = hooks[key];
        var toMerge = componentVNodeHooks[key];
        if (existing !== toMerge && !(existing && existing._merged)) {
          hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;
        }
      }
    }

    function mergeHook$1 (f1, f2) {
      var merged = function (a, b) {
        // flow complains about extra args which is why we use any
        f1(a, b);
        f2(a, b);
      };
      merged._merged = true;
      return merged
    }

    // transform component v-model info (value and callback) into
    // prop and event handler respectively.
    function transformModel (options, data) {
      var prop = (options.model && options.model.prop) || 'value';
      var event = (options.model && options.model.event) || 'input'
      ;(data.attrs || (data.attrs = {}))[prop] = data.model.value;
      var on = data.on || (data.on = {});
      var existing = on[event];
      var callback = data.model.callback;
      if (isDef(existing)) {
        if (
          Array.isArray(existing)
            ? existing.indexOf(callback) === -1
            : existing !== callback
        ) {
          on[event] = [callback].concat(existing);
        }
      } else {
        on[event] = callback;
      }
    }

    /*  */

    var SIMPLE_NORMALIZE = 1;
    var ALWAYS_NORMALIZE = 2;

    // wrapper function for providing a more flexible interface
    // without getting yelled at by flow
    function createElement (
      context,
      tag,
      data,
      children,
      normalizationType,
      alwaysNormalize
    ) {
      if (Array.isArray(data) || isPrimitive(data)) {
        normalizationType = children;
        children = data;
        data = undefined;
      }
      if (isTrue(alwaysNormalize)) {
        normalizationType = ALWAYS_NORMALIZE;
      }
      return _createElement(context, tag, data, children, normalizationType)
    }

    function _createElement (
      context,
      tag,
      data,
      children,
      normalizationType
    ) {
      if (isDef(data) && isDef((data).__ob__)) {
        return createEmptyVNode()
      }
      // object syntax in v-bind
      if (isDef(data) && isDef(data.is)) {
        tag = data.is;
      }
      if (!tag) {
        // in case of component :is set to falsy value
        return createEmptyVNode()
      }
      // support single function children as default scoped slot
      if (Array.isArray(children) &&
        typeof children[0] === 'function'
      ) {
        data = data || {};
        data.scopedSlots = { default: children[0] };
        children.length = 0;
      }
      if (normalizationType === ALWAYS_NORMALIZE) {
        children = normalizeChildren(children);
      } else if (normalizationType === SIMPLE_NORMALIZE) {
        children = simpleNormalizeChildren(children);
      }
      var vnode, ns;
      if (typeof tag === 'string') {
        var Ctor;
        ns = (context.$vnode && context.$vnode.ns) || config$1.getTagNamespace(tag);
        if (config$1.isReservedTag(tag)) {
          vnode = new VNode(
            config$1.parsePlatformTagName(tag), data, children,
            undefined, undefined, context
          );
        } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
          // component
          vnode = createComponent(Ctor, data, context, children, tag);
        } else {
          // unknown or unlisted namespaced elements
          // check at runtime because it may get assigned a namespace when its
          // parent normalizes children
          vnode = new VNode(
            tag, data, children,
            undefined, undefined, context
          );
        }
      } else {
        // direct component options / constructor
        vnode = createComponent(tag, data, context, children);
      }
      if (Array.isArray(vnode)) {
        return vnode
      } else if (isDef(vnode)) {
        if (isDef(ns)) { applyNS(vnode, ns); }
        if (isDef(data)) { registerDeepBindings(data); }
        return vnode
      } else {
        return createEmptyVNode()
      }
    }

    function applyNS (vnode, ns, force) {
      vnode.ns = ns;
      if (vnode.tag === 'foreignObject') {
        // use default namespace inside foreignObject
        ns = undefined;
        force = true;
      }
      if (isDef(vnode.children)) {
        for (var i = 0, l = vnode.children.length; i < l; i++) {
          var child = vnode.children[i];
          if (isDef(child.tag) && (
            isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {
            applyNS(child, ns, force);
          }
        }
      }
    }

    // ref #5318
    // necessary to ensure parent re-render when deep bindings like :style and
    // :class are used on slot nodes
    function registerDeepBindings (data) {
      if (isObject$1(data.style)) {
        traverse(data.style);
      }
      if (isObject$1(data.class)) {
        traverse(data.class);
      }
    }

    /*  */

    function initRender (vm) {
      vm._vnode = null; // the root of the child tree
      vm._staticTrees = null; // v-once cached trees
      var options = vm.$options;
      var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree
      var renderContext = parentVnode && parentVnode.context;
      vm.$slots = resolveSlots(options._renderChildren, renderContext);
      vm.$scopedSlots = emptyObject;
      // bind the createElement fn to this instance
      // so that we get proper render context inside it.
      // args order: tag, data, children, normalizationType, alwaysNormalize
      // internal version is used by render functions compiled from templates
      vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };
      // normalization is always applied for the public version, used in
      // user-written render functions.
      vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };

      // $attrs & $listeners are exposed for easier HOC creation.
      // they need to be reactive so that HOCs using them are always updated
      var parentData = parentVnode && parentVnode.data;

      /* istanbul ignore else */
      {
        defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true);
        defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, null, true);
      }
    }

    var currentRenderingInstance = null;

    function renderMixin (Vue) {
      // install runtime convenience helpers
      installRenderHelpers(Vue.prototype);

      Vue.prototype.$nextTick = function (fn) {
        return nextTick(fn, this)
      };

      Vue.prototype._render = function () {
        var vm = this;
        var ref = vm.$options;
        var render = ref.render;
        var _parentVnode = ref._parentVnode;

        if (_parentVnode) {
          vm.$scopedSlots = normalizeScopedSlots(
            _parentVnode.data.scopedSlots,
            vm.$slots,
            vm.$scopedSlots
          );
        }

        // set parent vnode. this allows render functions to have access
        // to the data on the placeholder node.
        vm.$vnode = _parentVnode;
        // render self
        var vnode;
        try {
          // There's no need to maintain a stack because all render fns are called
          // separately from one another. Nested component's render fns are called
          // when parent component is patched.
          currentRenderingInstance = vm;
          vnode = render.call(vm._renderProxy, vm.$createElement);
        } catch (e) {
          handleError(e, vm, "render");
          // return error render result,
          // or previous vnode to prevent render error causing blank component
          /* istanbul ignore else */
          {
            vnode = vm._vnode;
          }
        } finally {
          currentRenderingInstance = null;
        }
        // if the returned array contains only a single node, allow it
        if (Array.isArray(vnode) && vnode.length === 1) {
          vnode = vnode[0];
        }
        // return empty vnode in case the render function errored out
        if (!(vnode instanceof VNode)) {
          vnode = createEmptyVNode();
        }
        // set parent
        vnode.parent = _parentVnode;
        return vnode
      };
    }

    /*  */

    function ensureCtor (comp, base) {
      if (
        comp.__esModule ||
        (hasSymbol && comp[Symbol.toStringTag] === 'Module')
      ) {
        comp = comp.default;
      }
      return isObject$1(comp)
        ? base.extend(comp)
        : comp
    }

    function createAsyncPlaceholder (
      factory,
      data,
      context,
      children,
      tag
    ) {
      var node = createEmptyVNode();
      node.asyncFactory = factory;
      node.asyncMeta = { data: data, context: context, children: children, tag: tag };
      return node
    }

    function resolveAsyncComponent (
      factory,
      baseCtor
    ) {
      if (isTrue(factory.error) && isDef(factory.errorComp)) {
        return factory.errorComp
      }

      if (isDef(factory.resolved)) {
        return factory.resolved
      }

      var owner = currentRenderingInstance;
      if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
        // already pending
        factory.owners.push(owner);
      }

      if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
        return factory.loadingComp
      }

      if (owner && !isDef(factory.owners)) {
        var owners = factory.owners = [owner];
        var sync = true;
        var timerLoading = null;
        var timerTimeout = null

        ;(owner).$on('hook:destroyed', function () { return remove(owners, owner); });

        var forceRender = function (renderCompleted) {
          for (var i = 0, l = owners.length; i < l; i++) {
            (owners[i]).$forceUpdate();
          }

          if (renderCompleted) {
            owners.length = 0;
            if (timerLoading !== null) {
              clearTimeout(timerLoading);
              timerLoading = null;
            }
            if (timerTimeout !== null) {
              clearTimeout(timerTimeout);
              timerTimeout = null;
            }
          }
        };

        var resolve = once(function (res) {
          // cache resolved
          factory.resolved = ensureCtor(res, baseCtor);
          // invoke callbacks only if this is not a synchronous resolve
          // (async resolves are shimmed as synchronous during SSR)
          if (!sync) {
            forceRender(true);
          } else {
            owners.length = 0;
          }
        });

        var reject = once(function (reason) {
          if (isDef(factory.errorComp)) {
            factory.error = true;
            forceRender(true);
          }
        });

        var res = factory(resolve, reject);

        if (isObject$1(res)) {
          if (isPromise$1(res)) {
            // () => Promise
            if (isUndef(factory.resolved)) {
              res.then(resolve, reject);
            }
          } else if (isPromise$1(res.component)) {
            res.component.then(resolve, reject);

            if (isDef(res.error)) {
              factory.errorComp = ensureCtor(res.error, baseCtor);
            }

            if (isDef(res.loading)) {
              factory.loadingComp = ensureCtor(res.loading, baseCtor);
              if (res.delay === 0) {
                factory.loading = true;
              } else {
                timerLoading = setTimeout(function () {
                  timerLoading = null;
                  if (isUndef(factory.resolved) && isUndef(factory.error)) {
                    factory.loading = true;
                    forceRender(false);
                  }
                }, res.delay || 200);
              }
            }

            if (isDef(res.timeout)) {
              timerTimeout = setTimeout(function () {
                timerTimeout = null;
                if (isUndef(factory.resolved)) {
                  reject(
                     null
                  );
                }
              }, res.timeout);
            }
          }
        }

        sync = false;
        // return in case resolved synchronously
        return factory.loading
          ? factory.loadingComp
          : factory.resolved
      }
    }

    /*  */

    function getFirstComponentChild (children) {
      if (Array.isArray(children)) {
        for (var i = 0; i < children.length; i++) {
          var c = children[i];
          if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
            return c
          }
        }
      }
    }

    /*  */

    /*  */

    function initEvents (vm) {
      vm._events = Object.create(null);
      vm._hasHookEvent = false;
      // init parent attached events
      var listeners = vm.$options._parentListeners;
      if (listeners) {
        updateComponentListeners(vm, listeners);
      }
    }

    var target;

    function add (event, fn) {
      target.$on(event, fn);
    }

    function remove$1 (event, fn) {
      target.$off(event, fn);
    }

    function createOnceHandler (event, fn) {
      var _target = target;
      return function onceHandler () {
        var res = fn.apply(null, arguments);
        if (res !== null) {
          _target.$off(event, onceHandler);
        }
      }
    }

    function updateComponentListeners (
      vm,
      listeners,
      oldListeners
    ) {
      target = vm;
      updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);
      target = undefined;
    }

    function eventsMixin (Vue) {
      var hookRE = /^hook:/;
      Vue.prototype.$on = function (event, fn) {
        var vm = this;
        if (Array.isArray(event)) {
          for (var i = 0, l = event.length; i < l; i++) {
            vm.$on(event[i], fn);
          }
        } else {
          (vm._events[event] || (vm._events[event] = [])).push(fn);
          // optimize hook:event cost by using a boolean flag marked at registration
          // instead of a hash lookup
          if (hookRE.test(event)) {
            vm._hasHookEvent = true;
          }
        }
        return vm
      };

      Vue.prototype.$once = function (event, fn) {
        var vm = this;
        function on () {
          vm.$off(event, on);
          fn.apply(vm, arguments);
        }
        on.fn = fn;
        vm.$on(event, on);
        return vm
      };

      Vue.prototype.$off = function (event, fn) {
        var vm = this;
        // all
        if (!arguments.length) {
          vm._events = Object.create(null);
          return vm
        }
        // array of events
        if (Array.isArray(event)) {
          for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
            vm.$off(event[i$1], fn);
          }
          return vm
        }
        // specific event
        var cbs = vm._events[event];
        if (!cbs) {
          return vm
        }
        if (!fn) {
          vm._events[event] = null;
          return vm
        }
        // specific handler
        var cb;
        var i = cbs.length;
        while (i--) {
          cb = cbs[i];
          if (cb === fn || cb.fn === fn) {
            cbs.splice(i, 1);
            break
          }
        }
        return vm
      };

      Vue.prototype.$emit = function (event) {
        var vm = this;
        var cbs = vm._events[event];
        if (cbs) {
          cbs = cbs.length > 1 ? toArray(cbs) : cbs;
          var args = toArray(arguments, 1);
          var info = "event handler for \"" + event + "\"";
          for (var i = 0, l = cbs.length; i < l; i++) {
            invokeWithErrorHandling(cbs[i], vm, args, vm, info);
          }
        }
        return vm
      };
    }

    /*  */

    var activeInstance = null;

    function setActiveInstance(vm) {
      var prevActiveInstance = activeInstance;
      activeInstance = vm;
      return function () {
        activeInstance = prevActiveInstance;
      }
    }

    function initLifecycle (vm) {
      var options = vm.$options;

      // locate first non-abstract parent
      var parent = options.parent;
      if (parent && !options.abstract) {
        while (parent.$options.abstract && parent.$parent) {
          parent = parent.$parent;
        }
        parent.$children.push(vm);
      }

      vm.$parent = parent;
      vm.$root = parent ? parent.$root : vm;

      vm.$children = [];
      vm.$refs = {};

      vm._watcher = null;
      vm._inactive = null;
      vm._directInactive = false;
      vm._isMounted = false;
      vm._isDestroyed = false;
      vm._isBeingDestroyed = false;
    }

    function lifecycleMixin (Vue) {
      Vue.prototype._update = function (vnode, hydrating) {
        var vm = this;
        var prevEl = vm.$el;
        var prevVnode = vm._vnode;
        var restoreActiveInstance = setActiveInstance(vm);
        vm._vnode = vnode;
        // Vue.prototype.__patch__ is injected in entry points
        // based on the rendering backend used.
        if (!prevVnode) {
          // initial render
          vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);
        } else {
          // updates
          vm.$el = vm.__patch__(prevVnode, vnode);
        }
        restoreActiveInstance();
        // update __vue__ reference
        if (prevEl) {
          prevEl.__vue__ = null;
        }
        if (vm.$el) {
          vm.$el.__vue__ = vm;
        }
        // if parent is an HOC, update its $el as well
        if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
          vm.$parent.$el = vm.$el;
        }
        // updated hook is called by the scheduler to ensure that children are
        // updated in a parent's updated hook.
      };

      Vue.prototype.$forceUpdate = function () {
        var vm = this;
        if (vm._watcher) {
          vm._watcher.update();
        }
      };

      Vue.prototype.$destroy = function () {
        var vm = this;
        if (vm._isBeingDestroyed) {
          return
        }
        callHook(vm, 'beforeDestroy');
        vm._isBeingDestroyed = true;
        // remove self from parent
        var parent = vm.$parent;
        if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
          remove(parent.$children, vm);
        }
        // teardown watchers
        if (vm._watcher) {
          vm._watcher.teardown();
        }
        var i = vm._watchers.length;
        while (i--) {
          vm._watchers[i].teardown();
        }
        // remove reference from data ob
        // frozen object may not have observer.
        if (vm._data.__ob__) {
          vm._data.__ob__.vmCount--;
        }
        // call the last hook...
        vm._isDestroyed = true;
        // invoke destroy hooks on current rendered tree
        vm.__patch__(vm._vnode, null);
        // fire destroyed hook
        callHook(vm, 'destroyed');
        // turn off all instance listeners.
        vm.$off();
        // remove __vue__ reference
        if (vm.$el) {
          vm.$el.__vue__ = null;
        }
        // release circular reference (#6759)
        if (vm.$vnode) {
          vm.$vnode.parent = null;
        }
      };
    }

    function mountComponent (
      vm,
      el,
      hydrating
    ) {
      vm.$el = el;
      if (!vm.$options.render) {
        vm.$options.render = createEmptyVNode;
      }
      callHook(vm, 'beforeMount');

      var updateComponent;
      /* istanbul ignore if */
      {
        updateComponent = function () {
          vm._update(vm._render(), hydrating);
        };
      }

      // we set this to vm._watcher inside the watcher's constructor
      // since the watcher's initial patch may call $forceUpdate (e.g. inside child
      // component's mounted hook), which relies on vm._watcher being already defined
      new Watcher(vm, updateComponent, noop$1, {
        before: function before () {
          if (vm._isMounted && !vm._isDestroyed) {
            callHook(vm, 'beforeUpdate');
          }
        }
      }, true /* isRenderWatcher */);
      hydrating = false;

      // manually mounted instance, call mounted on self
      // mounted is called for render-created child components in its inserted hook
      if (vm.$vnode == null) {
        vm._isMounted = true;
        callHook(vm, 'mounted');
      }
      return vm
    }

    function updateChildComponent (
      vm,
      propsData,
      listeners,
      parentVnode,
      renderChildren
    ) {

      // determine whether component has slot children
      // we need to do this before overwriting $options._renderChildren.

      // check if there are dynamic scopedSlots (hand-written or compiled but with
      // dynamic slot names). Static scoped slots compiled from template has the
      // "$stable" marker.
      var newScopedSlots = parentVnode.data.scopedSlots;
      var oldScopedSlots = vm.$scopedSlots;
      var hasDynamicScopedSlot = !!(
        (newScopedSlots && !newScopedSlots.$stable) ||
        (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||
        (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key) ||
        (!newScopedSlots && vm.$scopedSlots.$key)
      );

      // Any static slot children from the parent may have changed during parent's
      // update. Dynamic scoped slots may also have changed. In such cases, a forced
      // update is necessary to ensure correctness.
      var needsForceUpdate = !!(
        renderChildren ||               // has new static slots
        vm.$options._renderChildren ||  // has old static slots
        hasDynamicScopedSlot
      );

      vm.$options._parentVnode = parentVnode;
      vm.$vnode = parentVnode; // update vm's placeholder node without re-render

      if (vm._vnode) { // update child tree's parent
        vm._vnode.parent = parentVnode;
      }
      vm.$options._renderChildren = renderChildren;

      // update $attrs and $listeners hash
      // these are also reactive so they may trigger child update if the child
      // used them during render
      vm.$attrs = parentVnode.data.attrs || emptyObject;
      vm.$listeners = listeners || emptyObject;

      // update props
      if (propsData && vm.$options.props) {
        toggleObserving(false);
        var props = vm._props;
        var propKeys = vm.$options._propKeys || [];
        for (var i = 0; i < propKeys.length; i++) {
          var key = propKeys[i];
          var propOptions = vm.$options.props; // wtf flow?
          props[key] = validateProp(key, propOptions, propsData, vm);
        }
        toggleObserving(true);
        // keep a copy of raw propsData
        vm.$options.propsData = propsData;
      }

      // update listeners
      listeners = listeners || emptyObject;
      var oldListeners = vm.$options._parentListeners;
      vm.$options._parentListeners = listeners;
      updateComponentListeners(vm, listeners, oldListeners);

      // resolve slots + force update if has children
      if (needsForceUpdate) {
        vm.$slots = resolveSlots(renderChildren, parentVnode.context);
        vm.$forceUpdate();
      }
    }

    function isInInactiveTree (vm) {
      while (vm && (vm = vm.$parent)) {
        if (vm._inactive) { return true }
      }
      return false
    }

    function activateChildComponent (vm, direct) {
      if (direct) {
        vm._directInactive = false;
        if (isInInactiveTree(vm)) {
          return
        }
      } else if (vm._directInactive) {
        return
      }
      if (vm._inactive || vm._inactive === null) {
        vm._inactive = false;
        for (var i = 0; i < vm.$children.length; i++) {
          activateChildComponent(vm.$children[i]);
        }
        callHook(vm, 'activated');
      }
    }

    function deactivateChildComponent (vm, direct) {
      if (direct) {
        vm._directInactive = true;
        if (isInInactiveTree(vm)) {
          return
        }
      }
      if (!vm._inactive) {
        vm._inactive = true;
        for (var i = 0; i < vm.$children.length; i++) {
          deactivateChildComponent(vm.$children[i]);
        }
        callHook(vm, 'deactivated');
      }
    }

    function callHook (vm, hook) {
      // #7573 disable dep collection when invoking lifecycle hooks
      pushTarget();
      var handlers = vm.$options[hook];
      var info = hook + " hook";
      if (handlers) {
        for (var i = 0, j = handlers.length; i < j; i++) {
          invokeWithErrorHandling(handlers[i], vm, null, vm, info);
        }
      }
      if (vm._hasHookEvent) {
        vm.$emit('hook:' + hook);
      }
      popTarget();
    }

    var queue = [];
    var activatedChildren = [];
    var has = {};
    var waiting = false;
    var flushing = false;
    var index = 0;

    /**
     * Reset the scheduler's state.
     */
    function resetSchedulerState () {
      index = queue.length = activatedChildren.length = 0;
      has = {};
      waiting = flushing = false;
    }

    // Async edge case #6566 requires saving the timestamp when event listeners are
    // attached. However, calling performance.now() has a perf overhead especially
    // if the page has thousands of event listeners. Instead, we take a timestamp
    // every time the scheduler flushes and use that for all event listeners
    // attached during that flush.
    var currentFlushTimestamp = 0;

    // Async edge case fix requires storing an event listener's attach timestamp.
    var getNow = Date.now;

    // Determine what event timestamp the browser is using. Annoyingly, the
    // timestamp can either be hi-res (relative to page load) or low-res
    // (relative to UNIX epoch), so in order to compare time we have to use the
    // same timestamp type when saving the flush timestamp.
    // All IE versions use low-res event timestamps, and have problematic clock
    // implementations (#9632)
    if (inBrowser && !isIE) {
      var performance = window.performance;
      if (
        performance &&
        typeof performance.now === 'function' &&
        getNow() > document.createEvent('Event').timeStamp
      ) {
        // if the event timestamp, although evaluated AFTER the Date.now(), is
        // smaller than it, it means the event is using a hi-res timestamp,
        // and we need to use the hi-res version for event listener timestamps as
        // well.
        getNow = function () { return performance.now(); };
      }
    }

    /**
     * Flush both queues and run the watchers.
     */
    function flushSchedulerQueue () {
      currentFlushTimestamp = getNow();
      flushing = true;
      var watcher, id;

      // Sort queue before flush.
      // This ensures that:
      // 1. Components are updated from parent to child. (because parent is always
      //    created before the child)
      // 2. A component's user watchers are run before its render watcher (because
      //    user watchers are created before the render watcher)
      // 3. If a component is destroyed during a parent component's watcher run,
      //    its watchers can be skipped.
      queue.sort(function (a, b) { return a.id - b.id; });

      // do not cache length because more watchers might be pushed
      // as we run existing watchers
      for (index = 0; index < queue.length; index++) {
        watcher = queue[index];
        if (watcher.before) {
          watcher.before();
        }
        id = watcher.id;
        has[id] = null;
        watcher.run();
      }

      // keep copies of post queues before resetting state
      var activatedQueue = activatedChildren.slice();
      var updatedQueue = queue.slice();

      resetSchedulerState();

      // call component updated and activated hooks
      callActivatedHooks(activatedQueue);
      callUpdatedHooks(updatedQueue);

      // devtool hook
      /* istanbul ignore if */
      if (devtools && config$1.devtools) {
        devtools.emit('flush');
      }
    }

    function callUpdatedHooks (queue) {
      var i = queue.length;
      while (i--) {
        var watcher = queue[i];
        var vm = watcher.vm;
        if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
          callHook(vm, 'updated');
        }
      }
    }

    /**
     * Queue a kept-alive component that was activated during patch.
     * The queue will be processed after the entire tree has been patched.
     */
    function queueActivatedComponent (vm) {
      // setting _inactive to false here so that a render function can
      // rely on checking whether it's in an inactive tree (e.g. router-view)
      vm._inactive = false;
      activatedChildren.push(vm);
    }

    function callActivatedHooks (queue) {
      for (var i = 0; i < queue.length; i++) {
        queue[i]._inactive = true;
        activateChildComponent(queue[i], true /* true */);
      }
    }

    /**
     * Push a watcher into the watcher queue.
     * Jobs with duplicate IDs will be skipped unless it's
     * pushed when the queue is being flushed.
     */
    function queueWatcher (watcher) {
      var id = watcher.id;
      if (has[id] == null) {
        has[id] = true;
        if (!flushing) {
          queue.push(watcher);
        } else {
          // if already flushing, splice the watcher based on its id
          // if already past its id, it will be run next immediately.
          var i = queue.length - 1;
          while (i > index && queue[i].id > watcher.id) {
            i--;
          }
          queue.splice(i + 1, 0, watcher);
        }
        // queue the flush
        if (!waiting) {
          waiting = true;
          nextTick(flushSchedulerQueue);
        }
      }
    }

    /*  */



    var uid$2 = 0;

    /**
     * A watcher parses an expression, collects dependencies,
     * and fires callback when the expression value changes.
     * This is used for both the $watch() api and directives.
     */
    var Watcher = function Watcher (
      vm,
      expOrFn,
      cb,
      options,
      isRenderWatcher
    ) {
      this.vm = vm;
      if (isRenderWatcher) {
        vm._watcher = this;
      }
      vm._watchers.push(this);
      // options
      if (options) {
        this.deep = !!options.deep;
        this.user = !!options.user;
        this.lazy = !!options.lazy;
        this.sync = !!options.sync;
        this.before = options.before;
      } else {
        this.deep = this.user = this.lazy = this.sync = false;
      }
      this.cb = cb;
      this.id = ++uid$2; // uid for batching
      this.active = true;
      this.dirty = this.lazy; // for lazy watchers
      this.deps = [];
      this.newDeps = [];
      this.depIds = new _Set();
      this.newDepIds = new _Set();
      this.expression =  '';
      // parse expression for getter
      if (typeof expOrFn === 'function') {
        this.getter = expOrFn;
      } else {
        this.getter = parsePath(expOrFn);
        if (!this.getter) {
          this.getter = noop$1;
        }
      }
      this.value = this.lazy
        ? undefined
        : this.get();
    };

    /**
     * Evaluate the getter, and re-collect dependencies.
     */
    Watcher.prototype.get = function get () {
      pushTarget(this);
      var value;
      var vm = this.vm;
      try {
        value = this.getter.call(vm, vm);
      } catch (e) {
        if (this.user) {
          handleError(e, vm, ("getter for watcher \"" + (this.expression) + "\""));
        } else {
          throw e
        }
      } finally {
        // "touch" every property so they are all tracked as
        // dependencies for deep watching
        if (this.deep) {
          traverse(value);
        }
        popTarget();
        this.cleanupDeps();
      }
      return value
    };

    /**
     * Add a dependency to this directive.
     */
    Watcher.prototype.addDep = function addDep (dep) {
      var id = dep.id;
      if (!this.newDepIds.has(id)) {
        this.newDepIds.add(id);
        this.newDeps.push(dep);
        if (!this.depIds.has(id)) {
          dep.addSub(this);
        }
      }
    };

    /**
     * Clean up for dependency collection.
     */
    Watcher.prototype.cleanupDeps = function cleanupDeps () {
      var i = this.deps.length;
      while (i--) {
        var dep = this.deps[i];
        if (!this.newDepIds.has(dep.id)) {
          dep.removeSub(this);
        }
      }
      var tmp = this.depIds;
      this.depIds = this.newDepIds;
      this.newDepIds = tmp;
      this.newDepIds.clear();
      tmp = this.deps;
      this.deps = this.newDeps;
      this.newDeps = tmp;
      this.newDeps.length = 0;
    };

    /**
     * Subscriber interface.
     * Will be called when a dependency changes.
     */
    Watcher.prototype.update = function update () {
      /* istanbul ignore else */
      if (this.lazy) {
        this.dirty = true;
      } else if (this.sync) {
        this.run();
      } else {
        queueWatcher(this);
      }
    };

    /**
     * Scheduler job interface.
     * Will be called by the scheduler.
     */
    Watcher.prototype.run = function run () {
      if (this.active) {
        var value = this.get();
        if (
          value !== this.value ||
          // Deep watchers and watchers on Object/Arrays should fire even
          // when the value is the same, because the value may
          // have mutated.
          isObject$1(value) ||
          this.deep
        ) {
          // set new value
          var oldValue = this.value;
          this.value = value;
          if (this.user) {
            var info = "callback for watcher \"" + (this.expression) + "\"";
            invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info);
          } else {
            this.cb.call(this.vm, value, oldValue);
          }
        }
      }
    };

    /**
     * Evaluate the value of the watcher.
     * This only gets called for lazy watchers.
     */
    Watcher.prototype.evaluate = function evaluate () {
      this.value = this.get();
      this.dirty = false;
    };

    /**
     * Depend on all deps collected by this watcher.
     */
    Watcher.prototype.depend = function depend () {
      var i = this.deps.length;
      while (i--) {
        this.deps[i].depend();
      }
    };

    /**
     * Remove self from all dependencies' subscriber list.
     */
    Watcher.prototype.teardown = function teardown () {
      if (this.active) {
        // remove self from vm's watcher list
        // this is a somewhat expensive operation so we skip it
        // if the vm is being destroyed.
        if (!this.vm._isBeingDestroyed) {
          remove(this.vm._watchers, this);
        }
        var i = this.deps.length;
        while (i--) {
          this.deps[i].removeSub(this);
        }
        this.active = false;
      }
    };

    /*  */

    var sharedPropertyDefinition = {
      enumerable: true,
      configurable: true,
      get: noop$1,
      set: noop$1
    };

    function proxy (target, sourceKey, key) {
      sharedPropertyDefinition.get = function proxyGetter () {
        return this[sourceKey][key]
      };
      sharedPropertyDefinition.set = function proxySetter (val) {
        this[sourceKey][key] = val;
      };
      Object.defineProperty(target, key, sharedPropertyDefinition);
    }

    function initState (vm) {
      vm._watchers = [];
      var opts = vm.$options;
      if (opts.props) { initProps(vm, opts.props); }
      if (opts.methods) { initMethods(vm, opts.methods); }
      if (opts.data) {
        initData(vm);
      } else {
        observe(vm._data = {}, true /* asRootData */);
      }
      if (opts.computed) { initComputed(vm, opts.computed); }
      if (opts.watch && opts.watch !== nativeWatch) {
        initWatch(vm, opts.watch);
      }
    }

    function initProps (vm, propsOptions) {
      var propsData = vm.$options.propsData || {};
      var props = vm._props = {};
      // cache prop keys so that future props updates can iterate using Array
      // instead of dynamic object key enumeration.
      var keys = vm.$options._propKeys = [];
      var isRoot = !vm.$parent;
      // root instance props should be converted
      if (!isRoot) {
        toggleObserving(false);
      }
      var loop = function ( key ) {
        keys.push(key);
        var value = validateProp(key, propsOptions, propsData, vm);
        /* istanbul ignore else */
        {
          defineReactive$$1(props, key, value);
        }
        // static props are already proxied on the component's prototype
        // during Vue.extend(). We only need to proxy props defined at
        // instantiation here.
        if (!(key in vm)) {
          proxy(vm, "_props", key);
        }
      };

      for (var key in propsOptions) loop( key );
      toggleObserving(true);
    }

    function initData (vm) {
      var data = vm.$options.data;
      data = vm._data = typeof data === 'function'
        ? getData(data, vm)
        : data || {};
      if (!isPlainObject(data)) {
        data = {};
      }
      // proxy data on instance
      var keys = Object.keys(data);
      var props = vm.$options.props;
      var methods = vm.$options.methods;
      var i = keys.length;
      while (i--) {
        var key = keys[i];
        if (props && hasOwn(props, key)) ; else if (!isReserved(key)) {
          proxy(vm, "_data", key);
        }
      }
      // observe data
      observe(data, true /* asRootData */);
    }

    function getData (data, vm) {
      // #7573 disable dep collection when invoking data getters
      pushTarget();
      try {
        return data.call(vm, vm)
      } catch (e) {
        handleError(e, vm, "data()");
        return {}
      } finally {
        popTarget();
      }
    }

    var computedWatcherOptions = { lazy: true };

    function initComputed (vm, computed) {
      // $flow-disable-line
      var watchers = vm._computedWatchers = Object.create(null);
      // computed properties are just getters during SSR
      var isSSR = isServerRendering();

      for (var key in computed) {
        var userDef = computed[key];
        var getter = typeof userDef === 'function' ? userDef : userDef.get;

        if (!isSSR) {
          // create internal watcher for the computed property.
          watchers[key] = new Watcher(
            vm,
            getter || noop$1,
            noop$1,
            computedWatcherOptions
          );
        }

        // component-defined computed properties are already defined on the
        // component prototype. We only need to define computed properties defined
        // at instantiation here.
        if (!(key in vm)) {
          defineComputed(vm, key, userDef);
        }
      }
    }

    function defineComputed (
      target,
      key,
      userDef
    ) {
      var shouldCache = !isServerRendering();
      if (typeof userDef === 'function') {
        sharedPropertyDefinition.get = shouldCache
          ? createComputedGetter(key)
          : createGetterInvoker(userDef);
        sharedPropertyDefinition.set = noop$1;
      } else {
        sharedPropertyDefinition.get = userDef.get
          ? shouldCache && userDef.cache !== false
            ? createComputedGetter(key)
            : createGetterInvoker(userDef.get)
          : noop$1;
        sharedPropertyDefinition.set = userDef.set || noop$1;
      }
      Object.defineProperty(target, key, sharedPropertyDefinition);
    }

    function createComputedGetter (key) {
      return function computedGetter () {
        var watcher = this._computedWatchers && this._computedWatchers[key];
        if (watcher) {
          if (watcher.dirty) {
            watcher.evaluate();
          }
          if (Dep.target) {
            watcher.depend();
          }
          return watcher.value
        }
      }
    }

    function createGetterInvoker(fn) {
      return function computedGetter () {
        return fn.call(this, this)
      }
    }

    function initMethods (vm, methods) {
      var props = vm.$options.props;
      for (var key in methods) {
        vm[key] = typeof methods[key] !== 'function' ? noop$1 : bind(methods[key], vm);
      }
    }

    function initWatch (vm, watch) {
      for (var key in watch) {
        var handler = watch[key];
        if (Array.isArray(handler)) {
          for (var i = 0; i < handler.length; i++) {
            createWatcher(vm, key, handler[i]);
          }
        } else {
          createWatcher(vm, key, handler);
        }
      }
    }

    function createWatcher (
      vm,
      expOrFn,
      handler,
      options
    ) {
      if (isPlainObject(handler)) {
        options = handler;
        handler = handler.handler;
      }
      if (typeof handler === 'string') {
        handler = vm[handler];
      }
      return vm.$watch(expOrFn, handler, options)
    }

    function stateMixin (Vue) {
      // flow somehow has problems with directly declared definition object
      // when using Object.defineProperty, so we have to procedurally build up
      // the object here.
      var dataDef = {};
      dataDef.get = function () { return this._data };
      var propsDef = {};
      propsDef.get = function () { return this._props };
      Object.defineProperty(Vue.prototype, '$data', dataDef);
      Object.defineProperty(Vue.prototype, '$props', propsDef);

      Vue.prototype.$set = set;
      Vue.prototype.$delete = del;

      Vue.prototype.$watch = function (
        expOrFn,
        cb,
        options
      ) {
        var vm = this;
        if (isPlainObject(cb)) {
          return createWatcher(vm, expOrFn, cb, options)
        }
        options = options || {};
        options.user = true;
        var watcher = new Watcher(vm, expOrFn, cb, options);
        if (options.immediate) {
          var info = "callback for immediate watcher \"" + (watcher.expression) + "\"";
          pushTarget();
          invokeWithErrorHandling(cb, vm, [watcher.value], vm, info);
          popTarget();
        }
        return function unwatchFn () {
          watcher.teardown();
        }
      };
    }

    /*  */

    var uid$3 = 0;

    function initMixin (Vue) {
      Vue.prototype._init = function (options) {
        var vm = this;
        // a uid
        vm._uid = uid$3++;

        // a flag to avoid this being observed
        vm._isVue = true;
        // merge options
        if (options && options._isComponent) {
          // optimize internal component instantiation
          // since dynamic options merging is pretty slow, and none of the
          // internal component options needs special treatment.
          initInternalComponent(vm, options);
        } else {
          vm.$options = mergeOptions(
            resolveConstructorOptions(vm.constructor),
            options || {},
            vm
          );
        }
        /* istanbul ignore else */
        {
          vm._renderProxy = vm;
        }
        // expose real self
        vm._self = vm;
        initLifecycle(vm);
        initEvents(vm);
        initRender(vm);
        callHook(vm, 'beforeCreate');
        initInjections(vm); // resolve injections before data/props
        initState(vm);
        initProvide(vm); // resolve provide after data/props
        callHook(vm, 'created');

        if (vm.$options.el) {
          vm.$mount(vm.$options.el);
        }
      };
    }

    function initInternalComponent (vm, options) {
      var opts = vm.$options = Object.create(vm.constructor.options);
      // doing this because it's faster than dynamic enumeration.
      var parentVnode = options._parentVnode;
      opts.parent = options.parent;
      opts._parentVnode = parentVnode;

      var vnodeComponentOptions = parentVnode.componentOptions;
      opts.propsData = vnodeComponentOptions.propsData;
      opts._parentListeners = vnodeComponentOptions.listeners;
      opts._renderChildren = vnodeComponentOptions.children;
      opts._componentTag = vnodeComponentOptions.tag;

      if (options.render) {
        opts.render = options.render;
        opts.staticRenderFns = options.staticRenderFns;
      }
    }

    function resolveConstructorOptions (Ctor) {
      var options = Ctor.options;
      if (Ctor.super) {
        var superOptions = resolveConstructorOptions(Ctor.super);
        var cachedSuperOptions = Ctor.superOptions;
        if (superOptions !== cachedSuperOptions) {
          // super option changed,
          // need to resolve new options.
          Ctor.superOptions = superOptions;
          // check if there are any late-modified/attached options (#4976)
          var modifiedOptions = resolveModifiedOptions(Ctor);
          // update base extend options
          if (modifiedOptions) {
            extend(Ctor.extendOptions, modifiedOptions);
          }
          options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
          if (options.name) {
            options.components[options.name] = Ctor;
          }
        }
      }
      return options
    }

    function resolveModifiedOptions (Ctor) {
      var modified;
      var latest = Ctor.options;
      var sealed = Ctor.sealedOptions;
      for (var key in latest) {
        if (latest[key] !== sealed[key]) {
          if (!modified) { modified = {}; }
          modified[key] = latest[key];
        }
      }
      return modified
    }

    function Vue$1 (options) {
      this._init(options);
    }

    initMixin(Vue$1);
    stateMixin(Vue$1);
    eventsMixin(Vue$1);
    lifecycleMixin(Vue$1);
    renderMixin(Vue$1);

    /*  */

    function initUse (Vue) {
      Vue.use = function (plugin) {
        var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));
        if (installedPlugins.indexOf(plugin) > -1) {
          return this
        }

        // additional parameters
        var args = toArray(arguments, 1);
        args.unshift(this);
        if (typeof plugin.install === 'function') {
          plugin.install.apply(plugin, args);
        } else if (typeof plugin === 'function') {
          plugin.apply(null, args);
        }
        installedPlugins.push(plugin);
        return this
      };
    }

    /*  */

    function initMixin$1 (Vue) {
      Vue.mixin = function (mixin) {
        this.options = mergeOptions(this.options, mixin);
        return this
      };
    }

    /*  */

    function initExtend (Vue) {
      /**
       * Each instance constructor, including Vue, has a unique
       * cid. This enables us to create wrapped "child
       * constructors" for prototypal inheritance and cache them.
       */
      Vue.cid = 0;
      var cid = 1;

      /**
       * Class inheritance
       */
      Vue.extend = function (extendOptions) {
        extendOptions = extendOptions || {};
        var Super = this;
        var SuperId = Super.cid;
        var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
        if (cachedCtors[SuperId]) {
          return cachedCtors[SuperId]
        }

        var name = extendOptions.name || Super.options.name;

        var Sub = function VueComponent (options) {
          this._init(options);
        };
        Sub.prototype = Object.create(Super.prototype);
        Sub.prototype.constructor = Sub;
        Sub.cid = cid++;
        Sub.options = mergeOptions(
          Super.options,
          extendOptions
        );
        Sub['super'] = Super;

        // For props and computed properties, we define the proxy getters on
        // the Vue instances at extension time, on the extended prototype. This
        // avoids Object.defineProperty calls for each instance created.
        if (Sub.options.props) {
          initProps$1(Sub);
        }
        if (Sub.options.computed) {
          initComputed$1(Sub);
        }

        // allow further extension/mixin/plugin usage
        Sub.extend = Super.extend;
        Sub.mixin = Super.mixin;
        Sub.use = Super.use;

        // create asset registers, so extended classes
        // can have their private assets too.
        ASSET_TYPES.forEach(function (type) {
          Sub[type] = Super[type];
        });
        // enable recursive self-lookup
        if (name) {
          Sub.options.components[name] = Sub;
        }

        // keep a reference to the super options at extension time.
        // later at instantiation we can check if Super's options have
        // been updated.
        Sub.superOptions = Super.options;
        Sub.extendOptions = extendOptions;
        Sub.sealedOptions = extend({}, Sub.options);

        // cache constructor
        cachedCtors[SuperId] = Sub;
        return Sub
      };
    }

    function initProps$1 (Comp) {
      var props = Comp.options.props;
      for (var key in props) {
        proxy(Comp.prototype, "_props", key);
      }
    }

    function initComputed$1 (Comp) {
      var computed = Comp.options.computed;
      for (var key in computed) {
        defineComputed(Comp.prototype, key, computed[key]);
      }
    }

    /*  */

    function initAssetRegisters (Vue) {
      /**
       * Create asset registration methods.
       */
      ASSET_TYPES.forEach(function (type) {
        Vue[type] = function (
          id,
          definition
        ) {
          if (!definition) {
            return this.options[type + 's'][id]
          } else {
            if (type === 'component' && isPlainObject(definition)) {
              definition.name = definition.name || id;
              definition = this.options._base.extend(definition);
            }
            if (type === 'directive' && typeof definition === 'function') {
              definition = { bind: definition, update: definition };
            }
            this.options[type + 's'][id] = definition;
            return definition
          }
        };
      });
    }

    /*  */





    function getComponentName (opts) {
      return opts && (opts.Ctor.options.name || opts.tag)
    }

    function matches (pattern, name) {
      if (Array.isArray(pattern)) {
        return pattern.indexOf(name) > -1
      } else if (typeof pattern === 'string') {
        return pattern.split(',').indexOf(name) > -1
      } else if (isRegExp(pattern)) {
        return pattern.test(name)
      }
      /* istanbul ignore next */
      return false
    }

    function pruneCache (keepAliveInstance, filter) {
      var cache = keepAliveInstance.cache;
      var keys = keepAliveInstance.keys;
      var _vnode = keepAliveInstance._vnode;
      for (var key in cache) {
        var entry = cache[key];
        if (entry) {
          var name = entry.name;
          if (name && !filter(name)) {
            pruneCacheEntry(cache, key, keys, _vnode);
          }
        }
      }
    }

    function pruneCacheEntry (
      cache,
      key,
      keys,
      current
    ) {
      var entry = cache[key];
      if (entry && (!current || entry.tag !== current.tag)) {
        entry.componentInstance.$destroy();
      }
      cache[key] = null;
      remove(keys, key);
    }

    var patternTypes = [String, RegExp, Array];

    var KeepAlive = {
      name: 'keep-alive',
      abstract: true,

      props: {
        include: patternTypes,
        exclude: patternTypes,
        max: [String, Number]
      },

      methods: {
        cacheVNode: function cacheVNode() {
          var ref = this;
          var cache = ref.cache;
          var keys = ref.keys;
          var vnodeToCache = ref.vnodeToCache;
          var keyToCache = ref.keyToCache;
          if (vnodeToCache) {
            var tag = vnodeToCache.tag;
            var componentInstance = vnodeToCache.componentInstance;
            var componentOptions = vnodeToCache.componentOptions;
            cache[keyToCache] = {
              name: getComponentName(componentOptions),
              tag: tag,
              componentInstance: componentInstance,
            };
            keys.push(keyToCache);
            // prune oldest entry
            if (this.max && keys.length > parseInt(this.max)) {
              pruneCacheEntry(cache, keys[0], keys, this._vnode);
            }
            this.vnodeToCache = null;
          }
        }
      },

      created: function created () {
        this.cache = Object.create(null);
        this.keys = [];
      },

      destroyed: function destroyed () {
        for (var key in this.cache) {
          pruneCacheEntry(this.cache, key, this.keys);
        }
      },

      mounted: function mounted () {
        var this$1 = this;

        this.cacheVNode();
        this.$watch('include', function (val) {
          pruneCache(this$1, function (name) { return matches(val, name); });
        });
        this.$watch('exclude', function (val) {
          pruneCache(this$1, function (name) { return !matches(val, name); });
        });
      },

      updated: function updated () {
        this.cacheVNode();
      },

      render: function render () {
        var slot = this.$slots.default;
        var vnode = getFirstComponentChild(slot);
        var componentOptions = vnode && vnode.componentOptions;
        if (componentOptions) {
          // check pattern
          var name = getComponentName(componentOptions);
          var ref = this;
          var include = ref.include;
          var exclude = ref.exclude;
          if (
            // not included
            (include && (!name || !matches(include, name))) ||
            // excluded
            (exclude && name && matches(exclude, name))
          ) {
            return vnode
          }

          var ref$1 = this;
          var cache = ref$1.cache;
          var keys = ref$1.keys;
          var key = vnode.key == null
            // same constructor may get registered as different local components
            // so cid alone is not enough (#3269)
            ? componentOptions.Ctor.cid + (componentOptions.tag ? ("::" + (componentOptions.tag)) : '')
            : vnode.key;
          if (cache[key]) {
            vnode.componentInstance = cache[key].componentInstance;
            // make current key freshest
            remove(keys, key);
            keys.push(key);
          } else {
            // delay setting the cache until update
            this.vnodeToCache = vnode;
            this.keyToCache = key;
          }

          vnode.data.keepAlive = true;
        }
        return vnode || (slot && slot[0])
      }
    };

    var builtInComponents = {
      KeepAlive: KeepAlive
    };

    /*  */

    function initGlobalAPI (Vue) {
      // config
      var configDef = {};
      configDef.get = function () { return config$1; };
      Object.defineProperty(Vue, 'config', configDef);

      // exposed util methods.
      // NOTE: these are not considered part of the public API - avoid relying on
      // them unless you are aware of the risk.
      Vue.util = {
        warn: warn,
        extend: extend,
        mergeOptions: mergeOptions,
        defineReactive: defineReactive$$1
      };

      Vue.set = set;
      Vue.delete = del;
      Vue.nextTick = nextTick;

      // 2.6 explicit observable API
      Vue.observable = function (obj) {
        observe(obj);
        return obj
      };

      Vue.options = Object.create(null);
      ASSET_TYPES.forEach(function (type) {
        Vue.options[type + 's'] = Object.create(null);
      });

      // this is used to identify the "base" constructor to extend all plain-object
      // components with in Weex's multi-instance scenarios.
      Vue.options._base = Vue;

      extend(Vue.options.components, builtInComponents);

      initUse(Vue);
      initMixin$1(Vue);
      initExtend(Vue);
      initAssetRegisters(Vue);
    }

    initGlobalAPI(Vue$1);

    Object.defineProperty(Vue$1.prototype, '$isServer', {
      get: isServerRendering
    });

    Object.defineProperty(Vue$1.prototype, '$ssrContext', {
      get: function get () {
        /* istanbul ignore next */
        return this.$vnode && this.$vnode.ssrContext
      }
    });

    // expose FunctionalRenderContext for ssr runtime helper installation
    Object.defineProperty(Vue$1, 'FunctionalRenderContext', {
      value: FunctionalRenderContext
    });

    Vue$1.version = '2.6.14';

    /*  */

    // these are reserved for web because they are directly compiled away
    // during template compilation
    var isReservedAttr = makeMap('style,class');

    // attributes that should be using props for binding
    var acceptValue = makeMap('input,textarea,option,select,progress');
    var mustUseProp = function (tag, type, attr) {
      return (
        (attr === 'value' && acceptValue(tag)) && type !== 'button' ||
        (attr === 'selected' && tag === 'option') ||
        (attr === 'checked' && tag === 'input') ||
        (attr === 'muted' && tag === 'video')
      )
    };

    var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

    var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');

    var convertEnumeratedValue = function (key, value) {
      return isFalsyAttrValue(value) || value === 'false'
        ? 'false'
        // allow arbitrary string value for contenteditable
        : key === 'contenteditable' && isValidContentEditableValue(value)
          ? value
          : 'true'
    };

    var isBooleanAttr = makeMap(
      'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
      'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
      'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
      'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
      'required,reversed,scoped,seamless,selected,sortable,' +
      'truespeed,typemustmatch,visible'
    );

    var xlinkNS = 'http://www.w3.org/1999/xlink';

    var isXlink = function (name) {
      return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'
    };

    var getXlinkProp = function (name) {
      return isXlink(name) ? name.slice(6, name.length) : ''
    };

    var isFalsyAttrValue = function (val) {
      return val == null || val === false
    };

    /*  */

    function genClassForVnode (vnode) {
      var data = vnode.data;
      var parentNode = vnode;
      var childNode = vnode;
      while (isDef(childNode.componentInstance)) {
        childNode = childNode.componentInstance._vnode;
        if (childNode && childNode.data) {
          data = mergeClassData(childNode.data, data);
        }
      }
      while (isDef(parentNode = parentNode.parent)) {
        if (parentNode && parentNode.data) {
          data = mergeClassData(data, parentNode.data);
        }
      }
      return renderClass(data.staticClass, data.class)
    }

    function mergeClassData (child, parent) {
      return {
        staticClass: concat$1(child.staticClass, parent.staticClass),
        class: isDef(child.class)
          ? [child.class, parent.class]
          : parent.class
      }
    }

    function renderClass (
      staticClass,
      dynamicClass
    ) {
      if (isDef(staticClass) || isDef(dynamicClass)) {
        return concat$1(staticClass, stringifyClass(dynamicClass))
      }
      /* istanbul ignore next */
      return ''
    }

    function concat$1 (a, b) {
      return a ? b ? (a + ' ' + b) : a : (b || '')
    }

    function stringifyClass (value) {
      if (Array.isArray(value)) {
        return stringifyArray(value)
      }
      if (isObject$1(value)) {
        return stringifyObject(value)
      }
      if (typeof value === 'string') {
        return value
      }
      /* istanbul ignore next */
      return ''
    }

    function stringifyArray (value) {
      var res = '';
      var stringified;
      for (var i = 0, l = value.length; i < l; i++) {
        if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
          if (res) { res += ' '; }
          res += stringified;
        }
      }
      return res
    }

    function stringifyObject (value) {
      var res = '';
      for (var key in value) {
        if (value[key]) {
          if (res) { res += ' '; }
          res += key;
        }
      }
      return res
    }

    /*  */

    var namespaceMap = {
      svg: 'http://www.w3.org/2000/svg',
      math: 'http://www.w3.org/1998/Math/MathML'
    };

    var isHTMLTag = makeMap(
      'html,body,base,head,link,meta,style,title,' +
      'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
      'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +
      'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
      's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
      'embed,object,param,source,canvas,script,noscript,del,ins,' +
      'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
      'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
      'output,progress,select,textarea,' +
      'details,dialog,menu,menuitem,summary,' +
      'content,element,shadow,template,blockquote,iframe,tfoot'
    );

    // this map is intentionally selective, only covering SVG elements that may
    // contain child elements.
    var isSVG = makeMap(
      'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +
      'foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
      'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',
      true
    );

    var isPreTag = function (tag) { return tag === 'pre'; };

    var isReservedTag = function (tag) {
      return isHTMLTag(tag) || isSVG(tag)
    };

    function getTagNamespace (tag) {
      if (isSVG(tag)) {
        return 'svg'
      }
      // basic support for MathML
      // note it doesn't support other MathML elements being component roots
      if (tag === 'math') {
        return 'math'
      }
    }

    var unknownElementCache = Object.create(null);
    function isUnknownElement (tag) {
      /* istanbul ignore if */
      if (!inBrowser) {
        return true
      }
      if (isReservedTag(tag)) {
        return false
      }
      tag = tag.toLowerCase();
      /* istanbul ignore if */
      if (unknownElementCache[tag] != null) {
        return unknownElementCache[tag]
      }
      var el = document.createElement(tag);
      if (tag.indexOf('-') > -1) {
        // http://stackoverflow.com/a/28210364/1070244
        return (unknownElementCache[tag] = (
          el.constructor === window.HTMLUnknownElement ||
          el.constructor === window.HTMLElement
        ))
      } else {
        return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))
      }
    }

    var isTextInputType = makeMap('text,number,password,search,email,tel,url');

    /*  */

    /**
     * Query an element selector if it's not an element already.
     */
    function query (el) {
      if (typeof el === 'string') {
        var selected = document.querySelector(el);
        if (!selected) {
          return document.createElement('div')
        }
        return selected
      } else {
        return el
      }
    }

    /*  */

    function createElement$1 (tagName, vnode) {
      var elm = document.createElement(tagName);
      if (tagName !== 'select') {
        return elm
      }
      // false or null will remove the attribute but undefined will not
      if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
        elm.setAttribute('multiple', 'multiple');
      }
      return elm
    }

    function createElementNS (namespace, tagName) {
      return document.createElementNS(namespaceMap[namespace], tagName)
    }

    function createTextNode (text) {
      return document.createTextNode(text)
    }

    function createComment (text) {
      return document.createComment(text)
    }

    function insertBefore (parentNode, newNode, referenceNode) {
      parentNode.insertBefore(newNode, referenceNode);
    }

    function removeChild (node, child) {
      node.removeChild(child);
    }

    function appendChild (node, child) {
      node.appendChild(child);
    }

    function parentNode (node) {
      return node.parentNode
    }

    function nextSibling (node) {
      return node.nextSibling
    }

    function tagName (node) {
      return node.tagName
    }

    function setTextContent (node, text) {
      node.textContent = text;
    }

    function setStyleScope (node, scopeId) {
      node.setAttribute(scopeId, '');
    }

    var nodeOps = /*#__PURE__*/Object.freeze({
      createElement: createElement$1,
      createElementNS: createElementNS,
      createTextNode: createTextNode,
      createComment: createComment,
      insertBefore: insertBefore,
      removeChild: removeChild,
      appendChild: appendChild,
      parentNode: parentNode,
      nextSibling: nextSibling,
      tagName: tagName,
      setTextContent: setTextContent,
      setStyleScope: setStyleScope
    });

    /*  */

    var ref = {
      create: function create (_, vnode) {
        registerRef(vnode);
      },
      update: function update (oldVnode, vnode) {
        if (oldVnode.data.ref !== vnode.data.ref) {
          registerRef(oldVnode, true);
          registerRef(vnode);
        }
      },
      destroy: function destroy (vnode) {
        registerRef(vnode, true);
      }
    };

    function registerRef (vnode, isRemoval) {
      var key = vnode.data.ref;
      if (!isDef(key)) { return }

      var vm = vnode.context;
      var ref = vnode.componentInstance || vnode.elm;
      var refs = vm.$refs;
      if (isRemoval) {
        if (Array.isArray(refs[key])) {
          remove(refs[key], ref);
        } else if (refs[key] === ref) {
          refs[key] = undefined;
        }
      } else {
        if (vnode.data.refInFor) {
          if (!Array.isArray(refs[key])) {
            refs[key] = [ref];
          } else if (refs[key].indexOf(ref) < 0) {
            // $flow-disable-line
            refs[key].push(ref);
          }
        } else {
          refs[key] = ref;
        }
      }
    }

    /**
     * Virtual DOM patching algorithm based on Snabbdom by
     * Simon Friis Vindum (@paldepind)
     * Licensed under the MIT License
     * https://github.com/paldepind/snabbdom/blob/master/LICENSE
     *
     * modified by Evan You (@yyx990803)
     *
     * Not type-checking this because this file is perf-critical and the cost
     * of making flow understand it is not worth it.
     */

    var emptyNode = new VNode('', {}, []);

    var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

    function sameVnode (a, b) {
      return (
        a.key === b.key &&
        a.asyncFactory === b.asyncFactory && (
          (
            a.tag === b.tag &&
            a.isComment === b.isComment &&
            isDef(a.data) === isDef(b.data) &&
            sameInputType(a, b)
          ) || (
            isTrue(a.isAsyncPlaceholder) &&
            isUndef(b.asyncFactory.error)
          )
        )
      )
    }

    function sameInputType (a, b) {
      if (a.tag !== 'input') { return true }
      var i;
      var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
      var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
      return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)
    }

    function createKeyToOldIdx (children, beginIdx, endIdx) {
      var i, key;
      var map = {};
      for (i = beginIdx; i <= endIdx; ++i) {
        key = children[i].key;
        if (isDef(key)) { map[key] = i; }
      }
      return map
    }

    function createPatchFunction (backend) {
      var i, j;
      var cbs = {};

      var modules = backend.modules;
      var nodeOps = backend.nodeOps;

      for (i = 0; i < hooks.length; ++i) {
        cbs[hooks[i]] = [];
        for (j = 0; j < modules.length; ++j) {
          if (isDef(modules[j][hooks[i]])) {
            cbs[hooks[i]].push(modules[j][hooks[i]]);
          }
        }
      }

      function emptyNodeAt (elm) {
        return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
      }

      function createRmCb (childElm, listeners) {
        function remove$$1 () {
          if (--remove$$1.listeners === 0) {
            removeNode(childElm);
          }
        }
        remove$$1.listeners = listeners;
        return remove$$1
      }

      function removeNode (el) {
        var parent = nodeOps.parentNode(el);
        // element may have already been removed due to v-html / v-text
        if (isDef(parent)) {
          nodeOps.removeChild(parent, el);
        }
      }

      function createElm (
        vnode,
        insertedVnodeQueue,
        parentElm,
        refElm,
        nested,
        ownerArray,
        index
      ) {
        if (isDef(vnode.elm) && isDef(ownerArray)) {
          // This vnode was used in a previous render!
          // now it's used as a new node, overwriting its elm would cause
          // potential patch errors down the road when it's used as an insertion
          // reference node. Instead, we clone the node on-demand before creating
          // associated DOM element for it.
          vnode = ownerArray[index] = cloneVNode(vnode);
        }

        vnode.isRootInsert = !nested; // for transition enter check
        if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
          return
        }

        var data = vnode.data;
        var children = vnode.children;
        var tag = vnode.tag;
        if (isDef(tag)) {

          vnode.elm = vnode.ns
            ? nodeOps.createElementNS(vnode.ns, tag)
            : nodeOps.createElement(tag, vnode);
          setScope(vnode);

          /* istanbul ignore if */
          {
            createChildren(vnode, children, insertedVnodeQueue);
            if (isDef(data)) {
              invokeCreateHooks(vnode, insertedVnodeQueue);
            }
            insert(parentElm, vnode.elm, refElm);
          }
        } else if (isTrue(vnode.isComment)) {
          vnode.elm = nodeOps.createComment(vnode.text);
          insert(parentElm, vnode.elm, refElm);
        } else {
          vnode.elm = nodeOps.createTextNode(vnode.text);
          insert(parentElm, vnode.elm, refElm);
        }
      }

      function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
        var i = vnode.data;
        if (isDef(i)) {
          var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
          if (isDef(i = i.hook) && isDef(i = i.init)) {
            i(vnode, false /* hydrating */);
          }
          // after calling the init hook, if the vnode is a child component
          // it should've created a child instance and mounted it. the child
          // component also has set the placeholder vnode's elm.
          // in that case we can just return the element and be done.
          if (isDef(vnode.componentInstance)) {
            initComponent(vnode, insertedVnodeQueue);
            insert(parentElm, vnode.elm, refElm);
            if (isTrue(isReactivated)) {
              reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
            }
            return true
          }
        }
      }

      function initComponent (vnode, insertedVnodeQueue) {
        if (isDef(vnode.data.pendingInsert)) {
          insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
          vnode.data.pendingInsert = null;
        }
        vnode.elm = vnode.componentInstance.$el;
        if (isPatchable(vnode)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
          setScope(vnode);
        } else {
          // empty component root.
          // skip all element-related modules except for ref (#3455)
          registerRef(vnode);
          // make sure to invoke the insert hook
          insertedVnodeQueue.push(vnode);
        }
      }

      function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
        var i;
        // hack for #4339: a reactivated component with inner transition
        // does not trigger because the inner node's created hooks are not called
        // again. It's not ideal to involve module-specific logic in here but
        // there doesn't seem to be a better way to do it.
        var innerNode = vnode;
        while (innerNode.componentInstance) {
          innerNode = innerNode.componentInstance._vnode;
          if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
            for (i = 0; i < cbs.activate.length; ++i) {
              cbs.activate[i](emptyNode, innerNode);
            }
            insertedVnodeQueue.push(innerNode);
            break
          }
        }
        // unlike a newly created component,
        // a reactivated keep-alive component doesn't insert itself
        insert(parentElm, vnode.elm, refElm);
      }

      function insert (parent, elm, ref$$1) {
        if (isDef(parent)) {
          if (isDef(ref$$1)) {
            if (nodeOps.parentNode(ref$$1) === parent) {
              nodeOps.insertBefore(parent, elm, ref$$1);
            }
          } else {
            nodeOps.appendChild(parent, elm);
          }
        }
      }

      function createChildren (vnode, children, insertedVnodeQueue) {
        if (Array.isArray(children)) {
          for (var i = 0; i < children.length; ++i) {
            createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);
          }
        } else if (isPrimitive(vnode.text)) {
          nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
        }
      }

      function isPatchable (vnode) {
        while (vnode.componentInstance) {
          vnode = vnode.componentInstance._vnode;
        }
        return isDef(vnode.tag)
      }

      function invokeCreateHooks (vnode, insertedVnodeQueue) {
        for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
          cbs.create[i$1](emptyNode, vnode);
        }
        i = vnode.data.hook; // Reuse variable
        if (isDef(i)) {
          if (isDef(i.create)) { i.create(emptyNode, vnode); }
          if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }
        }
      }

      // set scope id attribute for scoped CSS.
      // this is implemented as a special case to avoid the overhead
      // of going through the normal attribute patching process.
      function setScope (vnode) {
        var i;
        if (isDef(i = vnode.fnScopeId)) {
          nodeOps.setStyleScope(vnode.elm, i);
        } else {
          var ancestor = vnode;
          while (ancestor) {
            if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
              nodeOps.setStyleScope(vnode.elm, i);
            }
            ancestor = ancestor.parent;
          }
        }
        // for slot content they should also get the scopeId from the host instance.
        if (isDef(i = activeInstance) &&
          i !== vnode.context &&
          i !== vnode.fnContext &&
          isDef(i = i.$options._scopeId)
        ) {
          nodeOps.setStyleScope(vnode.elm, i);
        }
      }

      function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
        for (; startIdx <= endIdx; ++startIdx) {
          createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
        }
      }

      function invokeDestroyHook (vnode) {
        var i, j;
        var data = vnode.data;
        if (isDef(data)) {
          if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }
          for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }
        }
        if (isDef(i = vnode.children)) {
          for (j = 0; j < vnode.children.length; ++j) {
            invokeDestroyHook(vnode.children[j]);
          }
        }
      }

      function removeVnodes (vnodes, startIdx, endIdx) {
        for (; startIdx <= endIdx; ++startIdx) {
          var ch = vnodes[startIdx];
          if (isDef(ch)) {
            if (isDef(ch.tag)) {
              removeAndInvokeRemoveHook(ch);
              invokeDestroyHook(ch);
            } else { // Text node
              removeNode(ch.elm);
            }
          }
        }
      }

      function removeAndInvokeRemoveHook (vnode, rm) {
        if (isDef(rm) || isDef(vnode.data)) {
          var i;
          var listeners = cbs.remove.length + 1;
          if (isDef(rm)) {
            // we have a recursively passed down rm callback
            // increase the listeners count
            rm.listeners += listeners;
          } else {
            // directly removing
            rm = createRmCb(vnode.elm, listeners);
          }
          // recursively invoke hooks on child component root node
          if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
            removeAndInvokeRemoveHook(i, rm);
          }
          for (i = 0; i < cbs.remove.length; ++i) {
            cbs.remove[i](vnode, rm);
          }
          if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
            i(vnode, rm);
          } else {
            rm();
          }
        } else {
          removeNode(vnode.elm);
        }
      }

      function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
        var oldStartIdx = 0;
        var newStartIdx = 0;
        var oldEndIdx = oldCh.length - 1;
        var oldStartVnode = oldCh[0];
        var oldEndVnode = oldCh[oldEndIdx];
        var newEndIdx = newCh.length - 1;
        var newStartVnode = newCh[0];
        var newEndVnode = newCh[newEndIdx];
        var oldKeyToIdx, idxInOld, vnodeToMove, refElm;

        // removeOnly is a special flag used only by <transition-group>
        // to ensure removed elements stay in correct relative positions
        // during leaving transitions
        var canMove = !removeOnly;

        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
          if (isUndef(oldStartVnode)) {
            oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
          } else if (isUndef(oldEndVnode)) {
            oldEndVnode = oldCh[--oldEndIdx];
          } else if (sameVnode(oldStartVnode, newStartVnode)) {
            patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
            oldStartVnode = oldCh[++oldStartIdx];
            newStartVnode = newCh[++newStartIdx];
          } else if (sameVnode(oldEndVnode, newEndVnode)) {
            patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
            oldEndVnode = oldCh[--oldEndIdx];
            newEndVnode = newCh[--newEndIdx];
          } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
            patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
            canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
            oldStartVnode = oldCh[++oldStartIdx];
            newEndVnode = newCh[--newEndIdx];
          } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
            patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
            canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
            oldEndVnode = oldCh[--oldEndIdx];
            newStartVnode = newCh[++newStartIdx];
          } else {
            if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }
            idxInOld = isDef(newStartVnode.key)
              ? oldKeyToIdx[newStartVnode.key]
              : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
            if (isUndef(idxInOld)) { // New element
              createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
            } else {
              vnodeToMove = oldCh[idxInOld];
              if (sameVnode(vnodeToMove, newStartVnode)) {
                patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
                oldCh[idxInOld] = undefined;
                canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
              } else {
                // same key but different element. treat as new element
                createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
              }
            }
            newStartVnode = newCh[++newStartIdx];
          }
        }
        if (oldStartIdx > oldEndIdx) {
          refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
          addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
        } else if (newStartIdx > newEndIdx) {
          removeVnodes(oldCh, oldStartIdx, oldEndIdx);
        }
      }

      function findIdxInOld (node, oldCh, start, end) {
        for (var i = start; i < end; i++) {
          var c = oldCh[i];
          if (isDef(c) && sameVnode(node, c)) { return i }
        }
      }

      function patchVnode (
        oldVnode,
        vnode,
        insertedVnodeQueue,
        ownerArray,
        index,
        removeOnly
      ) {
        if (oldVnode === vnode) {
          return
        }

        if (isDef(vnode.elm) && isDef(ownerArray)) {
          // clone reused vnode
          vnode = ownerArray[index] = cloneVNode(vnode);
        }

        var elm = vnode.elm = oldVnode.elm;

        if (isTrue(oldVnode.isAsyncPlaceholder)) {
          if (isDef(vnode.asyncFactory.resolved)) {
            hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
          } else {
            vnode.isAsyncPlaceholder = true;
          }
          return
        }

        // reuse element for static trees.
        // note we only do this if the vnode is cloned -
        // if the new node is not cloned it means the render functions have been
        // reset by the hot-reload-api and we need to do a proper re-render.
        if (isTrue(vnode.isStatic) &&
          isTrue(oldVnode.isStatic) &&
          vnode.key === oldVnode.key &&
          (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))
        ) {
          vnode.componentInstance = oldVnode.componentInstance;
          return
        }

        var i;
        var data = vnode.data;
        if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
          i(oldVnode, vnode);
        }

        var oldCh = oldVnode.children;
        var ch = vnode.children;
        if (isDef(data) && isPatchable(vnode)) {
          for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }
          if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }
        }
        if (isUndef(vnode.text)) {
          if (isDef(oldCh) && isDef(ch)) {
            if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }
          } else if (isDef(ch)) {
            if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }
            addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
          } else if (isDef(oldCh)) {
            removeVnodes(oldCh, 0, oldCh.length - 1);
          } else if (isDef(oldVnode.text)) {
            nodeOps.setTextContent(elm, '');
          }
        } else if (oldVnode.text !== vnode.text) {
          nodeOps.setTextContent(elm, vnode.text);
        }
        if (isDef(data)) {
          if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }
        }
      }

      function invokeInsertHook (vnode, queue, initial) {
        // delay insert hooks for component root nodes, invoke them after the
        // element is really inserted
        if (isTrue(initial) && isDef(vnode.parent)) {
          vnode.parent.data.pendingInsert = queue;
        } else {
          for (var i = 0; i < queue.length; ++i) {
            queue[i].data.hook.insert(queue[i]);
          }
        }
      }
      // list of modules that can skip create hook during hydration because they
      // are already rendered on the client or has no need for initialization
      // Note: style is excluded because it relies on initial clone for future
      // deep updates (#7063).
      var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');

      // Note: this is a browser-only function so we can assume elms are DOM nodes.
      function hydrate (elm, vnode, insertedVnodeQueue, inVPre) {
        var i;
        var tag = vnode.tag;
        var data = vnode.data;
        var children = vnode.children;
        inVPre = inVPre || (data && data.pre);
        vnode.elm = elm;

        if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
          vnode.isAsyncPlaceholder = true;
          return true
        }
        if (isDef(data)) {
          if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }
          if (isDef(i = vnode.componentInstance)) {
            // child component. it should have hydrated its own tree.
            initComponent(vnode, insertedVnodeQueue);
            return true
          }
        }
        if (isDef(tag)) {
          if (isDef(children)) {
            // empty element, allow client to pick up and populate children
            if (!elm.hasChildNodes()) {
              createChildren(vnode, children, insertedVnodeQueue);
            } else {
              // v-html and domProps: innerHTML
              if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
                if (i !== elm.innerHTML) {
                  return false
                }
              } else {
                // iterate and compare children lists
                var childrenMatch = true;
                var childNode = elm.firstChild;
                for (var i$1 = 0; i$1 < children.length; i$1++) {
                  if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                    childrenMatch = false;
                    break
                  }
                  childNode = childNode.nextSibling;
                }
                // if childNode is not null, it means the actual childNodes list is
                // longer than the virtual children list.
                if (!childrenMatch || childNode) {
                  return false
                }
              }
            }
          }
          if (isDef(data)) {
            var fullInvoke = false;
            for (var key in data) {
              if (!isRenderedModule(key)) {
                fullInvoke = true;
                invokeCreateHooks(vnode, insertedVnodeQueue);
                break
              }
            }
            if (!fullInvoke && data['class']) {
              // ensure collecting deps for deep class bindings for future updates
              traverse(data['class']);
            }
          }
        } else if (elm.data !== vnode.text) {
          elm.data = vnode.text;
        }
        return true
      }

      return function patch (oldVnode, vnode, hydrating, removeOnly) {
        if (isUndef(vnode)) {
          if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }
          return
        }

        var isInitialPatch = false;
        var insertedVnodeQueue = [];

        if (isUndef(oldVnode)) {
          // empty mount (likely as component), create new root element
          isInitialPatch = true;
          createElm(vnode, insertedVnodeQueue);
        } else {
          var isRealElement = isDef(oldVnode.nodeType);
          if (!isRealElement && sameVnode(oldVnode, vnode)) {
            // patch existing root node
            patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
          } else {
            if (isRealElement) {
              // mounting to a real element
              // check if this is server-rendered content and if we can perform
              // a successful hydration.
              if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
                oldVnode.removeAttribute(SSR_ATTR);
                hydrating = true;
              }
              if (isTrue(hydrating)) {
                if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
                  invokeInsertHook(vnode, insertedVnodeQueue, true);
                  return oldVnode
                }
              }
              // either not server-rendered, or hydration failed.
              // create an empty node and replace it
              oldVnode = emptyNodeAt(oldVnode);
            }

            // replacing existing element
            var oldElm = oldVnode.elm;
            var parentElm = nodeOps.parentNode(oldElm);

            // create new node
            createElm(
              vnode,
              insertedVnodeQueue,
              // extremely rare edge case: do not insert if old element is in a
              // leaving transition. Only happens when combining transition +
              // keep-alive + HOCs. (#4590)
              oldElm._leaveCb ? null : parentElm,
              nodeOps.nextSibling(oldElm)
            );

            // update parent placeholder node element, recursively
            if (isDef(vnode.parent)) {
              var ancestor = vnode.parent;
              var patchable = isPatchable(vnode);
              while (ancestor) {
                for (var i = 0; i < cbs.destroy.length; ++i) {
                  cbs.destroy[i](ancestor);
                }
                ancestor.elm = vnode.elm;
                if (patchable) {
                  for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                    cbs.create[i$1](emptyNode, ancestor);
                  }
                  // #6513
                  // invoke insert hooks that may have been merged by create hooks.
                  // e.g. for directives that uses the "inserted" hook.
                  var insert = ancestor.data.hook.insert;
                  if (insert.merged) {
                    // start at index 1 to avoid re-invoking component mounted hook
                    for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                      insert.fns[i$2]();
                    }
                  }
                } else {
                  registerRef(ancestor);
                }
                ancestor = ancestor.parent;
              }
            }

            // destroy old node
            if (isDef(parentElm)) {
              removeVnodes([oldVnode], 0, 0);
            } else if (isDef(oldVnode.tag)) {
              invokeDestroyHook(oldVnode);
            }
          }
        }

        invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
        return vnode.elm
      }
    }

    /*  */

    var directives = {
      create: updateDirectives,
      update: updateDirectives,
      destroy: function unbindDirectives (vnode) {
        updateDirectives(vnode, emptyNode);
      }
    };

    function updateDirectives (oldVnode, vnode) {
      if (oldVnode.data.directives || vnode.data.directives) {
        _update(oldVnode, vnode);
      }
    }

    function _update (oldVnode, vnode) {
      var isCreate = oldVnode === emptyNode;
      var isDestroy = vnode === emptyNode;
      var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
      var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

      var dirsWithInsert = [];
      var dirsWithPostpatch = [];

      var key, oldDir, dir;
      for (key in newDirs) {
        oldDir = oldDirs[key];
        dir = newDirs[key];
        if (!oldDir) {
          // new directive, bind
          callHook$1(dir, 'bind', vnode, oldVnode);
          if (dir.def && dir.def.inserted) {
            dirsWithInsert.push(dir);
          }
        } else {
          // existing directive, update
          dir.oldValue = oldDir.value;
          dir.oldArg = oldDir.arg;
          callHook$1(dir, 'update', vnode, oldVnode);
          if (dir.def && dir.def.componentUpdated) {
            dirsWithPostpatch.push(dir);
          }
        }
      }

      if (dirsWithInsert.length) {
        var callInsert = function () {
          for (var i = 0; i < dirsWithInsert.length; i++) {
            callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
          }
        };
        if (isCreate) {
          mergeVNodeHook(vnode, 'insert', callInsert);
        } else {
          callInsert();
        }
      }

      if (dirsWithPostpatch.length) {
        mergeVNodeHook(vnode, 'postpatch', function () {
          for (var i = 0; i < dirsWithPostpatch.length; i++) {
            callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
          }
        });
      }

      if (!isCreate) {
        for (key in oldDirs) {
          if (!newDirs[key]) {
            // no longer present, unbind
            callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
          }
        }
      }
    }

    var emptyModifiers = Object.create(null);

    function normalizeDirectives$1 (
      dirs,
      vm
    ) {
      var res = Object.create(null);
      if (!dirs) {
        // $flow-disable-line
        return res
      }
      var i, dir;
      for (i = 0; i < dirs.length; i++) {
        dir = dirs[i];
        if (!dir.modifiers) {
          // $flow-disable-line
          dir.modifiers = emptyModifiers;
        }
        res[getRawDirName(dir)] = dir;
        dir.def = resolveAsset(vm.$options, 'directives', dir.name);
      }
      // $flow-disable-line
      return res
    }

    function getRawDirName (dir) {
      return dir.rawName || ((dir.name) + "." + (Object.keys(dir.modifiers || {}).join('.')))
    }

    function callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {
      var fn = dir.def && dir.def[hook];
      if (fn) {
        try {
          fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
        } catch (e) {
          handleError(e, vnode.context, ("directive " + (dir.name) + " " + hook + " hook"));
        }
      }
    }

    var baseModules = [
      ref,
      directives
    ];

    /*  */

    function updateAttrs (oldVnode, vnode) {
      var opts = vnode.componentOptions;
      if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
        return
      }
      if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
        return
      }
      var key, cur, old;
      var elm = vnode.elm;
      var oldAttrs = oldVnode.data.attrs || {};
      var attrs = vnode.data.attrs || {};
      // clone observed objects, as the user probably wants to mutate it
      if (isDef(attrs.__ob__)) {
        attrs = vnode.data.attrs = extend({}, attrs);
      }

      for (key in attrs) {
        cur = attrs[key];
        old = oldAttrs[key];
        if (old !== cur) {
          setAttr(elm, key, cur, vnode.data.pre);
        }
      }
      // #4391: in IE9, setting type can reset value for input[type=radio]
      // #6666: IE/Edge forces progress value down to 1 before setting a max
      /* istanbul ignore if */
      if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
        setAttr(elm, 'value', attrs.value);
      }
      for (key in oldAttrs) {
        if (isUndef(attrs[key])) {
          if (isXlink(key)) {
            elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
          } else if (!isEnumeratedAttr(key)) {
            elm.removeAttribute(key);
          }
        }
      }
    }

    function setAttr (el, key, value, isInPre) {
      if (isInPre || el.tagName.indexOf('-') > -1) {
        baseSetAttr(el, key, value);
      } else if (isBooleanAttr(key)) {
        // set attribute for blank value
        // e.g. <option disabled>Select one</option>
        if (isFalsyAttrValue(value)) {
          el.removeAttribute(key);
        } else {
          // technically allowfullscreen is a boolean attribute for <iframe>,
          // but Flash expects a value of "true" when used on <embed> tag
          value = key === 'allowfullscreen' && el.tagName === 'EMBED'
            ? 'true'
            : key;
          el.setAttribute(key, value);
        }
      } else if (isEnumeratedAttr(key)) {
        el.setAttribute(key, convertEnumeratedValue(key, value));
      } else if (isXlink(key)) {
        if (isFalsyAttrValue(value)) {
          el.removeAttributeNS(xlinkNS, getXlinkProp(key));
        } else {
          el.setAttributeNS(xlinkNS, key, value);
        }
      } else {
        baseSetAttr(el, key, value);
      }
    }

    function baseSetAttr (el, key, value) {
      if (isFalsyAttrValue(value)) {
        el.removeAttribute(key);
      } else {
        // #7138: IE10 & 11 fires input event when setting placeholder on
        // <textarea>... block the first input event and remove the blocker
        // immediately.
        /* istanbul ignore if */
        if (
          isIE && !isIE9 &&
          el.tagName === 'TEXTAREA' &&
          key === 'placeholder' && value !== '' && !el.__ieph
        ) {
          var blocker = function (e) {
            e.stopImmediatePropagation();
            el.removeEventListener('input', blocker);
          };
          el.addEventListener('input', blocker);
          // $flow-disable-line
          el.__ieph = true; /* IE placeholder patched */
        }
        el.setAttribute(key, value);
      }
    }

    var attrs = {
      create: updateAttrs,
      update: updateAttrs
    };

    /*  */

    function updateClass (oldVnode, vnode) {
      var el = vnode.elm;
      var data = vnode.data;
      var oldData = oldVnode.data;
      if (
        isUndef(data.staticClass) &&
        isUndef(data.class) && (
          isUndef(oldData) || (
            isUndef(oldData.staticClass) &&
            isUndef(oldData.class)
          )
        )
      ) {
        return
      }

      var cls = genClassForVnode(vnode);

      // handle transition classes
      var transitionClass = el._transitionClasses;
      if (isDef(transitionClass)) {
        cls = concat$1(cls, stringifyClass(transitionClass));
      }

      // set the class
      if (cls !== el._prevClass) {
        el.setAttribute('class', cls);
        el._prevClass = cls;
      }
    }

    var klass = {
      create: updateClass,
      update: updateClass
    };

    /*  */

    var validDivisionCharRE = /[\w).+\-_$\]]/;

    function parseFilters (exp) {
      var inSingle = false;
      var inDouble = false;
      var inTemplateString = false;
      var inRegex = false;
      var curly = 0;
      var square = 0;
      var paren = 0;
      var lastFilterIndex = 0;
      var c, prev, i, expression, filters;

      for (i = 0; i < exp.length; i++) {
        prev = c;
        c = exp.charCodeAt(i);
        if (inSingle) {
          if (c === 0x27 && prev !== 0x5C) { inSingle = false; }
        } else if (inDouble) {
          if (c === 0x22 && prev !== 0x5C) { inDouble = false; }
        } else if (inTemplateString) {
          if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }
        } else if (inRegex) {
          if (c === 0x2f && prev !== 0x5C) { inRegex = false; }
        } else if (
          c === 0x7C && // pipe
          exp.charCodeAt(i + 1) !== 0x7C &&
          exp.charCodeAt(i - 1) !== 0x7C &&
          !curly && !square && !paren
        ) {
          if (expression === undefined) {
            // first filter, end of expression
            lastFilterIndex = i + 1;
            expression = exp.slice(0, i).trim();
          } else {
            pushFilter();
          }
        } else {
          switch (c) {
            case 0x22: inDouble = true; break         // "
            case 0x27: inSingle = true; break         // '
            case 0x60: inTemplateString = true; break // `
            case 0x28: paren++; break                 // (
            case 0x29: paren--; break                 // )
            case 0x5B: square++; break                // [
            case 0x5D: square--; break                // ]
            case 0x7B: curly++; break                 // {
            case 0x7D: curly--; break                 // }
          }
          if (c === 0x2f) { // /
            var j = i - 1;
            var p = (void 0);
            // find first non-whitespace prev char
            for (; j >= 0; j--) {
              p = exp.charAt(j);
              if (p !== ' ') { break }
            }
            if (!p || !validDivisionCharRE.test(p)) {
              inRegex = true;
            }
          }
        }
      }

      if (expression === undefined) {
        expression = exp.slice(0, i).trim();
      } else if (lastFilterIndex !== 0) {
        pushFilter();
      }

      function pushFilter () {
        (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
        lastFilterIndex = i + 1;
      }

      if (filters) {
        for (i = 0; i < filters.length; i++) {
          expression = wrapFilter(expression, filters[i]);
        }
      }

      return expression
    }

    function wrapFilter (exp, filter) {
      var i = filter.indexOf('(');
      if (i < 0) {
        // _f: resolveFilter
        return ("_f(\"" + filter + "\")(" + exp + ")")
      } else {
        var name = filter.slice(0, i);
        var args = filter.slice(i + 1);
        return ("_f(\"" + name + "\")(" + exp + (args !== ')' ? ',' + args : args))
      }
    }

    /*  */



    /* eslint-disable no-unused-vars */
    function baseWarn (msg, range) {
      console.error(("[Vue compiler]: " + msg));
    }
    /* eslint-enable no-unused-vars */

    function pluckModuleFunction (
      modules,
      key
    ) {
      return modules
        ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })
        : []
    }

    function addProp (el, name, value, range, dynamic) {
      (el.props || (el.props = [])).push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));
      el.plain = false;
    }

    function addAttr (el, name, value, range, dynamic) {
      var attrs = dynamic
        ? (el.dynamicAttrs || (el.dynamicAttrs = []))
        : (el.attrs || (el.attrs = []));
      attrs.push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));
      el.plain = false;
    }

    // add a raw attr (use this in preTransforms)
    function addRawAttr (el, name, value, range) {
      el.attrsMap[name] = value;
      el.attrsList.push(rangeSetItem({ name: name, value: value }, range));
    }

    function addDirective (
      el,
      name,
      rawName,
      value,
      arg,
      isDynamicArg,
      modifiers,
      range
    ) {
      (el.directives || (el.directives = [])).push(rangeSetItem({
        name: name,
        rawName: rawName,
        value: value,
        arg: arg,
        isDynamicArg: isDynamicArg,
        modifiers: modifiers
      }, range));
      el.plain = false;
    }

    function prependModifierMarker (symbol, name, dynamic) {
      return dynamic
        ? ("_p(" + name + ",\"" + symbol + "\")")
        : symbol + name // mark the event as captured
    }

    function addHandler (
      el,
      name,
      value,
      modifiers,
      important,
      warn,
      range,
      dynamic
    ) {
      modifiers = modifiers || emptyObject;

      // normalize click.right and click.middle since they don't actually fire
      // this is technically browser-specific, but at least for now browsers are
      // the only target envs that have right/middle clicks.
      if (modifiers.right) {
        if (dynamic) {
          name = "(" + name + ")==='click'?'contextmenu':(" + name + ")";
        } else if (name === 'click') {
          name = 'contextmenu';
          delete modifiers.right;
        }
      } else if (modifiers.middle) {
        if (dynamic) {
          name = "(" + name + ")==='click'?'mouseup':(" + name + ")";
        } else if (name === 'click') {
          name = 'mouseup';
        }
      }

      // check capture modifier
      if (modifiers.capture) {
        delete modifiers.capture;
        name = prependModifierMarker('!', name, dynamic);
      }
      if (modifiers.once) {
        delete modifiers.once;
        name = prependModifierMarker('~', name, dynamic);
      }
      /* istanbul ignore if */
      if (modifiers.passive) {
        delete modifiers.passive;
        name = prependModifierMarker('&', name, dynamic);
      }

      var events;
      if (modifiers.native) {
        delete modifiers.native;
        events = el.nativeEvents || (el.nativeEvents = {});
      } else {
        events = el.events || (el.events = {});
      }

      var newHandler = rangeSetItem({ value: value.trim(), dynamic: dynamic }, range);
      if (modifiers !== emptyObject) {
        newHandler.modifiers = modifiers;
      }

      var handlers = events[name];
      /* istanbul ignore if */
      if (Array.isArray(handlers)) {
        important ? handlers.unshift(newHandler) : handlers.push(newHandler);
      } else if (handlers) {
        events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
      } else {
        events[name] = newHandler;
      }

      el.plain = false;
    }

    function getRawBindingAttr (
      el,
      name
    ) {
      return el.rawAttrsMap[':' + name] ||
        el.rawAttrsMap['v-bind:' + name] ||
        el.rawAttrsMap[name]
    }

    function getBindingAttr (
      el,
      name,
      getStatic
    ) {
      var dynamicValue =
        getAndRemoveAttr(el, ':' + name) ||
        getAndRemoveAttr(el, 'v-bind:' + name);
      if (dynamicValue != null) {
        return parseFilters(dynamicValue)
      } else if (getStatic !== false) {
        var staticValue = getAndRemoveAttr(el, name);
        if (staticValue != null) {
          return JSON.stringify(staticValue)
        }
      }
    }

    // note: this only removes the attr from the Array (attrsList) so that it
    // doesn't get processed by processAttrs.
    // By default it does NOT remove it from the map (attrsMap) because the map is
    // needed during codegen.
    function getAndRemoveAttr (
      el,
      name,
      removeFromMap
    ) {
      var val;
      if ((val = el.attrsMap[name]) != null) {
        var list = el.attrsList;
        for (var i = 0, l = list.length; i < l; i++) {
          if (list[i].name === name) {
            list.splice(i, 1);
            break
          }
        }
      }
      if (removeFromMap) {
        delete el.attrsMap[name];
      }
      return val
    }

    function getAndRemoveAttrByRegex (
      el,
      name
    ) {
      var list = el.attrsList;
      for (var i = 0, l = list.length; i < l; i++) {
        var attr = list[i];
        if (name.test(attr.name)) {
          list.splice(i, 1);
          return attr
        }
      }
    }

    function rangeSetItem (
      item,
      range
    ) {
      if (range) {
        if (range.start != null) {
          item.start = range.start;
        }
        if (range.end != null) {
          item.end = range.end;
        }
      }
      return item
    }

    /*  */

    /**
     * Cross-platform code generation for component v-model
     */
    function genComponentModel (
      el,
      value,
      modifiers
    ) {
      var ref = modifiers || {};
      var number = ref.number;
      var trim = ref.trim;

      var baseValueExpression = '$$v';
      var valueExpression = baseValueExpression;
      if (trim) {
        valueExpression =
          "(typeof " + baseValueExpression + " === 'string'" +
          "? " + baseValueExpression + ".trim()" +
          ": " + baseValueExpression + ")";
      }
      if (number) {
        valueExpression = "_n(" + valueExpression + ")";
      }
      var assignment = genAssignmentCode(value, valueExpression);

      el.model = {
        value: ("(" + value + ")"),
        expression: JSON.stringify(value),
        callback: ("function (" + baseValueExpression + ") {" + assignment + "}")
      };
    }

    /**
     * Cross-platform codegen helper for generating v-model value assignment code.
     */
    function genAssignmentCode (
      value,
      assignment
    ) {
      var res = parseModel(value);
      if (res.key === null) {
        return (value + "=" + assignment)
      } else {
        return ("$set(" + (res.exp) + ", " + (res.key) + ", " + assignment + ")")
      }
    }

    /**
     * Parse a v-model expression into a base path and a final key segment.
     * Handles both dot-path and possible square brackets.
     *
     * Possible cases:
     *
     * - test
     * - test[key]
     * - test[test1[key]]
     * - test["a"][key]
     * - xxx.test[a[a].test1[key]]
     * - test.xxx.a["asa"][test1[key]]
     *
     */

    var len, str, chr, index$1, expressionPos, expressionEndPos;



    function parseModel (val) {
      // Fix https://github.com/vuejs/vue/pull/7730
      // allow v-model="obj.val " (trailing whitespace)
      val = val.trim();
      len = val.length;

      if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
        index$1 = val.lastIndexOf('.');
        if (index$1 > -1) {
          return {
            exp: val.slice(0, index$1),
            key: '"' + val.slice(index$1 + 1) + '"'
          }
        } else {
          return {
            exp: val,
            key: null
          }
        }
      }

      str = val;
      index$1 = expressionPos = expressionEndPos = 0;

      while (!eof()) {
        chr = next();
        /* istanbul ignore if */
        if (isStringStart(chr)) {
          parseString(chr);
        } else if (chr === 0x5B) {
          parseBracket(chr);
        }
      }

      return {
        exp: val.slice(0, expressionPos),
        key: val.slice(expressionPos + 1, expressionEndPos)
      }
    }

    function next () {
      return str.charCodeAt(++index$1)
    }

    function eof () {
      return index$1 >= len
    }

    function isStringStart (chr) {
      return chr === 0x22 || chr === 0x27
    }

    function parseBracket (chr) {
      var inBracket = 1;
      expressionPos = index$1;
      while (!eof()) {
        chr = next();
        if (isStringStart(chr)) {
          parseString(chr);
          continue
        }
        if (chr === 0x5B) { inBracket++; }
        if (chr === 0x5D) { inBracket--; }
        if (inBracket === 0) {
          expressionEndPos = index$1;
          break
        }
      }
    }

    function parseString (chr) {
      var stringQuote = chr;
      while (!eof()) {
        chr = next();
        if (chr === stringQuote) {
          break
        }
      }
    }

    // in some cases, the event used has to be determined at runtime
    // so we used some reserved tokens during compile.
    var RANGE_TOKEN = '__r';
    var CHECKBOX_RADIO_TOKEN = '__c';

    function model (
      el,
      dir,
      _warn
    ) {
      var value = dir.value;
      var modifiers = dir.modifiers;
      var tag = el.tag;
      var type = el.attrsMap.type;

      if (el.component) {
        genComponentModel(el, value, modifiers);
        // component v-model doesn't need extra runtime
        return false
      } else if (tag === 'select') {
        genSelect(el, value, modifiers);
      } else if (tag === 'input' && type === 'checkbox') {
        genCheckboxModel(el, value, modifiers);
      } else if (tag === 'input' && type === 'radio') {
        genRadioModel(el, value, modifiers);
      } else if (tag === 'input' || tag === 'textarea') {
        genDefaultModel(el, value, modifiers);
      } else if (!config$1.isReservedTag(tag)) {
        genComponentModel(el, value, modifiers);
        // component v-model doesn't need extra runtime
        return false
      }

      // ensure runtime directive metadata
      return true
    }

    function genCheckboxModel (
      el,
      value,
      modifiers
    ) {
      var number = modifiers && modifiers.number;
      var valueBinding = getBindingAttr(el, 'value') || 'null';
      var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
      var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
      addProp(el, 'checked',
        "Array.isArray(" + value + ")" +
        "?_i(" + value + "," + valueBinding + ")>-1" + (
          trueValueBinding === 'true'
            ? (":(" + value + ")")
            : (":_q(" + value + "," + trueValueBinding + ")")
        )
      );
      addHandler(el, 'change',
        "var $$a=" + value + "," +
            '$$el=$event.target,' +
            "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" +
        'if(Array.isArray($$a)){' +
          "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," +
              '$$i=_i($$a,$$v);' +
          "if($$el.checked){$$i<0&&(" + (genAssignmentCode(value, '$$a.concat([$$v])')) + ")}" +
          "else{$$i>-1&&(" + (genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))')) + ")}" +
        "}else{" + (genAssignmentCode(value, '$$c')) + "}",
        null, true
      );
    }

    function genRadioModel (
      el,
      value,
      modifiers
    ) {
      var number = modifiers && modifiers.number;
      var valueBinding = getBindingAttr(el, 'value') || 'null';
      valueBinding = number ? ("_n(" + valueBinding + ")") : valueBinding;
      addProp(el, 'checked', ("_q(" + value + "," + valueBinding + ")"));
      addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);
    }

    function genSelect (
      el,
      value,
      modifiers
    ) {
      var number = modifiers && modifiers.number;
      var selectedVal = "Array.prototype.filter" +
        ".call($event.target.options,function(o){return o.selected})" +
        ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" +
        "return " + (number ? '_n(val)' : 'val') + "})";

      var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
      var code = "var $$selectedVal = " + selectedVal + ";";
      code = code + " " + (genAssignmentCode(value, assignment));
      addHandler(el, 'change', code, null, true);
    }

    function genDefaultModel (
      el,
      value,
      modifiers
    ) {
      var type = el.attrsMap.type;

      var ref = modifiers || {};
      var lazy = ref.lazy;
      var number = ref.number;
      var trim = ref.trim;
      var needCompositionGuard = !lazy && type !== 'range';
      var event = lazy
        ? 'change'
        : type === 'range'
          ? RANGE_TOKEN
          : 'input';

      var valueExpression = '$event.target.value';
      if (trim) {
        valueExpression = "$event.target.value.trim()";
      }
      if (number) {
        valueExpression = "_n(" + valueExpression + ")";
      }

      var code = genAssignmentCode(value, valueExpression);
      if (needCompositionGuard) {
        code = "if($event.target.composing)return;" + code;
      }

      addProp(el, 'value', ("(" + value + ")"));
      addHandler(el, event, code, null, true);
      if (trim || number) {
        addHandler(el, 'blur', '$forceUpdate()');
      }
    }

    /*  */

    // normalize v-model event tokens that can only be determined at runtime.
    // it's important to place the event as the first in the array because
    // the whole point is ensuring the v-model callback gets called before
    // user-attached handlers.
    function normalizeEvents (on) {
      /* istanbul ignore if */
      if (isDef(on[RANGE_TOKEN])) {
        // IE input[type=range] only supports `change` event
        var event = isIE ? 'change' : 'input';
        on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
        delete on[RANGE_TOKEN];
      }
      // This was originally intended to fix #4521 but no longer necessary
      // after 2.5. Keeping it for backwards compat with generated code from < 2.4
      /* istanbul ignore if */
      if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
        on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
        delete on[CHECKBOX_RADIO_TOKEN];
      }
    }

    var target$1;

    function createOnceHandler$1 (event, handler, capture) {
      var _target = target$1; // save current target element in closure
      return function onceHandler () {
        var res = handler.apply(null, arguments);
        if (res !== null) {
          remove$2(event, onceHandler, capture, _target);
        }
      }
    }

    // #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp
    // implementation and does not fire microtasks in between event propagation, so
    // safe to exclude.
    var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);

    function add$1 (
      name,
      handler,
      capture,
      passive
    ) {
      // async edge case #6566: inner click event triggers patch, event handler
      // attached to outer element during patch, and triggered again. This
      // happens because browsers fire microtask ticks between event propagation.
      // the solution is simple: we save the timestamp when a handler is attached,
      // and the handler would only fire if the event passed to it was fired
      // AFTER it was attached.
      if (useMicrotaskFix) {
        var attachedTimestamp = currentFlushTimestamp;
        var original = handler;
        handler = original._wrapper = function (e) {
          if (
            // no bubbling, should always fire.
            // this is just a safety net in case event.timeStamp is unreliable in
            // certain weird environments...
            e.target === e.currentTarget ||
            // event is fired after handler attachment
            e.timeStamp >= attachedTimestamp ||
            // bail for environments that have buggy event.timeStamp implementations
            // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState
            // #9681 QtWebEngine event.timeStamp is negative value
            e.timeStamp <= 0 ||
            // #9448 bail if event is fired in another document in a multi-page
            // electron/nw.js app, since event.timeStamp will be using a different
            // starting reference
            e.target.ownerDocument !== document
          ) {
            return original.apply(this, arguments)
          }
        };
      }
      target$1.addEventListener(
        name,
        handler,
        supportsPassive
          ? { capture: capture, passive: passive }
          : capture
      );
    }

    function remove$2 (
      name,
      handler,
      capture,
      _target
    ) {
      (_target || target$1).removeEventListener(
        name,
        handler._wrapper || handler,
        capture
      );
    }

    function updateDOMListeners (oldVnode, vnode) {
      if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
        return
      }
      var on = vnode.data.on || {};
      var oldOn = oldVnode.data.on || {};
      target$1 = vnode.elm;
      normalizeEvents(on);
      updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);
      target$1 = undefined;
    }

    var events = {
      create: updateDOMListeners,
      update: updateDOMListeners
    };

    /*  */

    var svgContainer;

    function updateDOMProps (oldVnode, vnode) {
      if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
        return
      }
      var key, cur;
      var elm = vnode.elm;
      var oldProps = oldVnode.data.domProps || {};
      var props = vnode.data.domProps || {};
      // clone observed objects, as the user probably wants to mutate it
      if (isDef(props.__ob__)) {
        props = vnode.data.domProps = extend({}, props);
      }

      for (key in oldProps) {
        if (!(key in props)) {
          elm[key] = '';
        }
      }

      for (key in props) {
        cur = props[key];
        // ignore children if the node has textContent or innerHTML,
        // as these will throw away existing DOM nodes and cause removal errors
        // on subsequent patches (#3360)
        if (key === 'textContent' || key === 'innerHTML') {
          if (vnode.children) { vnode.children.length = 0; }
          if (cur === oldProps[key]) { continue }
          // #6601 work around Chrome version <= 55 bug where single textNode
          // replaced by innerHTML/textContent retains its parentNode property
          if (elm.childNodes.length === 1) {
            elm.removeChild(elm.childNodes[0]);
          }
        }

        if (key === 'value' && elm.tagName !== 'PROGRESS') {
          // store value as _value as well since
          // non-string values will be stringified
          elm._value = cur;
          // avoid resetting cursor position when value is the same
          var strCur = isUndef(cur) ? '' : String(cur);
          if (shouldUpdateValue(elm, strCur)) {
            elm.value = strCur;
          }
        } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {
          // IE doesn't support innerHTML for SVG elements
          svgContainer = svgContainer || document.createElement('div');
          svgContainer.innerHTML = "<svg>" + cur + "</svg>";
          var svg = svgContainer.firstChild;
          while (elm.firstChild) {
            elm.removeChild(elm.firstChild);
          }
          while (svg.firstChild) {
            elm.appendChild(svg.firstChild);
          }
        } else if (
          // skip the update if old and new VDOM state is the same.
          // `value` is handled separately because the DOM value may be temporarily
          // out of sync with VDOM state due to focus, composition and modifiers.
          // This  #4521 by skipping the unnecessary `checked` update.
          cur !== oldProps[key]
        ) {
          // some property updates can throw
          // e.g. `value` on <progress> w/ non-finite value
          try {
            elm[key] = cur;
          } catch (e) {}
        }
      }
    }

    // check platforms/web/util/attrs.js acceptValue


    function shouldUpdateValue (elm, checkVal) {
      return (!elm.composing && (
        elm.tagName === 'OPTION' ||
        isNotInFocusAndDirty(elm, checkVal) ||
        isDirtyWithModifiers(elm, checkVal)
      ))
    }

    function isNotInFocusAndDirty (elm, checkVal) {
      // return true when textbox (.number and .trim) loses focus and its value is
      // not equal to the updated value
      var notInFocus = true;
      // #6157
      // work around IE bug when accessing document.activeElement in an iframe
      try { notInFocus = document.activeElement !== elm; } catch (e) {}
      return notInFocus && elm.value !== checkVal
    }

    function isDirtyWithModifiers (elm, newVal) {
      var value = elm.value;
      var modifiers = elm._vModifiers; // injected by v-model runtime
      if (isDef(modifiers)) {
        if (modifiers.number) {
          return toNumber(value) !== toNumber(newVal)
        }
        if (modifiers.trim) {
          return value.trim() !== newVal.trim()
        }
      }
      return value !== newVal
    }

    var domProps = {
      create: updateDOMProps,
      update: updateDOMProps
    };

    /*  */

    var parseStyleText = cached(function (cssText) {
      var res = {};
      var listDelimiter = /;(?![^(]*\))/g;
      var propertyDelimiter = /:(.+)/;
      cssText.split(listDelimiter).forEach(function (item) {
        if (item) {
          var tmp = item.split(propertyDelimiter);
          tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
        }
      });
      return res
    });

    // merge static and dynamic style data on the same vnode
    function normalizeStyleData (data) {
      var style = normalizeStyleBinding(data.style);
      // static style is pre-processed into an object during compilation
      // and is always a fresh object, so it's safe to merge into it
      return data.staticStyle
        ? extend(data.staticStyle, style)
        : style
    }

    // normalize possible array / string values into Object
    function normalizeStyleBinding (bindingStyle) {
      if (Array.isArray(bindingStyle)) {
        return toObject(bindingStyle)
      }
      if (typeof bindingStyle === 'string') {
        return parseStyleText(bindingStyle)
      }
      return bindingStyle
    }

    /**
     * parent component style should be after child's
     * so that parent component's style could override it
     */
    function getStyle (vnode, checkChild) {
      var res = {};
      var styleData;

      if (checkChild) {
        var childNode = vnode;
        while (childNode.componentInstance) {
          childNode = childNode.componentInstance._vnode;
          if (
            childNode && childNode.data &&
            (styleData = normalizeStyleData(childNode.data))
          ) {
            extend(res, styleData);
          }
        }
      }

      if ((styleData = normalizeStyleData(vnode.data))) {
        extend(res, styleData);
      }

      var parentNode = vnode;
      while ((parentNode = parentNode.parent)) {
        if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
          extend(res, styleData);
        }
      }
      return res
    }

    /*  */

    var cssVarRE = /^--/;
    var importantRE = /\s*!important$/;
    var setProp = function (el, name, val) {
      /* istanbul ignore if */
      if (cssVarRE.test(name)) {
        el.style.setProperty(name, val);
      } else if (importantRE.test(val)) {
        el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');
      } else {
        var normalizedName = normalize(name);
        if (Array.isArray(val)) {
          // Support values array created by autoprefixer, e.g.
          // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
          // Set them one by one, and the browser will only set those it can recognize
          for (var i = 0, len = val.length; i < len; i++) {
            el.style[normalizedName] = val[i];
          }
        } else {
          el.style[normalizedName] = val;
        }
      }
    };

    var vendorNames = ['Webkit', 'Moz', 'ms'];

    var emptyStyle;
    var normalize = cached(function (prop) {
      emptyStyle = emptyStyle || document.createElement('div').style;
      prop = camelize(prop);
      if (prop !== 'filter' && (prop in emptyStyle)) {
        return prop
      }
      var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
      for (var i = 0; i < vendorNames.length; i++) {
        var name = vendorNames[i] + capName;
        if (name in emptyStyle) {
          return name
        }
      }
    });

    function updateStyle (oldVnode, vnode) {
      var data = vnode.data;
      var oldData = oldVnode.data;

      if (isUndef(data.staticStyle) && isUndef(data.style) &&
        isUndef(oldData.staticStyle) && isUndef(oldData.style)
      ) {
        return
      }

      var cur, name;
      var el = vnode.elm;
      var oldStaticStyle = oldData.staticStyle;
      var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};

      // if static style exists, stylebinding already merged into it when doing normalizeStyleData
      var oldStyle = oldStaticStyle || oldStyleBinding;

      var style = normalizeStyleBinding(vnode.data.style) || {};

      // store normalized style under a different key for next diff
      // make sure to clone it if it's reactive, since the user likely wants
      // to mutate it.
      vnode.data.normalizedStyle = isDef(style.__ob__)
        ? extend({}, style)
        : style;

      var newStyle = getStyle(vnode, true);

      for (name in oldStyle) {
        if (isUndef(newStyle[name])) {
          setProp(el, name, '');
        }
      }
      for (name in newStyle) {
        cur = newStyle[name];
        if (cur !== oldStyle[name]) {
          // ie9 setting to null has no effect, must use empty string
          setProp(el, name, cur == null ? '' : cur);
        }
      }
    }

    var style = {
      create: updateStyle,
      update: updateStyle
    };

    /*  */

    var whitespaceRE = /\s+/;

    /**
     * Add class with compatibility for SVG since classList is not supported on
     * SVG elements in IE
     */
    function addClass (el, cls) {
      /* istanbul ignore if */
      if (!cls || !(cls = cls.trim())) {
        return
      }

      /* istanbul ignore else */
      if (el.classList) {
        if (cls.indexOf(' ') > -1) {
          cls.split(whitespaceRE).forEach(function (c) { return el.classList.add(c); });
        } else {
          el.classList.add(cls);
        }
      } else {
        var cur = " " + (el.getAttribute('class') || '') + " ";
        if (cur.indexOf(' ' + cls + ' ') < 0) {
          el.setAttribute('class', (cur + cls).trim());
        }
      }
    }

    /**
     * Remove class with compatibility for SVG since classList is not supported on
     * SVG elements in IE
     */
    function removeClass (el, cls) {
      /* istanbul ignore if */
      if (!cls || !(cls = cls.trim())) {
        return
      }

      /* istanbul ignore else */
      if (el.classList) {
        if (cls.indexOf(' ') > -1) {
          cls.split(whitespaceRE).forEach(function (c) { return el.classList.remove(c); });
        } else {
          el.classList.remove(cls);
        }
        if (!el.classList.length) {
          el.removeAttribute('class');
        }
      } else {
        var cur = " " + (el.getAttribute('class') || '') + " ";
        var tar = ' ' + cls + ' ';
        while (cur.indexOf(tar) >= 0) {
          cur = cur.replace(tar, ' ');
        }
        cur = cur.trim();
        if (cur) {
          el.setAttribute('class', cur);
        } else {
          el.removeAttribute('class');
        }
      }
    }

    /*  */

    function resolveTransition (def$$1) {
      if (!def$$1) {
        return
      }
      /* istanbul ignore else */
      if (typeof def$$1 === 'object') {
        var res = {};
        if (def$$1.css !== false) {
          extend(res, autoCssTransition(def$$1.name || 'v'));
        }
        extend(res, def$$1);
        return res
      } else if (typeof def$$1 === 'string') {
        return autoCssTransition(def$$1)
      }
    }

    var autoCssTransition = cached(function (name) {
      return {
        enterClass: (name + "-enter"),
        enterToClass: (name + "-enter-to"),
        enterActiveClass: (name + "-enter-active"),
        leaveClass: (name + "-leave"),
        leaveToClass: (name + "-leave-to"),
        leaveActiveClass: (name + "-leave-active")
      }
    });

    var hasTransition = inBrowser && !isIE9;
    var TRANSITION = 'transition';
    var ANIMATION = 'animation';

    // Transition property/event sniffing
    var transitionProp = 'transition';
    var transitionEndEvent = 'transitionend';
    var animationProp = 'animation';
    var animationEndEvent = 'animationend';
    if (hasTransition) {
      /* istanbul ignore if */
      if (window.ontransitionend === undefined &&
        window.onwebkittransitionend !== undefined
      ) {
        transitionProp = 'WebkitTransition';
        transitionEndEvent = 'webkitTransitionEnd';
      }
      if (window.onanimationend === undefined &&
        window.onwebkitanimationend !== undefined
      ) {
        animationProp = 'WebkitAnimation';
        animationEndEvent = 'webkitAnimationEnd';
      }
    }

    // binding to window is necessary to make hot reload work in IE in strict mode
    var raf = inBrowser
      ? window.requestAnimationFrame
        ? window.requestAnimationFrame.bind(window)
        : setTimeout
      : /* istanbul ignore next */ function (fn) { return fn(); };

    function nextFrame (fn) {
      raf(function () {
        raf(fn);
      });
    }

    function addTransitionClass (el, cls) {
      var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
      if (transitionClasses.indexOf(cls) < 0) {
        transitionClasses.push(cls);
        addClass(el, cls);
      }
    }

    function removeTransitionClass (el, cls) {
      if (el._transitionClasses) {
        remove(el._transitionClasses, cls);
      }
      removeClass(el, cls);
    }

    function whenTransitionEnds (
      el,
      expectedType,
      cb
    ) {
      var ref = getTransitionInfo(el, expectedType);
      var type = ref.type;
      var timeout = ref.timeout;
      var propCount = ref.propCount;
      if (!type) { return cb() }
      var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
      var ended = 0;
      var end = function () {
        el.removeEventListener(event, onEnd);
        cb();
      };
      var onEnd = function (e) {
        if (e.target === el) {
          if (++ended >= propCount) {
            end();
          }
        }
      };
      setTimeout(function () {
        if (ended < propCount) {
          end();
        }
      }, timeout + 1);
      el.addEventListener(event, onEnd);
    }

    var transformRE = /\b(transform|all)(,|$)/;

    function getTransitionInfo (el, expectedType) {
      var styles = window.getComputedStyle(el);
      // JSDOM may return undefined for transition properties
      var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');
      var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');
      var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
      var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');
      var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');
      var animationTimeout = getTimeout(animationDelays, animationDurations);

      var type;
      var timeout = 0;
      var propCount = 0;
      /* istanbul ignore if */
      if (expectedType === TRANSITION) {
        if (transitionTimeout > 0) {
          type = TRANSITION;
          timeout = transitionTimeout;
          propCount = transitionDurations.length;
        }
      } else if (expectedType === ANIMATION) {
        if (animationTimeout > 0) {
          type = ANIMATION;
          timeout = animationTimeout;
          propCount = animationDurations.length;
        }
      } else {
        timeout = Math.max(transitionTimeout, animationTimeout);
        type = timeout > 0
          ? transitionTimeout > animationTimeout
            ? TRANSITION
            : ANIMATION
          : null;
        propCount = type
          ? type === TRANSITION
            ? transitionDurations.length
            : animationDurations.length
          : 0;
      }
      var hasTransform =
        type === TRANSITION &&
        transformRE.test(styles[transitionProp + 'Property']);
      return {
        type: type,
        timeout: timeout,
        propCount: propCount,
        hasTransform: hasTransform
      }
    }

    function getTimeout (delays, durations) {
      /* istanbul ignore next */
      while (delays.length < durations.length) {
        delays = delays.concat(delays);
      }

      return Math.max.apply(null, durations.map(function (d, i) {
        return toMs(d) + toMs(delays[i])
      }))
    }

    // Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers
    // in a locale-dependent way, using a comma instead of a dot.
    // If comma is not replaced with a dot, the input will be rounded down (i.e. acting
    // as a floor function) causing unexpected behaviors
    function toMs (s) {
      return Number(s.slice(0, -1).replace(',', '.')) * 1000
    }

    /*  */

    function enter (vnode, toggleDisplay) {
      var el = vnode.elm;

      // call leave callback now
      if (isDef(el._leaveCb)) {
        el._leaveCb.cancelled = true;
        el._leaveCb();
      }

      var data = resolveTransition(vnode.data.transition);
      if (isUndef(data)) {
        return
      }

      /* istanbul ignore if */
      if (isDef(el._enterCb) || el.nodeType !== 1) {
        return
      }

      var css = data.css;
      var type = data.type;
      var enterClass = data.enterClass;
      var enterToClass = data.enterToClass;
      var enterActiveClass = data.enterActiveClass;
      var appearClass = data.appearClass;
      var appearToClass = data.appearToClass;
      var appearActiveClass = data.appearActiveClass;
      var beforeEnter = data.beforeEnter;
      var enter = data.enter;
      var afterEnter = data.afterEnter;
      var enterCancelled = data.enterCancelled;
      var beforeAppear = data.beforeAppear;
      var appear = data.appear;
      var afterAppear = data.afterAppear;
      var appearCancelled = data.appearCancelled;
      var duration = data.duration;

      // activeInstance will always be the <transition> component managing this
      // transition. One edge case to check is when the <transition> is placed
      // as the root node of a child component. In that case we need to check
      // <transition>'s parent for appear check.
      var context = activeInstance;
      var transitionNode = activeInstance.$vnode;
      while (transitionNode && transitionNode.parent) {
        context = transitionNode.context;
        transitionNode = transitionNode.parent;
      }

      var isAppear = !context._isMounted || !vnode.isRootInsert;

      if (isAppear && !appear && appear !== '') {
        return
      }

      var startClass = isAppear && appearClass
        ? appearClass
        : enterClass;
      var activeClass = isAppear && appearActiveClass
        ? appearActiveClass
        : enterActiveClass;
      var toClass = isAppear && appearToClass
        ? appearToClass
        : enterToClass;

      var beforeEnterHook = isAppear
        ? (beforeAppear || beforeEnter)
        : beforeEnter;
      var enterHook = isAppear
        ? (typeof appear === 'function' ? appear : enter)
        : enter;
      var afterEnterHook = isAppear
        ? (afterAppear || afterEnter)
        : afterEnter;
      var enterCancelledHook = isAppear
        ? (appearCancelled || enterCancelled)
        : enterCancelled;

      var explicitEnterDuration = toNumber(
        isObject$1(duration)
          ? duration.enter
          : duration
      );

      var expectsCSS = css !== false && !isIE9;
      var userWantsControl = getHookArgumentsLength(enterHook);

      var cb = el._enterCb = once(function () {
        if (expectsCSS) {
          removeTransitionClass(el, toClass);
          removeTransitionClass(el, activeClass);
        }
        if (cb.cancelled) {
          if (expectsCSS) {
            removeTransitionClass(el, startClass);
          }
          enterCancelledHook && enterCancelledHook(el);
        } else {
          afterEnterHook && afterEnterHook(el);
        }
        el._enterCb = null;
      });

      if (!vnode.data.show) {
        // remove pending leave element on enter by injecting an insert hook
        mergeVNodeHook(vnode, 'insert', function () {
          var parent = el.parentNode;
          var pendingNode = parent && parent._pending && parent._pending[vnode.key];
          if (pendingNode &&
            pendingNode.tag === vnode.tag &&
            pendingNode.elm._leaveCb
          ) {
            pendingNode.elm._leaveCb();
          }
          enterHook && enterHook(el, cb);
        });
      }

      // start enter transition
      beforeEnterHook && beforeEnterHook(el);
      if (expectsCSS) {
        addTransitionClass(el, startClass);
        addTransitionClass(el, activeClass);
        nextFrame(function () {
          removeTransitionClass(el, startClass);
          if (!cb.cancelled) {
            addTransitionClass(el, toClass);
            if (!userWantsControl) {
              if (isValidDuration(explicitEnterDuration)) {
                setTimeout(cb, explicitEnterDuration);
              } else {
                whenTransitionEnds(el, type, cb);
              }
            }
          }
        });
      }

      if (vnode.data.show) {
        toggleDisplay && toggleDisplay();
        enterHook && enterHook(el, cb);
      }

      if (!expectsCSS && !userWantsControl) {
        cb();
      }
    }

    function leave (vnode, rm) {
      var el = vnode.elm;

      // call enter callback now
      if (isDef(el._enterCb)) {
        el._enterCb.cancelled = true;
        el._enterCb();
      }

      var data = resolveTransition(vnode.data.transition);
      if (isUndef(data) || el.nodeType !== 1) {
        return rm()
      }

      /* istanbul ignore if */
      if (isDef(el._leaveCb)) {
        return
      }

      var css = data.css;
      var type = data.type;
      var leaveClass = data.leaveClass;
      var leaveToClass = data.leaveToClass;
      var leaveActiveClass = data.leaveActiveClass;
      var beforeLeave = data.beforeLeave;
      var leave = data.leave;
      var afterLeave = data.afterLeave;
      var leaveCancelled = data.leaveCancelled;
      var delayLeave = data.delayLeave;
      var duration = data.duration;

      var expectsCSS = css !== false && !isIE9;
      var userWantsControl = getHookArgumentsLength(leave);

      var explicitLeaveDuration = toNumber(
        isObject$1(duration)
          ? duration.leave
          : duration
      );

      var cb = el._leaveCb = once(function () {
        if (el.parentNode && el.parentNode._pending) {
          el.parentNode._pending[vnode.key] = null;
        }
        if (expectsCSS) {
          removeTransitionClass(el, leaveToClass);
          removeTransitionClass(el, leaveActiveClass);
        }
        if (cb.cancelled) {
          if (expectsCSS) {
            removeTransitionClass(el, leaveClass);
          }
          leaveCancelled && leaveCancelled(el);
        } else {
          rm();
          afterLeave && afterLeave(el);
        }
        el._leaveCb = null;
      });

      if (delayLeave) {
        delayLeave(performLeave);
      } else {
        performLeave();
      }

      function performLeave () {
        // the delayed leave may have already been cancelled
        if (cb.cancelled) {
          return
        }
        // record leaving element
        if (!vnode.data.show && el.parentNode) {
          (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;
        }
        beforeLeave && beforeLeave(el);
        if (expectsCSS) {
          addTransitionClass(el, leaveClass);
          addTransitionClass(el, leaveActiveClass);
          nextFrame(function () {
            removeTransitionClass(el, leaveClass);
            if (!cb.cancelled) {
              addTransitionClass(el, leaveToClass);
              if (!userWantsControl) {
                if (isValidDuration(explicitLeaveDuration)) {
                  setTimeout(cb, explicitLeaveDuration);
                } else {
                  whenTransitionEnds(el, type, cb);
                }
              }
            }
          });
        }
        leave && leave(el, cb);
        if (!expectsCSS && !userWantsControl) {
          cb();
        }
      }
    }

    function isValidDuration (val) {
      return typeof val === 'number' && !isNaN(val)
    }

    /**
     * Normalize a transition hook's argument length. The hook may be:
     * - a merged hook (invoker) with the original in .fns
     * - a wrapped component method (check ._length)
     * - a plain function (.length)
     */
    function getHookArgumentsLength (fn) {
      if (isUndef(fn)) {
        return false
      }
      var invokerFns = fn.fns;
      if (isDef(invokerFns)) {
        // invoker
        return getHookArgumentsLength(
          Array.isArray(invokerFns)
            ? invokerFns[0]
            : invokerFns
        )
      } else {
        return (fn._length || fn.length) > 1
      }
    }

    function _enter (_, vnode) {
      if (vnode.data.show !== true) {
        enter(vnode);
      }
    }

    var transition = inBrowser ? {
      create: _enter,
      activate: _enter,
      remove: function remove$$1 (vnode, rm) {
        /* istanbul ignore else */
        if (vnode.data.show !== true) {
          leave(vnode, rm);
        } else {
          rm();
        }
      }
    } : {};

    var platformModules = [
      attrs,
      klass,
      events,
      domProps,
      style,
      transition
    ];

    /*  */

    // the directive module should be applied last, after all
    // built-in modules have been applied.
    var modules = platformModules.concat(baseModules);

    var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

    /**
     * Not type checking this file because flow doesn't like attaching
     * properties to Elements.
     */

    /* istanbul ignore if */
    if (isIE9) {
      // http://www.matts411.com/post/internet-explorer-9-oninput/
      document.addEventListener('selectionchange', function () {
        var el = document.activeElement;
        if (el && el.vmodel) {
          trigger(el, 'input');
        }
      });
    }

    var directive = {
      inserted: function inserted (el, binding, vnode, oldVnode) {
        if (vnode.tag === 'select') {
          // #6903
          if (oldVnode.elm && !oldVnode.elm._vOptions) {
            mergeVNodeHook(vnode, 'postpatch', function () {
              directive.componentUpdated(el, binding, vnode);
            });
          } else {
            setSelected(el, binding, vnode.context);
          }
          el._vOptions = [].map.call(el.options, getValue);
        } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
          el._vModifiers = binding.modifiers;
          if (!binding.modifiers.lazy) {
            el.addEventListener('compositionstart', onCompositionStart);
            el.addEventListener('compositionend', onCompositionEnd);
            // Safari < 10.2 & UIWebView doesn't fire compositionend when
            // switching focus before confirming composition choice
            // this also fixes the issue where some browsers e.g. iOS Chrome
            // fires "change" instead of "input" on autocomplete.
            el.addEventListener('change', onCompositionEnd);
            /* istanbul ignore if */
            if (isIE9) {
              el.vmodel = true;
            }
          }
        }
      },

      componentUpdated: function componentUpdated (el, binding, vnode) {
        if (vnode.tag === 'select') {
          setSelected(el, binding, vnode.context);
          // in case the options rendered by v-for have changed,
          // it's possible that the value is out-of-sync with the rendered options.
          // detect such cases and filter out values that no longer has a matching
          // option in the DOM.
          var prevOptions = el._vOptions;
          var curOptions = el._vOptions = [].map.call(el.options, getValue);
          if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {
            // trigger change event if
            // no matching option found for at least one value
            var needReset = el.multiple
              ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })
              : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);
            if (needReset) {
              trigger(el, 'change');
            }
          }
        }
      }
    };

    function setSelected (el, binding, vm) {
      actuallySetSelected(el, binding);
      /* istanbul ignore if */
      if (isIE || isEdge) {
        setTimeout(function () {
          actuallySetSelected(el, binding);
        }, 0);
      }
    }

    function actuallySetSelected (el, binding, vm) {
      var value = binding.value;
      var isMultiple = el.multiple;
      if (isMultiple && !Array.isArray(value)) {
        return
      }
      var selected, option;
      for (var i = 0, l = el.options.length; i < l; i++) {
        option = el.options[i];
        if (isMultiple) {
          selected = looseIndexOf(value, getValue(option)) > -1;
          if (option.selected !== selected) {
            option.selected = selected;
          }
        } else {
          if (looseEqual(getValue(option), value)) {
            if (el.selectedIndex !== i) {
              el.selectedIndex = i;
            }
            return
          }
        }
      }
      if (!isMultiple) {
        el.selectedIndex = -1;
      }
    }

    function hasNoMatchingOption (value, options) {
      return options.every(function (o) { return !looseEqual(o, value); })
    }

    function getValue (option) {
      return '_value' in option
        ? option._value
        : option.value
    }

    function onCompositionStart (e) {
      e.target.composing = true;
    }

    function onCompositionEnd (e) {
      // prevent triggering an input event for no reason
      if (!e.target.composing) { return }
      e.target.composing = false;
      trigger(e.target, 'input');
    }

    function trigger (el, type) {
      var e = document.createEvent('HTMLEvents');
      e.initEvent(type, true, true);
      el.dispatchEvent(e);
    }

    /*  */

    // recursively search for possible transition defined inside the component root
    function locateNode (vnode) {
      return vnode.componentInstance && (!vnode.data || !vnode.data.transition)
        ? locateNode(vnode.componentInstance._vnode)
        : vnode
    }

    var show = {
      bind: function bind (el, ref, vnode) {
        var value = ref.value;

        vnode = locateNode(vnode);
        var transition$$1 = vnode.data && vnode.data.transition;
        var originalDisplay = el.__vOriginalDisplay =
          el.style.display === 'none' ? '' : el.style.display;
        if (value && transition$$1) {
          vnode.data.show = true;
          enter(vnode, function () {
            el.style.display = originalDisplay;
          });
        } else {
          el.style.display = value ? originalDisplay : 'none';
        }
      },

      update: function update (el, ref, vnode) {
        var value = ref.value;
        var oldValue = ref.oldValue;

        /* istanbul ignore if */
        if (!value === !oldValue) { return }
        vnode = locateNode(vnode);
        var transition$$1 = vnode.data && vnode.data.transition;
        if (transition$$1) {
          vnode.data.show = true;
          if (value) {
            enter(vnode, function () {
              el.style.display = el.__vOriginalDisplay;
            });
          } else {
            leave(vnode, function () {
              el.style.display = 'none';
            });
          }
        } else {
          el.style.display = value ? el.__vOriginalDisplay : 'none';
        }
      },

      unbind: function unbind (
        el,
        binding,
        vnode,
        oldVnode,
        isDestroy
      ) {
        if (!isDestroy) {
          el.style.display = el.__vOriginalDisplay;
        }
      }
    };

    var platformDirectives = {
      model: directive,
      show: show
    };

    /*  */

    var transitionProps = {
      name: String,
      appear: Boolean,
      css: Boolean,
      mode: String,
      type: String,
      enterClass: String,
      leaveClass: String,
      enterToClass: String,
      leaveToClass: String,
      enterActiveClass: String,
      leaveActiveClass: String,
      appearClass: String,
      appearActiveClass: String,
      appearToClass: String,
      duration: [Number, String, Object]
    };

    // in case the child is also an abstract component, e.g. <keep-alive>
    // we want to recursively retrieve the real component to be rendered
    function getRealChild (vnode) {
      var compOptions = vnode && vnode.componentOptions;
      if (compOptions && compOptions.Ctor.options.abstract) {
        return getRealChild(getFirstComponentChild(compOptions.children))
      } else {
        return vnode
      }
    }

    function extractTransitionData (comp) {
      var data = {};
      var options = comp.$options;
      // props
      for (var key in options.propsData) {
        data[key] = comp[key];
      }
      // events.
      // extract listeners and pass them directly to the transition methods
      var listeners = options._parentListeners;
      for (var key$1 in listeners) {
        data[camelize(key$1)] = listeners[key$1];
      }
      return data
    }

    function placeholder (h, rawChild) {
      if (/\d-keep-alive$/.test(rawChild.tag)) {
        return h('keep-alive', {
          props: rawChild.componentOptions.propsData
        })
      }
    }

    function hasParentTransition (vnode) {
      while ((vnode = vnode.parent)) {
        if (vnode.data.transition) {
          return true
        }
      }
    }

    function isSameChild (child, oldChild) {
      return oldChild.key === child.key && oldChild.tag === child.tag
    }

    var isNotTextNode = function (c) { return c.tag || isAsyncPlaceholder(c); };

    var isVShowDirective = function (d) { return d.name === 'show'; };

    var Transition = {
      name: 'transition',
      props: transitionProps,
      abstract: true,

      render: function render (h) {
        var this$1 = this;

        var children = this.$slots.default;
        if (!children) {
          return
        }

        // filter out text nodes (possible whitespaces)
        children = children.filter(isNotTextNode);
        /* istanbul ignore if */
        if (!children.length) {
          return
        }

        var mode = this.mode;

        var rawChild = children[0];

        // if this is a component root node and the component's
        // parent container node also has transition, skip.
        if (hasParentTransition(this.$vnode)) {
          return rawChild
        }

        // apply transition data to child
        // use getRealChild() to ignore abstract components e.g. keep-alive
        var child = getRealChild(rawChild);
        /* istanbul ignore if */
        if (!child) {
          return rawChild
        }

        if (this._leaving) {
          return placeholder(h, rawChild)
        }

        // ensure a key that is unique to the vnode type and to this transition
        // component instance. This key will be used to remove pending leaving nodes
        // during entering.
        var id = "__transition-" + (this._uid) + "-";
        child.key = child.key == null
          ? child.isComment
            ? id + 'comment'
            : id + child.tag
          : isPrimitive(child.key)
            ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)
            : child.key;

        var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
        var oldRawChild = this._vnode;
        var oldChild = getRealChild(oldRawChild);

        // mark v-show
        // so that the transition module can hand over the control to the directive
        if (child.data.directives && child.data.directives.some(isVShowDirective)) {
          child.data.show = true;
        }

        if (
          oldChild &&
          oldChild.data &&
          !isSameChild(child, oldChild) &&
          !isAsyncPlaceholder(oldChild) &&
          // #6687 component root is a comment node
          !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)
        ) {
          // replace old child transition data with fresh one
          // important for dynamic transitions!
          var oldData = oldChild.data.transition = extend({}, data);
          // handle transition mode
          if (mode === 'out-in') {
            // return placeholder node and queue update when leave finishes
            this._leaving = true;
            mergeVNodeHook(oldData, 'afterLeave', function () {
              this$1._leaving = false;
              this$1.$forceUpdate();
            });
            return placeholder(h, rawChild)
          } else if (mode === 'in-out') {
            if (isAsyncPlaceholder(child)) {
              return oldRawChild
            }
            var delayedLeave;
            var performLeave = function () { delayedLeave(); };
            mergeVNodeHook(data, 'afterEnter', performLeave);
            mergeVNodeHook(data, 'enterCancelled', performLeave);
            mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });
          }
        }

        return rawChild
      }
    };

    /*  */

    var props = extend({
      tag: String,
      moveClass: String
    }, transitionProps);

    delete props.mode;

    var TransitionGroup = {
      props: props,

      beforeMount: function beforeMount () {
        var this$1 = this;

        var update = this._update;
        this._update = function (vnode, hydrating) {
          var restoreActiveInstance = setActiveInstance(this$1);
          // force removing pass
          this$1.__patch__(
            this$1._vnode,
            this$1.kept,
            false, // hydrating
            true // removeOnly (!important, avoids unnecessary moves)
          );
          this$1._vnode = this$1.kept;
          restoreActiveInstance();
          update.call(this$1, vnode, hydrating);
        };
      },

      render: function render (h) {
        var tag = this.tag || this.$vnode.data.tag || 'span';
        var map = Object.create(null);
        var prevChildren = this.prevChildren = this.children;
        var rawChildren = this.$slots.default || [];
        var children = this.children = [];
        var transitionData = extractTransitionData(this);

        for (var i = 0; i < rawChildren.length; i++) {
          var c = rawChildren[i];
          if (c.tag) {
            if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
              children.push(c);
              map[c.key] = c
              ;(c.data || (c.data = {})).transition = transitionData;
            }
          }
        }

        if (prevChildren) {
          var kept = [];
          var removed = [];
          for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
            var c$1 = prevChildren[i$1];
            c$1.data.transition = transitionData;
            c$1.data.pos = c$1.elm.getBoundingClientRect();
            if (map[c$1.key]) {
              kept.push(c$1);
            } else {
              removed.push(c$1);
            }
          }
          this.kept = h(tag, null, kept);
          this.removed = removed;
        }

        return h(tag, null, children)
      },

      updated: function updated () {
        var children = this.prevChildren;
        var moveClass = this.moveClass || ((this.name || 'v') + '-move');
        if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
          return
        }

        // we divide the work into three loops to avoid mixing DOM reads and writes
        // in each iteration - which helps prevent layout thrashing.
        children.forEach(callPendingCbs);
        children.forEach(recordPosition);
        children.forEach(applyTranslation);

        // force reflow to put everything in position
        // assign to this to avoid being removed in tree-shaking
        // $flow-disable-line
        this._reflow = document.body.offsetHeight;

        children.forEach(function (c) {
          if (c.data.moved) {
            var el = c.elm;
            var s = el.style;
            addTransitionClass(el, moveClass);
            s.transform = s.WebkitTransform = s.transitionDuration = '';
            el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {
              if (e && e.target !== el) {
                return
              }
              if (!e || /transform$/.test(e.propertyName)) {
                el.removeEventListener(transitionEndEvent, cb);
                el._moveCb = null;
                removeTransitionClass(el, moveClass);
              }
            });
          }
        });
      },

      methods: {
        hasMove: function hasMove (el, moveClass) {
          /* istanbul ignore if */
          if (!hasTransition) {
            return false
          }
          /* istanbul ignore if */
          if (this._hasMove) {
            return this._hasMove
          }
          // Detect whether an element with the move class applied has
          // CSS transitions. Since the element may be inside an entering
          // transition at this very moment, we make a clone of it and remove
          // all other transition classes applied to ensure only the move class
          // is applied.
          var clone = el.cloneNode();
          if (el._transitionClasses) {
            el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });
          }
          addClass(clone, moveClass);
          clone.style.display = 'none';
          this.$el.appendChild(clone);
          var info = getTransitionInfo(clone);
          this.$el.removeChild(clone);
          return (this._hasMove = info.hasTransform)
        }
      }
    };

    function callPendingCbs (c) {
      /* istanbul ignore if */
      if (c.elm._moveCb) {
        c.elm._moveCb();
      }
      /* istanbul ignore if */
      if (c.elm._enterCb) {
        c.elm._enterCb();
      }
    }

    function recordPosition (c) {
      c.data.newPos = c.elm.getBoundingClientRect();
    }

    function applyTranslation (c) {
      var oldPos = c.data.pos;
      var newPos = c.data.newPos;
      var dx = oldPos.left - newPos.left;
      var dy = oldPos.top - newPos.top;
      if (dx || dy) {
        c.data.moved = true;
        var s = c.elm.style;
        s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
        s.transitionDuration = '0s';
      }
    }

    var platformComponents = {
      Transition: Transition,
      TransitionGroup: TransitionGroup
    };

    /*  */

    // install platform specific utils
    Vue$1.config.mustUseProp = mustUseProp;
    Vue$1.config.isReservedTag = isReservedTag;
    Vue$1.config.isReservedAttr = isReservedAttr;
    Vue$1.config.getTagNamespace = getTagNamespace;
    Vue$1.config.isUnknownElement = isUnknownElement;

    // install platform runtime directives & components
    extend(Vue$1.options.directives, platformDirectives);
    extend(Vue$1.options.components, platformComponents);

    // install platform patch function
    Vue$1.prototype.__patch__ = inBrowser ? patch : noop$1;

    // public mount method
    Vue$1.prototype.$mount = function (
      el,
      hydrating
    ) {
      el = el && inBrowser ? query(el) : undefined;
      return mountComponent(this, el, hydrating)
    };

    // devtools global hook
    /* istanbul ignore next */
    if (inBrowser) {
      setTimeout(function () {
        if (config$1.devtools) {
          if (devtools) {
            devtools.emit('init', Vue$1);
          }
        }
      }, 0);
    }

    /*  */

    var defaultTagRE = /\{\{((?:.|\r?\n)+?)\}\}/g;
    var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;

    var buildRegex = cached(function (delimiters) {
      var open = delimiters[0].replace(regexEscapeRE, '\\$&');
      var close = delimiters[1].replace(regexEscapeRE, '\\$&');
      return new RegExp(open + '((?:.|\\n)+?)' + close, 'g')
    });



    function parseText (
      text,
      delimiters
    ) {
      var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
      if (!tagRE.test(text)) {
        return
      }
      var tokens = [];
      var rawTokens = [];
      var lastIndex = tagRE.lastIndex = 0;
      var match, index, tokenValue;
      while ((match = tagRE.exec(text))) {
        index = match.index;
        // push text token
        if (index > lastIndex) {
          rawTokens.push(tokenValue = text.slice(lastIndex, index));
          tokens.push(JSON.stringify(tokenValue));
        }
        // tag token
        var exp = parseFilters(match[1].trim());
        tokens.push(("_s(" + exp + ")"));
        rawTokens.push({ '@binding': exp });
        lastIndex = index + match[0].length;
      }
      if (lastIndex < text.length) {
        rawTokens.push(tokenValue = text.slice(lastIndex));
        tokens.push(JSON.stringify(tokenValue));
      }
      return {
        expression: tokens.join('+'),
        tokens: rawTokens
      }
    }

    /*  */

    function transformNode (el, options) {
      var warn = options.warn || baseWarn;
      var staticClass = getAndRemoveAttr(el, 'class');
      if (staticClass) {
        el.staticClass = JSON.stringify(staticClass);
      }
      var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
      if (classBinding) {
        el.classBinding = classBinding;
      }
    }

    function genData (el) {
      var data = '';
      if (el.staticClass) {
        data += "staticClass:" + (el.staticClass) + ",";
      }
      if (el.classBinding) {
        data += "class:" + (el.classBinding) + ",";
      }
      return data
    }

    var klass$1 = {
      staticKeys: ['staticClass'],
      transformNode: transformNode,
      genData: genData
    };

    /*  */

    function transformNode$1 (el, options) {
      var warn = options.warn || baseWarn;
      var staticStyle = getAndRemoveAttr(el, 'style');
      if (staticStyle) {
        el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
      }

      var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
      if (styleBinding) {
        el.styleBinding = styleBinding;
      }
    }

    function genData$1 (el) {
      var data = '';
      if (el.staticStyle) {
        data += "staticStyle:" + (el.staticStyle) + ",";
      }
      if (el.styleBinding) {
        data += "style:(" + (el.styleBinding) + "),";
      }
      return data
    }

    var style$1 = {
      staticKeys: ['staticStyle'],
      transformNode: transformNode$1,
      genData: genData$1
    };

    /*  */

    var decoder;

    var he$1 = {
      decode: function decode (html) {
        decoder = decoder || document.createElement('div');
        decoder.innerHTML = html;
        return decoder.textContent
      }
    };

    /*  */

    var isUnaryTag = makeMap(
      'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +
      'link,meta,param,source,track,wbr'
    );

    // Elements that you can, intentionally, leave open
    // (and which close themselves)
    var canBeLeftOpenTag = makeMap(
      'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'
    );

    // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
    // Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
    var isNonPhrasingTag = makeMap(
      'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +
      'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +
      'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +
      'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +
      'title,tr,track'
    );

    /**
     * Not type-checking this file because it's mostly vendor code.
     */

    // Regular Expressions for parsing tags and attributes
    var attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
    var dynamicArgAttribute = /^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+?\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
    var ncname = "[a-zA-Z_][\\-\\.0-9_a-zA-Z" + (unicodeRegExp.source) + "]*";
    var qnameCapture = "((?:" + ncname + "\\:)?" + ncname + ")";
    var startTagOpen = new RegExp(("^<" + qnameCapture));
    var startTagClose = /^\s*(\/?)>/;
    var endTag = new RegExp(("^<\\/" + qnameCapture + "[^>]*>"));
    var doctype = /^<!DOCTYPE [^>]+>/i;
    // #7298: escape - to avoid being passed as HTML comment when inlined in page
    var comment = /^<!\--/;
    var conditionalComment = /^<!\[/;

    // Special Elements (can contain anything)
    var isPlainTextElement = makeMap('script,style,textarea', true);
    var reCache = {};

    var decodingMap = {
      '&lt;': '<',
      '&gt;': '>',
      '&quot;': '"',
      '&amp;': '&',
      '&#10;': '\n',
      '&#9;': '\t',
      '&#39;': "'"
    };
    var encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;
    var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g;

    // #5992
    var isIgnoreNewlineTag = makeMap('pre,textarea', true);
    var shouldIgnoreFirstNewline = function (tag, html) { return tag && isIgnoreNewlineTag(tag) && html[0] === '\n'; };

    function decodeAttr (value, shouldDecodeNewlines) {
      var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
      return value.replace(re, function (match) { return decodingMap[match]; })
    }

    function parseHTML (html, options) {
      var stack = [];
      var expectHTML = options.expectHTML;
      var isUnaryTag$$1 = options.isUnaryTag || no;
      var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
      var index = 0;
      var last, lastTag;
      while (html) {
        last = html;
        // Make sure we're not in a plaintext content element like script/style
        if (!lastTag || !isPlainTextElement(lastTag)) {
          var textEnd = html.indexOf('<');
          if (textEnd === 0) {
            // Comment:
            if (comment.test(html)) {
              var commentEnd = html.indexOf('-->');

              if (commentEnd >= 0) {
                if (options.shouldKeepComment) {
                  options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);
                }
                advance(commentEnd + 3);
                continue
              }
            }

            // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
            if (conditionalComment.test(html)) {
              var conditionalEnd = html.indexOf(']>');

              if (conditionalEnd >= 0) {
                advance(conditionalEnd + 2);
                continue
              }
            }

            // Doctype:
            var doctypeMatch = html.match(doctype);
            if (doctypeMatch) {
              advance(doctypeMatch[0].length);
              continue
            }

            // End tag:
            var endTagMatch = html.match(endTag);
            if (endTagMatch) {
              var curIndex = index;
              advance(endTagMatch[0].length);
              parseEndTag(endTagMatch[1], curIndex, index);
              continue
            }

            // Start tag:
            var startTagMatch = parseStartTag();
            if (startTagMatch) {
              handleStartTag(startTagMatch);
              if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {
                advance(1);
              }
              continue
            }
          }

          var text = (void 0), rest = (void 0), next = (void 0);
          if (textEnd >= 0) {
            rest = html.slice(textEnd);
            while (
              !endTag.test(rest) &&
              !startTagOpen.test(rest) &&
              !comment.test(rest) &&
              !conditionalComment.test(rest)
            ) {
              // < in plain text, be forgiving and treat it as text
              next = rest.indexOf('<', 1);
              if (next < 0) { break }
              textEnd += next;
              rest = html.slice(textEnd);
            }
            text = html.substring(0, textEnd);
          }

          if (textEnd < 0) {
            text = html;
          }

          if (text) {
            advance(text.length);
          }

          if (options.chars && text) {
            options.chars(text, index - text.length, index);
          }
        } else {
          var endTagLength = 0;
          var stackedTag = lastTag.toLowerCase();
          var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
          var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
            endTagLength = endTag.length;
            if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
              text = text
                .replace(/<!\--([\s\S]*?)-->/g, '$1') // #7298
                .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
            }
            if (shouldIgnoreFirstNewline(stackedTag, text)) {
              text = text.slice(1);
            }
            if (options.chars) {
              options.chars(text);
            }
            return ''
          });
          index += html.length - rest$1.length;
          html = rest$1;
          parseEndTag(stackedTag, index - endTagLength, index);
        }

        if (html === last) {
          options.chars && options.chars(html);
          break
        }
      }

      // Clean up any remaining tags
      parseEndTag();

      function advance (n) {
        index += n;
        html = html.substring(n);
      }

      function parseStartTag () {
        var start = html.match(startTagOpen);
        if (start) {
          var match = {
            tagName: start[1],
            attrs: [],
            start: index
          };
          advance(start[0].length);
          var end, attr;
          while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {
            attr.start = index;
            advance(attr[0].length);
            attr.end = index;
            match.attrs.push(attr);
          }
          if (end) {
            match.unarySlash = end[1];
            advance(end[0].length);
            match.end = index;
            return match
          }
        }
      }

      function handleStartTag (match) {
        var tagName = match.tagName;
        var unarySlash = match.unarySlash;

        if (expectHTML) {
          if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
            parseEndTag(lastTag);
          }
          if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
            parseEndTag(tagName);
          }
        }

        var unary = isUnaryTag$$1(tagName) || !!unarySlash;

        var l = match.attrs.length;
        var attrs = new Array(l);
        for (var i = 0; i < l; i++) {
          var args = match.attrs[i];
          var value = args[3] || args[4] || args[5] || '';
          var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'
            ? options.shouldDecodeNewlinesForHref
            : options.shouldDecodeNewlines;
          attrs[i] = {
            name: args[1],
            value: decodeAttr(value, shouldDecodeNewlines)
          };
        }

        if (!unary) {
          stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs, start: match.start, end: match.end });
          lastTag = tagName;
        }

        if (options.start) {
          options.start(tagName, attrs, unary, match.start, match.end);
        }
      }

      function parseEndTag (tagName, start, end) {
        var pos, lowerCasedTagName;
        if (start == null) { start = index; }
        if (end == null) { end = index; }

        // Find the closest opened tag of the same type
        if (tagName) {
          lowerCasedTagName = tagName.toLowerCase();
          for (pos = stack.length - 1; pos >= 0; pos--) {
            if (stack[pos].lowerCasedTag === lowerCasedTagName) {
              break
            }
          }
        } else {
          // If no tag name is provided, clean shop
          pos = 0;
        }

        if (pos >= 0) {
          // Close all the open elements, up the stack
          for (var i = stack.length - 1; i >= pos; i--) {
            if (options.end) {
              options.end(stack[i].tag, start, end);
            }
          }

          // Remove the open elements from the stack
          stack.length = pos;
          lastTag = pos && stack[pos - 1].tag;
        } else if (lowerCasedTagName === 'br') {
          if (options.start) {
            options.start(tagName, [], true, start, end);
          }
        } else if (lowerCasedTagName === 'p') {
          if (options.start) {
            options.start(tagName, [], false, start, end);
          }
          if (options.end) {
            options.end(tagName, start, end);
          }
        }
      }
    }

    /*  */

    var onRE = /^@|^v-on:/;
    var dirRE = /^v-|^@|^:|^#/;
    var forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
    var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
    var stripParensRE = /^\(|\)$/g;
    var dynamicArgRE = /^\[.*\]$/;

    var argRE = /:(.*)$/;
    var bindRE = /^:|^\.|^v-bind:/;
    var modifierRE = /\.[^.\]]+(?=[^\]]*$)/g;

    var slotRE = /^v-slot(:|$)|^#/;

    var lineBreakRE = /[\r\n]/;
    var whitespaceRE$1 = /[ \f\t\r\n]+/g;

    var decodeHTMLCached = cached(he$1.decode);

    var emptySlotScopeToken = "_empty_";

    // configurable state
    var warn$2;
    var delimiters;
    var transforms;
    var preTransforms;
    var postTransforms;
    var platformIsPreTag;
    var platformMustUseProp;
    var platformGetTagNamespace;

    function createASTElement (
      tag,
      attrs,
      parent
    ) {
      return {
        type: 1,
        tag: tag,
        attrsList: attrs,
        attrsMap: makeAttrsMap(attrs),
        rawAttrsMap: {},
        parent: parent,
        children: []
      }
    }

    /**
     * Convert HTML string to AST.
     */
    function parse (
      template,
      options
    ) {
      warn$2 = options.warn || baseWarn;

      platformIsPreTag = options.isPreTag || no;
      platformMustUseProp = options.mustUseProp || no;
      platformGetTagNamespace = options.getTagNamespace || no;
      var isReservedTag = options.isReservedTag || no;
      transforms = pluckModuleFunction(options.modules, 'transformNode');
      preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
      postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');

      delimiters = options.delimiters;

      var stack = [];
      var preserveWhitespace = options.preserveWhitespace !== false;
      var whitespaceOption = options.whitespace;
      var root;
      var currentParent;
      var inVPre = false;
      var inPre = false;

      function closeElement (element) {
        trimEndingWhitespace(element);
        if (!inVPre && !element.processed) {
          element = processElement(element, options);
        }
        // tree management
        if (!stack.length && element !== root) {
          // allow root elements with v-if, v-else-if and v-else
          if (root.if && (element.elseif || element.else)) {
            addIfCondition(root, {
              exp: element.elseif,
              block: element
            });
          }
        }
        if (currentParent && !element.forbidden) {
          if (element.elseif || element.else) {
            processIfConditions(element, currentParent);
          } else {
            if (element.slotScope) {
              // scoped slot
              // keep it in the children list so that v-else(-if) conditions can
              // find it as the prev node.
              var name = element.slotTarget || '"default"'
              ;(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
            }
            currentParent.children.push(element);
            element.parent = currentParent;
          }
        }

        // final children cleanup
        // filter out scoped slots
        element.children = element.children.filter(function (c) { return !(c).slotScope; });
        // remove trailing whitespace node again
        trimEndingWhitespace(element);

        // check pre state
        if (element.pre) {
          inVPre = false;
        }
        if (platformIsPreTag(element.tag)) {
          inPre = false;
        }
        // apply post-transforms
        for (var i = 0; i < postTransforms.length; i++) {
          postTransforms[i](element, options);
        }
      }

      function trimEndingWhitespace (el) {
        // remove trailing whitespace node
        if (!inPre) {
          var lastNode;
          while (
            (lastNode = el.children[el.children.length - 1]) &&
            lastNode.type === 3 &&
            lastNode.text === ' '
          ) {
            el.children.pop();
          }
        }
      }

      parseHTML(template, {
        warn: warn$2,
        expectHTML: options.expectHTML,
        isUnaryTag: options.isUnaryTag,
        canBeLeftOpenTag: options.canBeLeftOpenTag,
        shouldDecodeNewlines: options.shouldDecodeNewlines,
        shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
        shouldKeepComment: options.comments,
        outputSourceRange: options.outputSourceRange,
        start: function start (tag, attrs, unary, start$1, end) {
          // check namespace.
          // inherit parent ns if there is one
          var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);

          // handle IE svg bug
          /* istanbul ignore if */
          if (isIE && ns === 'svg') {
            attrs = guardIESVGBug(attrs);
          }

          var element = createASTElement(tag, attrs, currentParent);
          if (ns) {
            element.ns = ns;
          }

          if (isForbiddenTag(element) && !isServerRendering()) {
            element.forbidden = true;
          }

          // apply pre-transforms
          for (var i = 0; i < preTransforms.length; i++) {
            element = preTransforms[i](element, options) || element;
          }

          if (!inVPre) {
            processPre(element);
            if (element.pre) {
              inVPre = true;
            }
          }
          if (platformIsPreTag(element.tag)) {
            inPre = true;
          }
          if (inVPre) {
            processRawAttrs(element);
          } else if (!element.processed) {
            // structural directives
            processFor(element);
            processIf(element);
            processOnce(element);
          }

          if (!root) {
            root = element;
          }

          if (!unary) {
            currentParent = element;
            stack.push(element);
          } else {
            closeElement(element);
          }
        },

        end: function end (tag, start, end$1) {
          var element = stack[stack.length - 1];
          // pop stack
          stack.length -= 1;
          currentParent = stack[stack.length - 1];
          closeElement(element);
        },

        chars: function chars (text, start, end) {
          if (!currentParent) {
            return
          }
          // IE textarea placeholder bug
          /* istanbul ignore if */
          if (isIE &&
            currentParent.tag === 'textarea' &&
            currentParent.attrsMap.placeholder === text
          ) {
            return
          }
          var children = currentParent.children;
          if (inPre || text.trim()) {
            text = isTextTag(currentParent) ? text : decodeHTMLCached(text);
          } else if (!children.length) {
            // remove the whitespace-only node right after an opening tag
            text = '';
          } else if (whitespaceOption) {
            if (whitespaceOption === 'condense') {
              // in condense mode, remove the whitespace node if it contains
              // line break, otherwise condense to a single space
              text = lineBreakRE.test(text) ? '' : ' ';
            } else {
              text = ' ';
            }
          } else {
            text = preserveWhitespace ? ' ' : '';
          }
          if (text) {
            if (!inPre && whitespaceOption === 'condense') {
              // condense consecutive whitespaces into single space
              text = text.replace(whitespaceRE$1, ' ');
            }
            var res;
            var child;
            if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {
              child = {
                type: 2,
                expression: res.expression,
                tokens: res.tokens,
                text: text
              };
            } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
              child = {
                type: 3,
                text: text
              };
            }
            if (child) {
              children.push(child);
            }
          }
        },
        comment: function comment (text, start, end) {
          // adding anything as a sibling to the root node is forbidden
          // comments should still be allowed, but ignored
          if (currentParent) {
            var child = {
              type: 3,
              text: text,
              isComment: true
            };
            currentParent.children.push(child);
          }
        }
      });
      return root
    }

    function processPre (el) {
      if (getAndRemoveAttr(el, 'v-pre') != null) {
        el.pre = true;
      }
    }

    function processRawAttrs (el) {
      var list = el.attrsList;
      var len = list.length;
      if (len) {
        var attrs = el.attrs = new Array(len);
        for (var i = 0; i < len; i++) {
          attrs[i] = {
            name: list[i].name,
            value: JSON.stringify(list[i].value)
          };
          if (list[i].start != null) {
            attrs[i].start = list[i].start;
            attrs[i].end = list[i].end;
          }
        }
      } else if (!el.pre) {
        // non root node in pre blocks with no attributes
        el.plain = true;
      }
    }

    function processElement (
      element,
      options
    ) {
      processKey(element);

      // determine whether this is a plain element after
      // removing structural attributes
      element.plain = (
        !element.key &&
        !element.scopedSlots &&
        !element.attrsList.length
      );

      processRef(element);
      processSlotContent(element);
      processSlotOutlet(element);
      processComponent(element);
      for (var i = 0; i < transforms.length; i++) {
        element = transforms[i](element, options) || element;
      }
      processAttrs(element);
      return element
    }

    function processKey (el) {
      var exp = getBindingAttr(el, 'key');
      if (exp) {
        el.key = exp;
      }
    }

    function processRef (el) {
      var ref = getBindingAttr(el, 'ref');
      if (ref) {
        el.ref = ref;
        el.refInFor = checkInFor(el);
      }
    }

    function processFor (el) {
      var exp;
      if ((exp = getAndRemoveAttr(el, 'v-for'))) {
        var res = parseFor(exp);
        if (res) {
          extend(el, res);
        }
      }
    }



    function parseFor (exp) {
      var inMatch = exp.match(forAliasRE);
      if (!inMatch) { return }
      var res = {};
      res.for = inMatch[2].trim();
      var alias = inMatch[1].trim().replace(stripParensRE, '');
      var iteratorMatch = alias.match(forIteratorRE);
      if (iteratorMatch) {
        res.alias = alias.replace(forIteratorRE, '').trim();
        res.iterator1 = iteratorMatch[1].trim();
        if (iteratorMatch[2]) {
          res.iterator2 = iteratorMatch[2].trim();
        }
      } else {
        res.alias = alias;
      }
      return res
    }

    function processIf (el) {
      var exp = getAndRemoveAttr(el, 'v-if');
      if (exp) {
        el.if = exp;
        addIfCondition(el, {
          exp: exp,
          block: el
        });
      } else {
        if (getAndRemoveAttr(el, 'v-else') != null) {
          el.else = true;
        }
        var elseif = getAndRemoveAttr(el, 'v-else-if');
        if (elseif) {
          el.elseif = elseif;
        }
      }
    }

    function processIfConditions (el, parent) {
      var prev = findPrevElement(parent.children);
      if (prev && prev.if) {
        addIfCondition(prev, {
          exp: el.elseif,
          block: el
        });
      }
    }

    function findPrevElement (children) {
      var i = children.length;
      while (i--) {
        if (children[i].type === 1) {
          return children[i]
        } else {
          children.pop();
        }
      }
    }

    function addIfCondition (el, condition) {
      if (!el.ifConditions) {
        el.ifConditions = [];
      }
      el.ifConditions.push(condition);
    }

    function processOnce (el) {
      var once$$1 = getAndRemoveAttr(el, 'v-once');
      if (once$$1 != null) {
        el.once = true;
      }
    }

    // handle content being passed to a component as slot,
    // e.g. <template slot="xxx">, <div slot-scope="xxx">
    function processSlotContent (el) {
      var slotScope;
      if (el.tag === 'template') {
        slotScope = getAndRemoveAttr(el, 'scope');
        el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');
      } else if ((slotScope = getAndRemoveAttr(el, 'slot-scope'))) {
        el.slotScope = slotScope;
      }

      // slot="xxx"
      var slotTarget = getBindingAttr(el, 'slot');
      if (slotTarget) {
        el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
        el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']);
        // preserve slot as an attribute for native shadow DOM compat
        // only for non-scoped slots.
        if (el.tag !== 'template' && !el.slotScope) {
          addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));
        }
      }

      // 2.6 v-slot syntax
      {
        if (el.tag === 'template') {
          // v-slot on <template>
          var slotBinding = getAndRemoveAttrByRegex(el, slotRE);
          if (slotBinding) {
            var ref = getSlotName(slotBinding);
            var name = ref.name;
            var dynamic = ref.dynamic;
            el.slotTarget = name;
            el.slotTargetDynamic = dynamic;
            el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf
          }
        } else {
          // v-slot on component, denotes default slot
          var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);
          if (slotBinding$1) {
            // add the component's children to its default slot
            var slots = el.scopedSlots || (el.scopedSlots = {});
            var ref$1 = getSlotName(slotBinding$1);
            var name$1 = ref$1.name;
            var dynamic$1 = ref$1.dynamic;
            var slotContainer = slots[name$1] = createASTElement('template', [], el);
            slotContainer.slotTarget = name$1;
            slotContainer.slotTargetDynamic = dynamic$1;
            slotContainer.children = el.children.filter(function (c) {
              if (!c.slotScope) {
                c.parent = slotContainer;
                return true
              }
            });
            slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken;
            // remove children as they are returned from scopedSlots now
            el.children = [];
            // mark el non-plain so data gets generated
            el.plain = false;
          }
        }
      }
    }

    function getSlotName (binding) {
      var name = binding.name.replace(slotRE, '');
      if (!name) {
        if (binding.name[0] !== '#') {
          name = 'default';
        }
      }
      return dynamicArgRE.test(name)
        // dynamic [name]
        ? { name: name.slice(1, -1), dynamic: true }
        // static name
        : { name: ("\"" + name + "\""), dynamic: false }
    }

    // handle <slot/> outlets
    function processSlotOutlet (el) {
      if (el.tag === 'slot') {
        el.slotName = getBindingAttr(el, 'name');
      }
    }

    function processComponent (el) {
      var binding;
      if ((binding = getBindingAttr(el, 'is'))) {
        el.component = binding;
      }
      if (getAndRemoveAttr(el, 'inline-template') != null) {
        el.inlineTemplate = true;
      }
    }

    function processAttrs (el) {
      var list = el.attrsList;
      var i, l, name, rawName, value, modifiers, syncGen, isDynamic;
      for (i = 0, l = list.length; i < l; i++) {
        name = rawName = list[i].name;
        value = list[i].value;
        if (dirRE.test(name)) {
          // mark element as dynamic
          el.hasBindings = true;
          // modifiers
          modifiers = parseModifiers(name.replace(dirRE, ''));
          // support .foo shorthand syntax for the .prop modifier
          if (modifiers) {
            name = name.replace(modifierRE, '');
          }
          if (bindRE.test(name)) { // v-bind
            name = name.replace(bindRE, '');
            value = parseFilters(value);
            isDynamic = dynamicArgRE.test(name);
            if (isDynamic) {
              name = name.slice(1, -1);
            }
            if (modifiers) {
              if (modifiers.prop && !isDynamic) {
                name = camelize(name);
                if (name === 'innerHtml') { name = 'innerHTML'; }
              }
              if (modifiers.camel && !isDynamic) {
                name = camelize(name);
              }
              if (modifiers.sync) {
                syncGen = genAssignmentCode(value, "$event");
                if (!isDynamic) {
                  addHandler(
                    el,
                    ("update:" + (camelize(name))),
                    syncGen,
                    null,
                    false,
                    warn$2,
                    list[i]
                  );
                  if (hyphenate(name) !== camelize(name)) {
                    addHandler(
                      el,
                      ("update:" + (hyphenate(name))),
                      syncGen,
                      null,
                      false,
                      warn$2,
                      list[i]
                    );
                  }
                } else {
                  // handler w/ dynamic event name
                  addHandler(
                    el,
                    ("\"update:\"+(" + name + ")"),
                    syncGen,
                    null,
                    false,
                    warn$2,
                    list[i],
                    true // dynamic
                  );
                }
              }
            }
            if ((modifiers && modifiers.prop) || (
              !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)
            )) {
              addProp(el, name, value, list[i], isDynamic);
            } else {
              addAttr(el, name, value, list[i], isDynamic);
            }
          } else if (onRE.test(name)) { // v-on
            name = name.replace(onRE, '');
            isDynamic = dynamicArgRE.test(name);
            if (isDynamic) {
              name = name.slice(1, -1);
            }
            addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);
          } else { // normal directives
            name = name.replace(dirRE, '');
            // parse arg
            var argMatch = name.match(argRE);
            var arg = argMatch && argMatch[1];
            isDynamic = false;
            if (arg) {
              name = name.slice(0, -(arg.length + 1));
              if (dynamicArgRE.test(arg)) {
                arg = arg.slice(1, -1);
                isDynamic = true;
              }
            }
            addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);
          }
        } else {
          addAttr(el, name, JSON.stringify(value), list[i]);
          // #6887 firefox doesn't update muted state if set via attribute
          // even immediately after element creation
          if (!el.component &&
              name === 'muted' &&
              platformMustUseProp(el.tag, el.attrsMap.type, name)) {
            addProp(el, name, 'true', list[i]);
          }
        }
      }
    }

    function checkInFor (el) {
      var parent = el;
      while (parent) {
        if (parent.for !== undefined) {
          return true
        }
        parent = parent.parent;
      }
      return false
    }

    function parseModifiers (name) {
      var match = name.match(modifierRE);
      if (match) {
        var ret = {};
        match.forEach(function (m) { ret[m.slice(1)] = true; });
        return ret
      }
    }

    function makeAttrsMap (attrs) {
      var map = {};
      for (var i = 0, l = attrs.length; i < l; i++) {
        map[attrs[i].name] = attrs[i].value;
      }
      return map
    }

    // for script (e.g. type="x/template") or style, do not decode content
    function isTextTag (el) {
      return el.tag === 'script' || el.tag === 'style'
    }

    function isForbiddenTag (el) {
      return (
        el.tag === 'style' ||
        (el.tag === 'script' && (
          !el.attrsMap.type ||
          el.attrsMap.type === 'text/javascript'
        ))
      )
    }

    var ieNSBug = /^xmlns:NS\d+/;
    var ieNSPrefix = /^NS\d+:/;

    /* istanbul ignore next */
    function guardIESVGBug (attrs) {
      var res = [];
      for (var i = 0; i < attrs.length; i++) {
        var attr = attrs[i];
        if (!ieNSBug.test(attr.name)) {
          attr.name = attr.name.replace(ieNSPrefix, '');
          res.push(attr);
        }
      }
      return res
    }

    /*  */

    function preTransformNode (el, options) {
      if (el.tag === 'input') {
        var map = el.attrsMap;
        if (!map['v-model']) {
          return
        }

        var typeBinding;
        if (map[':type'] || map['v-bind:type']) {
          typeBinding = getBindingAttr(el, 'type');
        }
        if (!map.type && !typeBinding && map['v-bind']) {
          typeBinding = "(" + (map['v-bind']) + ").type";
        }

        if (typeBinding) {
          var ifCondition = getAndRemoveAttr(el, 'v-if', true);
          var ifConditionExtra = ifCondition ? ("&&(" + ifCondition + ")") : "";
          var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;
          var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);
          // 1. checkbox
          var branch0 = cloneASTElement(el);
          // process for on the main node
          processFor(branch0);
          addRawAttr(branch0, 'type', 'checkbox');
          processElement(branch0, options);
          branch0.processed = true; // prevent it from double-processed
          branch0.if = "(" + typeBinding + ")==='checkbox'" + ifConditionExtra;
          addIfCondition(branch0, {
            exp: branch0.if,
            block: branch0
          });
          // 2. add radio else-if condition
          var branch1 = cloneASTElement(el);
          getAndRemoveAttr(branch1, 'v-for', true);
          addRawAttr(branch1, 'type', 'radio');
          processElement(branch1, options);
          addIfCondition(branch0, {
            exp: "(" + typeBinding + ")==='radio'" + ifConditionExtra,
            block: branch1
          });
          // 3. other
          var branch2 = cloneASTElement(el);
          getAndRemoveAttr(branch2, 'v-for', true);
          addRawAttr(branch2, ':type', typeBinding);
          processElement(branch2, options);
          addIfCondition(branch0, {
            exp: ifCondition,
            block: branch2
          });

          if (hasElse) {
            branch0.else = true;
          } else if (elseIfCondition) {
            branch0.elseif = elseIfCondition;
          }

          return branch0
        }
      }
    }

    function cloneASTElement (el) {
      return createASTElement(el.tag, el.attrsList.slice(), el.parent)
    }

    var model$1 = {
      preTransformNode: preTransformNode
    };

    var modules$1 = [
      klass$1,
      style$1,
      model$1
    ];

    /*  */

    function text (el, dir) {
      if (dir.value) {
        addProp(el, 'textContent', ("_s(" + (dir.value) + ")"), dir);
      }
    }

    /*  */

    function html (el, dir) {
      if (dir.value) {
        addProp(el, 'innerHTML', ("_s(" + (dir.value) + ")"), dir);
      }
    }

    var directives$1 = {
      model: model,
      text: text,
      html: html
    };

    /*  */

    var baseOptions = {
      expectHTML: true,
      modules: modules$1,
      directives: directives$1,
      isPreTag: isPreTag,
      isUnaryTag: isUnaryTag,
      mustUseProp: mustUseProp,
      canBeLeftOpenTag: canBeLeftOpenTag,
      isReservedTag: isReservedTag,
      getTagNamespace: getTagNamespace,
      staticKeys: genStaticKeys(modules$1)
    };

    /*  */

    var isStaticKey;
    var isPlatformReservedTag;

    var genStaticKeysCached = cached(genStaticKeys$1);

    /**
     * Goal of the optimizer: walk the generated template AST tree
     * and detect sub-trees that are purely static, i.e. parts of
     * the DOM that never needs to change.
     *
     * Once we detect these sub-trees, we can:
     *
     * 1. Hoist them into constants, so that we no longer need to
     *    create fresh nodes for them on each re-render;
     * 2. Completely skip them in the patching process.
     */
    function optimize (root, options) {
      if (!root) { return }
      isStaticKey = genStaticKeysCached(options.staticKeys || '');
      isPlatformReservedTag = options.isReservedTag || no;
      // first pass: mark all non-static nodes.
      markStatic$1(root);
      // second pass: mark static roots.
      markStaticRoots(root, false);
    }

    function genStaticKeys$1 (keys) {
      return makeMap(
        'type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' +
        (keys ? ',' + keys : '')
      )
    }

    function markStatic$1 (node) {
      node.static = isStatic(node);
      if (node.type === 1) {
        // do not make component slot content static. this avoids
        // 1. components not able to mutate slot nodes
        // 2. static slot content fails for hot-reloading
        if (
          !isPlatformReservedTag(node.tag) &&
          node.tag !== 'slot' &&
          node.attrsMap['inline-template'] == null
        ) {
          return
        }
        for (var i = 0, l = node.children.length; i < l; i++) {
          var child = node.children[i];
          markStatic$1(child);
          if (!child.static) {
            node.static = false;
          }
        }
        if (node.ifConditions) {
          for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
            var block = node.ifConditions[i$1].block;
            markStatic$1(block);
            if (!block.static) {
              node.static = false;
            }
          }
        }
      }
    }

    function markStaticRoots (node, isInFor) {
      if (node.type === 1) {
        if (node.static || node.once) {
          node.staticInFor = isInFor;
        }
        // For a node to qualify as a static root, it should have children that
        // are not just static text. Otherwise the cost of hoisting out will
        // outweigh the benefits and it's better off to just always render it fresh.
        if (node.static && node.children.length && !(
          node.children.length === 1 &&
          node.children[0].type === 3
        )) {
          node.staticRoot = true;
          return
        } else {
          node.staticRoot = false;
        }
        if (node.children) {
          for (var i = 0, l = node.children.length; i < l; i++) {
            markStaticRoots(node.children[i], isInFor || !!node.for);
          }
        }
        if (node.ifConditions) {
          for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
            markStaticRoots(node.ifConditions[i$1].block, isInFor);
          }
        }
      }
    }

    function isStatic (node) {
      if (node.type === 2) { // expression
        return false
      }
      if (node.type === 3) { // text
        return true
      }
      return !!(node.pre || (
        !node.hasBindings && // no dynamic bindings
        !node.if && !node.for && // not v-if or v-for or v-else
        !isBuiltInTag(node.tag) && // not a built-in
        isPlatformReservedTag(node.tag) && // not a component
        !isDirectChildOfTemplateFor(node) &&
        Object.keys(node).every(isStaticKey)
      ))
    }

    function isDirectChildOfTemplateFor (node) {
      while (node.parent) {
        node = node.parent;
        if (node.tag !== 'template') {
          return false
        }
        if (node.for) {
          return true
        }
      }
      return false
    }

    /*  */

    var fnExpRE = /^([\w$_]+|\([^)]*?\))\s*=>|^function(?:\s+[\w$]+)?\s*\(/;
    var fnInvokeRE = /\([^)]*?\);*$/;
    var simplePathRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/;

    // KeyboardEvent.keyCode aliases
    var keyCodes = {
      esc: 27,
      tab: 9,
      enter: 13,
      space: 32,
      up: 38,
      left: 37,
      right: 39,
      down: 40,
      'delete': [8, 46]
    };

    // KeyboardEvent.key aliases
    var keyNames = {
      // #7880: IE11 and Edge use `Esc` for Escape key name.
      esc: ['Esc', 'Escape'],
      tab: 'Tab',
      enter: 'Enter',
      // #9112: IE11 uses `Spacebar` for Space key name.
      space: [' ', 'Spacebar'],
      // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.
      up: ['Up', 'ArrowUp'],
      left: ['Left', 'ArrowLeft'],
      right: ['Right', 'ArrowRight'],
      down: ['Down', 'ArrowDown'],
      // #9112: IE11 uses `Del` for Delete key name.
      'delete': ['Backspace', 'Delete', 'Del']
    };

    // #4868: modifiers that prevent the execution of the listener
    // need to explicitly return null so that we can determine whether to remove
    // the listener for .once
    var genGuard = function (condition) { return ("if(" + condition + ")return null;"); };

    var modifierCode = {
      stop: '$event.stopPropagation();',
      prevent: '$event.preventDefault();',
      self: genGuard("$event.target !== $event.currentTarget"),
      ctrl: genGuard("!$event.ctrlKey"),
      shift: genGuard("!$event.shiftKey"),
      alt: genGuard("!$event.altKey"),
      meta: genGuard("!$event.metaKey"),
      left: genGuard("'button' in $event && $event.button !== 0"),
      middle: genGuard("'button' in $event && $event.button !== 1"),
      right: genGuard("'button' in $event && $event.button !== 2")
    };

    function genHandlers (
      events,
      isNative
    ) {
      var prefix = isNative ? 'nativeOn:' : 'on:';
      var staticHandlers = "";
      var dynamicHandlers = "";
      for (var name in events) {
        var handlerCode = genHandler(events[name]);
        if (events[name] && events[name].dynamic) {
          dynamicHandlers += name + "," + handlerCode + ",";
        } else {
          staticHandlers += "\"" + name + "\":" + handlerCode + ",";
        }
      }
      staticHandlers = "{" + (staticHandlers.slice(0, -1)) + "}";
      if (dynamicHandlers) {
        return prefix + "_d(" + staticHandlers + ",[" + (dynamicHandlers.slice(0, -1)) + "])"
      } else {
        return prefix + staticHandlers
      }
    }

    function genHandler (handler) {
      if (!handler) {
        return 'function(){}'
      }

      if (Array.isArray(handler)) {
        return ("[" + (handler.map(function (handler) { return genHandler(handler); }).join(',')) + "]")
      }

      var isMethodPath = simplePathRE.test(handler.value);
      var isFunctionExpression = fnExpRE.test(handler.value);
      var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));

      if (!handler.modifiers) {
        if (isMethodPath || isFunctionExpression) {
          return handler.value
        }
        return ("function($event){" + (isFunctionInvocation ? ("return " + (handler.value)) : handler.value) + "}") // inline statement
      } else {
        var code = '';
        var genModifierCode = '';
        var keys = [];
        for (var key in handler.modifiers) {
          if (modifierCode[key]) {
            genModifierCode += modifierCode[key];
            // left/right
            if (keyCodes[key]) {
              keys.push(key);
            }
          } else if (key === 'exact') {
            var modifiers = (handler.modifiers);
            genModifierCode += genGuard(
              ['ctrl', 'shift', 'alt', 'meta']
                .filter(function (keyModifier) { return !modifiers[keyModifier]; })
                .map(function (keyModifier) { return ("$event." + keyModifier + "Key"); })
                .join('||')
            );
          } else {
            keys.push(key);
          }
        }
        if (keys.length) {
          code += genKeyFilter(keys);
        }
        // Make sure modifiers like prevent and stop get executed after key filtering
        if (genModifierCode) {
          code += genModifierCode;
        }
        var handlerCode = isMethodPath
          ? ("return " + (handler.value) + ".apply(null, arguments)")
          : isFunctionExpression
            ? ("return (" + (handler.value) + ").apply(null, arguments)")
            : isFunctionInvocation
              ? ("return " + (handler.value))
              : handler.value;
        return ("function($event){" + code + handlerCode + "}")
      }
    }

    function genKeyFilter (keys) {
      return (
        // make sure the key filters only apply to KeyboardEvents
        // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake
        // key events that do not have keyCode property...
        "if(!$event.type.indexOf('key')&&" +
        (keys.map(genFilterCode).join('&&')) + ")return null;"
      )
    }

    function genFilterCode (key) {
      var keyVal = parseInt(key, 10);
      if (keyVal) {
        return ("$event.keyCode!==" + keyVal)
      }
      var keyCode = keyCodes[key];
      var keyName = keyNames[key];
      return (
        "_k($event.keyCode," +
        (JSON.stringify(key)) + "," +
        (JSON.stringify(keyCode)) + "," +
        "$event.key," +
        "" + (JSON.stringify(keyName)) +
        ")"
      )
    }

    /*  */

    function on (el, dir) {
      el.wrapListeners = function (code) { return ("_g(" + code + "," + (dir.value) + ")"); };
    }

    /*  */

    function bind$1 (el, dir) {
      el.wrapData = function (code) {
        return ("_b(" + code + ",'" + (el.tag) + "'," + (dir.value) + "," + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + ")")
      };
    }

    /*  */

    var baseDirectives = {
      on: on,
      bind: bind$1,
      cloak: noop$1
    };

    /*  */





    var CodegenState = function CodegenState (options) {
      this.options = options;
      this.warn = options.warn || baseWarn;
      this.transforms = pluckModuleFunction(options.modules, 'transformCode');
      this.dataGenFns = pluckModuleFunction(options.modules, 'genData');
      this.directives = extend(extend({}, baseDirectives), options.directives);
      var isReservedTag = options.isReservedTag || no;
      this.maybeComponent = function (el) { return !!el.component || !isReservedTag(el.tag); };
      this.onceId = 0;
      this.staticRenderFns = [];
      this.pre = false;
    };



    function generate (
      ast,
      options
    ) {
      var state = new CodegenState(options);
      // fix #11483, Root level <script> tags should not be rendered.
      var code = ast ? (ast.tag === 'script' ? 'null' : genElement(ast, state)) : '_c("div")';
      return {
        render: ("with(this){return " + code + "}"),
        staticRenderFns: state.staticRenderFns
      }
    }

    function genElement (el, state) {
      if (el.parent) {
        el.pre = el.pre || el.parent.pre;
      }

      if (el.staticRoot && !el.staticProcessed) {
        return genStatic(el, state)
      } else if (el.once && !el.onceProcessed) {
        return genOnce(el, state)
      } else if (el.for && !el.forProcessed) {
        return genFor(el, state)
      } else if (el.if && !el.ifProcessed) {
        return genIf(el, state)
      } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {
        return genChildren(el, state) || 'void 0'
      } else if (el.tag === 'slot') {
        return genSlot(el, state)
      } else {
        // component or element
        var code;
        if (el.component) {
          code = genComponent(el.component, el, state);
        } else {
          var data;
          if (!el.plain || (el.pre && state.maybeComponent(el))) {
            data = genData$2(el, state);
          }

          var children = el.inlineTemplate ? null : genChildren(el, state, true);
          code = "_c('" + (el.tag) + "'" + (data ? ("," + data) : '') + (children ? ("," + children) : '') + ")";
        }
        // module transforms
        for (var i = 0; i < state.transforms.length; i++) {
          code = state.transforms[i](el, code);
        }
        return code
      }
    }

    // hoist static sub-trees out
    function genStatic (el, state) {
      el.staticProcessed = true;
      // Some elements (templates) need to behave differently inside of a v-pre
      // node.  All pre nodes are static roots, so we can use this as a location to
      // wrap a state change and reset it upon exiting the pre node.
      var originalPreState = state.pre;
      if (el.pre) {
        state.pre = el.pre;
      }
      state.staticRenderFns.push(("with(this){return " + (genElement(el, state)) + "}"));
      state.pre = originalPreState;
      return ("_m(" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")")
    }

    // v-once
    function genOnce (el, state) {
      el.onceProcessed = true;
      if (el.if && !el.ifProcessed) {
        return genIf(el, state)
      } else if (el.staticInFor) {
        var key = '';
        var parent = el.parent;
        while (parent) {
          if (parent.for) {
            key = parent.key;
            break
          }
          parent = parent.parent;
        }
        if (!key) {
          return genElement(el, state)
        }
        return ("_o(" + (genElement(el, state)) + "," + (state.onceId++) + "," + key + ")")
      } else {
        return genStatic(el, state)
      }
    }

    function genIf (
      el,
      state,
      altGen,
      altEmpty
    ) {
      el.ifProcessed = true; // avoid recursion
      return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)
    }

    function genIfConditions (
      conditions,
      state,
      altGen,
      altEmpty
    ) {
      if (!conditions.length) {
        return altEmpty || '_e()'
      }

      var condition = conditions.shift();
      if (condition.exp) {
        return ("(" + (condition.exp) + ")?" + (genTernaryExp(condition.block)) + ":" + (genIfConditions(conditions, state, altGen, altEmpty)))
      } else {
        return ("" + (genTernaryExp(condition.block)))
      }

      // v-if with v-once should generate code like (a)?_m(0):_m(1)
      function genTernaryExp (el) {
        return altGen
          ? altGen(el, state)
          : el.once
            ? genOnce(el, state)
            : genElement(el, state)
      }
    }

    function genFor (
      el,
      state,
      altGen,
      altHelper
    ) {
      var exp = el.for;
      var alias = el.alias;
      var iterator1 = el.iterator1 ? ("," + (el.iterator1)) : '';
      var iterator2 = el.iterator2 ? ("," + (el.iterator2)) : '';

      el.forProcessed = true; // avoid recursion
      return (altHelper || '_l') + "((" + exp + ")," +
        "function(" + alias + iterator1 + iterator2 + "){" +
          "return " + ((altGen || genElement)(el, state)) +
        '})'
    }

    function genData$2 (el, state) {
      var data = '{';

      // directives first.
      // directives may mutate the el's other properties before they are generated.
      var dirs = genDirectives(el, state);
      if (dirs) { data += dirs + ','; }

      // key
      if (el.key) {
        data += "key:" + (el.key) + ",";
      }
      // ref
      if (el.ref) {
        data += "ref:" + (el.ref) + ",";
      }
      if (el.refInFor) {
        data += "refInFor:true,";
      }
      // pre
      if (el.pre) {
        data += "pre:true,";
      }
      // record original tag name for components using "is" attribute
      if (el.component) {
        data += "tag:\"" + (el.tag) + "\",";
      }
      // module data generation functions
      for (var i = 0; i < state.dataGenFns.length; i++) {
        data += state.dataGenFns[i](el);
      }
      // attributes
      if (el.attrs) {
        data += "attrs:" + (genProps(el.attrs)) + ",";
      }
      // DOM props
      if (el.props) {
        data += "domProps:" + (genProps(el.props)) + ",";
      }
      // event handlers
      if (el.events) {
        data += (genHandlers(el.events, false)) + ",";
      }
      if (el.nativeEvents) {
        data += (genHandlers(el.nativeEvents, true)) + ",";
      }
      // slot target
      // only for non-scoped slots
      if (el.slotTarget && !el.slotScope) {
        data += "slot:" + (el.slotTarget) + ",";
      }
      // scoped slots
      if (el.scopedSlots) {
        data += (genScopedSlots(el, el.scopedSlots, state)) + ",";
      }
      // component v-model
      if (el.model) {
        data += "model:{value:" + (el.model.value) + ",callback:" + (el.model.callback) + ",expression:" + (el.model.expression) + "},";
      }
      // inline-template
      if (el.inlineTemplate) {
        var inlineTemplate = genInlineTemplate(el, state);
        if (inlineTemplate) {
          data += inlineTemplate + ",";
        }
      }
      data = data.replace(/,$/, '') + '}';
      // v-bind dynamic argument wrap
      // v-bind with dynamic arguments must be applied using the same v-bind object
      // merge helper so that class/style/mustUseProp attrs are handled correctly.
      if (el.dynamicAttrs) {
        data = "_b(" + data + ",\"" + (el.tag) + "\"," + (genProps(el.dynamicAttrs)) + ")";
      }
      // v-bind data wrap
      if (el.wrapData) {
        data = el.wrapData(data);
      }
      // v-on data wrap
      if (el.wrapListeners) {
        data = el.wrapListeners(data);
      }
      return data
    }

    function genDirectives (el, state) {
      var dirs = el.directives;
      if (!dirs) { return }
      var res = 'directives:[';
      var hasRuntime = false;
      var i, l, dir, needRuntime;
      for (i = 0, l = dirs.length; i < l; i++) {
        dir = dirs[i];
        needRuntime = true;
        var gen = state.directives[dir.name];
        if (gen) {
          // compile-time directive that manipulates AST.
          // returns true if it also needs a runtime counterpart.
          needRuntime = !!gen(el, dir, state.warn);
        }
        if (needRuntime) {
          hasRuntime = true;
          res += "{name:\"" + (dir.name) + "\",rawName:\"" + (dir.rawName) + "\"" + (dir.value ? (",value:(" + (dir.value) + "),expression:" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (",arg:" + (dir.isDynamicArg ? dir.arg : ("\"" + (dir.arg) + "\""))) : '') + (dir.modifiers ? (",modifiers:" + (JSON.stringify(dir.modifiers))) : '') + "},";
        }
      }
      if (hasRuntime) {
        return res.slice(0, -1) + ']'
      }
    }

    function genInlineTemplate (el, state) {
      var ast = el.children[0];
      if (ast && ast.type === 1) {
        var inlineRenderFns = generate(ast, state.options);
        return ("inlineTemplate:{render:function(){" + (inlineRenderFns.render) + "},staticRenderFns:[" + (inlineRenderFns.staticRenderFns.map(function (code) { return ("function(){" + code + "}"); }).join(',')) + "]}")
      }
    }

    function genScopedSlots (
      el,
      slots,
      state
    ) {
      // by default scoped slots are considered "stable", this allows child
      // components with only scoped slots to skip forced updates from parent.
      // but in some cases we have to bail-out of this optimization
      // for example if the slot contains dynamic names, has v-if or v-for on them...
      var needsForceUpdate = el.for || Object.keys(slots).some(function (key) {
        var slot = slots[key];
        return (
          slot.slotTargetDynamic ||
          slot.if ||
          slot.for ||
          containsSlotChild(slot) // is passing down slot from parent which may be dynamic
        )
      });

      // #9534: if a component with scoped slots is inside a conditional branch,
      // it's possible for the same component to be reused but with different
      // compiled slot content. To avoid that, we generate a unique key based on
      // the generated code of all the slot contents.
      var needsKey = !!el.if;

      // OR when it is inside another scoped slot or v-for (the reactivity may be
      // disconnected due to the intermediate scope variable)
      // #9438, #9506
      // TODO: this can be further optimized by properly analyzing in-scope bindings
      // and skip force updating ones that do not actually use scope variables.
      if (!needsForceUpdate) {
        var parent = el.parent;
        while (parent) {
          if (
            (parent.slotScope && parent.slotScope !== emptySlotScopeToken) ||
            parent.for
          ) {
            needsForceUpdate = true;
            break
          }
          if (parent.if) {
            needsKey = true;
          }
          parent = parent.parent;
        }
      }

      var generatedSlots = Object.keys(slots)
        .map(function (key) { return genScopedSlot(slots[key], state); })
        .join(',');

      return ("scopedSlots:_u([" + generatedSlots + "]" + (needsForceUpdate ? ",null,true" : "") + (!needsForceUpdate && needsKey ? (",null,false," + (hash(generatedSlots))) : "") + ")")
    }

    function hash(str) {
      var hash = 5381;
      var i = str.length;
      while(i) {
        hash = (hash * 33) ^ str.charCodeAt(--i);
      }
      return hash >>> 0
    }

    function containsSlotChild (el) {
      if (el.type === 1) {
        if (el.tag === 'slot') {
          return true
        }
        return el.children.some(containsSlotChild)
      }
      return false
    }

    function genScopedSlot (
      el,
      state
    ) {
      var isLegacySyntax = el.attrsMap['slot-scope'];
      if (el.if && !el.ifProcessed && !isLegacySyntax) {
        return genIf(el, state, genScopedSlot, "null")
      }
      if (el.for && !el.forProcessed) {
        return genFor(el, state, genScopedSlot)
      }
      var slotScope = el.slotScope === emptySlotScopeToken
        ? ""
        : String(el.slotScope);
      var fn = "function(" + slotScope + "){" +
        "return " + (el.tag === 'template'
          ? el.if && isLegacySyntax
            ? ("(" + (el.if) + ")?" + (genChildren(el, state) || 'undefined') + ":undefined")
            : genChildren(el, state) || 'undefined'
          : genElement(el, state)) + "}";
      // reverse proxy v-slot without scope on this.$slots
      var reverseProxy = slotScope ? "" : ",proxy:true";
      return ("{key:" + (el.slotTarget || "\"default\"") + ",fn:" + fn + reverseProxy + "}")
    }

    function genChildren (
      el,
      state,
      checkSkip,
      altGenElement,
      altGenNode
    ) {
      var children = el.children;
      if (children.length) {
        var el$1 = children[0];
        // optimize single v-for
        if (children.length === 1 &&
          el$1.for &&
          el$1.tag !== 'template' &&
          el$1.tag !== 'slot'
        ) {
          var normalizationType = checkSkip
            ? state.maybeComponent(el$1) ? ",1" : ",0"
            : "";
          return ("" + ((altGenElement || genElement)(el$1, state)) + normalizationType)
        }
        var normalizationType$1 = checkSkip
          ? getNormalizationType(children, state.maybeComponent)
          : 0;
        var gen = altGenNode || genNode;
        return ("[" + (children.map(function (c) { return gen(c, state); }).join(',')) + "]" + (normalizationType$1 ? ("," + normalizationType$1) : ''))
      }
    }

    // determine the normalization needed for the children array.
    // 0: no normalization needed
    // 1: simple normalization needed (possible 1-level deep nested array)
    // 2: full normalization needed
    function getNormalizationType (
      children,
      maybeComponent
    ) {
      var res = 0;
      for (var i = 0; i < children.length; i++) {
        var el = children[i];
        if (el.type !== 1) {
          continue
        }
        if (needsNormalization(el) ||
            (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {
          res = 2;
          break
        }
        if (maybeComponent(el) ||
            (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {
          res = 1;
        }
      }
      return res
    }

    function needsNormalization (el) {
      return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'
    }

    function genNode (node, state) {
      if (node.type === 1) {
        return genElement(node, state)
      } else if (node.type === 3 && node.isComment) {
        return genComment(node)
      } else {
        return genText(node)
      }
    }

    function genText (text) {
      return ("_v(" + (text.type === 2
        ? text.expression // no need for () because already wrapped in _s()
        : transformSpecialNewlines(JSON.stringify(text.text))) + ")")
    }

    function genComment (comment) {
      return ("_e(" + (JSON.stringify(comment.text)) + ")")
    }

    function genSlot (el, state) {
      var slotName = el.slotName || '"default"';
      var children = genChildren(el, state);
      var res = "_t(" + slotName + (children ? (",function(){return " + children + "}") : '');
      var attrs = el.attrs || el.dynamicAttrs
        ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) { return ({
            // slot props are camelized
            name: camelize(attr.name),
            value: attr.value,
            dynamic: attr.dynamic
          }); }))
        : null;
      var bind$$1 = el.attrsMap['v-bind'];
      if ((attrs || bind$$1) && !children) {
        res += ",null";
      }
      if (attrs) {
        res += "," + attrs;
      }
      if (bind$$1) {
        res += (attrs ? '' : ',null') + "," + bind$$1;
      }
      return res + ')'
    }

    // componentName is el.component, take it as argument to shun flow's pessimistic refinement
    function genComponent (
      componentName,
      el,
      state
    ) {
      var children = el.inlineTemplate ? null : genChildren(el, state, true);
      return ("_c(" + componentName + "," + (genData$2(el, state)) + (children ? ("," + children) : '') + ")")
    }

    function genProps (props) {
      var staticProps = "";
      var dynamicProps = "";
      for (var i = 0; i < props.length; i++) {
        var prop = props[i];
        var value = transformSpecialNewlines(prop.value);
        if (prop.dynamic) {
          dynamicProps += (prop.name) + "," + value + ",";
        } else {
          staticProps += "\"" + (prop.name) + "\":" + value + ",";
        }
      }
      staticProps = "{" + (staticProps.slice(0, -1)) + "}";
      if (dynamicProps) {
        return ("_d(" + staticProps + ",[" + (dynamicProps.slice(0, -1)) + "])")
      } else {
        return staticProps
      }
    }

    // #3895, #4268
    function transformSpecialNewlines (text) {
      return text
        .replace(/\u2028/g, '\\u2028')
        .replace(/\u2029/g, '\\u2029')
    }

    /*  */



    // these keywords should not appear inside expressions, but operators like
    // typeof, instanceof and in are allowed
    var prohibitedKeywordRE = new RegExp('\\b' + (
      'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +
      'super,throw,while,yield,delete,export,import,return,switch,default,' +
      'extends,finally,continue,debugger,function,arguments'
    ).split(',').join('\\b|\\b') + '\\b');

    /*  */



    function createFunction (code, errors) {
      try {
        return new Function(code)
      } catch (err) {
        errors.push({ err: err, code: code });
        return noop$1
      }
    }

    function createCompileToFunctionFn (compile) {
      var cache = Object.create(null);

      return function compileToFunctions (
        template,
        options,
        vm
      ) {
        options = extend({}, options);
        var warn$$1 = options.warn || warn;
        delete options.warn;

        // check cache
        var key = options.delimiters
          ? String(options.delimiters) + template
          : template;
        if (cache[key]) {
          return cache[key]
        }

        // compile
        var compiled = compile(template, options);

        // turn code into functions
        var res = {};
        var fnGenErrors = [];
        res.render = createFunction(compiled.render, fnGenErrors);
        res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
          return createFunction(code, fnGenErrors)
        });

        return (cache[key] = res)
      }
    }

    /*  */

    function createCompilerCreator (baseCompile) {
      return function createCompiler (baseOptions) {
        function compile (
          template,
          options
        ) {
          var finalOptions = Object.create(baseOptions);
          var errors = [];
          var tips = [];

          var warn = function (msg, range, tip) {
            (tip ? tips : errors).push(msg);
          };

          if (options) {
            // merge custom modules
            if (options.modules) {
              finalOptions.modules =
                (baseOptions.modules || []).concat(options.modules);
            }
            // merge custom directives
            if (options.directives) {
              finalOptions.directives = extend(
                Object.create(baseOptions.directives || null),
                options.directives
              );
            }
            // copy other options
            for (var key in options) {
              if (key !== 'modules' && key !== 'directives') {
                finalOptions[key] = options[key];
              }
            }
          }

          finalOptions.warn = warn;

          var compiled = baseCompile(template.trim(), finalOptions);
          compiled.errors = errors;
          compiled.tips = tips;
          return compiled
        }

        return {
          compile: compile,
          compileToFunctions: createCompileToFunctionFn(compile)
        }
      }
    }

    /*  */

    // `createCompilerCreator` allows creating compilers that use alternative
    // parser/optimizer/codegen, e.g the SSR optimizing compiler.
    // Here we just export a default compiler using the default parts.
    var createCompiler = createCompilerCreator(function baseCompile (
      template,
      options
    ) {
      var ast = parse(template.trim(), options);
      if (options.optimize !== false) {
        optimize(ast, options);
      }
      var code = generate(ast, options);
      return {
        ast: ast,
        render: code.render,
        staticRenderFns: code.staticRenderFns
      }
    });

    /*  */

    var ref$1 = createCompiler(baseOptions);
    var compileToFunctions = ref$1.compileToFunctions;

    /*  */

    // check whether current browser encodes a char inside attribute values
    var div;
    function getShouldDecode (href) {
      div = div || document.createElement('div');
      div.innerHTML = href ? "<a href=\"\n\"/>" : "<div a=\"\n\"/>";
      return div.innerHTML.indexOf('&#10;') > 0
    }

    // #3663: IE encodes newlines inside attribute values while other browsers don't
    var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;
    // #6828: chrome encodes content in a[href]
    var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;

    /*  */

    var idToTemplate = cached(function (id) {
      var el = query(id);
      return el && el.innerHTML
    });

    var mount = Vue$1.prototype.$mount;
    Vue$1.prototype.$mount = function (
      el,
      hydrating
    ) {
      el = el && query(el);

      /* istanbul ignore if */
      if (el === document.body || el === document.documentElement) {
        return this
      }

      var options = this.$options;
      // resolve template/el and convert to render function
      if (!options.render) {
        var template = options.template;
        if (template) {
          if (typeof template === 'string') {
            if (template.charAt(0) === '#') {
              template = idToTemplate(template);
            }
          } else if (template.nodeType) {
            template = template.innerHTML;
          } else {
            return this
          }
        } else if (el) {
          template = getOuterHTML(el);
        }
        if (template) {

          var ref = compileToFunctions(template, {
            outputSourceRange: "production" !== 'production',
            shouldDecodeNewlines: shouldDecodeNewlines,
            shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,
            delimiters: options.delimiters,
            comments: options.comments
          }, this);
          var render = ref.render;
          var staticRenderFns = ref.staticRenderFns;
          options.render = render;
          options.staticRenderFns = staticRenderFns;
        }
      }
      return mount.call(this, el, hydrating)
    };

    /**
     * Get outerHTML of elements, taking care
     * of SVG elements in IE as well.
     */
    function getOuterHTML (el) {
      if (el.outerHTML) {
        return el.outerHTML
      } else {
        var container = document.createElement('div');
        container.appendChild(el.cloneNode(true));
        return container.innerHTML
      }
    }

    Vue$1.compile = compileToFunctions;

    var Vue$1$1;
    var warn$1 = function () {};

    // NOTE(benlesh): the value of this method seems dubious now, but I'm not sure
    // if this is a Vue convention I'm just not familiar with. Perhaps it would
    // be better to just import and use Vue directly?
    function install (_Vue) {
      Vue$1$1 = _Vue;
      warn$1 = Vue$1$1.util.warn || warn$1;
    }

    // TODO(benlesh): as time passes, this should be updated to use RxJS 6.1's
    // `isObservable` method. But wait until you're ready to drop support for Rx 5
    function isObservable (ob) {
      return ob && typeof ob.subscribe === 'function'
    }

    function isObserver (subject) {
      return subject && (
        typeof subject.next === 'function'
      )
    }

    function defineReactive (vm, key, val) {
      if (key in vm) {
        vm[key] = val;
      } else {
        Vue$1$1.util.defineReactive(vm, key, val);
      }
    }

    function getKey (binding) {
      return [binding.arg].concat(Object.keys(binding.modifiers)).join(':')
    }

    var rxMixin = {
      created: function created () {
        var vm = this;
        var domStreams = vm.$options.domStreams;
        if (domStreams) {
          domStreams.forEach(function (key) {
            vm[key] = new Subject();
          });
        }

        var observableMethods = vm.$options.observableMethods;
        if (observableMethods) {
          if (Array.isArray(observableMethods)) {
            observableMethods.forEach(function (methodName) {
              vm[ methodName + '$' ] = vm.$createObservableMethod(methodName);
            });
          } else {
            Object.keys(observableMethods).forEach(function (methodName) {
              vm[observableMethods[methodName]] = vm.$createObservableMethod(methodName);
            });
          }
        }

        var obs = vm.$options.subscriptions;
        if (typeof obs === 'function') {
          obs = obs.call(vm);
        }
        if (obs) {
          vm.$observables = {};
          vm._subscription = new Subscription();
          Object.keys(obs).forEach(function (key) {
            defineReactive(vm, key, undefined);
            var ob = vm.$observables[key] = obs[key];
            if (!isObservable(ob)) {
              warn$1(
                'Invalid Observable found in subscriptions option with key "' + key + '".',
                vm
              );
              return
            }
            vm._subscription.add(obs[key].subscribe(function (value) {
              vm[key] = value;
            }, function (error) { throw error }));
          });
        }
      },

      beforeDestroy: function beforeDestroy () {
        if (this._subscription) {
          this._subscription.unsubscribe();
        }
      }
    };

    var streamDirective = {
      // Example ./example/counter_dir.html
      bind: function bind (el, binding, vnode) {
        var handle = binding.value;
        var event = binding.arg;
        var streamName = binding.expression;
        var modifiers = binding.modifiers;

        if (isObserver(handle)) {
          handle = { subject: handle };
        } else if (!handle || !isObserver(handle.subject)) {
          warn$1(
            'Invalid Subject found in directive with key "' + streamName + '".' +
            streamName + ' should be an instance of Subject or have the ' +
            'type { subject: Subject, data: any }.',
            vnode.context
          );
          return
        }

        var modifiersFuncs = {
          stop: function (e) { return e.stopPropagation(); },
          prevent: function (e) { return e.preventDefault(); }
        };

        var modifiersExists = Object.keys(modifiersFuncs).filter(
          function (key) { return modifiers[key]; }
        );

        var subject = handle.subject;
        var next = (subject.next || subject.onNext).bind(subject);

        if (!modifiers.native && vnode.componentInstance) {
          handle.subscription = vnode.componentInstance.$eventToObservable(event).subscribe(function (e) {
            modifiersExists.forEach(function (mod) { return modifiersFuncs[mod](e); });
            next({
              event: e,
              data: handle.data
            });
          });
        } else {
          var fromEventArgs = handle.options ? [el, event, handle.options] : [el, event];
          handle.subscription = fromEvent.apply(void 0, fromEventArgs).subscribe(function (e) {
            modifiersExists.forEach(function (mod) { return modifiersFuncs[mod](e); });
            next({
              event: e,
              data: handle.data
            });
          });
        }
    (el._rxHandles || (el._rxHandles = {}))[getKey(binding)] = handle;
      },

      update: function update (el, binding) {
        var handle = binding.value;
        var _handle = el._rxHandles && el._rxHandles[getKey(binding)];
        if (_handle && handle && isObserver(handle.subject)) {
          _handle.data = handle.data;
        }
      },

      unbind: function unbind (el, binding) {
        var key = getKey(binding);
        var handle = el._rxHandles && el._rxHandles[key];
        if (handle) {
          if (handle.subscription) {
            handle.subscription.unsubscribe();
          }
          el._rxHandles[key] = null;
        }
      }
    };

    function watchAsObservable (expOrFn, options) {
      var vm = this;
      var obs$ = new Observable(function (observer) {
        var _unwatch;
        var watch = function () {
          _unwatch = vm.$watch(expOrFn, function (newValue, oldValue) {
            observer.next({ oldValue: oldValue, newValue: newValue });
          }, options);
        };

        // if $watchAsObservable is called inside the subscriptions function,
        // because data hasn't been observed yet, the watcher will not work.
        // in that case, wait until created hook to watch.
        if (vm._data) {
          watch();
        } else {
          vm.$once('hook:created', watch);
        }

        // Returns function which disconnects the $watch expression
        return new Subscription(function () {
          _unwatch && _unwatch();
        })
      });

      return obs$
    }

    function fromDOMEvent (selector, event) {
      if (typeof window === 'undefined') {
        // TODO(benlesh): I'm not sure if this is really what you want here,
        // but it's equivalent to what you were doing. You might want EMPTY
        return NEVER
      }

      var vm = this;
      var doc = document.documentElement;
      var obs$ = new Observable(function (observer) {
        function listener (e) {
          if (!vm.$el) { return }
          if (selector === null && vm.$el === e.target) { return observer.next(e) }
          var els = vm.$el.querySelectorAll(selector);
          var el = e.target;
          for (var i = 0, len = els.length; i < len; i++) {
            if (els[i] === el) { return observer.next(e) }
          }
        }
        doc.addEventListener(event, listener);
        // Returns function which disconnects the $watch expression
        return new Subscription(function () {
          doc.removeEventListener(event, listener);
        })
      });

      return obs$
    }

    function subscribeTo$1 (observable, next, error, complete) {
      var subscription = observable.subscribe(next, error, complete)
      ;(this._subscription || (this._subscription = new Subscription())).add(subscription);
      return subscription
    }

    /**
     * @see {@link https://vuejs.org/v2/api/#vm-on}
     * @param {String||Array} evtName Event name
     * @return {Observable} Event stream
     */
    function eventToObservable (evtName) {
      var vm = this;
      var evtNames = Array.isArray(evtName) ? evtName : [evtName];
      var obs$ = new Observable(function (observer) {
        var eventPairs = evtNames.map(function (name) {
          var callback = function (msg) { return observer.next({ name: name, msg: msg }); };
          vm.$on(name, callback);
          return { name: name, callback: callback }
        });
        return function () {
          // Only remove the specific callback
          eventPairs.forEach(function (pair) { return vm.$off(pair.name, pair.callback); });
        }
      });

      return obs$
    }

    /**
     * @name Vue.prototype.$createObservableMethod
     * @description Creates an observable from a given function name.
     * @param {String} methodName Function name
     * @param {Boolean} [passContext] Append the call context at the end of emit data?
     * @return {Observable} Hot stream
     */
    function createObservableMethod (methodName, passContext) {
      var vm = this;

      if (vm[methodName] !== undefined) {
        warn$1(
          'Potential bug: ' +
          "Method " + methodName + " already defined on vm and has been overwritten by $createObservableMethod." +
          String(vm[methodName]),
          vm
        );
      }

      var creator = function (observer) {
        vm[methodName] = function () {
          var args = Array.from(arguments);
          if (passContext) {
            args.push(this);
            observer.next(args);
          } else {
            if (args.length <= 1) {
              observer.next(args[0]);
            } else {
              observer.next(args);
            }
          }
        };
        return function () {
          delete vm[methodName];
        }
      };

      // Must be a hot stream otherwise function context may overwrite over and over again
      return new Observable(creator).pipe(share())
    }

    /* global Vue */

    function VueRx (Vue) {
      install(Vue);
      Vue.mixin(rxMixin);
      Vue.directive('stream', streamDirective);
      Vue.prototype.$watchAsObservable = watchAsObservable;
      Vue.prototype.$fromDOMEvent = fromDOMEvent;
      Vue.prototype.$subscribeTo = subscribeTo$1;
      Vue.prototype.$eventToObservable = eventToObservable;
      Vue.prototype.$createObservableMethod = createObservableMethod;
      Vue.config.optionMergeStrategies.subscriptions = Vue.config.optionMergeStrategies.data;
    }

    // auto install
    if (typeof Vue !== 'undefined') {
      Vue.use(VueRx);
    }

    function _typeof(obj) {
      "@babel/helpers - typeof";

      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function (obj) {
          return typeof obj;
        };
      } else {
        _typeof = function (obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
      }

      return _typeof(obj);
    }

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
    }

    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);

      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
        keys.push.apply(keys, symbols);
      }

      return keys;
    }

    function _objectSpread2(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};

        if (i % 2) {
          ownKeys(Object(source), true).forEach(function (key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function (key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }

      return target;
    }

    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }

    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf(o);
    }

    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf(o, p);
    }

    function isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    function _construct(Parent, args, Class) {
      if (isNativeReflectConstruct()) {
        _construct = Reflect.construct;
      } else {
        _construct = function _construct(Parent, args, Class) {
          var a = [null];
          a.push.apply(a, args);
          var Constructor = Function.bind.apply(Parent, a);
          var instance = new Constructor();
          if (Class) _setPrototypeOf(instance, Class.prototype);
          return instance;
        };
      }

      return _construct.apply(null, arguments);
    }

    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }

    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? new Map() : undefined;

      _wrapNativeSuper = function _wrapNativeSuper(Class) {
        if (Class === null || !_isNativeFunction(Class)) return Class;

        if (typeof Class !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }

        if (typeof _cache !== "undefined") {
          if (_cache.has(Class)) return _cache.get(Class);

          _cache.set(Class, Wrapper);
        }

        function Wrapper() {
          return _construct(Class, arguments, _getPrototypeOf(this).constructor);
        }

        Wrapper.prototype = Object.create(Class.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf(Wrapper, Class);
      };

      return _wrapNativeSuper(Class);
    }

    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null) return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;

      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
      }

      return target;
    }

    function _objectWithoutProperties(source, excluded) {
      if (source == null) return {};

      var target = _objectWithoutPropertiesLoose(source, excluded);

      var key, i;

      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

        for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];
          if (excluded.indexOf(key) >= 0) continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
          target[key] = source[key];
        }
      }

      return target;
    }

    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized(self);
    }

    function _taggedTemplateLiteral(strings, raw) {
      if (!raw) {
        raw = strings.slice(0);
      }

      return Object.freeze(Object.defineProperties(strings, {
        raw: {
          value: Object.freeze(raw)
        }
      }));
    }

    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
    }

    function _toArray(arr) {
      return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest();
    }

    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
    }

    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

        return arr2;
      }
    }

    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }

    function _iterableToArray(iter) {
      if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
    }

    function _iterableToArrayLimit(arr, i) {
      if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
        return;
      }

      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;

      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance");
    }

    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }

    /**
     * +/- function to native math sign
     */
    function signPoly(value) {
      if (value < 0) return -1;
      return value > 0 ? 1 : 0;
    }

    var sign = Math.sign || signPoly;
    /**
     * Checks if the flag is set
     * @param val
     * @param flag
     * @returns {boolean}
     */

    function hasFlag(val, flag) {
      return (val & flag) === flag;
    }
    /**
     * Native modulo bug with negative numbers
     * @param n
     * @param mod
     * @returns {number}
     */


    function mod(n, mod) {
      return (n % mod + mod) % mod;
    }
    /**
     * Asserts a value is beetween min and max
     * @param val
     * @param min
     * @param max
     * @returns {number}
     */


    function bound(val, min, max) {
      return Math.max(min, Math.min(max, val));
    }
    /**
     * Get value of an object property/path even if it's nested
     */

    function getValueByPath(obj, path) {
      return path.split('.').reduce(function (o, i) {
        return o ? o[i] : null;
      }, obj);
    }
    /**
     * Extension of indexOf method by equality function if specified
     */

    function indexOf(array, obj, fn) {
      if (!array) return -1;
      if (!fn || typeof fn !== 'function') return array.indexOf(obj);

      for (var i = 0; i < array.length; i++) {
        if (fn(array[i], obj)) {
          return i;
        }
      }

      return -1;
    }
    /**
     * Merge function to replace Object.assign with deep merging possibility
     */

    var isObject$2 = function isObject(item) {
      return _typeof(item) === 'object' && !Array.isArray(item);
    };

    var mergeFn = function mergeFn(target, source) {
      var deep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      if (deep || !Object.assign) {
        var isDeep = function isDeep(prop) {
          return isObject$2(source[prop]) && target !== null && target.hasOwnProperty(prop) && isObject$2(target[prop]);
        };

        var replaced = Object.getOwnPropertyNames(source).map(function (prop) {
          return _defineProperty({}, prop, isDeep(prop) ? mergeFn(target[prop], source[prop], deep) : source[prop]);
        }).reduce(function (a, b) {
          return _objectSpread2({}, a, {}, b);
        }, {});
        return _objectSpread2({}, target, {}, replaced);
      } else {
        return Object.assign(target, source);
      }
    };

    var merge$1 = mergeFn;
    /**
     * Mobile detection
     * https://www.abeautifulsite.net/detecting-mobile-devices-with-javascript
     */

    var isMobile = {
      Android: function Android() {
        return typeof window !== 'undefined' && window.navigator.userAgent.match(/Android/i);
      },
      BlackBerry: function BlackBerry() {
        return typeof window !== 'undefined' && window.navigator.userAgent.match(/BlackBerry/i);
      },
      iOS: function iOS() {
        return typeof window !== 'undefined' && (window.navigator.userAgent.match(/iPhone|iPad|iPod/i) || window.navigator.platform === 'MacIntel' && window.navigator.maxTouchPoints > 1);
      },
      Opera: function Opera() {
        return typeof window !== 'undefined' && window.navigator.userAgent.match(/Opera Mini/i);
      },
      Windows: function Windows() {
        return typeof window !== 'undefined' && window.navigator.userAgent.match(/IEMobile/i);
      },
      any: function any() {
        return isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows();
      }
    };
    function removeElement(el) {
      if (typeof el.remove !== 'undefined') {
        el.remove();
      } else if (typeof el.parentNode !== 'undefined' && el.parentNode !== null) {
        el.parentNode.removeChild(el);
      }
    }
    function createAbsoluteElement(el) {
      var root = document.createElement('div');
      root.style.position = 'absolute';
      root.style.left = '0px';
      root.style.top = '0px';
      root.style.width = '100%';
      var wrapper = document.createElement('div');
      root.appendChild(wrapper);
      wrapper.appendChild(el);
      document.body.appendChild(root);
      return root;
    }
    function isVueComponent(c) {
      return c && c._isVue;
    }
    /**
     * Escape regex characters
     * http://stackoverflow.com/a/6969486
     */

    function escapeRegExpChars(value) {
      if (!value) return value; // eslint-disable-next-line

      return value.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
    }
    /**
     * Remove accents/diacritics in a string in JavaScript
     * https://stackoverflow.com/a/37511463
     */

    function removeDiacriticsFromString(value) {
      if (!value) return value;
      return value.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
    }
    function multiColumnSort(inputArray, sortingPriority) {
      // clone it to prevent the any watchers from triggering every sorting iteration
      var array = JSON.parse(JSON.stringify(inputArray));

      var fieldSorter = function fieldSorter(fields) {
        return function (a, b) {
          return fields.map(function (o) {
            var dir = 1;

            if (o[0] === '-') {
              dir = -1;
              o = o.substring(1);
            }

            var aValue = getValueByPath(a, o);
            var bValue = getValueByPath(b, o);
            return aValue > bValue ? dir : aValue < bValue ? -dir : 0;
          }).reduce(function (p, n) {
            return p || n;
          }, 0);
        };
      };

      return array.sort(fieldSorter(sortingPriority));
    }
    function toCssWidth(width) {
      return width === undefined ? null : isNaN(width) ? width : width + 'px';
    }
    /**
     * Return month names according to a specified locale
     * @param  {String} locale A bcp47 localerouter. undefined will use the user browser locale
     * @param  {String} format long (ex. March), short (ex. Mar) or narrow (M)
     * @return {Array<String>} An array of month names
     */

    function getMonthNames() {
      var locale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
      var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'long';
      var dates = [];

      for (var i = 0; i < 12; i++) {
        dates.push(new Date(2000, i, 15));
      }

      var dtf = new Intl.DateTimeFormat(locale, {
        month: format
      });
      return dates.map(function (d) {
        return dtf.format(d);
      });
    }
    /**
     * Return weekday names according to a specified locale
     * @param  {String} locale A bcp47 localerouter. undefined will use the user browser locale
     * @param  {String} format long (ex. Thursday), short (ex. Thu) or narrow (T)
     * @return {Array<String>} An array of weekday names
     */

    function getWeekdayNames() {
      var locale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
      var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'narrow';
      var dates = [];

      for (var i = 0; i < 7; i++) {
        var dt = new Date(2000, 0, i + 1);
        dates[dt.getDay()] = dt;
      }

      var dtf = new Intl.DateTimeFormat(locale, {
        weekday: format
      });
      return dates.map(function (d) {
        return dtf.format(d);
      });
    }
    /**
     * Accept a regex with group names and return an object
     * ex. matchWithGroups(/((?!=<year>)\d+)\/((?!=<month>)\d+)\/((?!=<day>)\d+)/, '2000/12/25')
     * will return { year: 2000, month: 12, day: 25 }
     * @param  {String} includes injections of (?!={groupname}) for each group
     * @param  {String} the string to run regex
     * @return {Object} an object with a property for each group having the group's match as the value
     */

    function matchWithGroups(pattern, str) {
      var matches = str.match(pattern);
      return pattern // get the pattern as a string
      .toString() // suss out the groups
      .match(/<(.+?)>/g) // remove the braces
      .map(function (group) {
        var groupMatches = group.match(/<(.+)>/);

        if (!groupMatches || groupMatches.length <= 0) {
          return null;
        }

        return group.match(/<(.+)>/)[1];
      }) // create an object with a property for each group having the group's match as the value
      .reduce(function (acc, curr, index, arr) {
        if (matches && matches.length > index) {
          acc[curr] = matches[index + 1];
        } else {
          acc[curr] = null;
        }

        return acc;
      }, {});
    }
    /**
     * Based on
     * https://github.com/fregante/supports-webp
     */

    function isWebpSupported() {
      return new Promise(function (resolve) {
        var image = new Image();

        image.onerror = function () {
          return resolve(false);
        };

        image.onload = function () {
          return resolve(image.width === 1);
        };

        image.src = 'data:image/webp;base64,UklGRiQAAABXRUJQVlA4IBgAAAAwAQCdASoBAAEAAwA0JaQAA3AA/vuUAAA=';
      }).catch(function () {
        return false;
      });
    }
    function isCustomElement(vm) {
      return 'shadowRoot' in vm.$root.$options;
    }
    var isDefined = function isDefined(d) {
      return d !== undefined;
    };
    /**
     * Checks if a value is null or undefined.
     * Based on
     * https://github.com/lodash/lodash/blob/master/isNil.js
     */

    var isNil = function isNil(value) {
      return value === null || value === undefined;
    };

    var config$2 = {
      defaultContainerElement: null,
      defaultIconPack: 'mdi',
      defaultIconComponent: null,
      defaultIconPrev: 'chevron-left',
      defaultIconNext: 'chevron-right',
      defaultLocale: undefined,
      defaultDialogConfirmText: null,
      defaultDialogCancelText: null,
      defaultSnackbarDuration: 3500,
      defaultSnackbarPosition: null,
      defaultToastDuration: 2000,
      defaultToastPosition: null,
      defaultNotificationDuration: 2000,
      defaultNotificationPosition: null,
      defaultTooltipType: 'is-primary',
      defaultTooltipDelay: null,
      defaultSidebarDelay: null,
      defaultInputAutocomplete: 'on',
      defaultDateFormatter: null,
      defaultDateParser: null,
      defaultDateCreator: null,
      defaultTimeCreator: null,
      defaultDayNames: null,
      defaultMonthNames: null,
      defaultFirstDayOfWeek: null,
      defaultUnselectableDaysOfWeek: null,
      defaultTimeFormatter: null,
      defaultTimeParser: null,
      defaultModalCanCancel: ['escape', 'x', 'outside', 'button'],
      defaultModalScroll: null,
      defaultDatepickerMobileNative: true,
      defaultTimepickerMobileNative: true,
      defaultNoticeQueue: true,
      defaultInputHasCounter: true,
      defaultTaginputHasCounter: true,
      defaultUseHtml5Validation: true,
      defaultDropdownMobileModal: true,
      defaultFieldLabelPosition: null,
      defaultDatepickerYearsRange: [-100, 10],
      defaultDatepickerNearbyMonthDays: true,
      defaultDatepickerNearbySelectableMonthDays: false,
      defaultDatepickerShowWeekNumber: false,
      defaultDatepickerWeekNumberClickable: false,
      defaultDatepickerMobileModal: true,
      defaultTrapFocus: true,
      defaultAutoFocus: true,
      defaultButtonRounded: false,
      defaultSwitchRounded: true,
      defaultCarouselInterval: 3500,
      defaultTabsExpanded: false,
      defaultTabsAnimated: true,
      defaultTabsType: null,
      defaultStatusIcon: true,
      defaultProgrammaticPromise: false,
      defaultLinkTags: ['a', 'button', 'input', 'router-link', 'nuxt-link', 'n-link', 'RouterLink', 'NuxtLink', 'NLink'],
      defaultImageWebpFallback: null,
      defaultImageLazy: true,
      defaultImageResponsive: true,
      defaultImageRatio: null,
      defaultImageSrcsetFormatter: null,
      defaultBreadcrumbTag: 'a',
      defaultBreadcrumbAlign: 'is-left',
      defaultBreadcrumbSeparator: '',
      defaultBreadcrumbSize: 'is-medium',
      customIconPacks: null
    };
    var setOptions = function setOptions(options) {
      config$2 = options;
    };
    var setVueInstance = function setVueInstance(Vue) {
      VueInstance = Vue;
    };
    var VueInstance;

    var FormElementMixin = {
      props: {
        size: String,
        expanded: Boolean,
        loading: Boolean,
        rounded: Boolean,
        icon: String,
        iconPack: String,
        // Native options to use in HTML5 validation
        autocomplete: String,
        maxlength: [Number, String],
        useHtml5Validation: {
          type: Boolean,
          default: function _default() {
            return config$2.defaultUseHtml5Validation;
          }
        },
        validationMessage: String,
        locale: {
          type: [String, Array],
          default: function _default() {
            return config$2.defaultLocale;
          }
        },
        statusIcon: {
          type: Boolean,
          default: function _default() {
            return config$2.defaultStatusIcon;
          }
        }
      },
      data: function data() {
        return {
          isValid: true,
          isFocused: false,
          newIconPack: this.iconPack || config$2.defaultIconPack
        };
      },
      computed: {
        /**
         * Find parent Field, max 3 levels deep.
         */
        parentField: function parentField() {
          var parent = this.$parent;

          for (var i = 0; i < 3; i++) {
            if (parent && !parent.$data._isField) {
              parent = parent.$parent;
            }
          }

          return parent;
        },

        /**
         * Get the type prop from parent if it's a Field.
         */
        statusType: function statusType() {
          var _ref = this.parentField || {},
              newType = _ref.newType;

          if (!newType) return;

          if (typeof newType === 'string') {
            return newType;
          } else {
            for (var key in newType) {
              if (newType[key]) {
                return key;
              }
            }
          }
        },

        /**
         * Get the message prop from parent if it's a Field.
         */
        statusMessage: function statusMessage() {
          if (!this.parentField) return;
          return this.parentField.newMessage || this.parentField.$slots.message;
        },

        /**
         * Fix icon size for inputs, large was too big
         */
        iconSize: function iconSize() {
          switch (this.size) {
            case 'is-small':
              return this.size;

            case 'is-medium':
              return;

            case 'is-large':
              return this.newIconPack === 'mdi' ? 'is-medium' : '';
          }
        }
      },
      methods: {
        /**
         * Focus method that work dynamically depending on the component.
         */
        focus: function focus() {
          var el = this.getElement();
          if (el === undefined) return;
          this.$nextTick(function () {
            if (el) el.focus();
          });
        },
        onBlur: function onBlur($event) {
          this.isFocused = false;
          this.$emit('blur', $event);
          this.checkHtml5Validity();
        },
        onFocus: function onFocus($event) {
          this.isFocused = true;
          this.$emit('focus', $event);
        },
        getElement: function getElement() {
          var el = this.$refs[this.$data._elementRef];

          while (isVueComponent(el)) {
            el = el.$refs[el.$data._elementRef];
          }

          return el;
        },
        setInvalid: function setInvalid() {
          var type = 'is-danger';
          var message = this.validationMessage || this.getElement().validationMessage;
          this.setValidity(type, message);
        },
        setValidity: function setValidity(type, message) {
          var _this = this;

          this.$nextTick(function () {
            if (_this.parentField) {
              // Set type only if not defined
              if (!_this.parentField.type) {
                _this.parentField.newType = type;
              } // Set message only if not defined


              if (!_this.parentField.message) {
                _this.parentField.newMessage = message;
              }
            }
          });
        },

        /**
         * Check HTML5 validation, set isValid property.
         * If validation fail, send 'is-danger' type,
         * and error message to parent if it's a Field.
         */
        checkHtml5Validity: function checkHtml5Validity() {
          if (!this.useHtml5Validation) return;
          var el = this.getElement();
          if (el === undefined) return;

          if (!el.checkValidity()) {
            this.setInvalid();
            this.isValid = false;
          } else {
            this.setValidity(null, null);
            this.isValid = true;
          }

          return this.isValid;
        }
      }
    };

    function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier
    /* server only */
    , shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
      if (typeof shadowMode !== 'boolean') {
        createInjectorSSR = createInjector;
        createInjector = shadowMode;
        shadowMode = false;
      } // Vue.extend constructor export interop.


      var options = typeof script === 'function' ? script.options : script; // render functions

      if (template && template.render) {
        options.render = template.render;
        options.staticRenderFns = template.staticRenderFns;
        options._compiled = true; // functional template

        if (isFunctionalTemplate) {
          options.functional = true;
        }
      } // scopedId


      if (scopeId) {
        options._scopeId = scopeId;
      }

      var hook;

      if (moduleIdentifier) {
        // server build
        hook = function hook(context) {
          // 2.3 injection
          context = context || // cached call
          this.$vnode && this.$vnode.ssrContext || // stateful
          this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional
          // 2.2 with runInNewContext: true

          if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
            context = __VUE_SSR_CONTEXT__;
          } // inject component styles


          if (style) {
            style.call(this, createInjectorSSR(context));
          } // register component module identifier for async chunk inference


          if (context && context._registeredComponents) {
            context._registeredComponents.add(moduleIdentifier);
          }
        }; // used by ssr in case component is cached and beforeCreate
        // never gets called


        options._ssrRegister = hook;
      } else if (style) {
        hook = shadowMode ? function () {
          style.call(this, createInjectorShadow(this.$root.$options.shadowRoot));
        } : function (context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook) {
        if (options.functional) {
          // register for functional component in vue file
          var originalRender = options.render;

          options.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = options.beforeCreate;
          options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }

      return script;
    }

    var normalizeComponent_1 = normalizeComponent;

    var use = function use(plugin) {
      if (typeof window !== 'undefined' && window.Vue) {
        window.Vue.use(plugin);
      }
    };
    var registerComponent = function registerComponent(Vue, component) {
      Vue.component(component.name, component);
    };
    var registerComponentProgrammatic = function registerComponentProgrammatic(Vue, property, component) {
      if (!Vue.prototype.$buefy) Vue.prototype.$buefy = {};
      Vue.prototype.$buefy[property] = component;
    };

    var mdiIcons = {
      sizes: {
        'default': 'mdi-24px',
        'is-small': null,
        'is-medium': 'mdi-36px',
        'is-large': 'mdi-48px'
      },
      iconPrefix: 'mdi-'
    };

    var faIcons = function faIcons() {
      var faIconPrefix = config$2 && config$2.defaultIconComponent ? '' : 'fa-';
      return {
        sizes: {
          'default': null,
          'is-small': null,
          'is-medium': faIconPrefix + 'lg',
          'is-large': faIconPrefix + '2x'
        },
        iconPrefix: faIconPrefix,
        internalIcons: {
          'information': 'info-circle',
          'alert': 'exclamation-triangle',
          'alert-circle': 'exclamation-circle',
          'chevron-right': 'angle-right',
          'chevron-left': 'angle-left',
          'chevron-down': 'angle-down',
          'eye-off': 'eye-slash',
          'menu-down': 'caret-down',
          'menu-up': 'caret-up',
          'close-circle': 'times-circle'
        }
      };
    };

    var getIcons = function getIcons() {
      var icons = {
        mdi: mdiIcons,
        fa: faIcons(),
        fas: faIcons(),
        far: faIcons(),
        fad: faIcons(),
        fab: faIcons(),
        fal: faIcons(),
        'fa-solid': faIcons(),
        'fa-regular': faIcons(),
        'fa-light': faIcons(),
        'fa-thin': faIcons(),
        'fa-duotone': faIcons(),
        'fa-brands': faIcons()
      };

      if (config$2 && config$2.customIconPacks) {
        icons = merge$1(icons, config$2.customIconPacks, true);
      }

      return icons;
    };

    var script = {
      name: 'BIcon',
      props: {
        type: [String, Object],
        component: String,
        pack: String,
        icon: String,
        size: String,
        customSize: String,
        customClass: String,
        both: Boolean // This is used internally to show both MDI and FA icon

      },
      computed: {
        iconConfig: function iconConfig() {
          var allIcons = getIcons();
          return allIcons[this.newPack];
        },
        iconPrefix: function iconPrefix() {
          if (this.iconConfig && this.iconConfig.iconPrefix) {
            return this.iconConfig.iconPrefix;
          }

          return '';
        },

        /**
        * Internal icon name based on the pack.
        * If pack is 'fa', gets the equivalent FA icon name of the MDI,
        * internal icons are always MDI.
        */
        newIcon: function newIcon() {
          return "".concat(this.iconPrefix).concat(this.getEquivalentIconOf(this.icon));
        },
        newPack: function newPack() {
          return this.pack || config$2.defaultIconPack;
        },
        newType: function newType() {
          if (!this.type) return;
          var splitType = [];

          if (typeof this.type === 'string') {
            splitType = this.type.split('-');
          } else {
            for (var key in this.type) {
              if (this.type[key]) {
                splitType = key.split('-');
                break;
              }
            }
          }

          if (splitType.length <= 1) return;

          var _splitType = splitType,
              _splitType2 = _toArray(_splitType),
              type = _splitType2.slice(1);

          return "has-text-".concat(type.join('-'));
        },
        newCustomSize: function newCustomSize() {
          return this.customSize || this.customSizeByPack;
        },
        customSizeByPack: function customSizeByPack() {
          if (this.iconConfig && this.iconConfig.sizes) {
            if (this.size && this.iconConfig.sizes[this.size] !== undefined) {
              return this.iconConfig.sizes[this.size];
            } else if (this.iconConfig.sizes.default) {
              return this.iconConfig.sizes.default;
            }
          }

          return null;
        },
        useIconComponent: function useIconComponent() {
          return this.component || config$2.defaultIconComponent;
        }
      },
      methods: {
        /**
        * Equivalent icon name of the MDI.
        */
        getEquivalentIconOf: function getEquivalentIconOf(value) {
          // Only transform the class if the both prop is set to true
          if (!this.both) {
            return value;
          }

          if (this.iconConfig && this.iconConfig.internalIcons && this.iconConfig.internalIcons[value]) {
            return this.iconConfig.internalIcons[value];
          }

          return value;
        }
      }
    };

    /* script */
    const __vue_script__ = script;

    /* template */
    var __vue_render__ = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('span',{staticClass:"icon",class:[_vm.newType, _vm.size]},[(!_vm.useIconComponent)?_c('i',{class:[_vm.newPack, _vm.newIcon, _vm.newCustomSize, _vm.customClass]}):_c(_vm.useIconComponent,{tag:"component",class:[_vm.customClass],attrs:{"icon":[_vm.newPack, _vm.newIcon],"size":_vm.newCustomSize}})],1)};
    var __vue_staticRenderFns__ = [];

      /* style */
      const __vue_inject_styles__ = undefined;
      /* scoped */
      const __vue_scope_id__ = undefined;
      /* module identifier */
      const __vue_module_identifier__ = undefined;
      /* functional template */
      const __vue_is_functional_template__ = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var Icon = normalizeComponent_1(
        { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },
        __vue_inject_styles__,
        __vue_script__,
        __vue_scope_id__,
        __vue_is_functional_template__,
        __vue_module_identifier__,
        undefined,
        undefined
      );

    var script$1 = {
      name: 'BInput',
      components: _defineProperty({}, Icon.name, Icon),
      mixins: [FormElementMixin],
      inheritAttrs: false,
      props: {
        value: [Number, String],
        type: {
          type: String,
          default: 'text'
        },
        lazy: {
          type: Boolean,
          default: false
        },
        passwordReveal: Boolean,
        iconClickable: Boolean,
        hasCounter: {
          type: Boolean,
          default: function _default() {
            return config$2.defaultInputHasCounter;
          }
        },
        customClass: {
          type: String,
          default: ''
        },
        iconRight: String,
        iconRightClickable: Boolean,
        iconRightType: String
      },
      data: function data() {
        return {
          newValue: this.value,
          newType: this.type,
          newAutocomplete: this.autocomplete || config$2.defaultInputAutocomplete,
          isPasswordVisible: false,
          _elementRef: this.type === 'textarea' ? 'textarea' : 'input'
        };
      },
      computed: {
        computedValue: {
          get: function get() {
            return this.newValue;
          },
          set: function set(value) {
            this.newValue = value;
            this.$emit('input', value);
          }
        },
        rootClasses: function rootClasses() {
          return [this.iconPosition, this.size, {
            'is-expanded': this.expanded,
            'is-loading': this.loading,
            'is-clearfix': !this.hasMessage
          }];
        },
        inputClasses: function inputClasses() {
          return [this.statusType, this.size, {
            'is-rounded': this.rounded
          }];
        },
        hasIconRight: function hasIconRight() {
          return this.passwordReveal || this.loading || this.statusIcon && this.statusTypeIcon || this.iconRight;
        },
        rightIcon: function rightIcon() {
          if (this.passwordReveal) {
            return this.passwordVisibleIcon;
          } else if (this.iconRight) {
            return this.iconRight;
          }

          return this.statusTypeIcon;
        },
        rightIconType: function rightIconType() {
          if (this.passwordReveal) {
            return 'is-primary';
          } else if (this.iconRight) {
            return this.iconRightType || null;
          }

          return this.statusType;
        },

        /**
        * Position of the icon or if it's both sides.
        */
        iconPosition: function iconPosition() {
          var iconClasses = '';

          if (this.icon) {
            iconClasses += 'has-icons-left ';
          }

          if (this.hasIconRight) {
            iconClasses += 'has-icons-right';
          }

          return iconClasses;
        },

        /**
        * Icon name (MDI) based on the type.
        */
        statusTypeIcon: function statusTypeIcon() {
          switch (this.statusType) {
            case 'is-success':
              return 'check';

            case 'is-danger':
              return 'alert-circle';

            case 'is-info':
              return 'information';

            case 'is-warning':
              return 'alert';
          }
        },

        /**
        * Check if have any message prop from parent if it's a Field.
        */
        hasMessage: function hasMessage() {
          return !!this.statusMessage;
        },

        /**
        * Current password-reveal icon name.
        */
        passwordVisibleIcon: function passwordVisibleIcon() {
          return !this.isPasswordVisible ? 'eye' : 'eye-off';
        },

        /**
        * Get value length
        */
        valueLength: function valueLength() {
          if (typeof this.computedValue === 'string') {
            return this.computedValue.length;
          } else if (typeof this.computedValue === 'number') {
            return this.computedValue.toString().length;
          }

          return 0;
        }
      },
      watch: {
        /**
        * When v-model is changed:
        *   1. Set internal value.
        */
        value: function value(_value) {
          this.newValue = _value;
        }
      },
      methods: {
        /**
        * Toggle the visibility of a password-reveal input
        * by changing the type and focus the input right away.
        */
        togglePasswordVisibility: function togglePasswordVisibility() {
          var _this = this;

          this.isPasswordVisible = !this.isPasswordVisible;
          this.newType = this.isPasswordVisible ? 'text' : 'password';
          this.$nextTick(function () {
            _this.focus();
          });
        },
        iconClick: function iconClick(emit, event) {
          var _this2 = this;

          this.$emit(emit, event);
          this.$nextTick(function () {
            _this2.focus();
          });
        },
        rightIconClick: function rightIconClick(event) {
          if (this.passwordReveal) {
            this.togglePasswordVisibility();
          } else if (this.iconRightClickable) {
            this.iconClick('icon-right-click', event);
          }
        },
        onInput: function onInput(event) {
          if (!this.lazy) {
            var value = event.target.value;
            this.updateValue(value);
          }
        },
        onChange: function onChange(event) {
          if (this.lazy) {
            var value = event.target.value;
            this.updateValue(value);
          }
        },
        updateValue: function updateValue(value) {
          this.computedValue = value;
          !this.isValid && this.checkHtml5Validity();
        }
      }
    };

    /* script */
    const __vue_script__$1 = script$1;

    /* template */
    var __vue_render__$1 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"control",class:_vm.rootClasses},[(_vm.type !== 'textarea')?_c('input',_vm._b({ref:"input",staticClass:"input",class:[_vm.inputClasses, _vm.customClass],attrs:{"type":_vm.newType,"autocomplete":_vm.newAutocomplete,"maxlength":_vm.maxlength},domProps:{"value":_vm.computedValue},on:{"input":_vm.onInput,"change":_vm.onChange,"blur":_vm.onBlur,"focus":_vm.onFocus}},'input',_vm.$attrs,false)):_c('textarea',_vm._b({ref:"textarea",staticClass:"textarea",class:[_vm.inputClasses, _vm.customClass],attrs:{"maxlength":_vm.maxlength},domProps:{"value":_vm.computedValue},on:{"input":_vm.onInput,"change":_vm.onChange,"blur":_vm.onBlur,"focus":_vm.onFocus}},'textarea',_vm.$attrs,false)),(_vm.icon)?_c('b-icon',{staticClass:"is-left",class:{'is-clickable': _vm.iconClickable},attrs:{"icon":_vm.icon,"pack":_vm.iconPack,"size":_vm.iconSize},nativeOn:{"click":function($event){return _vm.iconClick('icon-click', $event)}}}):_vm._e(),(!_vm.loading && _vm.hasIconRight)?_c('b-icon',{staticClass:"is-right",class:{ 'is-clickable': _vm.passwordReveal || _vm.iconRightClickable },attrs:{"icon":_vm.rightIcon,"pack":_vm.iconPack,"size":_vm.iconSize,"type":_vm.rightIconType,"both":""},nativeOn:{"click":function($event){return _vm.rightIconClick($event)}}}):_vm._e(),(_vm.maxlength && _vm.hasCounter && _vm.type !== 'number')?_c('small',{staticClass:"help counter",class:{ 'is-invisible': !_vm.isFocused }},[_vm._v(" "+_vm._s(_vm.valueLength)+" / "+_vm._s(_vm.maxlength)+" ")]):_vm._e()],1)};
    var __vue_staticRenderFns__$1 = [];

      /* style */
      const __vue_inject_styles__$1 = undefined;
      /* scoped */
      const __vue_scope_id__$1 = undefined;
      /* module identifier */
      const __vue_module_identifier__$1 = undefined;
      /* functional template */
      const __vue_is_functional_template__$1 = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var Input = normalizeComponent_1(
        { render: __vue_render__$1, staticRenderFns: __vue_staticRenderFns__$1 },
        __vue_inject_styles__$1,
        __vue_script__$1,
        __vue_scope_id__$1,
        __vue_is_functional_template__$1,
        __vue_module_identifier__$1,
        undefined,
        undefined
      );

    var script$2 = {
      name: 'BAutocomplete',
      components: _defineProperty({}, Input.name, Input),
      mixins: [FormElementMixin],
      inheritAttrs: false,
      props: {
        value: [Number, String],
        data: {
          type: Array,
          default: function _default() {
            return [];
          }
        },
        field: {
          type: String,
          default: 'value'
        },
        keepFirst: Boolean,
        clearOnSelect: Boolean,
        openOnFocus: Boolean,
        customFormatter: Function,
        checkInfiniteScroll: Boolean,
        keepOpen: Boolean,
        selectOnClickOutside: Boolean,
        clearable: Boolean,
        maxHeight: [String, Number],
        dropdownPosition: {
          type: String,
          default: 'auto'
        },
        groupField: String,
        groupOptions: String,
        iconRight: String,
        iconRightClickable: Boolean,
        appendToBody: Boolean,
        type: {
          type: String,
          default: 'text'
        },
        confirmKeys: {
          type: Array,
          default: function _default() {
            return ['Tab', 'Enter'];
          }
        },
        selectableHeader: Boolean,
        selectableFooter: Boolean
      },
      data: function data() {
        return {
          selected: null,
          hovered: null,
          headerHovered: null,
          footerHovered: null,
          isActive: false,
          newValue: this.value,
          newAutocomplete: this.autocomplete || 'off',
          ariaAutocomplete: this.keepFirst ? 'both' : 'list',
          isListInViewportVertically: true,
          hasFocus: false,
          style: {},
          _isAutocomplete: true,
          _elementRef: 'input',
          _bodyEl: undefined // Used to append to body

        };
      },
      computed: {
        computedData: function computedData() {
          var _this = this;

          if (this.groupField) {
            if (this.groupOptions) {
              var newData = [];
              this.data.forEach(function (option) {
                var group = getValueByPath(option, _this.groupField);
                var items = getValueByPath(option, _this.groupOptions);
                newData.push({
                  group: group,
                  items: items
                });
              });
              return newData;
            } else {
              var tmp = {};
              this.data.forEach(function (option) {
                var group = getValueByPath(option, _this.groupField);
                if (!tmp[group]) tmp[group] = [];
                tmp[group].push(option);
              });
              var _newData = [];
              Object.keys(tmp).forEach(function (group) {
                _newData.push({
                  group: group,
                  items: tmp[group]
                });
              });
              return _newData;
            }
          }

          return [{
            items: this.data
          }];
        },
        isEmpty: function isEmpty() {
          if (!this.computedData) return true;
          return !this.computedData.some(function (element) {
            return element.items && element.items.length;
          });
        },

        /**
         * White-listed items to not close when clicked.
         * Add input, dropdown and all children.
         */
        whiteList: function whiteList() {
          var whiteList = [];
          whiteList.push(this.$refs.input.$el.querySelector('input'));
          whiteList.push(this.$refs.dropdown); // Add all children from dropdown

          if (this.$refs.dropdown !== undefined) {
            var children = this.$refs.dropdown.querySelectorAll('*');
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var child = _step.value;
                whiteList.push(child);
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
          }

          if (this.$parent.$data._isTaginput) {
            // Add taginput container
            whiteList.push(this.$parent.$el); // Add .tag and .delete

            var tagInputChildren = this.$parent.$el.querySelectorAll('*');
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = tagInputChildren[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var tagInputChild = _step2.value;
                whiteList.push(tagInputChild);
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                  _iterator2.return();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
          }

          return whiteList;
        },

        /**
         * Check if exists default slot
         */
        hasDefaultSlot: function hasDefaultSlot() {
          return !!this.$scopedSlots.default;
        },

        /**
         * Check if exists group slot
         */
        hasGroupSlot: function hasGroupSlot() {
          return !!this.$scopedSlots.group;
        },

        /**
         * Check if exists "empty" slot
         */
        hasEmptySlot: function hasEmptySlot() {
          return !!this.$slots.empty;
        },

        /**
         * Check if exists "header" slot
         */
        hasHeaderSlot: function hasHeaderSlot() {
          return !!this.$slots.header;
        },

        /**
         * Check if exists "footer" slot
         */
        hasFooterSlot: function hasFooterSlot() {
          return !!this.$slots.footer;
        },

        /**
         * Apply dropdownPosition property
         */
        isOpenedTop: function isOpenedTop() {
          return this.dropdownPosition === 'top' || this.dropdownPosition === 'auto' && !this.isListInViewportVertically;
        },
        newIconRight: function newIconRight() {
          if (this.clearable && this.newValue) {
            return 'close-circle';
          }

          return this.iconRight;
        },
        newIconRightClickable: function newIconRightClickable() {
          if (this.clearable) {
            return true;
          }

          return this.iconRightClickable;
        },
        contentStyle: function contentStyle() {
          return {
            maxHeight: toCssWidth(this.maxHeight)
          };
        }
      },
      watch: {
        /**
         * When dropdown is toggled, check the visibility to know when
         * to open upwards.
         */
        isActive: function isActive(active) {
          var _this2 = this;

          if (this.dropdownPosition === 'auto') {
            if (active) {
              this.calcDropdownInViewportVertical();
            } else {
              // Timeout to wait for the animation to finish before recalculating
              setTimeout(function () {
                _this2.calcDropdownInViewportVertical();
              }, 100);
            }
          }
        },

        /**
         * When updating input's value
         *   1. Emit changes
         *   2. If value isn't the same as selected, set null
         *   3. Close dropdown if value is clear or else open it
         */
        newValue: function newValue(value) {
          this.$emit('input', value); // Check if selected is invalid

          var currentValue = this.getValue(this.selected);

          if (currentValue && currentValue !== value) {
            this.setSelected(null, false);
          } // Close dropdown if input is clear or else open it


          if (this.hasFocus && (!this.openOnFocus || value)) {
            this.isActive = !!value;
          }
        },

        /**
         * When v-model is changed:
         *   1. Update internal value.
         *   2. If it's invalid, validate again.
         */
        value: function value(_value) {
          this.newValue = _value;
        },

        /**
         * Select first option if "keep-first
         */
        data: function data() {
          var _this3 = this;

          // Keep first option always pre-selected
          if (this.keepFirst) {
            this.$nextTick(function () {
              if (_this3.isActive) {
                _this3.selectFirstOption(_this3.computedData);
              } else {
                _this3.setHovered(null);
              }
            });
          } else {
            if (this.hovered) {
              // reset hovered if list doesn't contain it
              var hoveredValue = this.getValue(this.hovered);
              var data = this.computedData.map(function (d) {
                return d.items;
              }).reduce(function (a, b) {
                return [].concat(_toConsumableArray(a), _toConsumableArray(b));
              }, []);

              if (!data.some(function (d) {
                return _this3.getValue(d) === hoveredValue;
              })) {
                this.setHovered(null);
              }
            }
          }
        }
      },
      methods: {
        /**
         * Set which option is currently hovered.
         */
        setHovered: function setHovered(option) {
          if (option === undefined) return;
          this.hovered = option;
        },

        /**
         * Set which option is currently selected, update v-model,
         * update input value and close dropdown.
         */
        setSelected: function setSelected(option) {
          var _this4 = this;

          var closeDropdown = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          var event = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
          if (option === undefined) return;
          this.selected = option;
          this.$emit('select', this.selected, event);

          if (this.selected !== null) {
            if (this.clearOnSelect) {
              var input = this.$refs.input;
              input.newValue = '';
              input.$refs.input.value = '';
            } else {
              this.newValue = this.getValue(this.selected);
            }

            this.setHovered(null);
          }

          closeDropdown && this.$nextTick(function () {
            _this4.isActive = false;
          });
          this.checkValidity();
        },

        /**
         * Select first option
         */
        selectFirstOption: function selectFirstOption(computedData) {
          var _this5 = this;

          this.$nextTick(function () {
            var nonEmptyElements = computedData.filter(function (element) {
              return element.items && element.items.length;
            });

            if (nonEmptyElements.length) {
              var option = nonEmptyElements[0].items[0];

              _this5.setHovered(option);
            } else {
              _this5.setHovered(null);
            }
          });
        },
        keydown: function keydown(event) {
          var key = event.key; // cannot destructure preventDefault (https://stackoverflow.com/a/49616808/2774496)
          // prevent emit submit event

          if (key === 'Enter') event.preventDefault(); // Close dropdown on Tab & no hovered

          if (key === 'Escape' || key === 'Tab') {
            this.isActive = false;
          }

          if (this.confirmKeys.indexOf(key) >= 0) {
            // If adding by comma, don't add the comma to the input
            if (key === ',') event.preventDefault(); // Close dropdown on select by Tab

            var closeDropdown = !this.keepOpen || key === 'Tab';

            if (this.hovered === null) {
              // header and footer uses headerHovered && footerHovered. If header or footer
              // was selected then fire event otherwise just return so a value isn't selected
              this.checkIfHeaderOrFooterSelected(event, null, closeDropdown);
              return;
            }

            this.setSelected(this.hovered, closeDropdown, event);
          }
        },
        selectHeaderOrFoterByClick: function selectHeaderOrFoterByClick(event, origin) {
          this.checkIfHeaderOrFooterSelected(event, {
            origin: origin
          });
        },

        /**
         * Check if header or footer was selected.
         */
        checkIfHeaderOrFooterSelected: function checkIfHeaderOrFooterSelected(event, triggerClick) {
          var closeDropdown = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

          if (this.selectableHeader && (this.headerHovered || triggerClick && triggerClick.origin === 'header')) {
            this.$emit('select-header', event);
            this.headerHovered = false;
            if (triggerClick) this.setHovered(null);
            if (closeDropdown) this.isActive = false;
          }

          if (this.selectableFooter && (this.footerHovered || triggerClick && triggerClick.origin === 'footer')) {
            this.$emit('select-footer', event);
            this.footerHovered = false;
            if (triggerClick) this.setHovered(null);
            if (closeDropdown) this.isActive = false;
          }
        },

        /**
         * Close dropdown if clicked outside.
         */
        clickedOutside: function clickedOutside(event) {
          var target = isCustomElement(this) ? event.composedPath()[0] : event.target;

          if (!this.hasFocus && this.whiteList.indexOf(target) < 0) {
            if (this.keepFirst && this.hovered && this.selectOnClickOutside) {
              this.setSelected(this.hovered, true);
            } else {
              this.isActive = false;
            }
          }
        },

        /**
         * Return display text for the input.
         * If object, get value from path, or else just the value.
         */
        getValue: function getValue(option) {
          if (option === null) return;

          if (typeof this.customFormatter !== 'undefined') {
            return this.customFormatter(option);
          }

          return _typeof(option) === 'object' ? getValueByPath(option, this.field) : option;
        },

        /**
         * Check if the scroll list inside the dropdown
         * reached it's end.
         */
        checkIfReachedTheEndOfScroll: function checkIfReachedTheEndOfScroll(list) {
          if (list.clientHeight !== list.scrollHeight && list.scrollTop + list.clientHeight >= list.scrollHeight) {
            this.$emit('infinite-scroll');
          }
        },

        /**
         * Calculate if the dropdown is vertically visible when activated,
         * otherwise it is openened upwards.
         */
        calcDropdownInViewportVertical: function calcDropdownInViewportVertical() {
          var _this6 = this;

          this.$nextTick(function () {
            /**
             * this.$refs.dropdown may be undefined
             * when Autocomplete is conditional rendered
             */
            if (_this6.$refs.dropdown === undefined) return;

            var rect = _this6.$refs.dropdown.getBoundingClientRect();

            _this6.isListInViewportVertically = rect.top >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight);

            if (_this6.appendToBody) {
              _this6.updateAppendToBody();
            }
          });
        },

        /**
         * Arrows keys listener.
         * If dropdown is active, set hovered option, or else just open.
         */
        keyArrows: function keyArrows(direction) {
          var sum = direction === 'down' ? 1 : -1;

          if (this.isActive) {
            var data = this.computedData.map(function (d) {
              return d.items;
            }).reduce(function (a, b) {
              return [].concat(_toConsumableArray(a), _toConsumableArray(b));
            }, []);

            if (this.hasHeaderSlot && this.selectableHeader) {
              data.unshift(undefined);
            }

            if (this.hasFooterSlot && this.selectableFooter) {
              data.push(undefined);
            }

            var index;

            if (this.headerHovered) {
              index = 0 + sum;
            } else if (this.footerHovered) {
              index = data.length - 1 + sum;
            } else {
              index = data.indexOf(this.hovered) + sum;
            }

            index = index > data.length - 1 ? data.length - 1 : index;
            index = index < 0 ? 0 : index;
            this.footerHovered = false;
            this.headerHovered = false;
            this.setHovered(data[index] !== undefined ? data[index] : null);

            if (this.hasFooterSlot && this.selectableFooter && index === data.length - 1) {
              this.footerHovered = true;
            }

            if (this.hasHeaderSlot && this.selectableHeader && index === 0) {
              this.headerHovered = true;
            }

            var list = this.$refs.dropdown.querySelector('.dropdown-content');
            var querySelectorText = 'a.dropdown-item:not(.is-disabled)';

            if (this.hasHeaderSlot && this.selectableHeader) {
              querySelectorText += ',div.dropdown-header';
            }

            if (this.hasFooterSlot && this.selectableFooter) {
              querySelectorText += ',div.dropdown-footer';
            }

            var element = list.querySelectorAll(querySelectorText)[index];
            if (!element) return;
            var visMin = list.scrollTop;
            var visMax = list.scrollTop + list.clientHeight - element.clientHeight;

            if (element.offsetTop < visMin) {
              list.scrollTop = element.offsetTop;
            } else if (element.offsetTop >= visMax) {
              list.scrollTop = element.offsetTop - list.clientHeight + element.clientHeight;
            }
          } else {
            this.isActive = true;
          }
        },

        /**
         * Focus listener.
         * If value is the same as selected, select all text.
         */
        focused: function focused(event) {
          if (this.getValue(this.selected) === this.newValue) {
            this.$el.querySelector('input').select();
          }

          if (this.openOnFocus) {
            this.isActive = true;

            if (this.keepFirst) {
              // If open on focus, update the hovered
              this.selectFirstOption(this.computedData);
            }
          }

          this.hasFocus = true;
          this.$emit('focus', event);
        },

        /**
         * Blur listener.
         */
        onBlur: function onBlur(event) {
          this.hasFocus = false;
          this.$emit('blur', event);
        },
        onInput: function onInput() {
          var currentValue = this.getValue(this.selected);
          if (currentValue && currentValue === this.newValue) return;
          this.$emit('typing', this.newValue);
          this.checkValidity();
        },
        rightIconClick: function rightIconClick(event) {
          if (this.clearable) {
            this.newValue = '';
            this.setSelected(null, false);

            if (this.openOnFocus) {
              this.$refs.input.$el.focus();
            }
          } else {
            this.$emit('icon-right-click', event);
          }
        },
        checkValidity: function checkValidity() {
          var _this7 = this;

          if (this.useHtml5Validation) {
            this.$nextTick(function () {
              _this7.checkHtml5Validity();
            });
          }
        },
        updateAppendToBody: function updateAppendToBody() {
          var dropdownMenu = this.$refs.dropdown;
          var trigger = this.$refs.input.$el;

          if (dropdownMenu && trigger) {
            // update wrapper dropdown
            var root = this.$data._bodyEl;
            root.classList.forEach(function (item) {
              return root.classList.remove(item);
            });
            root.classList.add('autocomplete');
            root.classList.add('control');

            if (this.expandend) {
              root.classList.add('is-expandend');
            }

            var rect = trigger.getBoundingClientRect();
            var top = rect.top + window.scrollY;
            var left = rect.left + window.scrollX;

            if (!this.isOpenedTop) {
              top += trigger.clientHeight;
            } else {
              top -= dropdownMenu.clientHeight;
            }

            this.style = {
              position: 'absolute',
              top: "".concat(top, "px"),
              left: "".concat(left, "px"),
              width: "".concat(trigger.clientWidth, "px"),
              maxWidth: "".concat(trigger.clientWidth, "px"),
              zIndex: '99'
            };
          }
        }
      },
      created: function created() {
        if (typeof window !== 'undefined') {
          document.addEventListener('click', this.clickedOutside);

          if (this.dropdownPosition === 'auto') {
            window.addEventListener('resize', this.calcDropdownInViewportVertical);
          }
        }
      },
      mounted: function mounted() {
        var _this8 = this;

        if (this.checkInfiniteScroll && this.$refs.dropdown && this.$refs.dropdown.querySelector('.dropdown-content')) {
          var list = this.$refs.dropdown.querySelector('.dropdown-content');
          list.addEventListener('scroll', function () {
            return _this8.checkIfReachedTheEndOfScroll(list);
          });
        }

        if (this.appendToBody) {
          this.$data._bodyEl = createAbsoluteElement(this.$refs.dropdown);
          this.updateAppendToBody();
        }
      },
      beforeDestroy: function beforeDestroy() {
        if (typeof window !== 'undefined') {
          document.removeEventListener('click', this.clickedOutside);

          if (this.dropdownPosition === 'auto') {
            window.removeEventListener('resize', this.calcDropdownInViewportVertical);
          }
        }

        if (this.checkInfiniteScroll && this.$refs.dropdown && this.$refs.dropdown.querySelector('.dropdown-content')) {
          var list = this.$refs.dropdown.querySelector('.dropdown-content');
          list.removeEventListener('scroll', this.checkIfReachedTheEndOfScroll);
        }

        if (this.appendToBody) {
          removeElement(this.$data._bodyEl);
        }
      }
    };

    /* script */
    const __vue_script__$2 = script$2;

    /* template */
    var __vue_render__$2 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"autocomplete control",class:{ 'is-expanded': _vm.expanded }},[_c('b-input',_vm._b({ref:"input",attrs:{"type":_vm.type,"size":_vm.size,"loading":_vm.loading,"rounded":_vm.rounded,"icon":_vm.icon,"icon-right":_vm.newIconRight,"icon-right-clickable":_vm.newIconRightClickable,"icon-pack":_vm.iconPack,"maxlength":_vm.maxlength,"autocomplete":_vm.newAutocomplete,"use-html5-validation":false,"aria-autocomplete":_vm.ariaAutocomplete},on:{"input":_vm.onInput,"focus":_vm.focused,"blur":_vm.onBlur,"icon-right-click":_vm.rightIconClick,"icon-click":function (event) { return _vm.$emit('icon-click', event); }},nativeOn:{"keydown":[function($event){return _vm.keydown($event)},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"up",38,$event.key,["Up","ArrowUp"])){ return null; }$event.preventDefault();return _vm.keyArrows('up')},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"down",40,$event.key,["Down","ArrowDown"])){ return null; }$event.preventDefault();return _vm.keyArrows('down')}]},model:{value:(_vm.newValue),callback:function ($$v) {_vm.newValue=$$v;},expression:"newValue"}},'b-input',_vm.$attrs,false)),_c('transition',{attrs:{"name":"fade"}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.isActive && (!_vm.isEmpty || _vm.hasEmptySlot || _vm.hasHeaderSlot)),expression:"isActive && (!isEmpty || hasEmptySlot || hasHeaderSlot)"}],ref:"dropdown",staticClass:"dropdown-menu",class:{ 'is-opened-top': _vm.isOpenedTop && !_vm.appendToBody },style:(_vm.style)},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.isActive),expression:"isActive"}],staticClass:"dropdown-content",style:(_vm.contentStyle)},[(_vm.hasHeaderSlot)?_c('div',{staticClass:"dropdown-item dropdown-header",class:{ 'is-hovered': _vm.headerHovered },attrs:{"role":"button","tabindex":"0"},on:{"click":function($event){return _vm.selectHeaderOrFoterByClick($event, 'header')}}},[_vm._t("header")],2):_vm._e(),_vm._l((_vm.computedData),function(element,groupindex){return [(element.group)?_c('div',{key:groupindex + 'group',staticClass:"dropdown-item"},[(_vm.hasGroupSlot)?_vm._t("group",null,{"group":element.group,"index":groupindex}):_c('span',{staticClass:"has-text-weight-bold"},[_vm._v(" "+_vm._s(element.group)+" ")])],2):_vm._e(),_vm._l((element.items),function(option,index){return _c('a',{key:groupindex + ':' + index,staticClass:"dropdown-item",class:{ 'is-hovered': option === _vm.hovered },attrs:{"role":"button","tabindex":"0"},on:{"click":function($event){$event.stopPropagation();return _vm.setSelected(option, !_vm.keepOpen, $event)}}},[(_vm.hasDefaultSlot)?_vm._t("default",null,{"option":option,"index":index}):_c('span',[_vm._v(" "+_vm._s(_vm.getValue(option, true))+" ")])],2)})]}),(_vm.isEmpty && _vm.hasEmptySlot)?_c('div',{staticClass:"dropdown-item is-disabled"},[_vm._t("empty")],2):_vm._e(),(_vm.hasFooterSlot)?_c('div',{staticClass:"dropdown-item dropdown-footer",class:{ 'is-hovered': _vm.footerHovered },attrs:{"role":"button","tabindex":"0"},on:{"click":function($event){return _vm.selectHeaderOrFoterByClick($event, 'footer')}}},[_vm._t("footer")],2):_vm._e()],2)])])],1)};
    var __vue_staticRenderFns__$2 = [];

      /* style */
      const __vue_inject_styles__$2 = undefined;
      /* scoped */
      const __vue_scope_id__$2 = undefined;
      /* module identifier */
      const __vue_module_identifier__$2 = undefined;
      /* functional template */
      const __vue_is_functional_template__$2 = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var Autocomplete = normalizeComponent_1(
        { render: __vue_render__$2, staticRenderFns: __vue_staticRenderFns__$2 },
        __vue_inject_styles__$2,
        __vue_script__$2,
        __vue_scope_id__$2,
        __vue_is_functional_template__$2,
        __vue_module_identifier__$2,
        undefined,
        undefined
      );

    var Plugin = {
      install: function install(Vue) {
        registerComponent(Vue, Autocomplete);
      }
    };
    use(Plugin);

    //
    var script$3 = {
      name: 'BBreadcrumb',
      props: {
        align: {
          type: String,
          default: function _default() {
            return config$2.defaultBreadcrumbAlign;
          }
        },
        separator: {
          type: String,
          default: function _default() {
            return config$2.defaultBreadcrumbSeparator;
          }
        },
        size: {
          type: String,
          default: function _default() {
            return config$2.defaultBreadcrumbSize;
          }
        }
      },
      computed: {
        breadcrumbClasses: function breadcrumbClasses() {
          return ['breadcrumb', this.align, this.separator, this.size];
        }
      }
    };

    /* script */
    const __vue_script__$3 = script$3;

    /* template */
    var __vue_render__$3 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('nav',{class:_vm.breadcrumbClasses},[_c('ul',[_vm._t("default")],2)])};
    var __vue_staticRenderFns__$3 = [];

      /* style */
      const __vue_inject_styles__$3 = undefined;
      /* scoped */
      const __vue_scope_id__$3 = undefined;
      /* module identifier */
      const __vue_module_identifier__$3 = undefined;
      /* functional template */
      const __vue_is_functional_template__$3 = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var Breadcrumb = normalizeComponent_1(
        { render: __vue_render__$3, staticRenderFns: __vue_staticRenderFns__$3 },
        __vue_inject_styles__$3,
        __vue_script__$3,
        __vue_scope_id__$3,
        __vue_is_functional_template__$3,
        __vue_module_identifier__$3,
        undefined,
        undefined
      );

    //
    var script$1$1 = {
      name: 'BBreadcrumbItem',
      inheritAttrs: false,
      props: {
        tag: {
          type: String,
          default: function _default() {
            return config$2.defaultBreadcrumbTag;
          }
        },
        active: Boolean
      }
    };

    /* script */
    const __vue_script__$1$1 = script$1$1;

    /* template */
    var __vue_render__$1$1 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('li',{class:{ 'is-active': _vm.active }},[_c(_vm.tag,_vm._g(_vm._b({tag:"component"},'component',_vm.$attrs,false),_vm.$listeners),[_vm._t("default")],2)],1)};
    var __vue_staticRenderFns__$1$1 = [];

      /* style */
      const __vue_inject_styles__$1$1 = undefined;
      /* scoped */
      const __vue_scope_id__$1$1 = undefined;
      /* module identifier */
      const __vue_module_identifier__$1$1 = undefined;
      /* functional template */
      const __vue_is_functional_template__$1$1 = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var BreadcrumbItem = normalizeComponent_1(
        { render: __vue_render__$1$1, staticRenderFns: __vue_staticRenderFns__$1$1 },
        __vue_inject_styles__$1$1,
        __vue_script__$1$1,
        __vue_scope_id__$1$1,
        __vue_is_functional_template__$1$1,
        __vue_module_identifier__$1$1,
        undefined,
        undefined
      );

    var Plugin$1 = {
      install: function install(Vue) {
        registerComponent(Vue, Breadcrumb);
        registerComponent(Vue, BreadcrumbItem);
      }
    };
    use(Plugin$1);

    var script$4 = {
      name: 'BButton',
      components: _defineProperty({}, Icon.name, Icon),
      inheritAttrs: false,
      props: {
        type: [String, Object],
        size: String,
        label: String,
        iconPack: String,
        iconLeft: String,
        iconRight: String,
        rounded: {
          type: Boolean,
          default: function _default() {
            return config$2.defaultButtonRounded;
          }
        },
        loading: Boolean,
        outlined: Boolean,
        expanded: Boolean,
        inverted: Boolean,
        focused: Boolean,
        active: Boolean,
        hovered: Boolean,
        selected: Boolean,
        nativeType: {
          type: String,
          default: 'button',
          validator: function validator(value) {
            return ['button', 'submit', 'reset'].indexOf(value) >= 0;
          }
        },
        tag: {
          type: String,
          default: 'button',
          validator: function validator(value) {
            return config$2.defaultLinkTags.indexOf(value) >= 0;
          }
        }
      },
      computed: {
        computedTag: function computedTag() {
          if (this.$attrs.disabled !== undefined && this.$attrs.disabled !== false) {
            return 'button';
          }

          return this.tag;
        },
        iconSize: function iconSize() {
          if (!this.size || this.size === 'is-medium') {
            return 'is-small';
          } else if (this.size === 'is-large') {
            return 'is-medium';
          }

          return this.size;
        }
      }
    };

    /* script */
    const __vue_script__$4 = script$4;

    /* template */
    var __vue_render__$4 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(_vm.computedTag,_vm._g(_vm._b({tag:"component",staticClass:"button",class:[_vm.size, _vm.type, {
            'is-rounded': _vm.rounded,
            'is-loading': _vm.loading,
            'is-outlined': _vm.outlined,
            'is-fullwidth': _vm.expanded,
            'is-inverted': _vm.inverted,
            'is-focused': _vm.focused,
            'is-active': _vm.active,
            'is-hovered': _vm.hovered,
            'is-selected': _vm.selected
        }],attrs:{"type":_vm.nativeType}},'component',_vm.$attrs,false),_vm.$listeners),[(_vm.iconLeft)?_c('b-icon',{attrs:{"pack":_vm.iconPack,"icon":_vm.iconLeft,"size":_vm.iconSize}}):_vm._e(),(_vm.label)?_c('span',[_vm._v(_vm._s(_vm.label))]):(_vm.$slots.default)?_c('span',[_vm._t("default")],2):_vm._e(),(_vm.iconRight)?_c('b-icon',{attrs:{"pack":_vm.iconPack,"icon":_vm.iconRight,"size":_vm.iconSize}}):_vm._e()],1)};
    var __vue_staticRenderFns__$4 = [];

      /* style */
      const __vue_inject_styles__$4 = undefined;
      /* scoped */
      const __vue_scope_id__$4 = undefined;
      /* module identifier */
      const __vue_module_identifier__$4 = undefined;
      /* functional template */
      const __vue_is_functional_template__$4 = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var Button = normalizeComponent_1(
        { render: __vue_render__$4, staticRenderFns: __vue_staticRenderFns__$4 },
        __vue_inject_styles__$4,
        __vue_script__$4,
        __vue_scope_id__$4,
        __vue_is_functional_template__$4,
        __vue_module_identifier__$4,
        undefined,
        undefined
      );

    var Plugin$2 = {
      install: function install(Vue) {
        registerComponent(Vue, Button);
      }
    };
    use(Plugin$2);

    var items = 1;
    var sorted = 3;
    var Sorted = sorted;
    var ProviderParentMixin = (function (itemName) {
      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var mixin = {
        provide: function provide() {
          return _defineProperty({}, 'b' + itemName, this);
        }
      };

      if (hasFlag(flags, items)) {
        mixin.data = function () {
          return {
            childItems: []
          };
        };

        mixin.methods = {
          _registerItem: function _registerItem(item) {
            this.childItems.push(item);
          },
          _unregisterItem: function _unregisterItem(item) {
            this.childItems = this.childItems.filter(function (i) {
              return i !== item;
            });
          }
        };

        if (hasFlag(flags, sorted)) {
          mixin.watch = {
            /**
             * When items are added/removed deep search in the elements default's slot
             * And mark the items with their index
             */
            childItems: function childItems(items) {
              if (items.length > 0 && this.$scopedSlots.default) {
                var tag = items[0].$vnode.tag;
                var index = 0;

                var deepSearch = function deepSearch(children) {
                  var _iteratorNormalCompletion = true;
                  var _didIteratorError = false;
                  var _iteratorError = undefined;

                  try {
                    var _loop = function _loop() {
                      var child = _step.value;

                      if (child.tag === tag) {
                        // An item with the same tag will for sure be found
                        var it = items.find(function (i) {
                          return i.$vnode === child;
                        });

                        if (it) {
                          it.index = index++;
                        }
                      } else if (child.tag) {
                        var sub = child.componentInstance ? child.componentInstance.$scopedSlots.default ? child.componentInstance.$scopedSlots.default() : child.componentInstance.$children : child.children;

                        if (Array.isArray(sub) && sub.length > 0) {
                          deepSearch(sub.map(function (e) {
                            return e.$vnode;
                          }));
                        }
                      }
                    };

                    for (var _iterator = children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                      _loop();
                    }
                  } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                      }
                    } finally {
                      if (_didIteratorError) {
                        throw _iteratorError;
                      }
                    }
                  }

                  return false;
                };

                deepSearch(this.$scopedSlots.default());
              }
            }
          };
          mixin.computed = {
            /**
             * When items are added/removed sort them according to their position
             */
            sortedItems: function sortedItems() {
              return this.childItems.slice().sort(function (i1, i2) {
                return i1.index - i2.index;
              });
            }
          };
        }
      }

      return mixin;
    });

    var sorted$1 = 1;
    var optional = 2;
    var Sorted$1 = sorted$1;
    var InjectedChildMixin = (function (parentItemName) {
      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var mixin = {
        inject: {
          parent: {
            from: 'b' + parentItemName,
            default: false
          }
        },
        created: function created() {
          if (!this.parent) {
            if (!hasFlag(flags, optional)) {
              this.$destroy();
              throw new Error('You should wrap ' + this.$options.name + ' in a ' + parentItemName);
            }
          } else if (this.parent._registerItem) {
            this.parent._registerItem(this);
          }
        },
        beforeDestroy: function beforeDestroy() {
          if (this.parent && this.parent._unregisterItem) {
            this.parent._unregisterItem(this);
          }
        }
      };

      if (hasFlag(flags, sorted$1)) {
        mixin.data = function () {
          return {
            index: null
          };
        };
      }

      return mixin;
    });

    var script$5 = {
      name: 'BImage',
      props: {
        src: String,
        alt: String,
        srcFallback: String,
        webpFallback: {
          type: String,
          default: function _default() {
            return config$2.defaultImageWebpFallback;
          }
        },
        lazy: {
          type: Boolean,
          default: function _default() {
            return config$2.defaultImageLazy;
          }
        },
        responsive: {
          type: Boolean,
          default: function _default() {
            return config$2.defaultImageResponsive;
          }
        },
        ratio: {
          type: String,
          default: function _default() {
            return config$2.defaultImageRatio;
          }
        },
        placeholder: String,
        srcset: String,
        srcsetSizes: Array,
        srcsetFormatter: {
          type: Function,
          default: function _default(src, size, vm) {
            if (typeof config$2.defaultImageSrcsetFormatter === 'function') {
              return config$2.defaultImageSrcsetFormatter(src, size);
            } else {
              return vm.formatSrcset(src, size);
            }
          }
        },
        rounded: {
          type: Boolean,
          default: false
        },
        captionFirst: {
          type: Boolean,
          default: false
        },
        customClass: String
      },
      data: function data() {
        return {
          clientWidth: 0,
          webpSupportVerified: false,
          webpSupported: false,
          useNativeLazy: false,
          observer: null,
          inViewPort: false,
          bulmaKnownRatio: ['square', '1by1', '5by4', '4by3', '3by2', '5by3', '16by9', 'b2y1', '3by1', '4by5', '3by4', '2by3', '3by5', '9by16', '1by2', '1by3'],
          loaded: false,
          failed: false
        };
      },
      computed: {
        ratioPattern: function ratioPattern() {
          return new RegExp(/([0-9]+)by([0-9]+)/);
        },
        hasRatio: function hasRatio() {
          return this.ratio && this.ratioPattern.test(this.ratio);
        },
        figureClasses: function figureClasses() {
          var classes = {
            image: this.responsive
          };

          if (this.hasRatio && this.bulmaKnownRatio.indexOf(this.ratio) >= 0) {
            classes["is-".concat(this.ratio)] = true;
          }

          return classes;
        },
        figureStyles: function figureStyles() {
          if (this.hasRatio && this.bulmaKnownRatio.indexOf(this.ratio) < 0) {
            var ratioValues = this.ratioPattern.exec(this.ratio);
            return {
              paddingTop: "".concat(ratioValues[2] / ratioValues[1] * 100, "%")
            };
          }
        },
        imgClasses: function imgClasses() {
          return _defineProperty({
            'is-rounded': this.rounded,
            'has-ratio': this.hasRatio
          }, this.customClass, !!this.customClass);
        },
        srcExt: function srcExt() {
          return this.getExt(this.src);
        },
        isWepb: function isWepb() {
          return this.srcExt === 'webp';
        },
        computedSrc: function computedSrc() {
          var src = this.src;

          if (this.failed && this.srcFallback) {
            src = this.srcFallback;
          }

          if (!this.webpSupported && this.isWepb && this.webpFallback) {
            if (this.webpFallback.startsWith('.')) {
              return src.replace(/\.webp/gi, "".concat(this.webpFallback));
            }

            return this.webpFallback;
          }

          return src;
        },
        computedWidth: function computedWidth() {
          if (this.responsive && this.clientWidth > 0) {
            return this.clientWidth;
          }
        },
        computedNativeLazy: function computedNativeLazy() {
          if (this.lazy && this.useNativeLazy) {
            return 'lazy';
          }
        },
        isDisplayed: function isDisplayed() {
          return (this.webpSupportVerified || !this.isWepb) && (!this.lazy || this.useNativeLazy || this.inViewPort);
        },
        placeholderExt: function placeholderExt() {
          if (this.placeholder) {
            return this.getExt(this.placeholder);
          }
        },
        isPlaceholderWepb: function isPlaceholderWepb() {
          if (this.placeholder) {
            return this.placeholderExt === 'webp';
          }
        },
        computedPlaceholder: function computedPlaceholder() {
          if (!this.webpSupported && this.isPlaceholderWepb && this.webpFallback && this.webpFallback.startsWith('.')) {
            return this.placeholder.replace(/\.webp/gi, "".concat(this.webpFallback));
          }

          return this.placeholder;
        },
        isPlaceholderDisplayed: function isPlaceholderDisplayed() {
          return !this.loaded && (this.$slots.placeholder || this.placeholder && (this.webpSupportVerified || !this.isPlaceholderWepb));
        },
        computedSrcset: function computedSrcset() {
          var _this = this;

          if (this.srcset) {
            if (!this.webpSupported && this.isWepb && this.webpFallback && this.webpFallback.startsWith('.')) {
              return this.srcset.replace(/\.webp/gi, "".concat(this.webpFallback));
            }

            return this.srcset;
          }

          if (this.srcsetSizes && Array.isArray(this.srcsetSizes) && this.srcsetSizes.length > 0) {
            return this.srcsetSizes.map(function (size) {
              return "".concat(_this.srcsetFormatter(_this.computedSrc, size, _this), " ").concat(size, "w");
            }).join(',');
          }
        },
        computedSizes: function computedSizes() {
          if (this.computedSrcset && this.computedWidth) {
            return "".concat(this.computedWidth, "px");
          }
        },
        isCaptionFirst: function isCaptionFirst() {
          return this.$slots.caption && this.captionFirst;
        },
        isCaptionLast: function isCaptionLast() {
          return this.$slots.caption && !this.captionFirst;
        }
      },
      methods: {
        getExt: function getExt(filename) {
          var clean = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

          if (filename) {
            var noParam = clean ? filename.split('?')[0] : filename;
            return noParam.split('.').pop();
          }

          return '';
        },
        setWidth: function setWidth() {
          this.clientWidth = this.$el.clientWidth;
        },
        formatSrcset: function formatSrcset(src, size) {
          var ext = this.getExt(src, false);
          var name = src.split('.').slice(0, -1).join('.');
          return "".concat(name, "-").concat(size, ".").concat(ext);
        },
        onLoad: function onLoad(event) {
          this.loaded = true;
          this.emit('load', event);
        },
        onError: function onError(event) {
          this.emit('error', event);

          if (!this.failed) {
            this.failed = true;
          }
        },
        emit: function emit(eventName, event) {
          var target = event.target;
          this.$emit(eventName, event, target.currentSrc || target.src || this.computedSrc);
        }
      },
      created: function created() {
        var _this2 = this;

        if (this.isWepb) {
          isWebpSupported().then(function (supported) {
            _this2.webpSupportVerified = true;
            _this2.webpSupported = supported;
          });
        }

        if (this.lazy) {
          // We use native lazy loading if supported
          // We try to use Intersection Observer if native lazy loading is not supported
          // We use the lazy attribute anyway if we cannot detect support (SSR for example).
          var nativeLazySupported = typeof window !== 'undefined' && 'HTMLImageElement' in window && 'loading' in HTMLImageElement.prototype;
          var intersectionObserverSupported = typeof window !== 'undefined' && 'IntersectionObserver' in window;

          if (!nativeLazySupported && intersectionObserverSupported) {
            this.observer = new IntersectionObserver(function (events) {
              var _events$ = events[0],
                  target = _events$.target,
                  isIntersecting = _events$.isIntersecting;

              if (isIntersecting && !_this2.inViewPort) {
                _this2.inViewPort = true;

                _this2.observer.unobserve(target);
              }
            });
          } else {
            this.useNativeLazy = true;
          }
        }
      },
      mounted: function mounted() {
        if (this.lazy && this.observer) {
          this.observer.observe(this.$el);
        }

        this.setWidth();

        if (typeof window !== 'undefined') {
          window.addEventListener('resize', this.setWidth);
        }
      },
      beforeDestroy: function beforeDestroy() {
        if (this.observer) {
          this.observer.disconnect();
        }

        if (typeof window !== 'undefined') {
          window.removeEventListener('resize', this.setWidth);
        }
      }
    };

    /* script */
    const __vue_script__$5 = script$5;

    /* template */
    var __vue_render__$5 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('figure',{staticClass:"b-image-wrapper",class:_vm.figureClasses,style:(_vm.figureStyles)},[(_vm.isCaptionFirst)?_c('figcaption',[_vm._t("caption")],2):_vm._e(),_c('transition',{attrs:{"name":"fade"}},[(_vm.isDisplayed)?_c('img',{class:_vm.imgClasses,attrs:{"srcset":_vm.computedSrcset,"src":_vm.computedSrc,"alt":_vm.alt,"width":_vm.computedWidth,"sizes":_vm.computedSizes,"loading":_vm.computedNativeLazy},on:{"load":_vm.onLoad,"error":_vm.onError}}):_vm._e()]),_c('transition',{attrs:{"name":"fade"}},[(_vm.isPlaceholderDisplayed)?_vm._t("placeholder",[_c('img',{staticClass:"placeholder",class:_vm.imgClasses,attrs:{"src":_vm.computedPlaceholder,"alt":_vm.alt}})]):_vm._e()],2),(_vm.isCaptionLast)?_c('figcaption',[_vm._t("caption")],2):_vm._e()],1)};
    var __vue_staticRenderFns__$5 = [];

      /* style */
      const __vue_inject_styles__$5 = undefined;
      /* scoped */
      const __vue_scope_id__$5 = undefined;
      /* module identifier */
      const __vue_module_identifier__$5 = undefined;
      /* functional template */
      const __vue_is_functional_template__$5 = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var Image$1 = normalizeComponent_1(
        { render: __vue_render__$5, staticRenderFns: __vue_staticRenderFns__$5 },
        __vue_inject_styles__$5,
        __vue_script__$5,
        __vue_scope_id__$5,
        __vue_is_functional_template__$5,
        __vue_module_identifier__$5,
        undefined,
        undefined
      );

    var script$6 = {
      name: 'BCarousel',
      components: _defineProperty({}, Icon.name, Icon),
      mixins: [ProviderParentMixin('carousel', Sorted)],
      props: {
        value: {
          type: Number,
          default: 0
        },
        animated: {
          type: String,
          default: 'slide'
        },
        interval: Number,
        hasDrag: {
          type: Boolean,
          default: true
        },
        autoplay: {
          type: Boolean,
          default: true
        },
        pauseHover: {
          type: Boolean,
          default: true
        },
        pauseInfo: {
          type: Boolean,
          default: true
        },
        pauseInfoType: {
          type: String,
          default: 'is-white'
        },
        pauseText: {
          type: String,
          default: 'Pause'
        },
        arrow: {
          type: Boolean,
          default: true
        },
        arrowHover: {
          type: Boolean,
          default: true
        },
        repeat: {
          type: Boolean,
          default: true
        },
        iconPack: String,
        iconSize: String,
        iconPrev: {
          type: String,
          default: function _default() {
            return config$2.defaultIconPrev;
          }
        },
        iconNext: {
          type: String,
          default: function _default() {
            return config$2.defaultIconNext;
          }
        },
        indicator: {
          type: Boolean,
          default: true
        },
        indicatorBackground: Boolean,
        indicatorCustom: Boolean,
        indicatorCustomSize: {
          type: String,
          default: 'is-small'
        },
        indicatorInside: {
          type: Boolean,
          default: true
        },
        indicatorMode: {
          type: String,
          default: 'click'
        },
        indicatorPosition: {
          type: String,
          default: 'is-bottom'
        },
        indicatorStyle: {
          type: String,
          default: 'is-dots'
        },
        overlay: Boolean,
        progress: Boolean,
        progressType: {
          type: String,
          default: 'is-primary'
        },
        withCarouselList: Boolean
      },
      data: function data() {
        return {
          transition: 'next',
          activeChild: this.value || 0,
          isPause: false,
          dragX: false,
          timer: null
        };
      },
      computed: {
        indicatorClasses: function indicatorClasses() {
          return [{
            'has-background': this.indicatorBackground,
            'has-custom': this.indicatorCustom,
            'is-inside': this.indicatorInside
          }, this.indicatorCustom && this.indicatorCustomSize, this.indicatorInside && this.indicatorPosition];
        },
        // checking arrows
        hasPrev: function hasPrev() {
          return this.repeat || this.activeChild !== 0;
        },
        hasNext: function hasNext() {
          return this.repeat || this.activeChild < this.childItems.length - 1;
        }
      },
      watch: {
        /**
         * When v-model is changed set the new active item.
         */
        value: function value(_value) {
          this.changeActive(_value);
        },

        /**
         * When carousel-items are updated, set active one.
         */
        sortedItems: function sortedItems(items) {
          if (this.activeChild >= items.length && this.activeChild > 0) {
            this.changeActive(this.activeChild - 1);
          }
        },

        /**
         *  When autoplay is changed, start or pause timer accordingly
         */
        autoplay: function autoplay(status) {
          status ? this.startTimer() : this.pauseTimer();
        },

        /**
         *  Since the timer can get paused at the end, if repeat is changed we need to restart it
         */
        repeat: function repeat(status) {
          if (status) {
            this.startTimer();
          }
        }
      },
      methods: {
        startTimer: function startTimer() {
          var _this = this;

          if (!this.autoplay || this.timer) return;
          this.isPause = false;
          this.timer = setInterval(function () {
            if (!_this.repeat && _this.activeChild >= _this.childItems.length - 1) {
              _this.pauseTimer();
            } else {
              _this.next();
            }
          }, this.interval || config$2.defaultCarouselInterval);
        },
        pauseTimer: function pauseTimer() {
          this.isPause = true;

          if (this.timer) {
            clearInterval(this.timer);
            this.timer = null;
          }
        },
        restartTimer: function restartTimer() {
          this.pauseTimer();
          this.startTimer();
        },
        checkPause: function checkPause() {
          if (this.pauseHover && this.autoplay) {
            this.pauseTimer();
          }
        },

        /**
         * Change the active item and emit change event.
         * action only for animated slide, there true = next, false = prev
         */
        changeActive: function changeActive(newIndex) {
          var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          if (this.activeChild === newIndex || isNaN(newIndex)) return;
          direction = direction || newIndex - this.activeChild;
          newIndex = this.repeat ? mod(newIndex, this.childItems.length) : bound(newIndex, 0, this.childItems.length - 1);
          this.transition = direction > 0 ? 'prev' : 'next'; // Transition names are reversed from the actual direction for correct effect

          this.activeChild = newIndex;

          if (newIndex !== this.value) {
            this.$emit('input', newIndex);
          }

          this.restartTimer();
          this.$emit('change', newIndex); // BC
        },
        // Indicator trigger when change active item.
        modeChange: function modeChange(trigger, value) {
          if (this.indicatorMode === trigger) {
            return this.changeActive(value);
          }
        },
        prev: function prev() {
          this.changeActive(this.activeChild - 1, -1);
        },
        next: function next() {
          this.changeActive(this.activeChild + 1, 1);
        },
        // handle drag event
        dragStart: function dragStart(event) {
          if (!this.hasDrag || !event.target.draggable) return;
          this.dragX = event.touches ? event.changedTouches[0].pageX : event.pageX;

          if (event.touches) {
            this.pauseTimer();
          } else {
            event.preventDefault();
          }
        },
        dragEnd: function dragEnd(event) {
          if (this.dragX === false) return;
          var detected = event.touches ? event.changedTouches[0].pageX : event.pageX;
          var diffX = detected - this.dragX;

          if (Math.abs(diffX) > 30) {
            if (diffX < 0) {
              this.next();
            } else {
              this.prev();
            }
          } else {
            event.target.click();
            this.sortedItems[this.activeChild].$emit('click');
            this.$emit('click');
          }

          if (event.touches) {
            this.startTimer();
          }

          this.dragX = false;
        }
      },
      mounted: function mounted() {
        this.startTimer();
      },
      beforeDestroy: function beforeDestroy() {
        this.pauseTimer();
      }
    };

    /* script */
    const __vue_script__$6 = script$6;

    /* template */
    var __vue_render__$6 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"carousel",class:{'is-overlay': _vm.overlay},on:{"mouseenter":_vm.checkPause,"mouseleave":_vm.startTimer}},[(_vm.progress)?_c('progress',{staticClass:"progress",class:_vm.progressType,attrs:{"max":_vm.childItems.length - 1},domProps:{"value":_vm.activeChild}},[_vm._v(" "+_vm._s(_vm.childItems.length - 1)+" ")]):_vm._e(),_c('div',{staticClass:"carousel-items",on:{"mousedown":_vm.dragStart,"mouseup":_vm.dragEnd,"touchstart":function($event){$event.stopPropagation();return _vm.dragStart($event)},"touchend":function($event){$event.stopPropagation();return _vm.dragEnd($event)}}},[_vm._t("default"),(_vm.arrow)?_c('div',{staticClass:"carousel-arrow",class:{'is-hovered': _vm.arrowHover}},[_c('b-icon',{directives:[{name:"show",rawName:"v-show",value:(_vm.hasPrev),expression:"hasPrev"}],staticClass:"has-icons-left",attrs:{"pack":_vm.iconPack,"icon":_vm.iconPrev,"size":_vm.iconSize,"both":""},nativeOn:{"click":function($event){return _vm.prev($event)}}}),_c('b-icon',{directives:[{name:"show",rawName:"v-show",value:(_vm.hasNext),expression:"hasNext"}],staticClass:"has-icons-right",attrs:{"pack":_vm.iconPack,"icon":_vm.iconNext,"size":_vm.iconSize,"both":""},nativeOn:{"click":function($event){return _vm.next($event)}}})],1):_vm._e()],2),(_vm.autoplay && _vm.pauseHover && _vm.pauseInfo && _vm.isPause)?_c('div',{staticClass:"carousel-pause"},[_c('span',{staticClass:"tag",class:_vm.pauseInfoType},[_vm._v(" "+_vm._s(_vm.pauseText)+" ")])]):_vm._e(),(_vm.withCarouselList && !_vm.indicator)?[_vm._t("list",null,{"active":_vm.activeChild,"switch":_vm.changeActive})]:_vm._e(),(_vm.indicator)?_c('div',{staticClass:"carousel-indicator",class:_vm.indicatorClasses},_vm._l((_vm.sortedItems),function(item,index){return _c('a',{key:item._uid,staticClass:"indicator-item",class:{'is-active': item.isActive},on:{"mouseover":function($event){return _vm.modeChange('hover', index)},"click":function($event){return _vm.modeChange('click', index)}}},[_vm._t("indicators",[_c('span',{staticClass:"indicator-style",class:_vm.indicatorStyle})],{"i":index})],2)}),0):_vm._e(),(_vm.overlay)?[_vm._t("overlay")]:_vm._e()],2)};
    var __vue_staticRenderFns__$6 = [];

      /* style */
      const __vue_inject_styles__$6 = undefined;
      /* scoped */
      const __vue_scope_id__$6 = undefined;
      /* module identifier */
      const __vue_module_identifier__$6 = undefined;
      /* functional template */
      const __vue_is_functional_template__$6 = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var Carousel = normalizeComponent_1(
        { render: __vue_render__$6, staticRenderFns: __vue_staticRenderFns__$6 },
        __vue_inject_styles__$6,
        __vue_script__$6,
        __vue_scope_id__$6,
        __vue_is_functional_template__$6,
        __vue_module_identifier__$6,
        undefined,
        undefined
      );

    //
    var script$1$2 = {
      name: 'BCarouselItem',
      mixins: [InjectedChildMixin('carousel', Sorted$1)],
      data: function data() {
        return {
          transitionName: null
        };
      },
      computed: {
        transition: function transition() {
          if (this.parent.animated === 'fade') {
            return 'fade';
          } else if (this.parent.transition) {
            return 'slide-' + this.parent.transition;
          }
        },
        isActive: function isActive() {
          return this.parent.activeChild === this.index;
        }
      }
    };

    /* script */
    const __vue_script__$1$2 = script$1$2;

    /* template */
    var __vue_render__$1$2 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":_vm.transition}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.isActive),expression:"isActive"}],staticClass:"carousel-item"},[_vm._t("default")],2)])};
    var __vue_staticRenderFns__$1$2 = [];

      /* style */
      const __vue_inject_styles__$1$2 = undefined;
      /* scoped */
      const __vue_scope_id__$1$2 = undefined;
      /* module identifier */
      const __vue_module_identifier__$1$2 = undefined;
      /* functional template */
      const __vue_is_functional_template__$1$2 = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var CarouselItem = normalizeComponent_1(
        { render: __vue_render__$1$2, staticRenderFns: __vue_staticRenderFns__$1$2 },
        __vue_inject_styles__$1$2,
        __vue_script__$1$2,
        __vue_scope_id__$1$2,
        __vue_is_functional_template__$1$2,
        __vue_module_identifier__$1$2,
        undefined,
        undefined
      );

    var _components;
    var script$2$1 = {
      name: 'BCarouselList',
      components: (_components = {}, _defineProperty(_components, Icon.name, Icon), _defineProperty(_components, Image$1.name, Image$1), _components),
      props: {
        data: {
          type: Array,
          default: function _default() {
            return [];
          }
        },
        value: {
          type: Number,
          default: 0
        },
        scrollValue: {
          type: Number,
          default: 0
        },
        hasDrag: {
          type: Boolean,
          default: true
        },
        hasGrayscale: Boolean,
        hasOpacity: Boolean,
        repeat: Boolean,
        itemsToShow: {
          type: Number,
          default: 4
        },
        itemsToList: {
          type: Number,
          default: 1
        },
        asIndicator: Boolean,
        arrow: {
          type: Boolean,
          default: true
        },
        arrowHover: {
          type: Boolean,
          default: true
        },
        iconPack: String,
        iconSize: String,
        iconPrev: {
          type: String,
          default: function _default() {
            return config$2.defaultIconPrev;
          }
        },
        iconNext: {
          type: String,
          default: function _default() {
            return config$2.defaultIconNext;
          }
        },
        breakpoints: {
          type: Object,
          default: function _default() {
            return {};
          }
        }
      },
      data: function data() {
        return {
          activeItem: this.value,
          scrollIndex: this.asIndicator ? this.scrollValue : this.value,
          delta: 0,
          dragX: false,
          hold: 0,
          windowWidth: 0,
          touch: false,
          observer: null,
          refresh_: 0
        };
      },
      computed: {
        dragging: function dragging() {
          return this.dragX !== false;
        },
        listClass: function listClass() {
          return [{
            'has-grayscale': this.settings.hasGrayscale,
            'has-opacity': this.settings.hasOpacity,
            'is-dragging': this.dragging
          }];
        },
        itemStyle: function itemStyle() {
          return "width: ".concat(this.itemWidth, "px;");
        },
        translation: function translation() {
          return -bound(this.delta + this.scrollIndex * this.itemWidth, 0, (this.data.length - this.settings.itemsToShow) * this.itemWidth);
        },
        total: function total() {
          return this.data.length - this.settings.itemsToShow;
        },
        hasPrev: function hasPrev() {
          return this.settings.repeat || this.scrollIndex > 0;
        },
        hasNext: function hasNext() {
          return this.settings.repeat || this.scrollIndex < this.total;
        },
        breakpointKeys: function breakpointKeys() {
          return Object.keys(this.breakpoints).sort(function (a, b) {
            return b - a;
          });
        },
        settings: function settings() {
          var _this = this;

          var breakpoint = this.breakpointKeys.filter(function (breakpoint) {
            if (_this.windowWidth >= breakpoint) {
              return true;
            }
          })[0];

          if (breakpoint) {
            return _objectSpread2({}, this.$props, {}, this.breakpoints[breakpoint]);
          }

          return this.$props;
        },
        itemWidth: function itemWidth() {
          if (this.windowWidth) {
            // Ensure component is mounted

            /* eslint-disable-next-line */
            this.refresh_; // We force the computed property to refresh if this prop is changed

            var rect = this.$el.getBoundingClientRect();
            return rect.width / this.settings.itemsToShow;
          }

          return 0;
        }
      },
      watch: {
        /**
         * When v-model is changed set the new active item.
         */
        value: function value(_value) {
          this.switchTo(this.asIndicator ? _value - (this.itemsToShow - 3) / 2 : _value);

          if (this.activeItem !== _value) {
            this.activeItem = bound(_value, 0, this.data.length - 1);
          }
        },
        scrollValue: function scrollValue(value) {
          this.switchTo(value);
        }
      },
      methods: {
        resized: function resized() {
          this.windowWidth = window.innerWidth;
        },
        switchTo: function switchTo(newIndex) {
          if (newIndex === this.scrollIndex || isNaN(newIndex)) {
            return;
          }

          if (this.settings.repeat) {
            newIndex = mod(newIndex, this.total + 1);
          }

          newIndex = bound(newIndex, 0, this.total);
          this.scrollIndex = newIndex;

          if (!this.asIndicator && this.value !== newIndex) {
            this.$emit('input', newIndex);
          } else if (this.scrollIndex !== newIndex) {
            this.$emit('updated:scroll', newIndex);
          }
        },
        next: function next() {
          this.switchTo(this.scrollIndex + this.settings.itemsToList);
        },
        prev: function prev() {
          this.switchTo(this.scrollIndex - this.settings.itemsToList);
        },
        checkAsIndicator: function checkAsIndicator(value, event) {
          if (!this.asIndicator) return;
          var dragEndX = event.changedTouches ? event.changedTouches[0].clientX : event.clientX;
          if (this.hold - Date.now() > 2000 || Math.abs(this.dragX - dragEndX) > 10) return;
          this.dragX = false;
          this.hold = 0;
          event.preventDefault(); // Make the item appear in the middle

          this.activeItem = value;
          this.$emit('switch', value);
        },
        // handle drag event
        dragStart: function dragStart(event) {
          if (this.dragging || !this.settings.hasDrag || event.button !== 0 && event.type !== 'touchstart') return;
          this.hold = Date.now();
          this.touch = !!event.touches;
          this.dragX = this.touch ? event.touches[0].clientX : event.clientX;
          window.addEventListener(this.touch ? 'touchmove' : 'mousemove', this.dragMove);
          window.addEventListener(this.touch ? 'touchend' : 'mouseup', this.dragEnd);
        },
        dragMove: function dragMove(event) {
          if (!this.dragging) return;
          var dragEndX = event.touches ? (event.changedTouches[0] || event.touches[0]).clientX : event.clientX;
          this.delta = this.dragX - dragEndX;

          if (!event.touches) {
            event.preventDefault();
          }
        },
        dragEnd: function dragEnd() {
          if (!this.dragging && !this.hold) return;

          if (this.hold) {
            var signCheck = sign(this.delta);
            var results = Math.round(Math.abs(this.delta / this.itemWidth) + 0.15); // Hack

            this.switchTo(this.scrollIndex + signCheck * results);
          }

          this.delta = 0;
          this.dragX = false;
          window.removeEventListener(this.touch ? 'touchmove' : 'mousemove', this.dragMove);
          window.removeEventListener(this.touch ? 'touchend' : 'mouseup', this.dragEnd);
        },
        refresh: function refresh() {
          var _this2 = this;

          this.$nextTick(function () {
            _this2.refresh_++;
          });
        }
      },
      mounted: function mounted() {
        if (typeof window !== 'undefined') {
          if (window.ResizeObserver) {
            this.observer = new ResizeObserver(this.refresh);
            this.observer.observe(this.$el);
          }

          window.addEventListener('resize', this.resized);
          document.addEventListener('animationend', this.refresh);
          document.addEventListener('transitionend', this.refresh);
          document.addEventListener('transitionstart', this.refresh);
          this.resized();
        }

        if (this.$attrs.config) {
          throw new Error('The config prop was removed, you need to use v-bind instead');
        }
      },
      beforeDestroy: function beforeDestroy() {
        if (typeof window !== 'undefined') {
          if (window.ResizeObserver) {
            this.observer.disconnect();
          }

          window.removeEventListener('resize', this.resized);
          document.removeEventListener('animationend', this.refresh);
          document.removeEventListener('transitionend', this.refresh);
          document.removeEventListener('transitionstart', this.refresh);
          this.dragEnd();
        }
      }
    };

    /* script */
    const __vue_script__$2$1 = script$2$1;

    /* template */
    var __vue_render__$2$1 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"carousel-list",class:{'has-shadow': _vm.scrollIndex > 0},on:{"mousedown":function($event){$event.preventDefault();return _vm.dragStart($event)},"touchstart":_vm.dragStart}},[_c('div',{staticClass:"carousel-slides",class:_vm.listClass,style:('transform:translateX('+_vm.translation+'px)')},_vm._l((_vm.data),function(list,index){return _c('div',{key:index,staticClass:"carousel-slide",class:{'is-active': _vm.asIndicator ? _vm.activeItem === index : _vm.scrollIndex === index},style:(_vm.itemStyle),on:{"mouseup":function($event){return _vm.checkAsIndicator(index, $event)},"touchend":function($event){return _vm.checkAsIndicator(index, $event)}}},[_vm._t("item",[_c('b-image',_vm._b({attrs:{"src":list.image}},'b-image',list,false))],{"index":index,"active":_vm.activeItem,"scroll":_vm.scrollIndex,"list":list},list)],2)}),0),(_vm.arrow)?_c('div',{staticClass:"carousel-arrow",class:{'is-hovered': _vm.settings.arrowHover}},[_c('b-icon',{directives:[{name:"show",rawName:"v-show",value:(_vm.hasPrev),expression:"hasPrev"}],staticClass:"has-icons-left",attrs:{"pack":_vm.settings.iconPack,"icon":_vm.settings.iconPrev,"size":_vm.settings.iconSize,"both":""},nativeOn:{"click":function($event){$event.preventDefault();return _vm.prev($event)}}}),_c('b-icon',{directives:[{name:"show",rawName:"v-show",value:(_vm.hasNext),expression:"hasNext"}],staticClass:"has-icons-right",attrs:{"pack":_vm.settings.iconPack,"icon":_vm.settings.iconNext,"size":_vm.settings.iconSize,"both":""},nativeOn:{"click":function($event){$event.preventDefault();return _vm.next($event)}}})],1):_vm._e()])};
    var __vue_staticRenderFns__$2$1 = [];

      /* style */
      const __vue_inject_styles__$2$1 = undefined;
      /* scoped */
      const __vue_scope_id__$2$1 = undefined;
      /* module identifier */
      const __vue_module_identifier__$2$1 = undefined;
      /* functional template */
      const __vue_is_functional_template__$2$1 = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var CarouselList = normalizeComponent_1(
        { render: __vue_render__$2$1, staticRenderFns: __vue_staticRenderFns__$2$1 },
        __vue_inject_styles__$2$1,
        __vue_script__$2$1,
        __vue_scope_id__$2$1,
        __vue_is_functional_template__$2$1,
        __vue_module_identifier__$2$1,
        undefined,
        undefined
      );

    var Plugin$3 = {
      install: function install(Vue) {
        registerComponent(Vue, Carousel);
        registerComponent(Vue, CarouselItem);
        registerComponent(Vue, CarouselList);
      }
    };
    use(Plugin$3);

    var CheckRadioMixin = {
      props: {
        value: [String, Number, Boolean, Function, Object, Array],
        nativeValue: [String, Number, Boolean, Function, Object, Array],
        type: String,
        disabled: Boolean,
        required: Boolean,
        name: String,
        size: String
      },
      data: function data() {
        return {
          newValue: this.value
        };
      },
      computed: {
        computedValue: {
          get: function get() {
            return this.newValue;
          },
          set: function set(value) {
            this.newValue = value;
            this.$emit('input', value);
          }
        }
      },
      watch: {
        /**
        * When v-model change, set internal value.
        */
        value: function value(_value) {
          this.newValue = _value;
        }
      },
      methods: {
        focus: function focus() {
          // MacOS FireFox and Safari do not focus when clicked
          this.$refs.input.focus();
        }
      }
    };

    //
    var script$7 = {
      name: 'BCheckbox',
      mixins: [CheckRadioMixin],
      props: {
        indeterminate: Boolean,
        ariaLabelledby: String,
        trueValue: {
          type: [String, Number, Boolean, Function, Object, Array],
          default: true
        },
        falseValue: {
          type: [String, Number, Boolean, Function, Object, Array],
          default: false
        },
        autocomplete: {
          type: String,
          default: 'on'
        }
      }
    };

    /* script */
    const __vue_script__$7 = script$7;

    /* template */
    var __vue_render__$7 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('label',{ref:"label",staticClass:"b-checkbox checkbox",class:[_vm.size, { 'is-disabled': _vm.disabled }],attrs:{"disabled":_vm.disabled},on:{"click":_vm.focus,"keydown":[function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"enter",13,$event.key,"Enter")){ return null; }$event.preventDefault();return _vm.$refs.label.click()},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"space",32,$event.key,[" ","Spacebar"])){ return null; }$event.preventDefault();return _vm.$refs.label.click()}]}},[_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.computedValue),expression:"computedValue"}],ref:"input",attrs:{"type":"checkbox","autocomplete":_vm.autocomplete,"disabled":_vm.disabled,"required":_vm.required,"name":_vm.name,"true-value":_vm.trueValue,"false-value":_vm.falseValue,"aria-labelledby":_vm.ariaLabelledby},domProps:{"indeterminate":_vm.indeterminate,"value":_vm.nativeValue,"checked":Array.isArray(_vm.computedValue)?_vm._i(_vm.computedValue,_vm.nativeValue)>-1:_vm._q(_vm.computedValue,_vm.trueValue)},on:{"click":function($event){$event.stopPropagation();},"change":function($event){var $$a=_vm.computedValue,$$el=$event.target,$$c=$$el.checked?(_vm.trueValue):(_vm.falseValue);if(Array.isArray($$a)){var $$v=_vm.nativeValue,$$i=_vm._i($$a,$$v);if($$el.checked){$$i<0&&(_vm.computedValue=$$a.concat([$$v]));}else {$$i>-1&&(_vm.computedValue=$$a.slice(0,$$i).concat($$a.slice($$i+1)));}}else {_vm.computedValue=$$c;}}}}),_c('span',{staticClass:"check",class:_vm.type}),_c('span',{staticClass:"control-label",attrs:{"id":_vm.ariaLabelledby}},[_vm._t("default")],2)])};
    var __vue_staticRenderFns__$7 = [];

      /* style */
      const __vue_inject_styles__$7 = undefined;
      /* scoped */
      const __vue_scope_id__$7 = undefined;
      /* module identifier */
      const __vue_module_identifier__$7 = undefined;
      /* functional template */
      const __vue_is_functional_template__$7 = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var Checkbox = normalizeComponent_1(
        { render: __vue_render__$7, staticRenderFns: __vue_staticRenderFns__$7 },
        __vue_inject_styles__$7,
        __vue_script__$7,
        __vue_scope_id__$7,
        __vue_is_functional_template__$7,
        __vue_module_identifier__$7,
        undefined,
        undefined
      );

    //
    var script$8 = {
      name: 'BCheckboxButton',
      mixins: [CheckRadioMixin],
      props: {
        type: {
          type: String,
          default: 'is-primary'
        },
        expanded: Boolean
      },
      data: function data() {
        return {
          isFocused: false
        };
      },
      computed: {
        checked: function checked() {
          if (Array.isArray(this.newValue)) {
            return this.newValue.indexOf(this.nativeValue) >= 0;
          }

          return this.newValue === this.nativeValue;
        }
      }
    };

    /* script */
    const __vue_script__$8 = script$8;

    /* template */
    var __vue_render__$8 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"control",class:{ 'is-expanded': _vm.expanded }},[_c('label',{ref:"label",staticClass:"b-checkbox checkbox button",class:[_vm.checked ? _vm.type : null, _vm.size, {
                'is-disabled': _vm.disabled,
                'is-focused': _vm.isFocused
            }],attrs:{"disabled":_vm.disabled},on:{"click":_vm.focus,"keydown":function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"enter",13,$event.key,"Enter")){ return null; }$event.preventDefault();return _vm.$refs.label.click()}}},[_vm._t("default"),_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.computedValue),expression:"computedValue"}],ref:"input",attrs:{"type":"checkbox","disabled":_vm.disabled,"required":_vm.required,"name":_vm.name},domProps:{"value":_vm.nativeValue,"checked":Array.isArray(_vm.computedValue)?_vm._i(_vm.computedValue,_vm.nativeValue)>-1:(_vm.computedValue)},on:{"click":function($event){$event.stopPropagation();},"focus":function($event){_vm.isFocused = true;},"blur":function($event){_vm.isFocused = false;},"change":function($event){var $$a=_vm.computedValue,$$el=$event.target,$$c=$$el.checked?(true):(false);if(Array.isArray($$a)){var $$v=_vm.nativeValue,$$i=_vm._i($$a,$$v);if($$el.checked){$$i<0&&(_vm.computedValue=$$a.concat([$$v]));}else {$$i>-1&&(_vm.computedValue=$$a.slice(0,$$i).concat($$a.slice($$i+1)));}}else {_vm.computedValue=$$c;}}}})],2)])};
    var __vue_staticRenderFns__$8 = [];

      /* style */
      const __vue_inject_styles__$8 = undefined;
      /* scoped */
      const __vue_scope_id__$8 = undefined;
      /* module identifier */
      const __vue_module_identifier__$8 = undefined;
      /* functional template */
      const __vue_is_functional_template__$8 = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var CheckboxButton = normalizeComponent_1(
        { render: __vue_render__$8, staticRenderFns: __vue_staticRenderFns__$8 },
        __vue_inject_styles__$8,
        __vue_script__$8,
        __vue_scope_id__$8,
        __vue_is_functional_template__$8,
        __vue_module_identifier__$8,
        undefined,
        undefined
      );

    var Plugin$4 = {
      install: function install(Vue) {
        registerComponent(Vue, Checkbox);
        registerComponent(Vue, CheckboxButton);
      }
    };
    use(Plugin$4);

    var script$9 = {
      name: 'BCollapse',
      // deprecated, to replace with default 'value' in the next breaking change
      model: {
        prop: 'open',
        event: 'update:open'
      },
      props: {
        open: {
          type: Boolean,
          default: true
        },
        animation: {
          type: String,
          default: 'fade'
        },
        ariaId: {
          type: String,
          default: ''
        },
        position: {
          type: String,
          default: 'is-top',
          validator: function validator(value) {
            return ['is-top', 'is-bottom'].indexOf(value) > -1;
          }
        }
      },
      data: function data() {
        return {
          isOpen: this.open
        };
      },
      watch: {
        open: function open(value) {
          this.isOpen = value;
        }
      },
      methods: {
        /**
        * Toggle and emit events
        */
        toggle: function toggle() {
          this.isOpen = !this.isOpen;
          this.$emit('update:open', this.isOpen);
          this.$emit(this.isOpen ? 'open' : 'close');
        }
      },
      render: function render(createElement) {
        var trigger = createElement('div', {
          staticClass: 'collapse-trigger',
          on: {
            click: this.toggle
          }
        }, this.$scopedSlots.trigger ? [this.$scopedSlots.trigger({
          open: this.isOpen
        })] : [this.$slots.trigger]);
        var content = createElement('transition', {
          props: {
            name: this.animation
          }
        }, [createElement('div', {
          staticClass: 'collapse-content',
          attrs: {
            'id': this.ariaId
          },
          directives: [{
            name: 'show',
            value: this.isOpen
          }]
        }, this.$slots.default)]);
        return createElement('div', {
          staticClass: 'collapse'
        }, this.position === 'is-top' ? [trigger, content] : [content, trigger]);
      }
    };

    /* script */
    const __vue_script__$9 = script$9;

    /* template */

      /* style */
      const __vue_inject_styles__$9 = undefined;
      /* scoped */
      const __vue_scope_id__$9 = undefined;
      /* module identifier */
      const __vue_module_identifier__$9 = undefined;
      /* functional template */
      const __vue_is_functional_template__$9 = undefined;
      /* style inject */
      
      /* style inject SSR */
      

      
      var Collapse = normalizeComponent_1(
        {},
        __vue_inject_styles__$9,
        __vue_script__$9,
        __vue_scope_id__$9,
        __vue_is_functional_template__$9,
        __vue_module_identifier__$9,
        undefined,
        undefined
      );

    var Plugin$5 = {
      install: function install(Vue) {
        registerComponent(Vue, Collapse);
      }
    };
    use(Plugin$5);

    var AM = 'AM';
    var PM = 'PM';
    var HOUR_FORMAT_24 = '24';
    var HOUR_FORMAT_12 = '12';

    var defaultTimeFormatter = function defaultTimeFormatter(date, vm) {
      return vm.dtf.format(date);
    };

    var defaultTimeParser = function defaultTimeParser(timeString, vm) {
      if (timeString) {
        var d = null;

        if (vm.computedValue && !isNaN(vm.computedValue)) {
          d = new Date(vm.computedValue);
        } else {
          d = vm.timeCreator();
          d.setMilliseconds(0);
        }

        if (vm.dtf.formatToParts && typeof vm.dtf.formatToParts === 'function') {
          var formatRegex = vm.dtf.formatToParts(d).map(function (part) {
            if (part.type === 'literal') {
              return part.value.replace(/ /g, '\\s?');
            } else if (part.type === 'dayPeriod') {
              return "((?!=<".concat(part.type, ">)(").concat(vm.amString, "|").concat(vm.pmString, "|").concat(AM, "|").concat(PM, "|").concat(AM.toLowerCase(), "|").concat(PM.toLowerCase(), ")?)");
            }

            return "((?!=<".concat(part.type, ">)\\d+)");
          }).join('');
          var timeGroups = matchWithGroups(formatRegex, timeString); // We do a simple validation for the group.
          // If it is not valid, it will fallback to Date.parse below

          timeGroups.hour = timeGroups.hour ? parseInt(timeGroups.hour, 10) : null;
          timeGroups.minute = timeGroups.minute ? parseInt(timeGroups.minute, 10) : null;
          timeGroups.second = timeGroups.second ? parseInt(timeGroups.second, 10) : null;

          if (timeGroups.hour && timeGroups.hour >= 0 && timeGroups.hour < 24 && timeGroups.minute && timeGroups.minute >= 0 && timeGroups.minute < 59) {
            if (timeGroups.dayPeriod && (timeGroups.dayPeriod.toLowerCase() === vm.pmString.toLowerCase() || timeGroups.dayPeriod.toLowerCase() === PM.toLowerCase()) && timeGroups.hour < 12) {
              timeGroups.hour += 12;
            }

            d.setHours(timeGroups.hour);
            d.setMinutes(timeGroups.minute);
            d.setSeconds(timeGroups.second || 0);
            return d;
          }
        } // Fallback if formatToParts is not supported or if we were not able to parse a valid date


        var am = false;

        if (vm.hourFormat === HOUR_FORMAT_12) {
          var dateString12 = timeString.split(' ');
          timeString = dateString12[0];
          am = dateString12[1] === vm.amString || dateString12[1] === AM;
        }

        var time = timeString.split(':');
        var hours = parseInt(time[0], 10);
        var minutes = parseInt(time[1], 10);
        var seconds = vm.enableSeconds ? parseInt(time[2], 10) : 0;

        if (isNaN(hours) || hours < 0 || hours > 23 || vm.hourFormat === HOUR_FORMAT_12 && (hours < 1 || hours > 12) || isNaN(minutes) || minutes < 0 || minutes > 59) {
          return null;
        }

        d.setSeconds(seconds);
        d.setMinutes(minutes);

        if (vm.hourFormat === HOUR_FORMAT_12) {
          if (am && hours === 12) {
            hours = 0;
          } else if (!am && hours !== 12) {
            hours += 12;
          }
        }

        d.setHours(hours);
        return new Date(d.getTime());
      }

      return null;
    };

    var TimepickerMixin = {
      mixins: [FormElementMixin],
      inheritAttrs: false,
      props: {
        value: Date,
        inline: Boolean,
        minTime: Date,
        maxTime: Date,
        placeholder: String,
        editable: Boolean,
        disabled: Boolean,
        hourFormat: {
          type: String,
          validator: function validator(value) {
            return value === HOUR_FORMAT_24 || value === HOUR_FORMAT_12;
          }
        },
        incrementHours: {
          type: Number,
          default: 1
        },
        incrementMinutes: {
          type: Number,
          default: 1
        },
        incrementSeconds: {
          type: Number,
          default: 1
        },
        timeFormatter: {
          type: Function,
          default: function _default(date, vm) {
            if (typeof config$2.defaultTimeFormatter === 'function') {
              return config$2.defaultTimeFormatter(date);
            } else {
              return defaultTimeFormatter(date, vm);
            }
          }
        },
        timeParser: {
          type: Function,
          default: function _default(date, vm) {
            if (typeof config$2.defaultTimeParser === 'function') {
              return config$2.defaultTimeParser(date);
            } else {
              return defaultTimeParser(date, vm);
            }
          }
        },
        mobileNative: {
          type: Boolean,
          default: function _default() {
            return config$2.defaultTimepickerMobileNative;
          }
        },
        timeCreator: {
          type: Function,
          default: function _default() {
            if (typeof config$2.defaultTimeCreator === 'function') {
              return config$2.defaultTimeCreator();
            } else {
              return new Date();
            }
          }
        },
        position: String,
        unselectableTimes: Array,
        openOnFocus: Boolean,
        enableSeconds: Boolean,
        defaultMinutes: Number,
        defaultSeconds: Number,
        focusable: {
          type: Boolean,
          default: true
        },
        tzOffset: {
          type: Number,
          default: 0
        },
        appendToBody: Boolean,
        resetOnMeridianChange: {
          type: Boolean,
          default: false
        }
      },
      data: function data() {
        return {
          dateSelected: this.value,
          hoursSelected: null,
          minutesSelected: null,
          secondsSelected: null,
          meridienSelected: null,
          _elementRef: 'input',
          AM: AM,
          PM: PM,
          HOUR_FORMAT_24: HOUR_FORMAT_24,
          HOUR_FORMAT_12: HOUR_FORMAT_12
        };
      },
      computed: {
        computedValue: {
          get: function get() {
            return this.dateSelected;
          },
          set: function set(value) {
            this.dateSelected = value;
            this.$emit('input', this.dateSelected);
          }
        },
        localeOptions: function localeOptions() {
          return new Intl.DateTimeFormat(this.locale, {
            hour: 'numeric',
            minute: 'numeric',
            second: this.enableSeconds ? 'numeric' : undefined
          }).resolvedOptions();
        },
        dtf: function dtf() {
          return new Intl.DateTimeFormat(this.locale, {
            hour: this.localeOptions.hour || 'numeric',
            minute: this.localeOptions.minute || 'numeric',
            second: this.enableSeconds ? this.localeOptions.second || 'numeric' : undefined,
            // Fixes 12 hour display github.com/buefy/buefy/issues/3418
            hourCycle: !this.isHourFormat24 ? 'h12' : 'h23'
          });
        },
        newHourFormat: function newHourFormat() {
          return this.hourFormat || (this.localeOptions.hour12 ? HOUR_FORMAT_12 : HOUR_FORMAT_24);
        },
        sampleTime: function sampleTime() {
          var d = this.timeCreator();
          d.setHours(10);
          d.setSeconds(0);
          d.setMinutes(0);
          d.setMilliseconds(0);
          return d;
        },
        hourLiteral: function hourLiteral() {
          if (this.dtf.formatToParts && typeof this.dtf.formatToParts === 'function') {
            var d = this.sampleTime;
            var parts = this.dtf.formatToParts(d);
            var literal = parts.find(function (part, idx) {
              return idx > 0 && parts[idx - 1].type === 'hour';
            });

            if (literal) {
              return literal.value;
            }
          }

          return ':';
        },
        minuteLiteral: function minuteLiteral() {
          if (this.dtf.formatToParts && typeof this.dtf.formatToParts === 'function') {
            var d = this.sampleTime;
            var parts = this.dtf.formatToParts(d);
            var literal = parts.find(function (part, idx) {
              return idx > 0 && parts[idx - 1].type === 'minute';
            });

            if (literal) {
              return literal.value;
            }
          }

          return ':';
        },
        secondLiteral: function secondLiteral() {
          if (this.dtf.formatToParts && typeof this.dtf.formatToParts === 'function') {
            var d = this.sampleTime;
            var parts = this.dtf.formatToParts(d);
            var literal = parts.find(function (part, idx) {
              return idx > 0 && parts[idx - 1].type === 'second';
            });

            if (literal) {
              return literal.value;
            }
          }
        },
        amString: function amString() {
          if (this.dtf.formatToParts && typeof this.dtf.formatToParts === 'function') {
            var d = this.sampleTime;
            d.setHours(10);
            var dayPeriod = this.dtf.formatToParts(d).find(function (part) {
              return part.type === 'dayPeriod';
            });

            if (dayPeriod) {
              return dayPeriod.value;
            }
          }

          return AM;
        },
        pmString: function pmString() {
          if (this.dtf.formatToParts && typeof this.dtf.formatToParts === 'function') {
            var d = this.sampleTime;
            d.setHours(20);
            var dayPeriod = this.dtf.formatToParts(d).find(function (part) {
              return part.type === 'dayPeriod';
            });

            if (dayPeriod) {
              return dayPeriod.value;
            }
          }

          return PM;
        },
        hours: function hours() {
          if (!this.incrementHours || this.incrementHours < 1) throw new Error('Hour increment cannot be null or less than 1.');
          var hours = [];
          var numberOfHours = this.isHourFormat24 ? 24 : 12;

          for (var i = 0; i < numberOfHours; i += this.incrementHours) {
            var value = i;
            var label = value;

            if (!this.isHourFormat24) {
              value = i + 1;
              label = value;

              if (this.meridienSelected === this.amString) {
                if (value === 12) {
                  value = 0;
                }
              } else if (this.meridienSelected === this.pmString) {
                if (value !== 12) {
                  value += 12;
                }
              }
            }

            hours.push({
              label: this.formatNumber(label),
              value: value
            });
          }

          return hours;
        },
        minutes: function minutes() {
          if (!this.incrementMinutes || this.incrementMinutes < 1) throw new Error('Minute increment cannot be null or less than 1.');
          var minutes = [];

          for (var i = 0; i < 60; i += this.incrementMinutes) {
            minutes.push({
              label: this.formatNumber(i, true),
              value: i
            });
          }

          return minutes;
        },
        seconds: function seconds() {
          if (!this.incrementSeconds || this.incrementSeconds < 1) throw new Error('Second increment cannot be null or less than 1.');
          var seconds = [];

          for (var i = 0; i < 60; i += this.incrementSeconds) {
            seconds.push({
              label: this.formatNumber(i, true),
              value: i
            });
          }

          return seconds;
        },
        meridiens: function meridiens() {
          return [this.amString, this.pmString];
        },
        isMobile: function isMobile$1() {
          return this.mobileNative && isMobile.any();
        },
        isHourFormat24: function isHourFormat24() {
          return this.newHourFormat === HOUR_FORMAT_24;
        }
      },
      watch: {
        hourFormat: function hourFormat() {
          if (this.hoursSelected !== null) {
            this.meridienSelected = this.hoursSelected >= 12 ? this.pmString : this.amString;
          }
        },
        locale: function locale() {
          // see updateInternalState default
          if (!this.value) {
            this.meridienSelected = this.amString;
          }
        },

        /**
         * When v-model is changed:
         *   1. Update internal value.
         *   2. If it's invalid, validate again.
         */
        value: {
          handler: function handler(value) {
            this.updateInternalState(value);
            !this.isValid && this.$refs.input.checkHtml5Validity();
          },
          immediate: true
        }
      },
      methods: {
        onMeridienChange: function onMeridienChange(value) {
          if (this.hoursSelected !== null && this.resetOnMeridianChange) {
            this.hoursSelected = null;
            this.minutesSelected = null;
            this.secondsSelected = null;
            this.computedValue = null;
          } else if (this.hoursSelected !== null) {
            if (value === this.pmString) {
              this.hoursSelected += 12;
            } else if (value === this.amString) {
              this.hoursSelected -= 12;
            }
          }

          this.updateDateSelected(this.hoursSelected, this.minutesSelected, this.enableSeconds ? this.secondsSelected : 0, value);
        },
        onHoursChange: function onHoursChange(value) {
          if (!this.minutesSelected && typeof this.defaultMinutes !== 'undefined') {
            this.minutesSelected = this.defaultMinutes;
          }

          if (!this.secondsSelected && typeof this.defaultSeconds !== 'undefined') {
            this.secondsSelected = this.defaultSeconds;
          }

          this.updateDateSelected(parseInt(value, 10), this.minutesSelected, this.enableSeconds ? this.secondsSelected : 0, this.meridienSelected);
        },
        onMinutesChange: function onMinutesChange(value) {
          if (!this.secondsSelected && this.defaultSeconds) {
            this.secondsSelected = this.defaultSeconds;
          }

          this.updateDateSelected(this.hoursSelected, parseInt(value, 10), this.enableSeconds ? this.secondsSelected : 0, this.meridienSelected);
        },
        onSecondsChange: function onSecondsChange(value) {
          this.updateDateSelected(this.hoursSelected, this.minutesSelected, parseInt(value, 10), this.meridienSelected);
        },
        updateDateSelected: function updateDateSelected(hours, minutes, seconds, meridiens) {
          if (hours != null && minutes != null && (!this.isHourFormat24 && meridiens !== null || this.isHourFormat24)) {
            var time = null;

            if (this.computedValue && !isNaN(this.computedValue)) {
              time = new Date(this.computedValue);
            } else {
              time = this.timeCreator();
              time.setMilliseconds(0);
            }

            time.setHours(hours);
            time.setMinutes(minutes);
            time.setSeconds(seconds);
            if (!isNaN(time.getTime())) this.computedValue = new Date(time.getTime());
          }
        },
        updateInternalState: function updateInternalState(value) {
          if (value) {
            this.hoursSelected = value.getHours();
            this.minutesSelected = value.getMinutes();
            this.secondsSelected = value.getSeconds();
            this.meridienSelected = value.getHours() >= 12 ? this.pmString : this.amString;
          } else {
            this.hoursSelected = null;
            this.minutesSelected = null;
            this.secondsSelected = null;
            this.meridienSelected = this.amString;
          }

          this.dateSelected = value;
        },
        isHourDisabled: function isHourDisabled(hour) {
          var _this = this;

          var disabled = false;

          if (this.minTime) {
            var minHours = this.minTime.getHours();
            var noMinutesAvailable = this.minutes.every(function (minute) {
              return _this.isMinuteDisabledForHour(hour, minute.value);
            });
            disabled = hour < minHours || noMinutesAvailable;
          }

          if (this.maxTime) {
            if (!disabled) {
              var maxHours = this.maxTime.getHours();
              disabled = hour > maxHours;
            }
          }

          if (this.unselectableTimes) {
            if (!disabled) {
              var unselectable = this.unselectableTimes.filter(function (time) {
                if (_this.enableSeconds && _this.secondsSelected !== null) {
                  return time.getHours() === hour && time.getMinutes() === _this.minutesSelected && time.getSeconds() === _this.secondsSelected;
                } else if (_this.minutesSelected !== null) {
                  return time.getHours() === hour && time.getMinutes() === _this.minutesSelected;
                }

                return false;
              });

              if (unselectable.length > 0) {
                disabled = true;
              } else {
                disabled = this.minutes.every(function (minute) {
                  return _this.unselectableTimes.filter(function (time) {
                    return time.getHours() === hour && time.getMinutes() === minute.value;
                  }).length > 0;
                });
              }
            }
          }

          return disabled;
        },
        isMinuteDisabledForHour: function isMinuteDisabledForHour(hour, minute) {
          var disabled = false;

          if (this.minTime) {
            var minHours = this.minTime.getHours();
            var minMinutes = this.minTime.getMinutes();
            disabled = hour === minHours && minute < minMinutes;
          }

          if (this.maxTime) {
            if (!disabled) {
              var maxHours = this.maxTime.getHours();
              var maxMinutes = this.maxTime.getMinutes();
              disabled = hour === maxHours && minute > maxMinutes;
            }
          }

          return disabled;
        },
        isMinuteDisabled: function isMinuteDisabled(minute) {
          var _this2 = this;

          var disabled = false;

          if (this.hoursSelected !== null) {
            if (this.isHourDisabled(this.hoursSelected)) {
              disabled = true;
            } else {
              disabled = this.isMinuteDisabledForHour(this.hoursSelected, minute);
            }

            if (this.unselectableTimes) {
              if (!disabled) {
                var unselectable = this.unselectableTimes.filter(function (time) {
                  if (_this2.enableSeconds && _this2.secondsSelected !== null) {
                    return time.getHours() === _this2.hoursSelected && time.getMinutes() === minute && time.getSeconds() === _this2.secondsSelected;
                  } else {
                    return time.getHours() === _this2.hoursSelected && time.getMinutes() === minute;
                  }
                });
                disabled = unselectable.length > 0;
              }
            }
          }

          return disabled;
        },
        isSecondDisabled: function isSecondDisabled(second) {
          var _this3 = this;

          var disabled = false;

          if (this.minutesSelected !== null) {
            if (this.isMinuteDisabled(this.minutesSelected)) {
              disabled = true;
            } else {
              if (this.minTime) {
                var minHours = this.minTime.getHours();
                var minMinutes = this.minTime.getMinutes();
                var minSeconds = this.minTime.getSeconds();
                disabled = this.hoursSelected === minHours && this.minutesSelected === minMinutes && second < minSeconds;
              }

              if (this.maxTime) {
                if (!disabled) {
                  var maxHours = this.maxTime.getHours();
                  var maxMinutes = this.maxTime.getMinutes();
                  var maxSeconds = this.maxTime.getSeconds();
                  disabled = this.hoursSelected === maxHours && this.minutesSelected === maxMinutes && second > maxSeconds;
                }
              }
            }

            if (this.unselectableTimes) {
              if (!disabled) {
                var unselectable = this.unselectableTimes.filter(function (time) {
                  return time.getHours() === _this3.hoursSelected && time.getMinutes() === _this3.minutesSelected && time.getSeconds() === second;
                });
                disabled = unselectable.length > 0;
              }
            }
          }

          return disabled;
        },

        /*
         * Parse string into date
         */
        onChange: function onChange(value) {
          var date = this.timeParser(value, this);
          this.updateInternalState(date);

          if (date && !isNaN(date)) {
            this.computedValue = date;
          } else {
            // Force refresh input value when not valid date
            this.computedValue = null;
            this.$refs.input.newValue = this.computedValue;
          }
        },

        /*
         * Toggle timepicker
         */
        toggle: function toggle(active) {
          if (this.$refs.dropdown) {
            this.$refs.dropdown.isActive = typeof active === 'boolean' ? active : !this.$refs.dropdown.isActive;
          }
        },

        /*
         * Close timepicker
         */
        close: function close() {
          this.toggle(false);
        },

        /*
         * Call default onFocus method and show timepicker
         */
        handleOnFocus: function handleOnFocus() {
          this.onFocus();

          if (this.openOnFocus) {
            this.toggle(true);
          }
        },

        /*
         * Format date into string 'HH-MM-SS'
         */
        formatHHMMSS: function formatHHMMSS(value) {
          var date = new Date(value);

          if (value && !isNaN(date)) {
            var hours = date.getHours();
            var minutes = date.getMinutes();
            var seconds = date.getSeconds();
            return this.formatNumber(hours, true) + ':' + this.formatNumber(minutes, true) + ':' + this.formatNumber(seconds, true);
          }

          return '';
        },

        /*
         * Parse time from string
         */
        onChangeNativePicker: function onChangeNativePicker(event) {
          var date = event.target.value;

          if (date) {
            var time = null;

            if (this.computedValue && !isNaN(this.computedValue)) {
              time = new Date(this.computedValue);
            } else {
              time = new Date();
              time.setMilliseconds(0);
            }

            var t = date.split(':');
            time.setHours(parseInt(t[0], 10));
            time.setMinutes(parseInt(t[1], 10));
            time.setSeconds(t[2] ? parseInt(t[2], 10) : 0);
            this.computedValue = new Date(time.getTime());
          } else {
            this.computedValue = null;
          }
        },
        formatNumber: function formatNumber(value, prependZero) {
          return this.isHourFormat24 || prependZero ? this.pad(value) : value;
        },
        pad: function pad(value) {
          return (value < 10 ? '0' : '') + value;
        },

        /*
         * Format date into string
         */
        formatValue: function formatValue(date) {
          if (date && !isNaN(date)) {
            return this.timeFormatter(date, this);
          } else {
            return null;
          }
        },

        /**
         * Keypress event that is bound to the document.
         */
        keyPress: function keyPress(_ref) {
          var key = _ref.key;

          if (this.$refs.dropdown && this.$refs.dropdown.isActive && (key === 'Escape' || key === 'Esc')) {
            this.toggle(false);
          }
        },

        /**
         * Emit 'blur' event on dropdown is not active (closed)
         */
        onActiveChange: function onActiveChange(value) {
          if (!value) {
            this.onBlur();
          }
        }
      },
      created: function created() {
        if (typeof window !== 'undefined') {
          document.addEventListener('keyup', this.keyPress);
        }
      },
      beforeDestroy: function beforeDestroy() {
        if (typeof window !== 'undefined') {
          document.removeEventListener('keyup', this.keyPress);
        }
      }
    };

    var findFocusable = function findFocusable(element) {
      var programmatic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (!element) {
        return null;
      }

      if (programmatic) {
        return element.querySelectorAll("*[tabindex=\"-1\"]");
      }

      return element.querySelectorAll("a[href]:not([tabindex=\"-1\"]),\n                                     area[href],\n                                     input:not([disabled]),\n                                     select:not([disabled]),\n                                     textarea:not([disabled]),\n                                     button:not([disabled]),\n                                     iframe,\n                                     object,\n                                     embed,\n                                     *[tabindex]:not([tabindex=\"-1\"]),\n                                     *[contenteditable]");
    };

    var onKeyDown;

    var bind$2 = function bind(el, _ref) {
      var _ref$value = _ref.value,
          value = _ref$value === void 0 ? true : _ref$value;

      if (value) {
        var focusable = findFocusable(el);
        var focusableProg = findFocusable(el, true);

        if (focusable && focusable.length > 0) {
          onKeyDown = function onKeyDown(event) {
            // Need to get focusable each time since it can change between key events
            // ex. changing month in a datepicker
            focusable = findFocusable(el);
            focusableProg = findFocusable(el, true);
            var firstFocusable = focusable[0];
            var lastFocusable = focusable[focusable.length - 1];

            if (event.target === firstFocusable && event.shiftKey && event.key === 'Tab') {
              event.preventDefault();
              lastFocusable.focus();
            } else if ((event.target === lastFocusable || Array.from(focusableProg).indexOf(event.target) >= 0) && !event.shiftKey && event.key === 'Tab') {
              event.preventDefault();
              firstFocusable.focus();
            }
          };

          el.addEventListener('keydown', onKeyDown);
        }
      }
    };

    var unbind = function unbind(el) {
      el.removeEventListener('keydown', onKeyDown);
    };

    var directive$1 = {
      bind: bind$2,
      unbind: unbind
    };

    var DEFAULT_CLOSE_OPTIONS = ['escape', 'outside'];
    var script$a = {
      name: 'BDropdown',
      directives: {
        trapFocus: directive$1
      },
      mixins: [ProviderParentMixin('dropdown')],
      props: {
        value: {
          type: [String, Number, Boolean, Object, Array, Function],
          default: null
        },
        disabled: Boolean,
        inline: Boolean,
        scrollable: Boolean,
        maxHeight: {
          type: [String, Number],
          default: 200
        },
        position: {
          type: String,
          validator: function validator(value) {
            return ['is-top-right', 'is-top-left', 'is-bottom-left', 'is-bottom-right'].indexOf(value) > -1;
          }
        },
        triggers: {
          type: Array,
          default: function _default() {
            return ['click'];
          }
        },
        mobileModal: {
          type: Boolean,
          default: function _default() {
            return config$2.defaultDropdownMobileModal;
          }
        },
        ariaRole: {
          type: String,
          validator: function validator(value) {
            return ['menu', 'list', 'dialog'].indexOf(value) > -1;
          },
          default: null
        },
        animation: {
          type: String,
          default: 'fade'
        },
        multiple: Boolean,
        trapFocus: {
          type: Boolean,
          default: function _default() {
            return config$2.defaultTrapFocus;
          }
        },
        closeOnClick: {
          type: Boolean,
          default: true
        },
        canClose: {
          type: [Array, Boolean],
          default: true
        },
        expanded: Boolean,
        appendToBody: Boolean,
        appendToBodyCopyParent: Boolean
      },
      data: function data() {
        return {
          selected: this.value,
          style: {},
          isActive: false,
          isHoverable: false,
          _bodyEl: undefined // Used to append to body

        };
      },
      computed: {
        rootClasses: function rootClasses() {
          return [this.position, {
            'is-disabled': this.disabled,
            'is-hoverable': this.hoverable,
            'is-inline': this.inline,
            'is-active': this.isActive || this.inline,
            'is-mobile-modal': this.isMobileModal,
            'is-expanded': this.expanded
          }];
        },
        isMobileModal: function isMobileModal() {
          return this.mobileModal && !this.inline;
        },
        cancelOptions: function cancelOptions() {
          return typeof this.canClose === 'boolean' ? this.canClose ? DEFAULT_CLOSE_OPTIONS : [] : this.canClose;
        },
        contentStyle: function contentStyle() {
          return {
            maxHeight: this.scrollable ? toCssWidth(this.maxHeight) : null,
            overflow: this.scrollable ? 'auto' : null
          };
        },
        hoverable: function hoverable() {
          return this.triggers.indexOf('hover') >= 0;
        }
      },
      watch: {
        /**
        * When v-model is changed set the new selected item.
        */
        value: function value(_value) {
          this.selected = _value;
        },

        /**
        * Emit event when isActive value is changed.
        */
        isActive: function isActive(value) {
          var _this = this;

          this.$emit('active-change', value);
          this.handleScroll();

          if (this.appendToBody) {
            this.$nextTick(function () {
              _this.updateAppendToBody();
            });
          }
        },
        isHoverable: function isHoverable(value) {
          if (this.hoverable) {
            this.$emit('active-change', value);
          }
        }
      },
      methods: {
        handleScroll: function handleScroll() {
          if (typeof window === 'undefined') return;

          if (this.isMobileModal) {
            if (this.isActive) {
              document.documentElement.classList.add('is-clipped-touch');
            } else {
              document.documentElement.classList.remove('is-clipped-touch');
            }
          }
        },

        /**
         * Click listener from DropdownItem.
         *   1. Set new selected item.
         *   2. Emit input event to update the user v-model.
         *   3. Close the dropdown.
         */
        selectItem: function selectItem(value) {
          if (this.multiple) {
            if (this.selected) {
              if (this.selected.indexOf(value) === -1) {
                // Add value
                this.selected = [].concat(_toConsumableArray(this.selected), [value]);
              } else {
                // Remove value
                this.selected = this.selected.filter(function (val) {
                  return val !== value;
                });
              }
            } else {
              this.selected = [value];
            }

            this.$emit('change', this.selected);
          } else {
            if (this.selected !== value) {
              this.selected = value;
              this.$emit('change', this.selected);
            }
          }

          this.$emit('input', this.selected);

          if (!this.multiple) {
            this.isActive = !this.closeOnClick;

            if (this.hoverable && this.closeOnClick) {
              this.isHoverable = false;
            }
          }
        },

        /**
        * White-listed items to not close when clicked.
        */
        isInWhiteList: function isInWhiteList(el) {
          if (el === this.$refs.dropdownMenu) return true;
          if (el === this.$refs.trigger) return true; // All chidren from dropdown

          if (this.$refs.dropdownMenu !== undefined) {
            var children = this.$refs.dropdownMenu.querySelectorAll('*');
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var child = _step.value;

                if (el === child) {
                  return true;
                }
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
          } // All children from trigger


          if (this.$refs.trigger !== undefined) {
            var _children = this.$refs.trigger.querySelectorAll('*');

            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = _children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var _child = _step2.value;

                if (el === _child) {
                  return true;
                }
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                  _iterator2.return();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
          }

          return false;
        },

        /**
        * Close dropdown if clicked outside.
        */
        clickedOutside: function clickedOutside(event) {
          if (this.cancelOptions.indexOf('outside') < 0) return;
          if (this.inline) return;
          var target = isCustomElement(this) ? event.composedPath()[0] : event.target;
          if (!this.isInWhiteList(target)) this.isActive = false;
        },

        /**
         * Keypress event that is bound to the document
         */
        keyPress: function keyPress(_ref) {
          var key = _ref.key;

          if (this.isActive && (key === 'Escape' || key === 'Esc')) {
            if (this.cancelOptions.indexOf('escape') < 0) return;
            this.isActive = false;
          }
        },
        onClick: function onClick() {
          if (this.triggers.indexOf('click') < 0) return;
          this.toggle();
        },
        onContextMenu: function onContextMenu() {
          if (this.triggers.indexOf('contextmenu') < 0) return;
          this.toggle();
        },
        onHover: function onHover() {
          if (this.triggers.indexOf('hover') < 0) return;
          this.isHoverable = true;
        },
        onFocus: function onFocus() {
          if (this.triggers.indexOf('focus') < 0) return;
          this.toggle();
        },

        /**
        * Toggle dropdown if it's not disabled.
        */
        toggle: function toggle() {
          var _this2 = this;

          if (this.disabled) return;

          if (!this.isActive) {
            // if not active, toggle after clickOutside event
            // this fixes toggling programmatic
            this.$nextTick(function () {
              var value = !_this2.isActive;
              _this2.isActive = value; // Vue 2.6.x ???

              setTimeout(function () {
                return _this2.isActive = value;
              });
            });
          } else {
            this.isActive = !this.isActive;
          }
        },
        updateAppendToBody: function updateAppendToBody() {
          var dropdown = this.$refs.dropdown;
          var dropdownMenu = this.$refs.dropdownMenu;
          var trigger = this.$refs.trigger;

          if (dropdownMenu && trigger) {
            // update wrapper dropdown
            var dropdownWrapper = this.$data._bodyEl.children[0];
            dropdownWrapper.classList.forEach(function (item) {
              return dropdownWrapper.classList.remove(item);
            });
            dropdownWrapper.classList.add('dropdown');
            dropdownWrapper.classList.add('dropdown-menu-animation');

            if (this.$vnode && this.$vnode.data && this.$vnode.data.staticClass) {
              dropdownWrapper.classList.add(this.$vnode.data.staticClass);
            }

            this.rootClasses.forEach(function (item) {
              // skip position prop
              if (item && _typeof(item) === 'object') {
                for (var key in item) {
                  if (item[key]) {
                    dropdownWrapper.classList.add(key);
                  }
                }
              }
            });

            if (this.appendToBodyCopyParent) {
              var parentNode = this.$refs.dropdown.parentNode;
              var parent = this.$data._bodyEl;
              parent.classList.forEach(function (item) {
                return parent.classList.remove(item);
              });
              parentNode.classList.forEach(function (item) {
                parent.classList.add(item);
              });
            }

            var rect = trigger.getBoundingClientRect();
            var top = rect.top + window.scrollY;
            var left = rect.left + window.scrollX;

            if (!this.position || this.position.indexOf('bottom') >= 0) {
              top += trigger.clientHeight;
            } else {
              top -= dropdownMenu.clientHeight;
            }

            if (this.position && this.position.indexOf('left') >= 0) {
              left -= dropdownMenu.clientWidth - trigger.clientWidth;
            }

            this.style = {
              position: 'absolute',
              top: "".concat(top, "px"),
              left: "".concat(left, "px"),
              zIndex: '99',
              width: this.expanded ? "".concat(dropdown.offsetWidth, "px") : undefined
            };
          }
        }
      },
      mounted: function mounted() {
        if (this.appendToBody) {
          this.$data._bodyEl = createAbsoluteElement(this.$refs.dropdownMenu);
          this.updateAppendToBody();
        }
      },
      created: function created() {
        if (typeof window !== 'undefined') {
          document.addEventListener('click', this.clickedOutside);
          document.addEventListener('keyup', this.keyPress);
        }
      },
      beforeDestroy: function beforeDestroy() {
        if (typeof window !== 'undefined') {
          document.removeEventListener('click', this.clickedOutside);
          document.removeEventListener('keyup', this.keyPress);
        }

        if (this.appendToBody) {
          removeElement(this.$data._bodyEl);
        }
      }
    };

    /* script */
    const __vue_script__$a = script$a;

    /* template */
    var __vue_render__$9 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{ref:"dropdown",staticClass:"dropdown dropdown-menu-animation",class:_vm.rootClasses,on:{"mouseleave":function($event){_vm.isHoverable = false;}}},[(!_vm.inline)?_c('div',{ref:"trigger",staticClass:"dropdown-trigger",attrs:{"tabindex":_vm.disabled ? false : 0,"aria-haspopup":"true"},on:{"click":_vm.onClick,"contextmenu":function($event){$event.preventDefault();return _vm.onContextMenu($event)},"mouseenter":_vm.onHover,"!focus":function($event){return _vm.onFocus($event)}}},[_vm._t("trigger",null,{"active":_vm.isActive})],2):_vm._e(),_c('transition',{attrs:{"name":_vm.animation}},[(_vm.isMobileModal)?_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.isActive),expression:"isActive"}],staticClass:"background",attrs:{"aria-hidden":!_vm.isActive}}):_vm._e()]),_c('transition',{attrs:{"name":_vm.animation}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:((!_vm.disabled && (_vm.isActive || _vm.isHoverable)) || _vm.inline),expression:"(!disabled && (isActive || isHoverable)) || inline"},{name:"trap-focus",rawName:"v-trap-focus",value:(_vm.trapFocus),expression:"trapFocus"}],ref:"dropdownMenu",staticClass:"dropdown-menu",style:(_vm.style),attrs:{"aria-hidden":!_vm.isActive}},[_c('div',{staticClass:"dropdown-content",style:(_vm.contentStyle),attrs:{"role":_vm.ariaRole,"aria-modal":!_vm.inline}},[_vm._t("default")],2)])])],1)};
    var __vue_staticRenderFns__$9 = [];

      /* style */
      const __vue_inject_styles__$a = undefined;
      /* scoped */
      const __vue_scope_id__$a = undefined;
      /* module identifier */
      const __vue_module_identifier__$a = undefined;
      /* functional template */
      const __vue_is_functional_template__$a = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var Dropdown = normalizeComponent_1(
        { render: __vue_render__$9, staticRenderFns: __vue_staticRenderFns__$9 },
        __vue_inject_styles__$a,
        __vue_script__$a,
        __vue_scope_id__$a,
        __vue_is_functional_template__$a,
        __vue_module_identifier__$a,
        undefined,
        undefined
      );

    //
    var script$1$3 = {
      name: 'BDropdownItem',
      mixins: [InjectedChildMixin('dropdown')],
      props: {
        value: {
          type: [String, Number, Boolean, Object, Array, Function],
          default: null
        },
        separator: Boolean,
        disabled: Boolean,
        custom: Boolean,
        focusable: {
          type: Boolean,
          default: true
        },
        paddingless: Boolean,
        hasLink: Boolean,
        ariaRole: {
          type: String,
          default: ''
        }
      },
      computed: {
        anchorClasses: function anchorClasses() {
          return {
            'is-disabled': this.parent.disabled || this.disabled,
            'is-paddingless': this.paddingless,
            'is-active': this.isActive
          };
        },
        itemClasses: function itemClasses() {
          return {
            'dropdown-item': !this.hasLink,
            'is-disabled': this.disabled,
            'is-paddingless': this.paddingless,
            'is-active': this.isActive,
            'has-link': this.hasLink
          };
        },
        ariaRoleItem: function ariaRoleItem() {
          return this.ariaRole === 'menuitem' || this.ariaRole === 'listitem' ? this.ariaRole : null;
        },
        isClickable: function isClickable() {
          return !this.parent.disabled && !this.separator && !this.disabled && !this.custom;
        },
        isActive: function isActive() {
          if (this.parent.selected === null) return false;
          if (this.parent.multiple) return this.parent.selected.indexOf(this.value) >= 0;
          return this.value === this.parent.selected;
        },
        isFocusable: function isFocusable() {
          return this.hasLink ? false : this.focusable;
        }
      },
      methods: {
        /**
        * Click listener, select the item.
        */
        selectItem: function selectItem() {
          if (!this.isClickable) return;
          this.parent.selectItem(this.value);
          this.$emit('click');
        }
      }
    };

    /* script */
    const __vue_script__$1$3 = script$1$3;

    /* template */
    var __vue_render__$1$3 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return (_vm.separator)?_c('hr',{staticClass:"dropdown-divider"}):(!_vm.custom && !_vm.hasLink)?_c('a',{staticClass:"dropdown-item",class:_vm.anchorClasses,attrs:{"role":_vm.ariaRoleItem,"tabindex":_vm.isFocusable ? 0 : null},on:{"click":_vm.selectItem}},[_vm._t("default")],2):_c('div',{class:_vm.itemClasses,attrs:{"role":_vm.ariaRoleItem,"tabindex":_vm.isFocusable ? 0 : null},on:{"click":_vm.selectItem}},[_vm._t("default")],2)};
    var __vue_staticRenderFns__$1$3 = [];

      /* style */
      const __vue_inject_styles__$1$3 = undefined;
      /* scoped */
      const __vue_scope_id__$1$3 = undefined;
      /* module identifier */
      const __vue_module_identifier__$1$3 = undefined;
      /* functional template */
      const __vue_is_functional_template__$1$3 = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var DropdownItem = normalizeComponent_1(
        { render: __vue_render__$1$3, staticRenderFns: __vue_staticRenderFns__$1$3 },
        __vue_inject_styles__$1$3,
        __vue_script__$1$3,
        __vue_scope_id__$1$3,
        __vue_is_functional_template__$1$3,
        __vue_module_identifier__$1$3,
        undefined,
        undefined
      );

    var script$b = {
      name: 'BFieldBody',
      props: {
        message: {
          type: [String, Array]
        },
        type: {
          type: [String, Object]
        }
      },
      render: function render(createElement) {
        var _this = this;

        var first = true;
        return createElement('div', {
          attrs: {
            'class': 'field-body'
          }
        }, this.$slots.default.map(function (element) {
          // skip returns and comments
          if (!element.tag) {
            return element;
          }

          var message;

          if (first) {
            message = _this.message;
            first = false;
          }

          return createElement('b-field', {
            attrs: {
              type: _this.type,
              message: message
            }
          }, [element]);
        }));
      }
    };

    /* script */
    const __vue_script__$b = script$b;

    /* template */

      /* style */
      const __vue_inject_styles__$b = undefined;
      /* scoped */
      const __vue_scope_id__$b = undefined;
      /* module identifier */
      const __vue_module_identifier__$b = undefined;
      /* functional template */
      const __vue_is_functional_template__$b = undefined;
      /* style inject */
      
      /* style inject SSR */
      

      
      var FieldBody = normalizeComponent_1(
        {},
        __vue_inject_styles__$b,
        __vue_script__$b,
        __vue_scope_id__$b,
        __vue_is_functional_template__$b,
        __vue_module_identifier__$b,
        undefined,
        undefined
      );

    var script$1$4 = {
      name: 'BField',
      components: _defineProperty({}, FieldBody.name, FieldBody),
      provide: function provide() {
        return {
          'BField': this
        };
      },
      inject: {
        parent: {
          from: 'BField',
          default: false
        }
      },
      // Used internally only when using Field in Field
      props: {
        type: [String, Object],
        label: String,
        labelFor: String,
        message: [String, Array, Object],
        grouped: Boolean,
        groupMultiline: Boolean,
        position: String,
        expanded: Boolean,
        horizontal: Boolean,
        addons: {
          type: Boolean,
          default: true
        },
        customClass: String,
        labelPosition: {
          type: String,
          default: function _default() {
            return config$2.defaultFieldLabelPosition;
          }
        }
      },
      data: function data() {
        return {
          newType: this.type,
          newMessage: this.message,
          fieldLabelSize: null,
          _isField: true // Used internally by Input and Select

        };
      },
      computed: {
        rootClasses: function rootClasses() {
          return [{
            'is-expanded': this.expanded,
            'is-horizontal': this.horizontal,
            'is-floating-in-label': this.hasLabel && !this.horizontal && this.labelPosition === 'inside',
            'is-floating-label': this.hasLabel && !this.horizontal && this.labelPosition === 'on-border'
          }, this.numberInputClasses];
        },
        innerFieldClasses: function innerFieldClasses() {
          return [this.fieldType(), this.newPosition, {
            'is-grouped-multiline': this.groupMultiline
          }];
        },
        hasInnerField: function hasInnerField() {
          return this.grouped || this.groupMultiline || this.hasAddons();
        },

        /**
        * Correct Bulma class for the side of the addon or group.
        *
        * This is not kept like the others (is-small, etc.),
        * because since 'has-addons' is set automatically it
        * doesn't make sense to teach users what addons are exactly.
        */
        newPosition: function newPosition() {
          if (this.position === undefined) return;
          var position = this.position.split('-');
          if (position.length < 1) return;
          var prefix = this.grouped ? 'is-grouped-' : 'has-addons-';
          if (this.position) return prefix + position[1];
        },

        /**
        * Formatted message in case it's an array
        * (each element is separated by <br> tag)
        */
        formattedMessage: function formattedMessage() {
          if (this.parent && this.parent.hasInnerField) {
            return ''; // Message will be displayed in parent field
          }

          if (typeof this.newMessage === 'string') {
            return [this.newMessage];
          }

          var messages = [];

          if (Array.isArray(this.newMessage)) {
            this.newMessage.forEach(function (message) {
              if (typeof message === 'string') {
                messages.push(message);
              } else {
                for (var key in message) {
                  if (message[key]) {
                    messages.push(key);
                  }
                }
              }
            });
          } else {
            for (var key in this.newMessage) {
              if (this.newMessage[key]) {
                messages.push(key);
              }
            }
          }

          return messages.filter(function (m) {
            if (m) return m;
          });
        },
        hasLabel: function hasLabel() {
          return this.label || this.$slots.label;
        },
        hasMessage: function hasMessage() {
          return (!this.parent || !this.parent.hasInnerField) && this.newMessage || this.$slots.message;
        },
        numberInputClasses: function numberInputClasses() {
          if (this.$slots.default) {
            var numberinput = this.$slots.default.filter(function (node) {
              return node.tag && node.tag.toLowerCase().indexOf('numberinput') >= 0;
            })[0];

            if (numberinput) {
              var classes = ['has-numberinput'];
              var controlsPosition = numberinput.componentOptions.propsData.controlsPosition;
              var size = numberinput.componentOptions.propsData.size;

              if (controlsPosition) {
                classes.push("has-numberinput-".concat(controlsPosition));
              }

              if (size) {
                classes.push("has-numberinput-".concat(size));
              }

              return classes;
            }
          }

          return null;
        }
      },
      watch: {
        /**
        * Set internal type when prop change.
        */
        type: function type(value) {
          this.newType = value;
        },

        /**
        * Set internal message when prop change.
        */
        message: function message(value) {
          this.newMessage = value;
        },

        /**
        * Set parent message if we use Field in Field.
        */
        newMessage: function newMessage(value) {
          if (this.parent && this.parent.hasInnerField) {
            if (!this.parent.type) {
              this.parent.newType = this.newType;
            }

            if (!this.parent.message) {
              this.parent.newMessage = value;
            }
          }
        }
      },
      methods: {
        /**
        * Field has addons if there are more than one slot
        * (element / component) in the Field.
        * Or is grouped when prop is set.
        * Is a method to be called when component re-render.
        */
        fieldType: function fieldType() {
          if (this.grouped) return 'is-grouped';
          if (this.hasAddons()) return 'has-addons';
        },
        hasAddons: function hasAddons() {
          var renderedNode = 0;

          if (this.$slots.default) {
            renderedNode = this.$slots.default.reduce(function (i, node) {
              return node.tag ? i + 1 : i;
            }, 0);
          }

          return renderedNode > 1 && this.addons && !this.horizontal;
        }
      },
      mounted: function mounted() {
        if (this.horizontal) {
          // Bulma docs: .is-normal for any .input or .button
          var elements = this.$el.querySelectorAll('.input, .select, .button, .textarea, .b-slider');

          if (elements.length > 0) {
            this.fieldLabelSize = 'is-normal';
          }
        }
      }
    };

    /* script */
    const __vue_script__$1$4 = script$1$4;

    /* template */
    var __vue_render__$a = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"field",class:_vm.rootClasses},[(_vm.horizontal)?_c('div',{staticClass:"field-label",class:[_vm.customClass, _vm.fieldLabelSize]},[(_vm.hasLabel)?_c('label',{staticClass:"label",class:_vm.customClass,attrs:{"for":_vm.labelFor}},[(_vm.$slots.label)?_vm._t("label"):[_vm._v(_vm._s(_vm.label))]],2):_vm._e()]):[(_vm.hasLabel)?_c('label',{staticClass:"label",class:_vm.customClass,attrs:{"for":_vm.labelFor}},[(_vm.$slots.label)?_vm._t("label"):[_vm._v(_vm._s(_vm.label))]],2):_vm._e()],(_vm.horizontal)?_c('b-field-body',{attrs:{"message":_vm.newMessage ? _vm.formattedMessage : '',"type":_vm.newType}},[_vm._t("default")],2):(_vm.hasInnerField)?_c('div',{staticClass:"field-body"},[_c('b-field',{class:_vm.innerFieldClasses,attrs:{"addons":false,"type":_vm.newType}},[_vm._t("default")],2)],1):[_vm._t("default")],(_vm.hasMessage && !_vm.horizontal)?_c('p',{staticClass:"help",class:_vm.newType},[(_vm.$slots.message)?_vm._t("message"):[_vm._l((_vm.formattedMessage),function(mess,i){return [_vm._v(" "+_vm._s(mess)+" "),((i + 1) < _vm.formattedMessage.length)?_c('br',{key:i}):_vm._e()]})]],2):_vm._e()],2)};
    var __vue_staticRenderFns__$a = [];

      /* style */
      const __vue_inject_styles__$1$4 = undefined;
      /* scoped */
      const __vue_scope_id__$1$4 = undefined;
      /* module identifier */
      const __vue_module_identifier__$1$4 = undefined;
      /* functional template */
      const __vue_is_functional_template__$1$4 = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var Field = normalizeComponent_1(
        { render: __vue_render__$a, staticRenderFns: __vue_staticRenderFns__$a },
        __vue_inject_styles__$1$4,
        __vue_script__$1$4,
        __vue_scope_id__$1$4,
        __vue_is_functional_template__$1$4,
        __vue_module_identifier__$1$4,
        undefined,
        undefined
      );

    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    // These should match the variables in clockpicker.scss
    var indicatorSize = 40;
    var paddingInner = 5;
    var script$c = {
      name: 'BClockpickerFace',
      props: {
        pickerSize: Number,
        min: Number,
        max: Number,
        double: Boolean,
        value: Number,
        faceNumbers: Array,
        disabledValues: Function
      },
      data: function data() {
        return {
          isDragging: false,
          inputValue: this.value,
          prevAngle: 720
        };
      },
      computed: {
        /**
        * How many number indicators are shown on the face
        */
        count: function count() {
          return this.max - this.min + 1;
        },

        /**
        * How many number indicators are shown per ring on the face
        */
        countPerRing: function countPerRing() {
          return this.double ? this.count / 2 : this.count;
        },

        /**
        * Radius of the clock face
        */
        radius: function radius() {
          return this.pickerSize / 2;
        },

        /**
        * Radius of the outer ring of number indicators
        */
        outerRadius: function outerRadius() {
          return this.radius - paddingInner - indicatorSize / 2;
        },

        /**
        * Radius of the inner ring of number indicators
        */
        innerRadius: function innerRadius() {
          return Math.max(this.outerRadius * 0.6, this.outerRadius - paddingInner - indicatorSize); // 48px gives enough room for the outer ring of numbers
        },

        /**
        * The angle for each selectable value
        * For hours this ends up being 30 degrees, for minutes 6 degrees
        */
        degreesPerUnit: function degreesPerUnit() {
          return 360 / this.countPerRing;
        },

        /**
        * Used for calculating x/y grid location based on degrees
        */
        degrees: function degrees() {
          return this.degreesPerUnit * Math.PI / 180;
        },

        /**
        * Calculates the angle the clock hand should be rotated for the
        * selected value
        */
        handRotateAngle: function handRotateAngle() {
          var currentAngle = this.prevAngle;

          while (currentAngle < 0) {
            currentAngle += 360;
          }

          var targetAngle = this.calcHandAngle(this.displayedValue);
          var degreesDiff = this.shortestDistanceDegrees(currentAngle, targetAngle);
          var angle = this.prevAngle + degreesDiff;
          return angle;
        },

        /**
        * Determines how long the selector hand is based on if the
        * selected value is located along the outer or inner ring
        */
        handScale: function handScale() {
          return this.calcHandScale(this.displayedValue);
        },
        handStyle: function handStyle() {
          return {
            transform: "rotate(".concat(this.handRotateAngle, "deg) scaleY(").concat(this.handScale, ")"),
            transition: '.3s cubic-bezier(.25,.8,.50,1)'
          };
        },

        /**
        * The value the hand should be pointing at
        */
        displayedValue: function displayedValue() {
          return this.inputValue == null ? this.min : this.inputValue;
        }
      },
      watch: {
        value: function value(_value) {
          if (_value !== this.inputValue) {
            this.prevAngle = this.handRotateAngle;
          }

          this.inputValue = _value;
        }
      },
      methods: {
        isDisabled: function isDisabled(value) {
          return this.disabledValues && this.disabledValues(value);
        },

        /**
        * Calculates the distance between two points
        */
        euclidean: function euclidean(p0, p1) {
          var dx = p1.x - p0.x;
          var dy = p1.y - p0.y;
          return Math.sqrt(dx * dx + dy * dy);
        },
        shortestDistanceDegrees: function shortestDistanceDegrees(start, stop) {
          var modDiff = (stop - start) % 360;
          var shortestDistance = 180 - Math.abs(Math.abs(modDiff) - 180);
          return (modDiff + 360) % 360 < 180 ? shortestDistance * 1 : shortestDistance * -1;
        },

        /**
        * Calculates the angle of the line from the center point
        * to the given point.
        */
        coordToAngle: function coordToAngle(center, p1) {
          var value = 2 * Math.atan2(p1.y - center.y - this.euclidean(center, p1), p1.x - center.x);
          return Math.abs(value * 180 / Math.PI);
        },

        /**
        * Generates the inline style translate() property for a
        * number indicator, which determines it's location on the
        * clock face
        */
        getNumberTranslate: function getNumberTranslate(value) {
          var _this$getNumberCoords = this.getNumberCoords(value),
              x = _this$getNumberCoords.x,
              y = _this$getNumberCoords.y;

          return "translate(".concat(x, "px, ").concat(y, "px)");
        },

        /***
        * Calculates the coordinates on the clock face for a number
        * indicator value
        */
        getNumberCoords: function getNumberCoords(value) {
          var radius = this.isInnerRing(value) ? this.innerRadius : this.outerRadius;
          return {
            x: Math.round(radius * Math.sin((value - this.min) * this.degrees)),
            y: Math.round(-radius * Math.cos((value - this.min) * this.degrees))
          };
        },
        getFaceNumberClasses: function getFaceNumberClasses(num) {
          return {
            'active': num.value === this.displayedValue,
            'disabled': this.isDisabled(num.value)
          };
        },

        /**
        * Determines if a value resides on the inner ring
        */
        isInnerRing: function isInnerRing(value) {
          return this.double && value - this.min >= this.countPerRing;
        },
        calcHandAngle: function calcHandAngle(value) {
          var angle = this.degreesPerUnit * (value - this.min);
          if (this.isInnerRing(value)) angle -= 360;
          return angle;
        },
        calcHandScale: function calcHandScale(value) {
          return this.isInnerRing(value) ? this.innerRadius / this.outerRadius : 1;
        },
        onMouseDown: function onMouseDown(e) {
          e.preventDefault();
          this.isDragging = true;
          this.onDragMove(e);
        },
        onMouseUp: function onMouseUp() {
          this.isDragging = false;

          if (!this.isDisabled(this.inputValue)) {
            this.$emit('change', this.inputValue);
          }
        },
        onDragMove: function onDragMove(e) {
          e.preventDefault();
          if (!this.isDragging && e.type !== 'click') return;

          var _this$$refs$clock$get = this.$refs.clock.getBoundingClientRect(),
              width = _this$$refs$clock$get.width,
              top = _this$$refs$clock$get.top,
              left = _this$$refs$clock$get.left;

          var _ref = 'touches' in e ? e.touches[0] : e,
              clientX = _ref.clientX,
              clientY = _ref.clientY;

          var center = {
            x: width / 2,
            y: -width / 2
          };
          var coords = {
            x: clientX - left,
            y: top - clientY
          };
          var handAngle = Math.round(this.coordToAngle(center, coords) + 360) % 360;
          var insideClick = this.double && this.euclidean(center, coords) < (this.outerRadius + this.innerRadius) / 2 - 16;
          var value = Math.round(handAngle / this.degreesPerUnit) + this.min + (insideClick ? this.countPerRing : 0); // Necessary to fix edge case when selecting left part of max value

          if (handAngle >= 360 - this.degreesPerUnit / 2) {
            value = insideClick ? this.max : this.min;
          }

          this.update(value);
        },
        update: function update(value) {
          if (this.inputValue !== value && !this.isDisabled(value)) {
            this.prevAngle = this.handRotateAngle;
            this.inputValue = value;
            this.$emit('input', value);
          }
        }
      }
    };

    /* script */
    const __vue_script__$c = script$c;

    /* template */
    var __vue_render__$b = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"b-clockpicker-face",on:{"mousedown":_vm.onMouseDown,"mouseup":_vm.onMouseUp,"mousemove":_vm.onDragMove,"touchstart":_vm.onMouseDown,"touchend":_vm.onMouseUp,"touchmove":_vm.onDragMove}},[_c('div',{ref:"clock",staticClass:"b-clockpicker-face-outer-ring"},[_c('div',{staticClass:"b-clockpicker-face-hand",style:(_vm.handStyle)}),_vm._l((_vm.faceNumbers),function(num,index){return _c('span',{key:index,staticClass:"b-clockpicker-face-number",class:_vm.getFaceNumberClasses(num),style:({ transform: _vm.getNumberTranslate(num.value) })},[_c('span',[_vm._v(_vm._s(num.label))])])})],2)])};
    var __vue_staticRenderFns__$b = [];

      /* style */
      const __vue_inject_styles__$c = undefined;
      /* scoped */
      const __vue_scope_id__$c = undefined;
      /* module identifier */
      const __vue_module_identifier__$c = undefined;
      /* functional template */
      const __vue_is_functional_template__$c = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var ClockpickerFace = normalizeComponent_1(
        { render: __vue_render__$b, staticRenderFns: __vue_staticRenderFns__$b },
        __vue_inject_styles__$c,
        __vue_script__$c,
        __vue_scope_id__$c,
        __vue_is_functional_template__$c,
        __vue_module_identifier__$c,
        undefined,
        undefined
      );

    var _components$1;
    var outerPadding = 12;
    var script$1$5 = {
      name: 'BClockpicker',
      components: (_components$1 = {}, _defineProperty(_components$1, ClockpickerFace.name, ClockpickerFace), _defineProperty(_components$1, Input.name, Input), _defineProperty(_components$1, Field.name, Field), _defineProperty(_components$1, Icon.name, Icon), _defineProperty(_components$1, Dropdown.name, Dropdown), _defineProperty(_components$1, DropdownItem.name, DropdownItem), _components$1),
      mixins: [TimepickerMixin],
      props: {
        pickerSize: {
          type: Number,
          default: 290
        },
        incrementMinutes: {
          type: Number,
          default: 5
        },
        autoSwitch: {
          type: Boolean,
          default: true
        },
        type: {
          type: String,
          default: 'is-primary'
        },
        hoursLabel: {
          type: String,
          default: function _default() {
            return config$2.defaultClockpickerHoursLabel || 'Hours';
          }
        },
        minutesLabel: {
          type: String,
          default: function _default() {
            return config$2.defaultClockpickerMinutesLabel || 'Min';
          }
        }
      },
      data: function data() {
        return {
          isSelectingHour: true,
          isDragging: false,
          _isClockpicker: true
        };
      },
      computed: {
        hoursDisplay: function hoursDisplay() {
          if (this.hoursSelected == null) return '--';
          if (this.isHourFormat24) return this.pad(this.hoursSelected);
          var display = this.hoursSelected;

          if (this.meridienSelected === this.pmString) {
            display -= 12;
          }

          if (display === 0) display = 12;
          return display;
        },
        minutesDisplay: function minutesDisplay() {
          return this.minutesSelected == null ? '--' : this.pad(this.minutesSelected);
        },
        minFaceValue: function minFaceValue() {
          return this.isSelectingHour && !this.isHourFormat24 && this.meridienSelected === this.pmString ? 12 : 0;
        },
        maxFaceValue: function maxFaceValue() {
          return this.isSelectingHour ? !this.isHourFormat24 && this.meridienSelected === this.amString ? 11 : 23 : 59;
        },
        faceSize: function faceSize() {
          return this.pickerSize - outerPadding * 2;
        },
        faceDisabledValues: function faceDisabledValues() {
          return this.isSelectingHour ? this.isHourDisabled : this.isMinuteDisabled;
        }
      },
      methods: {
        onClockInput: function onClockInput(value) {
          if (this.isSelectingHour) {
            this.hoursSelected = value;
            this.onHoursChange(value);
          } else {
            this.minutesSelected = value;
            this.onMinutesChange(value);
          }
        },
        onClockChange: function onClockChange(value) {
          if (this.autoSwitch && this.isSelectingHour) {
            this.isSelectingHour = !this.isSelectingHour;
          }
        },
        onMeridienClick: function onMeridienClick(value) {
          if (this.meridienSelected !== value) {
            this.meridienSelected = value;
            this.onMeridienChange(value);
          }
        },

        /*
         * Avoid dropdown toggle when is already visible
         */
        onInputClick: function onInputClick(event) {
          if (this.$refs.dropdown.isActive) {
            event.stopPropagation();
          }
        }
      }
    };

    /* script */
    const __vue_script__$1$5 = script$1$5;

    /* template */
    var __vue_render__$1$4 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"b-clockpicker control",class:[_vm.size, _vm.type, {'is-expanded': _vm.expanded}]},[(!_vm.isMobile || _vm.inline)?_c('b-dropdown',{ref:"dropdown",attrs:{"position":_vm.position,"disabled":_vm.disabled,"inline":_vm.inline,"append-to-body":_vm.appendToBody,"append-to-body-copy-parent":""},on:{"active-change":_vm.onActiveChange},scopedSlots:_vm._u([(!_vm.inline)?{key:"trigger",fn:function(){return [_vm._t("trigger",[_c('b-input',_vm._b({ref:"input",attrs:{"slot":"trigger","autocomplete":"off","value":_vm.formatValue(_vm.computedValue),"placeholder":_vm.placeholder,"size":_vm.size,"icon":_vm.icon,"icon-pack":_vm.iconPack,"loading":_vm.loading,"disabled":_vm.disabled,"readonly":!_vm.editable,"rounded":_vm.rounded,"use-html5-validation":_vm.useHtml5Validation},on:{"focus":_vm.handleOnFocus,"blur":function($event){return _vm.checkHtml5Validity()}},nativeOn:{"click":function($event){return _vm.onInputClick($event)},"keyup":function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"enter",13,$event.key,"Enter")){ return null; }return _vm.toggle(true)},"change":function($event){return _vm.onChange($event.target.value)}},slot:"trigger"},'b-input',_vm.$attrs,false))])]},proxy:true}:null],null,true)},[_c('div',{staticClass:"card",attrs:{"disabled":_vm.disabled,"custom":""}},[(_vm.inline)?_c('header',{staticClass:"card-header"},[_c('div',{staticClass:"b-clockpicker-header card-header-title"},[_c('div',{staticClass:"b-clockpicker-time"},[_c('span',{staticClass:"b-clockpicker-btn",class:{ active: _vm.isSelectingHour },on:{"click":function($event){_vm.isSelectingHour = true;}}},[_vm._v(_vm._s(_vm.hoursDisplay))]),_c('span',[_vm._v(_vm._s(_vm.hourLiteral))]),_c('span',{staticClass:"b-clockpicker-btn",class:{ active: !_vm.isSelectingHour },on:{"click":function($event){_vm.isSelectingHour = false;}}},[_vm._v(_vm._s(_vm.minutesDisplay))])]),(!_vm.isHourFormat24)?_c('div',{staticClass:"b-clockpicker-period"},[_c('div',{staticClass:"b-clockpicker-btn",class:{
                                    active: _vm.meridienSelected === _vm.amString || _vm.meridienSelected === _vm.AM
                                },on:{"click":function($event){return _vm.onMeridienClick(_vm.amString)}}},[_vm._v(_vm._s(_vm.amString))]),_c('div',{staticClass:"b-clockpicker-btn",class:{
                                    active: _vm.meridienSelected === _vm.pmString || _vm.meridienSelected === _vm.PM
                                },on:{"click":function($event){return _vm.onMeridienClick(_vm.pmString)}}},[_vm._v(_vm._s(_vm.pmString))])]):_vm._e()])]):_vm._e(),_c('div',{staticClass:"card-content"},[_c('div',{staticClass:"b-clockpicker-body",style:({ width: _vm.faceSize + 'px', height: _vm.faceSize + 'px' })},[(!_vm.inline)?_c('div',{staticClass:"b-clockpicker-time"},[_c('div',{staticClass:"b-clockpicker-btn",class:{ active: _vm.isSelectingHour },on:{"click":function($event){_vm.isSelectingHour = true;}}},[_vm._v(_vm._s(_vm.hoursLabel))]),_c('span',{staticClass:"b-clockpicker-btn",class:{ active: !_vm.isSelectingHour },on:{"click":function($event){_vm.isSelectingHour = false;}}},[_vm._v(_vm._s(_vm.minutesLabel))])]):_vm._e(),(!_vm.isHourFormat24 && !_vm.inline)?_c('div',{staticClass:"b-clockpicker-period"},[_c('div',{staticClass:"b-clockpicker-btn",class:{
                                    active: _vm.meridienSelected === _vm.amString || _vm.meridienSelected === _vm.AM
                                },on:{"click":function($event){return _vm.onMeridienClick(_vm.amString)}}},[_vm._v(_vm._s(_vm.amString))]),_c('div',{staticClass:"b-clockpicker-btn",class:{
                                    active: _vm.meridienSelected === _vm.pmString || _vm.meridienSelected === _vm.PM
                                },on:{"click":function($event){return _vm.onMeridienClick(_vm.pmString)}}},[_vm._v(_vm._s(_vm.pmString))])]):_vm._e(),_c('b-clockpicker-face',{attrs:{"picker-size":_vm.faceSize,"min":_vm.minFaceValue,"max":_vm.maxFaceValue,"face-numbers":_vm.isSelectingHour ? _vm.hours : _vm.minutes,"disabled-values":_vm.faceDisabledValues,"double":_vm.isSelectingHour && _vm.isHourFormat24,"value":_vm.isSelectingHour ? _vm.hoursSelected : _vm.minutesSelected},on:{"input":_vm.onClockInput,"change":_vm.onClockChange}})],1)]),(_vm.$slots.default !== undefined && _vm.$slots.default.length)?_c('footer',{staticClass:"b-clockpicker-footer card-footer"},[_vm._t("default")],2):_vm._e()])]):_c('b-input',_vm._b({ref:"input",attrs:{"type":"time","autocomplete":"off","value":_vm.formatHHMMSS(_vm.computedValue),"placeholder":_vm.placeholder,"size":_vm.size,"icon":_vm.icon,"icon-pack":_vm.iconPack,"loading":_vm.loading,"max":_vm.formatHHMMSS(_vm.maxTime),"min":_vm.formatHHMMSS(_vm.minTime),"disabled":_vm.disabled,"readonly":false,"use-html5-validation":_vm.useHtml5Validation},on:{"focus":_vm.handleOnFocus,"blur":function($event){_vm.onBlur() && _vm.checkHtml5Validity();}},nativeOn:{"click":function($event){$event.stopPropagation();return _vm.toggle(true)},"keyup":function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"enter",13,$event.key,"Enter")){ return null; }return _vm.toggle(true)},"change":function($event){return _vm.onChangeNativePicker($event)}}},'b-input',_vm.$attrs,false))],1)};
    var __vue_staticRenderFns__$1$4 = [];

      /* style */
      const __vue_inject_styles__$1$5 = undefined;
      /* scoped */
      const __vue_scope_id__$1$5 = undefined;
      /* module identifier */
      const __vue_module_identifier__$1$5 = undefined;
      /* functional template */
      const __vue_is_functional_template__$1$5 = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var Clockpicker = normalizeComponent_1(
        { render: __vue_render__$1$4, staticRenderFns: __vue_staticRenderFns__$1$4 },
        __vue_inject_styles__$1$5,
        __vue_script__$1$5,
        __vue_scope_id__$1$5,
        __vue_is_functional_template__$1$5,
        __vue_module_identifier__$1$5,
        undefined,
        undefined
      );

    var Plugin$6 = {
      install: function install(Vue) {
        registerComponent(Vue, Clockpicker);
      }
    };
    use(Plugin$6);

    var script$d = {
      name: 'BSelect',
      components: _defineProperty({}, Icon.name, Icon),
      mixins: [FormElementMixin],
      inheritAttrs: false,
      props: {
        value: {
          type: [String, Number, Boolean, Object, Array, Function, Date],
          default: null
        },
        placeholder: String,
        multiple: Boolean,
        nativeSize: [String, Number]
      },
      data: function data() {
        return {
          selected: this.value,
          _elementRef: 'select'
        };
      },
      computed: {
        computedValue: {
          get: function get() {
            return this.selected;
          },
          set: function set(value) {
            this.selected = value;
            this.$emit('input', value);
            !this.isValid && this.checkHtml5Validity();
          }
        },
        spanClasses: function spanClasses() {
          return [this.size, this.statusType, {
            'is-fullwidth': this.expanded,
            'is-loading': this.loading,
            'is-multiple': this.multiple,
            'is-rounded': this.rounded,
            'is-empty': this.selected === null
          }];
        }
      },
      watch: {
        /**
        * When v-model is changed:
        *   1. Set the selected option.
        *   2. If it's invalid, validate again.
        */
        value: function value(_value) {
          this.selected = _value;
          !this.isValid && this.checkHtml5Validity();
        }
      }
    };

    /* script */
    const __vue_script__$d = script$d;

    /* template */
    var __vue_render__$c = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"control",class:{ 'is-expanded': _vm.expanded, 'has-icons-left': _vm.icon }},[_c('span',{staticClass:"select",class:_vm.spanClasses},[_c('select',_vm._b({directives:[{name:"model",rawName:"v-model",value:(_vm.computedValue),expression:"computedValue"}],ref:"select",attrs:{"multiple":_vm.multiple,"size":_vm.nativeSize},on:{"blur":function($event){_vm.$emit('blur', $event) && _vm.checkHtml5Validity();},"focus":function($event){return _vm.$emit('focus', $event)},"change":function($event){var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return val}); _vm.computedValue=$event.target.multiple ? $$selectedVal : $$selectedVal[0];}}},'select',_vm.$attrs,false),[(_vm.placeholder)?[(_vm.computedValue == null)?_c('option',{attrs:{"disabled":"","hidden":""},domProps:{"value":null}},[_vm._v(" "+_vm._s(_vm.placeholder)+" ")]):_vm._e()]:_vm._e(),_vm._t("default")],2)]),(_vm.icon)?_c('b-icon',{staticClass:"is-left",attrs:{"icon":_vm.icon,"pack":_vm.iconPack,"size":_vm.iconSize}}):_vm._e()],1)};
    var __vue_staticRenderFns__$c = [];

      /* style */
      const __vue_inject_styles__$d = undefined;
      /* scoped */
      const __vue_scope_id__$d = undefined;
      /* module identifier */
      const __vue_module_identifier__$d = undefined;
      /* functional template */
      const __vue_is_functional_template__$d = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var Select = normalizeComponent_1(
        { render: __vue_render__$c, staticRenderFns: __vue_staticRenderFns__$c },
        __vue_inject_styles__$d,
        __vue_script__$d,
        __vue_scope_id__$d,
        __vue_is_functional_template__$d,
        __vue_module_identifier__$d,
        undefined,
        undefined
      );

    var script$e = {
      name: 'BTooltip',
      props: {
        active: {
          type: Boolean,
          default: true
        },
        type: {
          type: String,
          default: function _default() {
            return config$2.defaultTooltipType;
          }
        },
        label: String,
        delay: {
          type: Number,
          default: function _default() {
            return config$2.defaultTooltipDelay;
          }
        },
        position: {
          type: String,
          default: 'is-top',
          validator: function validator(value) {
            return ['is-top', 'is-bottom', 'is-left', 'is-right'].indexOf(value) > -1;
          }
        },
        triggers: {
          type: Array,
          default: function _default() {
            return ['hover'];
          }
        },
        always: Boolean,
        square: Boolean,
        dashed: Boolean,
        multilined: Boolean,
        size: {
          type: String,
          default: 'is-medium'
        },
        appendToBody: Boolean,
        animated: {
          type: Boolean,
          default: true
        },
        animation: {
          type: String,
          default: 'fade'
        },
        contentClass: String,
        autoClose: {
          type: [Array, Boolean],
          default: true
        }
      },
      data: function data() {
        return {
          isActive: false,
          triggerStyle: {},
          timer: null,
          _bodyEl: undefined // Used to append to body

        };
      },
      computed: {
        rootClasses: function rootClasses() {
          return ['b-tooltip', this.type, this.position, this.size, {
            'is-square': this.square,
            'is-always': this.always,
            'is-multiline': this.multilined,
            'is-dashed': this.dashed
          }];
        },
        newAnimation: function newAnimation() {
          return this.animated ? this.animation : undefined;
        }
      },
      watch: {
        isActive: function isActive() {
          this.$emit(this.isActive ? 'open' : 'close');

          if (this.appendToBody) {
            this.updateAppendToBody();
          }
        }
      },
      methods: {
        updateAppendToBody: function updateAppendToBody() {
          var tooltip = this.$refs.tooltip;
          var trigger = this.$refs.trigger;

          if (tooltip && trigger) {
            // update wrapper tooltip
            var tooltipEl = this.$data._bodyEl.children[0];
            tooltipEl.classList.forEach(function (item) {
              return tooltipEl.classList.remove(item);
            });

            if (this.$vnode && this.$vnode.data && this.$vnode.data.staticClass) {
              tooltipEl.classList.add(this.$vnode.data.staticClass);
            }

            this.rootClasses.forEach(function (item) {
              if (_typeof(item) === 'object') {
                for (var key in item) {
                  if (item[key]) {
                    tooltipEl.classList.add(key);
                  }
                }
              } else {
                tooltipEl.classList.add(item);
              }
            });
            var rect = trigger.getBoundingClientRect();
            var top = rect.top + window.scrollY;
            var left = rect.left + window.scrollX;
            var quaterHeight = trigger.clientHeight / 2 / 2;

            switch (this.position) {
              case 'is-top':
                tooltipEl.style.width = "".concat(trigger.clientWidth, "px");
                tooltipEl.style.height = "0px";
                top -= trigger.clientHeight - quaterHeight;
                break;

              case 'is-bottom':
                tooltipEl.style.width = "".concat(trigger.clientWidth, "px");
                tooltipEl.style.height = "0px";
                top += quaterHeight;
                break;

              case 'is-left':
                tooltipEl.style.width = "0px";
                tooltipEl.style.height = "".concat(trigger.clientHeight, "px");
                break;

              case 'is-right':
                tooltipEl.style.width = "0px";
                tooltipEl.style.height = "".concat(trigger.clientHeight, "px");
                left += trigger.clientWidth;
                break;
            }

            var wrapper = this.$data._bodyEl;
            wrapper.style.position = 'absolute';
            wrapper.style.top = "".concat(top, "px");
            wrapper.style.left = "".concat(left, "px");
            wrapper.style.width = "0px";
            wrapper.style.zIndex = this.isActive || this.always ? '99' : '-1';
            this.triggerStyle = {
              zIndex: this.isActive || this.always ? '100' : undefined
            };
          }
        },
        onClick: function onClick() {
          var _this = this;

          if (this.triggers.indexOf('click') < 0) return; // if not active, toggle after clickOutside event
          // this fixes toggling programmatic

          this.$nextTick(function () {
            setTimeout(function () {
              return _this.open();
            });
          });
        },
        onHover: function onHover() {
          if (this.triggers.indexOf('hover') < 0) return;
          this.open();
        },
        onContextMenu: function onContextMenu(e) {
          if (this.triggers.indexOf('contextmenu') < 0) return;
          e.preventDefault();
          this.open();
        },
        onFocus: function onFocus() {
          if (this.triggers.indexOf('focus') < 0) return;
          this.open();
        },
        open: function open() {
          var _this2 = this;

          if (this.delay) {
            this.timer = setTimeout(function () {
              _this2.isActive = true;
              _this2.timer = null;
            }, this.delay);
          } else {
            this.isActive = true;
          }
        },
        close: function close() {
          if (typeof this.autoClose === 'boolean') {
            this.isActive = !this.autoClose;
            if (this.autoClose && this.timer) clearTimeout(this.timer);
          }
        },

        /**
        * Close tooltip if clicked outside.
        */
        clickedOutside: function clickedOutside(event) {
          if (this.isActive) {
            if (Array.isArray(this.autoClose)) {
              if (this.autoClose.includes('outside')) {
                if (!this.isInWhiteList(event.target)) {
                  this.isActive = false;
                  return;
                }
              }

              if (this.autoClose.includes('inside')) {
                if (this.isInWhiteList(event.target)) this.isActive = false;
              }
            }
          }
        },

        /**
         * Keypress event that is bound to the document
         */
        keyPress: function keyPress(_ref) {
          var key = _ref.key;

          if (this.isActive && (key === 'Escape' || key === 'Esc')) {
            if (Array.isArray(this.autoClose)) {
              if (this.autoClose.indexOf('escape') >= 0) this.isActive = false;
            }
          }
        },

        /**
        * White-listed items to not close when clicked.
        */
        isInWhiteList: function isInWhiteList(el) {
          if (el === this.$refs.content) return true; // All chidren from content

          if (this.$refs.content !== undefined) {
            var children = this.$refs.content.querySelectorAll('*');
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var child = _step.value;

                if (el === child) {
                  return true;
                }
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
          }

          return false;
        }
      },
      mounted: function mounted() {
        if (this.appendToBody && typeof window !== 'undefined') {
          this.$data._bodyEl = createAbsoluteElement(this.$refs.content);
          this.updateAppendToBody();
        }
      },
      created: function created() {
        if (typeof window !== 'undefined') {
          document.addEventListener('click', this.clickedOutside);
          document.addEventListener('keyup', this.keyPress);
        }
      },
      beforeDestroy: function beforeDestroy() {
        if (typeof window !== 'undefined') {
          document.removeEventListener('click', this.clickedOutside);
          document.removeEventListener('keyup', this.keyPress);
        }

        if (this.appendToBody) {
          removeElement(this.$data._bodyEl);
        }
      }
    };

    /* script */
    const __vue_script__$e = script$e;

    /* template */
    var __vue_render__$d = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{ref:"tooltip",class:_vm.rootClasses},[_c('transition',{attrs:{"name":_vm.newAnimation}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.active && (_vm.isActive || _vm.always)),expression:"active && (isActive || always)"}],ref:"content",class:['tooltip-content', _vm.contentClass]},[(_vm.label)?[_vm._v(_vm._s(_vm.label))]:(_vm.$slots.content)?[_vm._t("content")]:_vm._e()],2)]),_c('div',{ref:"trigger",staticClass:"tooltip-trigger",style:(_vm.triggerStyle),on:{"click":_vm.onClick,"contextmenu":_vm.onContextMenu,"mouseenter":_vm.onHover,"!focus":function($event){return _vm.onFocus($event)},"!blur":function($event){return _vm.close($event)},"mouseleave":_vm.close}},[_vm._t("default")],2)],1)};
    var __vue_staticRenderFns__$d = [];

      /* style */
      const __vue_inject_styles__$e = undefined;
      /* scoped */
      const __vue_scope_id__$e = undefined;
      /* module identifier */
      const __vue_module_identifier__$e = undefined;
      /* functional template */
      const __vue_is_functional_template__$e = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var Tooltip = normalizeComponent_1(
        { render: __vue_render__$d, staticRenderFns: __vue_staticRenderFns__$d },
        __vue_inject_styles__$e,
        __vue_script__$e,
        __vue_scope_id__$e,
        __vue_is_functional_template__$e,
        __vue_module_identifier__$e,
        undefined,
        undefined
      );

    var colorChannels = ['red', 'green', 'blue', 'alpha'];
    var colorsNammed = {
      black: '#000000',
      silver: '#c0c0c0',
      gray: '#808080',
      white: '#ffffff',
      maroon: '#800000',
      red: '#ff0000',
      purple: '#800080',
      fuchsia: '#ff00ff',
      green: '#008000',
      lime: '#00ff00',
      olive: '#808000',
      yellow: '#ffff00',
      navy: '#000080',
      blue: '#0000ff',
      teal: '#008080',
      aqua: '#00ffff',
      orange: '#ffa500',
      aliceblue: '#f0f8ff',
      antiquewhite: '#faebd7',
      aquamarine: '#7fffd4',
      azure: '#f0ffff',
      beige: '#f5f5dc',
      bisque: '#ffe4c4',
      blanchedalmond: '#ffebcd',
      blueviolet: '#8a2be2',
      brown: '#a52a2a',
      burlywood: '#deb887',
      cadetblue: '#5f9ea0',
      chartreuse: '#7fff00',
      chocolate: '#d2691e',
      coral: '#ff7f50',
      cornflowerblue: '#6495ed',
      cornsilk: '#fff8dc',
      crimson: '#dc143c',
      cyan: '#00ffff',
      darkblue: '#00008b',
      darkcyan: '#008b8b',
      darkgoldenrod: '#b8860b',
      darkgray: '#a9a9a9',
      darkgreen: '#006400',
      darkgrey: '#a9a9a9',
      darkkhaki: '#bdb76b',
      darkmagenta: '#8b008b',
      darkolivegreen: '#556b2f',
      darkorange: '#ff8c00',
      darkorchid: '#9932cc',
      darkred: '#8b0000',
      darksalmon: '#e9967a',
      darkseagreen: '#8fbc8f',
      darkslateblue: '#483d8b',
      darkslategray: '#2f4f4f',
      darkslategrey: '#2f4f4f',
      darkturquoise: '#00ced1',
      darkviolet: '#9400d3',
      deeppink: '#ff1493',
      deepskyblue: '#00bfff',
      dimgray: '#696969',
      dimgrey: '#696969',
      dodgerblue: '#1e90ff',
      firebrick: '#b22222',
      floralwhite: '#fffaf0',
      forestgreen: '#228b22',
      gainsboro: '#dcdcdc',
      ghostwhite: '#f8f8ff',
      gold: '#ffd700',
      goldenrod: '#daa520',
      greenyellow: '#adff2f',
      grey: '#808080',
      honeydew: '#f0fff0',
      hotpink: '#ff69b4',
      indianred: '#cd5c5c',
      indigo: '#4b0082',
      ivory: '#fffff0',
      khaki: '#f0e68c',
      lavender: '#e6e6fa',
      lavenderblush: '#fff0f5',
      lawngreen: '#7cfc00',
      lemonchiffon: '#fffacd',
      lightblue: '#add8e6',
      lightcoral: '#f08080',
      lightcyan: '#e0ffff',
      lightgoldenrodyellow: '#fafad2',
      lightgray: '#d3d3d3',
      lightgreen: '#90ee90',
      lightgrey: '#d3d3d3',
      lightpink: '#ffb6c1',
      lightsalmon: '#ffa07a',
      lightseagreen: '#20b2aa',
      lightskyblue: '#87cefa',
      lightslategray: '#778899',
      lightslategrey: '#778899',
      lightsteelblue: '#b0c4de',
      lightyellow: '#ffffe0',
      limegreen: '#32cd32',
      linen: '#faf0e6',
      magenta: '#ff00ff',
      mediumaquamarine: '#66cdaa',
      mediumblue: '#0000cd',
      mediumorchid: '#ba55d3',
      mediumpurple: '#9370db',
      mediumseagreen: '#3cb371',
      mediumslateblue: '#7b68ee',
      mediumspringgreen: '#00fa9a',
      mediumturquoise: '#48d1cc',
      mediumvioletred: '#c71585',
      midnightblue: '#191970',
      mintcream: '#f5fffa',
      mistyrose: '#ffe4e1',
      moccasin: '#ffe4b5',
      navajowhite: '#ffdead',
      oldlace: '#fdf5e6',
      olivedrab: '#6b8e23',
      orangered: '#ff4500',
      orchid: '#da70d6',
      palegoldenrod: '#eee8aa',
      palegreen: '#98fb98',
      paleturquoise: '#afeeee',
      palevioletred: '#db7093',
      papayawhip: '#ffefd5',
      peachpuff: '#ffdab9',
      peru: '#cd853f',
      pink: '#ffc0cb',
      plum: '#dda0dd',
      powderblue: '#b0e0e6',
      rosybrown: '#bc8f8f',
      royalblue: '#4169e1',
      saddlebrown: '#8b4513',
      salmon: '#fa8072',
      sandybrown: '#f4a460',
      seagreen: '#2e8b57',
      seashell: '#fff5ee',
      sienna: '#a0522d',
      skyblue: '#87ceeb',
      slateblue: '#6a5acd',
      slategray: '#708090',
      slategrey: '#708090',
      snow: '#fffafa',
      springgreen: '#00ff7f',
      steelblue: '#4682b4',
      tan: '#d2b48c',
      thistle: '#d8bfd8',
      tomato: '#ff6347',
      turquoise: '#40e0d0',
      violet: '#ee82ee',
      wheat: '#f5deb3',
      whitesmoke: '#f5f5f5',
      yellowgreen: '#9acd32',
      rebeccapurple: '#663399'
    };
    var ColorTypeError =
    /*#__PURE__*/
    function (_Error) {
      _inherits(ColorTypeError, _Error);

      function ColorTypeError() {
        _classCallCheck(this, ColorTypeError);

        return _possibleConstructorReturn(this, _getPrototypeOf(ColorTypeError).call(this, 'ColorTypeError: type must be hex(a), rgb(a) or hsl(a)'));
      }

      return ColorTypeError;
    }(_wrapNativeSuper(Error));

    var Color =
    /*#__PURE__*/
    function () {
      function Color() {
        var _this = this;

        _classCallCheck(this, Color);

        if (arguments.length > 0) {
          return Color.parse.apply(Color, arguments);
        }

        this.$channels = new Uint8Array(colorChannels.length);
        colorChannels.forEach(function (channel, index) {
          Object.defineProperty(_this, channel, {
            get: function get() {
              return _this.$channels[index];
            },
            set: function set(byte) {
              if (!Number.isNaN(byte / 1)) {
                _this.$channels[index] = Math.min(255, Math.max(0, byte));
              }
            },
            enumerable: true,
            configurable: true
          });
        }) // Required for observability
        ;
        ['hue', 'saturation', 'lightness'].forEach(function (name) {
          var capitalizedName = name.replace(/^./, function (m) {
            return m.toUpperCase();
          });
          Object.defineProperty(_this, name, {
            get: function get() {
              return _this["get".concat(capitalizedName)]();
            },
            set: function set(value) {
              if (!Number.isNaN(value / 1)) {
                _this["set".concat(capitalizedName)](value);
              }
            },
            enumerable: true,
            configurable: true
          });
        });
      }

      _createClass(Color, [{
        key: "getHue",
        value: function getHue() {
          var _Array$from$map = Array.from(this.$channels).map(function (c) {
            return c / 255;
          }),
              _Array$from$map2 = _slicedToArray(_Array$from$map, 3),
              red = _Array$from$map2[0],
              green = _Array$from$map2[1],
              blue = _Array$from$map2[2];

          var _ref = [Math.min(red, green, blue), Math.max(red, green, blue)],
              min = _ref[0],
              max = _ref[1];
          var delta = max - min;
          var hue = 0;

          if (delta === 0) {
            return hue;
          }

          if (red === max) {
            hue = (green - blue) / delta % 6;
          } else if (green === max) {
            hue = (blue - red) / delta + 2;
          } else {
            hue = (red - green) / delta + 4;
          }

          hue *= 60;

          while (hue !== -Infinity && hue < 0) {
            hue += 360;
          }

          return Math.round(hue % 360);
        }
      }, {
        key: "setHue",
        value: function setHue(value) {
          var color = Color.fromHSL(value, this.saturation, this.lightness, this.alpha / 255);

          for (var i = 0; i < this.$channels.length; i++) {
            this.$channels[i] = Number(color.$channels[i]);
          }
        }
      }, {
        key: "getSaturation",
        value: function getSaturation() {
          var _Array$from$map3 = Array.from(this.$channels).map(function (c) {
            return c / 255;
          }),
              _Array$from$map4 = _slicedToArray(_Array$from$map3, 3),
              red = _Array$from$map4[0],
              green = _Array$from$map4[1],
              blue = _Array$from$map4[2];

          var _ref2 = [Math.min(red, green, blue), Math.max(red, green, blue)],
              min = _ref2[0],
              max = _ref2[1];
          var delta = max - min;
          return delta !== 0 ? Math.round(delta / (1 - Math.abs(2 * this.lightness - 1)) * 100) / 100 : 0;
        }
      }, {
        key: "setSaturation",
        value: function setSaturation(value) {
          var _this2 = this;

          var color = Color.fromHSL(this.hue, value, this.lightness, this.alpha / 255);
          colorChannels.forEach(function (_, i) {
            return _this2.$channels[i] = color.$channels[i];
          });
        }
      }, {
        key: "getLightness",
        value: function getLightness() {
          var _Array$from$map5 = Array.from(this.$channels).map(function (c) {
            return c / 255;
          }),
              _Array$from$map6 = _slicedToArray(_Array$from$map5, 3),
              red = _Array$from$map6[0],
              green = _Array$from$map6[1],
              blue = _Array$from$map6[2];

          var _ref3 = [Math.min(red, green, blue), Math.max(red, green, blue)],
              min = _ref3[0],
              max = _ref3[1];
          return Math.round((max + min) / 2 * 100) / 100;
        }
      }, {
        key: "setLightness",
        value: function setLightness(value) {
          var _this3 = this;

          var color = Color.fromHSL(this.hue, this.lightness, value, this.alpha / 255);
          colorChannels.forEach(function (_, i) {
            return _this3.$channels[i] = color.$channels[i];
          });
        }
      }, {
        key: "clone",
        value: function clone() {
          var _this4 = this;

          var color = new Color();
          colorChannels.forEach(function (_, i) {
            return color.$channels[i] = _this4.$channels[i];
          });
          return color;
        }
      }, {
        key: "toString",
        value: function toString() {
          var _this5 = this;

          var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'hex';

          switch (String(type).toLowerCase()) {
            case 'hex':
              return '#' + colorChannels.slice(0, 3).map(function (channel) {
                return _this5[channel].toString(16).padStart(2, '0');
              }).join('');

            case 'hexa':
              return '#' + colorChannels.map(function (channel) {
                return _this5[channel].toString(16).padStart(2, '0');
              }).join('');

            case 'rgb':
              return "rgb(".concat(this.red, ", ").concat(this.green, ", ").concat(this.blue, ")");

            case 'rgba':
              return "rgba(".concat(this.red, ", ").concat(this.green, ", ").concat(this.blue, ", ").concat(Math.round(this.alpha / 2.55) / 100, ")");

            case 'hsl':
              return "hsl(".concat(Math.round(this.hue), "deg, ").concat(Math.round(this.saturation * 100), "%, ").concat(Math.round(this.lightness * 100), "%)");

            case 'hsla':
              return "hsla(".concat(Math.round(this.hue), "deg, ").concat(Math.round(this.saturation * 100), "%, ").concat(Math.round(this.lightness * 100), "%, ").concat(Math.round(this.alpha / 2.55) / 100, ")");

            default:
              throw new ColorTypeError();
          }
        }
      }, {
        key: Symbol.toString,
        get: function get() {
          return this.toString('hex');
        }
      }], [{
        key: "parse",
        value: function parse() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          if (_typeof(args[0]) === 'object') {
            return Color.parseObject(args[0]);
          } else if (args.every(function (arg) {
            return !Number.isNaN(arg / 1);
          })) {
            var color = new Color();

            if (args.length > 3) {
              color.red = args[0];
              color.green = args[1];
              color.blue = args[2];

              if (args[3]) {
                color.alpha = args[3];
              }
            } else if (args.length === 1) {
              var index = Number(args[0]);
              return Color.parseIndex(index, index > Math.pow(2, 24) ? 3 : 4);
            }
          } else if (typeof args[0] === 'string') {
            var match = null;

            if (typeof colorsNammed[args[0].toLowerCase()] === 'string') {
              return Color.parseHex(colorsNammed[args[0].toLowerCase()]);
            } else if ((match = args[0].match(/^(#|&h|0x)?(([a-f0-9]{3,4}){1,2})$/i)) !== null) {
              return Color.parseHex(match[2]);
            } else if ((match = args[0].match(/^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)(\s*,\s*(\d*\.?\d+))?\s*\)$/i)) !== null) {
              var channels = [match[1], match[2], match[3], typeof match[5] !== 'undefined' ? match[5] : 1];
              return Color.fromRGB.apply(Color, _toConsumableArray(channels.map(function (value) {
                return Number(value);
              })));
            } else if (match = args[0].match(/^(h(sl|wb)a?|lab|color|cmyk)\(/i)) {
              throw new Error('Color expression not implemented yet');
            }
          }

          return new Color();
        }
      }, {
        key: "parseObject",
        value: function parseObject(object) {
          var color = new Color();

          if (object === null || _typeof(object) !== 'object') {
            return color;
          }

          if (Color.isColor(object)) {
            return object.clone();
          }

          colorChannels.forEach(function (channel) {
            if (!Number.isNaN(object[channel])) {
              color[channel] = object[channel];
            }
          });
          return color;
        }
      }, {
        key: "parseHex",
        value: function parseHex(hex) {
          if (typeof hex !== 'string') {
            throw new Error('Hex expression must be a string');
          }

          hex = hex.trim().replace(/^(0x|&h|#)/i, '');

          if (hex.length === 3 || hex.length === 4) {
            hex = hex.split('').map(function (c) {
              return c.repeat(2);
            }).join('');
          }

          if (!(hex.length === 6 || hex.length === 8)) {
            throw new Error('Incorrect Hex expression length');
          }

          var chans = hex.split(/(..)/).filter(function (value) {
            return value;
          }).map(function (value) {
            return Number.parseInt(value, 16);
          });

          if (typeof chans[3] === 'number') {
            chans[3] /= 255;
          }

          return Color.fromRGB.apply(Color, _toConsumableArray(chans));
        }
      }, {
        key: "parseIndex",
        value: function parseIndex(value) {
          var channels = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;
          var color = new Color();

          for (var i = 0; i < 4; i++) {
            color[colorChannels[i]] = value >> (channels - i) * 8 && 0xff;
          }

          return color;
        }
      }, {
        key: "fromRGB",
        value: function fromRGB(red, green, blue) {
          var alpha = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

          if ([red, green, blue, alpha].some(function (arg) {
            return Number.isNaN(arg / 1);
          })) {
            throw new Error('Invalid arguments');
          }

          alpha *= 255;
          var color = new Color();
          [red, green, blue, alpha].forEach(function (value, index) {
            color[colorChannels[index]] = value;
          });
          return color;
        }
      }, {
        key: "fromHSL",
        value: function fromHSL(hue, saturation, lightness) {
          var alpha = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

          if ([hue, saturation, lightness, alpha].some(function (arg) {
            return Number.isNaN(arg);
          })) {
            throw new Error('Invalid arguments');
          }

          while (hue < 0 && hue !== -Infinity) {
            hue += 360;
          }

          hue = hue % 360;
          saturation = Math.max(0, Math.min(1, saturation));
          lightness = Math.max(0, Math.min(1, lightness));
          alpha = Math.max(0, Math.min(1, alpha));
          var c = (1 - Math.abs(2 * lightness - 1)) * saturation;
          var x = c * (1 - Math.abs(hue / 60 % 2 - 1));
          var m = lightness - c / 2;

          var _ref4 = hue < 60 ? [c, x, 0] : hue < 120 ? [x, c, 0] : hue < 180 ? [0, c, x] : hue < 240 ? [0, x, c] : hue < 300 ? [x, 0, c] : [c, 0, x],
              _ref5 = _slicedToArray(_ref4, 3),
              r = _ref5[0],
              g = _ref5[1],
              b = _ref5[2];

          return Color.fromRGB((r + m) * 255, (g + m) * 255, (b + m) * 255, alpha);
        }
      }, {
        key: "isColor",
        value: function isColor(arg) {
          return arg instanceof Color;
        }
      }]);

      return Color;
    }();

    //
    var cos30 = 0.86602540378;
    var sin30 = 0.5;
    var id = 0;
    var script$f = {
      name: 'BColorpickerHSLRepresentationTriangle',
      props: {
        value: {
          type: Object,
          required: true,
          validator: function validator(value) {
            return typeof value.hue === 'number' && typeof value.saturation === 'number' && typeof value.lightness === 'number';
          }
        },
        size: {
          type: Number,
          default: 200
        },
        thickness: {
          type: Number,
          default: 20
        }
      },
      data: function data() {
        return {
          id: id++,
          hue: this.value.hue,
          saturation: this.value.saturation,
          lightness: this.value.lightness,
          captureMouse: false,
          captureType: 'hue',
          clientOffset: {
            cx: -1,
            cy: -1,
            width: 0,
            height: 0
          },
          cos30: cos30,
          sin30: sin30,
          debounce: 0
        };
      },
      computed: {
        viewBox: function viewBox() {
          var size = this.size;
          return "0 0 ".concat(size, " ").concat(size);
        },
        internalRadius: function internalRadius() {
          return this.size / 2 - this.thickness;
        },
        haloPath: function haloPath() {
          var size = this.size,
              thickness = this.thickness;
          var radius = size / 2 - 2; // 2px padding

          var thicknessRadius = radius - thickness;
          var center = size / 2;
          return "M".concat(center - radius, " ").concat(center, "a").concat(radius, "  ").concat(radius, "  0 1 1 ").concat(2 * radius, " 0") + "h".concat(-thickness) + "a".concat(-thicknessRadius, "  ").concat(thicknessRadius, "  0 1 0 ").concat(-2 * thicknessRadius, " 0") + "a".concat(thicknessRadius, "  ").concat(thicknessRadius, "  0 1 0 ").concat(2 * thicknessRadius, " 0") + "h".concat(thickness) + "a".concat(radius, "  ").concat(radius, "  0 1 1 ").concat(-2 * radius, " 0z");
        },
        trianglePath: function trianglePath() {
          var size = this.size,
              thickness = this.thickness;
          var radius = size - 4;
          var thicknessRadius = (radius - 2 * thickness) / 2;
          return "M0 ".concat(-thicknessRadius) + "L".concat(cos30 * thicknessRadius, " ").concat(sin30 * thicknessRadius) + "H".concat(-cos30 * thicknessRadius, "z");
        }
      },
      watch: {
        captureMouse: function captureMouse(newValue, oldValue) {
          if (oldValue === false && newValue !== false) {
            var rect = this.$el.getBoundingClientRect(); // Caching offset

            this.clientOffset.cx = rect.x + rect.width / 2;
            this.clientOffset.cy = rect.y + rect.height / 2;
            this.clientOffset.width = rect.width;
            this.clientOffset.height = rect.height;
          }
        },
        value: {
          deep: true,
          handler: function handler(newColor) {
            var _this = this;

            var hue = newColor.hue,
                saturation = newColor.saturation,
                lightness = newColor.lightness;
            window.clearTimeout(this.debounce);
            this.debounce = window.setTimeout(function () {
              if (lightness >= 0.03 && lightness <= 0.97 && saturation > 0) {
                _this.hue = hue;
              }

              _this.saturation = saturation;
              _this.lightness = lightness;
            }, 200);
          }
        }
      },
      methods: {
        increaseHue: function increaseHue() {
          var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
          this.hue = (this.hue + value) % 360;
        },
        decreaseHue: function decreaseHue() {
          var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
          this.hue = (360 + this.hue - value) % 360;
        },
        increaseSaturation: function increaseSaturation() {
          var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.01;
          this.saturation = Math.min(1, Math.max(0, this.saturation + value));
          this.lightness = Math.min(0.5 + (1 - this.saturation) * 0.5, Math.max(0.5 - (1 - this.saturation) * 0.5, this.lightness));
        },
        decreaseSaturation: function decreaseSaturation() {
          var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.01;
          this.saturation = Math.min(1, Math.max(0, this.saturation - value));
          this.lightness = Math.min(0.5 + (1 - this.saturation) * 0.5, Math.max(0.5 - (1 - this.saturation) * 0.5, this.lightness));
        },
        increaseLightness: function increaseLightness() {
          var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.01;
          this.lightness = Math.min(0.5 + (1 - this.saturation) * 0.5, Math.max(0.5 - (1 - this.saturation) * 0.5, this.lightness + value));
        },
        decreaseLightness: function decreaseLightness() {
          var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.01;
          this.lightness = Math.min(0.5 + (1 - this.saturation) * 0.5, Math.max(0.5 - (1 - this.saturation) * 0.5, this.lightness - value));
        },
        hueKeyPress: function hueKeyPress(event) {
          var handled = false;

          switch (event.key) {
            case 'ArrowRight':
            case 'ArrowUp':
              this.increaseHue();
              handled = true;
              break;

            case 'ArrowLeft':
            case 'ArrowDown':
              this.decreaseHue();
              handled = true;
              break;

            case 'Home':
              this.increaseHue(360 - this.hue);
              handled = true;
              break;

            case 'End':
              this.decreaseHue(this.hue);
              handled = true;
              break;

            case 'PageUp':
              this.increaseHue(60 - this.hue % 60);
              handled = true;
              break;

            case 'PageDown':
              this.decreaseHue(60 + this.hue % 60);
              handled = true;
              break;
          }

          if (handled) {
            event.preventDefault();
            event.stopPropagation();
            this.emitColor();
          }
        },
        slKeyPress: function slKeyPress(event) {
          var handled = false;

          switch (event.key) {
            case 'ArrowRight':
              this.decreaseLightness();
              handled = true;
              break;

            case 'ArrowUp':
              this.increaseSaturation();
              handled = true;
              break;

            case 'ArrowLeft':
              this.increaseLightness();
              handled = true;
              break;

            case 'ArrowDown':
              this.decreaseSaturation();
              handled = true;
              break;

            case 'Home':
              this.increaseLightness(1 - this.lightness);
              handled = true;
              break;

            case 'End':
              this.decreaseLightness(this.lightness);
              handled = true;
              break;

            case 'PageUp':
              this.increaseSaturation(1 - this.saturation);
              handled = true;
              break;

            case 'PageDown':
              this.decreaseSaturation(this.saturation);
              handled = true;
              break;
          }

          if (handled) {
            event.preventDefault();
            event.stopPropagation();
            this.emitColor();
          }
        },
        clickHue: function clickHue(event) {
          this.startMouseCapture(event);
          this.trackMouse(event);
          this.stopMouseCapture(event);
          this.$refs.hueCursor.focus();
        },
        clickSL: function clickSL(event) {
          this.startMouseCapture(event);
          this.trackMouse(event);
          this.stopMouseCapture(event);
          this.$refs.slCursor.focus();
        },
        trackMouse: function trackMouse(event) {
          if (this.captureMouse === false) {
            return;
          }

          event.preventDefault();
          event.stopPropagation();
          var mouseX = 0,
              mouseY = 0;

          if (typeof event.touches !== 'undefined' && event.touches.length) {
            var _ref = [event.touches[0].clientX, event.touches[0].clientY];
            mouseX = _ref[0];
            mouseY = _ref[1];
          } else {
            var _ref2 = [event.clientX, event.clientY];
            mouseX = _ref2[0];
            mouseY = _ref2[1];
          }

          var angle = Math.atan2(mouseY - this.clientOffset.cy, mouseX - this.clientOffset.cx);

          if (this.captureType === 'sl') {
            var d = Math.sqrt(Math.pow(mouseX - this.clientOffset.cx, 2) + Math.pow(mouseY - this.clientOffset.cy, 2));
            var ratio = this.size / this.clientOffset.width;
            var dx = d * Math.cos(angle - this.hue / 180 * Math.PI) * ratio;
            var dy = d * Math.sin(angle - this.hue / 180 * Math.PI) * ratio;
            var radius = this.internalRadius;
            var saturation = 1 - (Math.min(radius * sin30, Math.max(-radius, dy)) + radius) / (radius + radius * sin30);
            var lightness = (Math.min(radius * cos30 * (1 - saturation), Math.max(-radius * cos30 * (1 - saturation), dx)) + radius * cos30) / (radius * 2 * cos30);
            this.saturation = Math.round(saturation * 1000) / 1000;
            this.lightness = 1 - Math.round(lightness * 1000) / 1000;
          } else {
            this.hue = Math.round(angle / Math.PI * 180 + 90) % 360;
          }

          this.emitColor();
        },
        startMouseCapture: function startMouseCapture(event) {
          event.stopPropagation();
          this.captureMouse = true;

          if (event.target.closest('.colorpicker-triangle-slider-sl') !== null) {
            this.captureType = 'sl';
          } else {
            this.captureType = 'hue';
          }
        },
        stopMouseCapture: function stopMouseCapture(event) {
          if (this.captureMouse !== false) {
            event.preventDefault();
            event.stopPropagation();
            this.$refs[this.captureType === 'sl' ? 'slCursor' : 'hueCursor'].focus();
          }

          this.captureMouse = false;
        },
        emitColor: function emitColor() {
          var hue = this.hue,
              saturation = this.saturation,
              lightness = this.lightness;
          this.$emit('input', Color.fromHSL(hue, saturation, lightness));
          window.clearTimeout(this.debounce);
        }
      },
      mounted: function mounted() {
        window.addEventListener('mousemove', this.trackMouse);
        window.addEventListener('touchmove', this.trackMouse, {
          passive: false
        });
        window.addEventListener('mouseup', this.stopMouseCapture);
        window.addEventListener('touchend', this.stopMouseCapture);
      },
      beforeDestroy: function beforeDestroy() {
        window.removeEventListener('mousemove', this.trackMouse);
        window.removeEventListener('touchmove', this.trackMouse);
        window.removeEventListener('mouseup', this.stopMouseCapture);
        window.removeEventListener('touchend', this.stopMouseCapture);
      }
    };

    /* script */
    const __vue_script__$f = script$f;

    /* template */
    var __vue_render__$e = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('svg',{staticClass:"b-colorpicker-triangle",attrs:{"viewBox":_vm.viewBox}},[_c('defs',[_c('linearGradient',{attrs:{"id":("cp-triangle-gradient-ligthness-" + _vm.id),"x1":"0","y1":"0","x2":"1","y2":"0"}},[_c('stop',{attrs:{"offset":"0%","stop-color":"#fff"}}),_c('stop',{attrs:{"offset":"100%","stop-color":"#000"}})],1),_c('linearGradient',{attrs:{"id":("cp-triangle-gradient-saturation-" + _vm.id),"x1":"0","y1":"0","x2":"0","y2":"1"}},[_c('stop',{attrs:{"offset":"0%","stop-color":("hsl(" + _vm.hue + "deg, 100%, 50%)"),"stop-opacity":"1"}}),_c('stop',{attrs:{"offset":"100%","stop-color":("hsl(" + _vm.hue + "deg, 100%, 50%)"),"stop-opacity":"0"}})],1),_c('clipPath',{attrs:{"id":("cp-triangle-clip-" + _vm.id)}},[_c('path',{attrs:{"d":_vm.haloPath}})])],1),_c('g',{staticClass:"colorpicker-triangle-slider-hue"},[_c('foreignObject',{attrs:{"x":0,"y":0,"width":_vm.size,"height":_vm.size,"clip-path":("url(#cp-triangle-clip-" + _vm.id + ")")}},[_c('div',{staticClass:"colorpicker-triangle-hue",on:{"click":_vm.clickHue,"mousedown":function($event){$event.preventDefault();return _vm.startMouseCapture($event)},"touchstart":function($event){$event.preventDefault();return _vm.startMouseCapture($event)}}})]),_c('g',{style:(("transform: rotate(" + _vm.hue + "deg)"))},[_c('foreignObject',{attrs:{"x":_vm.size / 2 - 4,"y":0,"width":"8","height":_vm.thickness + 4}},[_c('div',{ref:"hueCursor",staticClass:"hue-range-thumb",style:(("background-color: hsl(" + _vm.hue + "deg, 100%, 50%)")),attrs:{"role":"slider","tabindex":"0","aria-label":"Hue","aria-valuemin":"0","aria-valuenow":_vm.hue,"aria-valuemax":"360"},on:{"click":_vm.clickHue,"keydown":_vm.hueKeyPress,"mousedown":function($event){$event.preventDefault();return _vm.startMouseCapture($event)},"touchstart":function($event){$event.preventDefault();return _vm.startMouseCapture($event)}}})])],1)],1),_c('g',{staticClass:"colorpicker-triangle-slider-sl",style:(("transform: rotate(" + _vm.hue + "deg) translate(50%, 50%)")),attrs:{"role":"graphics-datagroup","aria-datascales":"lightness, saturation"}},[_c('path',{attrs:{"d":_vm.trianglePath,"fill":("url(#cp-triangle-gradient-ligthness-" + _vm.id + ")")}}),_c('path',{staticStyle:{"mix-blend-mode":"overlay"},attrs:{"d":_vm.trianglePath,"fill":("url(#cp-triangle-gradient-saturation-" + _vm.id + ")")},on:{"click":_vm.clickSL,"mousedown":function($event){$event.preventDefault();return _vm.startMouseCapture($event)},"touchstart":function($event){$event.preventDefault();return _vm.startMouseCapture($event)}}}),_c('foreignObject',{attrs:{"x":((_vm.internalRadius - 3) * _vm.cos30) * (-_vm.lightness + 0.5) * 2 - 6,"y":-_vm.internalRadius + (1 - _vm.saturation) * (_vm.internalRadius - 3) * 1.5 - 3,"width":"12","height":"12"}},[_c('div',{ref:"slCursor",staticClass:"sl-range-thumb",style:({
                        backgroundColor: ("hsl(" + _vm.hue + "deg, " + (_vm.saturation * 100) + "%, " + (_vm.lightness * 100) + "%)")
                    }),attrs:{"tabindex":"0","aria-datavalues":((_vm.saturation * 100) + "%, " + (_vm.lightness * 100) + "%")},on:{"click":_vm.clickSL,"keydown":_vm.slKeyPress,"mousedown":function($event){$event.preventDefault();return _vm.startMouseCapture($event)},"touchstart":function($event){$event.preventDefault();return _vm.startMouseCapture($event)}}})])],1)])};
    var __vue_staticRenderFns__$e = [];

      /* style */
      const __vue_inject_styles__$f = undefined;
      /* scoped */
      const __vue_scope_id__$f = undefined;
      /* module identifier */
      const __vue_module_identifier__$f = undefined;
      /* functional template */
      const __vue_is_functional_template__$f = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var ColorpickerHSLRepresentationTriangle = normalizeComponent_1(
        { render: __vue_render__$e, staticRenderFns: __vue_staticRenderFns__$e },
        __vue_inject_styles__$f,
        __vue_script__$f,
        __vue_scope_id__$f,
        __vue_is_functional_template__$f,
        __vue_module_identifier__$f,
        undefined,
        undefined
      );

    function _templateObject3() {
      var data = _taggedTemplateLiteral(["", "px"]);

      _templateObject3 = function _templateObject3() {
        return data;
      };

      return data;
    }

    function _templateObject2() {
      var data = _taggedTemplateLiteral(["", "px"]);

      _templateObject2 = function _templateObject2() {
        return data;
      };

      return data;
    }

    function _templateObject() {
      var data = _taggedTemplateLiteral(["", "px"]);

      _templateObject = function _templateObject() {
        return data;
      };

      return data;
    }

    var precision = function precision(strs) {
      for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        values[_key - 1] = arguments[_key];
      }

      var tmp = [];
      strs.forEach(function (str, i) {
        tmp.push(str);

        if (values[i]) {
          tmp.push(Number.isNaN(values[i] / 1) ? values[i] : Math.round(values * 10) / 10);
        }
      });
      return tmp.join('');
    };

    var script$1$6 = {
      name: 'BColorpickerHSLRepresentationSquare',
      props: {
        value: {
          type: Object,
          required: true,
          validator: function validator(value) {
            return typeof value.hue === 'number' && typeof value.saturation === 'number' && typeof value.lightness === 'number';
          }
        },
        size: {
          type: Number,
          default: 200
        },
        thickness: {
          type: Number,
          default: 20
        }
      },
      data: function data() {
        return {
          hue: this.value.hue,
          saturation: this.value.saturation,
          lightness: this.value.lightness,
          captureMouse: false,
          captureType: 'hue',
          clientOffset: {
            cx: -1,
            cy: -1,
            width: 0,
            height: 0
          },
          debounce: 0
        };
      },
      computed: {
        hueThumbStyle: function hueThumbStyle() {
          var hue = this.hue,
              size = this.size,
              thickness = this.thickness;
          var side = size - thickness;
          var offset = size / 2;
          var angle = (hue + 720 + 90) % 360 / 180 * Math.PI;
          var ciq = 1 / Math.cos(Math.PI / 4);
          var _x$y = {
            x: -Math.min(1, Math.max(-1, ciq * Math.cos(angle))) / 2 * side + offset,
            y: -Math.min(1, Math.max(-1, ciq * Math.sin(angle))) / 2 * side + offset
          },
              x = _x$y.x,
              y = _x$y.y;
          return {
            background: "hsl(".concat(hue, "deg, 100%, 50%)"),
            left: precision(_templateObject(), x),
            top: precision(_templateObject2(), y),
            width: precision(_templateObject3(), thickness - 2)
          };
        },
        slThumbStyle: function slThumbStyle() {
          var hue = this.hue,
              saturation = this.saturation,
              lightness = this.lightness;
          saturation = Math.max(0, Math.min(1, saturation));
          lightness = Math.max(0, Math.min(1, lightness));
          return {
            background: "hsl(".concat(hue, "deg, ").concat(saturation * 100, "%, ").concat(lightness * 100, "%)"),
            left: "".concat(saturation * 100, "%"),
            top: "".concat((1 - lightness) * 100, "%")
          };
        },
        SLBackground: function SLBackground() {
          var hue = this.hue;
          return "linear-gradient(90deg, hsl(".concat(hue, "deg, 0%, 50%), hsl(").concat(hue, "deg, 100%, 50%))");
        }
      },
      watch: {
        captureMouse: function captureMouse(newValue, oldValue) {
          if (oldValue === false && newValue !== false) {
            var rect = this.$el.getBoundingClientRect(); // Caching offset

            this.clientOffset.cx = rect.x + rect.width / 2;
            this.clientOffset.cy = rect.y + rect.height / 2;
            this.clientOffset.width = rect.width;
            this.clientOffset.height = rect.height;
          }
        },
        value: {
          deep: true,
          handler: function handler(newColor) {
            var _this = this;

            var hue = newColor.hue,
                saturation = newColor.saturation,
                lightness = newColor.lightness;
            window.clearTimeout(this.debounce);
            this.debounce = window.setTimeout(function () {
              _this.hue = hue;
              _this.saturation = saturation;
              _this.lightness = lightness;
            }, 200);
          }
        }
      },
      methods: {
        increaseHue: function increaseHue() {
          var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
          this.hue = (this.hue + value) % 360;
        },
        decreaseHue: function decreaseHue() {
          var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
          this.hue = (360 + this.hue - value) % 360;
        },
        increaseSaturation: function increaseSaturation() {
          var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.01;
          this.saturation = Math.min(1, Math.max(0, this.saturation + value));
          this.lightness = Math.min(0.5 + (1 - this.saturation) * 0.5, Math.max(0.5 - (1 - this.saturation) * 0.5, this.lightness));
        },
        decreaseSaturation: function decreaseSaturation() {
          var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.01;
          this.saturation = Math.min(1, Math.max(0, this.saturation - value));
          this.lightness = Math.min(0.5 + (1 - this.saturation) * 0.5, Math.max(0.5 - (1 - this.saturation) * 0.5, this.lightness));
        },
        increaseLightness: function increaseLightness() {
          var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.01;
          this.lightness = Math.min(0.5 + (1 - this.saturation) * 0.5, Math.max(0.5 - (1 - this.saturation) * 0.5, this.lightness + value));
        },
        decreaseLightness: function decreaseLightness() {
          var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.01;
          this.lightness = Math.min(0.5 + (1 - this.saturation) * 0.5, Math.max(0.5 - (1 - this.saturation) * 0.5, this.lightness - value));
        },
        hueKeyPress: function hueKeyPress(event) {
          var handled = false;

          switch (event.key) {
            case 'ArrowRight':
            case 'ArrowUp':
              this.increaseHue();
              handled = true;
              break;

            case 'ArrowLeft':
            case 'ArrowDown':
              this.decreaseHue();
              handled = true;
              break;

            case 'Home':
              this.increaseHue(360 - this.hue);
              handled = true;
              break;

            case 'End':
              this.decreaseHue(this.hue);
              handled = true;
              break;

            case 'PageUp':
              this.increaseHue(60 - this.hue % 60);
              handled = true;
              break;

            case 'PageDown':
              this.decreaseHue(60 + this.hue % 60);
              handled = true;
              break;
          }

          if (handled) {
            event.preventDefault();
            event.stopPropagation();
            this.emitColor();
          }
        },
        slKeyPress: function slKeyPress(event) {
          var handled = false;

          switch (event.key) {
            case 'ArrowRight':
              this.increaseSaturation();
              handled = true;
              break;

            case 'ArrowUp':
              this.increaseLightness();
              handled = true;
              break;

            case 'ArrowLeft':
              this.decreaseSaturation();
              handled = true;
              break;

            case 'ArrowDown':
              this.decreaseLightness();
              handled = true;
              break;

            case 'Home':
              this.increaseLightness(1 - this.lightness);
              handled = true;
              break;

            case 'End':
              this.decreaseLightness(this.lightness);
              handled = true;
              break;

            case 'PageUp':
              this.increaseSaturation(1 - this.saturation);
              handled = true;
              break;

            case 'PageDown':
              this.decreaseSaturation(this.saturation);
              handled = true;
              break;
          }

          if (handled) {
            event.preventDefault();
            event.stopPropagation();
            this.emitColor();
          }
        },
        startMouseCapture: function startMouseCapture(event) {
          event.stopPropagation();
          this.captureMouse = true;

          if (event.target.closest('.colorpicker-square-slider-sl') !== null) {
            this.captureType = 'sl';
          } else {
            this.captureType = 'hue';
          }
        },
        stopMouseCapture: function stopMouseCapture(event) {
          if (this.captureMouse !== false) {
            event.preventDefault();
            event.stopPropagation();
            this.$refs[this.captureType === 'sl' ? 'slCursor' : 'hueCursor'].focus();
          }

          this.captureMouse = false;
        },
        clickHue: function clickHue(event) {
          this.startMouseCapture(event);
          this.trackMouse(event);
          this.stopMouseCapture(event);
          this.$refs.hueCursor.focus();
        },
        clickSL: function clickSL(event) {
          this.startMouseCapture(event);
          this.trackMouse(event);
          this.stopMouseCapture(event);
          this.$refs.slCursor.focus();
        },
        trackMouse: function trackMouse(event) {
          if (this.captureMouse === false) {
            return;
          }

          event.preventDefault();
          event.stopPropagation();
          var mouseX = 0,
              mouseY = 0;

          if (typeof event.touches !== 'undefined' && event.touches.length) {
            var _ref = [event.touches[0].clientX, event.touches[0].clientY];
            mouseX = _ref[0];
            mouseY = _ref[1];
          } else {
            var _ref2 = [event.clientX, event.clientY];
            mouseX = _ref2[0];
            mouseY = _ref2[1];
          }

          var angle = Math.atan2(mouseY - this.clientOffset.cy, mouseX - this.clientOffset.cx);

          if (this.captureType === 'sl') {
            var saturation = (mouseX - this.clientOffset.cx) / (this.clientOffset.width - this.thickness * 2) + 0.5;
            var lightness = (mouseY - this.clientOffset.cy) / (this.clientOffset.height - this.thickness * 2) + 0.5;
            this.saturation = Math.round(Math.min(1, Math.max(0, saturation)) * 1000) / 1000;
            this.lightness = 1 - Math.round(Math.min(1, Math.max(0, lightness)) * 1000) / 1000;
          } else {
            this.hue = Math.round(angle / Math.PI * 180 + 90) % 360;
          }

          this.emitColor();
        },
        emitColor: function emitColor() {
          var hue = this.hue,
              saturation = this.saturation,
              lightness = this.lightness;
          this.$emit('input', Color.fromHSL(hue, saturation, lightness));
          window.clearTimeout(this.debounce);
        }
      },
      mounted: function mounted() {
        window.addEventListener('mousemove', this.trackMouse);
        window.addEventListener('touchmove', this.trackMouse, {
          passive: false
        });
        window.addEventListener('mouseup', this.stopMouseCapture);
        window.addEventListener('touchend', this.stopMouseCapture);
      },
      beforeDestroy: function beforeDestroy() {
        window.removeEventListener('mousemove', this.trackMouse);
        window.removeEventListener('touchmove', this.trackMouse);
        window.removeEventListener('mouseup', this.stopMouseCapture);
        window.removeEventListener('touchend', this.stopMouseCapture);
      }
    };

    /* script */
    const __vue_script__$1$6 = script$1$6;

    /* template */
    var __vue_render__$1$5 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"b-colorpicker-square",style:({ width: (_vm.size + "px") })},[_c('div',{staticClass:"colorpicker-square-slider-hue",on:{"click":_vm.clickHue,"mousedown":function($event){$event.preventDefault();return _vm.startMouseCapture($event)},"touchstart":function($event){$event.preventDefault();return _vm.startMouseCapture($event)}}},[_c('div',{ref:"hueCursor",staticClass:"hue-range-thumb",style:(_vm.hueThumbStyle),attrs:{"role":"slider","tabindex":"0","aria-label":"Hue","aria-valuemin":"0","aria-valuemax":"359"}})]),_c('div',{staticClass:"colorpicker-square-slider-sl",style:({
                background: _vm.SLBackground,
                margin: (_vm.thickness + "px")
            }),attrs:{"aria-datascales":"lightness, saturation"},on:{"click":_vm.clickSL,"mousedown":function($event){$event.preventDefault();return _vm.startMouseCapture($event)},"touchstart":function($event){$event.preventDefault();return _vm.startMouseCapture($event)}}},[_c('div',{ref:"slCursor",staticClass:"sl-range-thumb",style:(_vm.slThumbStyle),attrs:{"role":"slider","tabindex":"0","aria-datavalues":((_vm.saturation * 100) + "%, " + (_vm.lightness * 100) + "%")},on:{"click":_vm.clickSL,"keydown":_vm.slKeyPress,"mousedown":function($event){$event.preventDefault();return _vm.startMouseCapture($event)},"touchstart":function($event){$event.preventDefault();return _vm.startMouseCapture($event)}}})])])};
    var __vue_staticRenderFns__$1$5 = [];

      /* style */
      const __vue_inject_styles__$1$6 = undefined;
      /* scoped */
      const __vue_scope_id__$1$6 = undefined;
      /* module identifier */
      const __vue_module_identifier__$1$6 = undefined;
      /* functional template */
      const __vue_is_functional_template__$1$6 = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var ColorpickerHSLRepresentationSquare = normalizeComponent_1(
        { render: __vue_render__$1$5, staticRenderFns: __vue_staticRenderFns__$1$5 },
        __vue_inject_styles__$1$6,
        __vue_script__$1$6,
        __vue_scope_id__$1$6,
        __vue_is_functional_template__$1$6,
        __vue_module_identifier__$1$6,
        undefined,
        undefined
      );

    var script$2$2 = {
      name: 'BColorpickerAlphaSlider',
      components: _defineProperty({}, Tooltip.name, Tooltip),
      props: {
        value: {
          type: Number,
          validator: function validator(value) {
            return value >= 0 && value < 256;
          }
        },
        color: [String, Object]
      },
      data: function data() {
        var color = Color.parse(this.color);
        color.alpha = 0;
        return {
          startColor: color.toString('hex'),
          endColor: color.toString('hexa'),
          percent: Math.round((1 - this.value / 255) * 100),
          captureMouse: false,
          clientOffset: {
            cx: -1,
            cy: -1,
            width: 0,
            height: 0
          }
        };
      },
      computed: {
        style: function style() {
          return {
            backgroundImage: "linear-gradient(90deg, ".concat(this.startColor, " 0%, ").concat(this.endColor, " 100%),\n                    linear-gradient(45deg, #c7c7c7 25%, transparent 25%, transparent 75%, #c7c7c7 75%, #c7c7c7),\n                    linear-gradient(45deg, #c7c7c7 25%, transparent 25%, transparent 75%, #c7c7c7 75%, #c7c7c7)"),
            backgroundSize: '100% 100%, 1em 1em, 1em 1em',
            backgroundPosition: '0 0, .5em .5em, 0 0'
          };
        }
      },
      watch: {
        value: function value(newValue, oldValue) {
          if (newValue !== oldValue) {
            this.percent = Math.round((1 - newValue / 255) * 100);
          }
        },
        color: function color(newColor) {
          var color = Color.parse(newColor);
          color.alpha = 0;
          this.startColor = color.toString('hex');
          this.endColor = color.toString('hexa');
        },
        captureMouse: function captureMouse(newValue, oldValue) {
          if (oldValue === false && newValue !== false) {
            var rect = this.$el.getBoundingClientRect(); // Caching offset

            this.clientOffset.cx = rect.x + rect.width / 2;
            this.clientOffset.cy = rect.y + rect.height / 2;
            this.clientOffset.width = rect.width;
            this.clientOffset.height = rect.height;
          }
        }
      },
      methods: {
        increaseAlpha: function increaseAlpha() {
          var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
          this.percent = Math.max(0, Math.min(100, this.percent + value));
        },
        decreaseAlpha: function decreaseAlpha() {
          var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.01;
          this.increaseAlpha(-value);
        },
        alphaKeyPress: function alphaKeyPress(event) {
          var handled = false;

          switch (event.key) {
            case 'ArrowRight':
            case 'ArrowUp':
              this.increaseAlpha();
              handled = true;
              break;

            case 'ArrowLeft':
            case 'ArrowDown':
              this.decreaseAlpha();
              handled = true;
              break;

            case 'Home':
              this.decreaseAlpha(this.percent);
              handled = true;
              break;

            case 'End':
              this.increaseAlpha(100 - this.percent);
              handled = true;
              break;

            case 'PageUp':
              this.increaseAlpha(10 - this.percent % 10);
              handled = true;
              break;

            case 'PageDown':
              this.decreaseAlpha(this.percent % 10);
              handled = true;
              break;
          }

          if (handled) {
            event.preventDefault();
            event.stopPropagation();
            this.emitAlpha();
          }
        },
        clickAlpha: function clickAlpha(event) {
          this.startMouseCapture(event);
          this.trackMouse(event);
          this.stopMouseCapture(event);
          this.$refs.alphaCursor.focus();
        },
        startMouseCapture: function startMouseCapture(event) {
          event.stopPropagation();
          this.captureMouse = true;
        },
        trackMouse: function trackMouse(event) {
          if (this.captureMouse === false) {
            return;
          }

          event.preventDefault();
          event.stopPropagation();
          var _ref = [0, 0],
              mouseX = _ref[0];

          if (typeof event.touches !== 'undefined' && event.touches.length) {
            var _ref2 = [event.touches[0].clientX];
            mouseX = _ref2[0];
          } else {
            var _ref3 = [event.clientX];
            mouseX = _ref3[0];
          }

          var ratio = 0.5 + (this.clientOffset.cx - mouseX) / this.clientOffset.width;
          this.percent = Math.round(100 - Math.max(0, Math.min(1, ratio)) * 100);
          this.emitAlpha();
        },
        stopMouseCapture: function stopMouseCapture(event) {
          if (this.captureMouse !== false) {
            event.preventDefault();
            event.stopPropagation();
            this.$refs.alphaCursor.focus();
          }

          this.captureMouse = false;
        },
        emitAlpha: function emitAlpha() {
          this.$emit('input', (1 - this.percent / 100) * 255);
        }
      },
      mounted: function mounted() {
        window.addEventListener('mousemove', this.trackMouse);
        window.addEventListener('touchmove', this.trackMouse, {
          passive: false
        });
        window.addEventListener('mouseup', this.stopMouseCapture);
        window.addEventListener('touchend', this.stopMouseCapture);
      },
      beforeDestroy: function beforeDestroy() {
        window.removeEventListener('mousemove', this.trackMouse);
        window.removeEventListener('touchmove', this.trackMouse);
        window.removeEventListener('mouseup', this.stopMouseCapture);
        window.removeEventListener('touchend', this.stopMouseCapture);
      }
    };

    /* script */
    const __vue_script__$2$2 = script$2$2;

    /* template */
    var __vue_render__$2$2 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"b-colorpicker-alpha-slider",style:(_vm.style),on:{"click":_vm.clickAlpha,"keydown":_vm.alphaKeyPress,"mousedown":_vm.startMouseCapture,"touchstart":function($event){$event.preventDefault();return _vm.startMouseCapture($event)}}},[_c('div',{ref:"alphaCursor",staticClass:"alpha-range-thumb",style:({ left: (_vm.percent + "%") }),attrs:{"role":"slider","tabindex":"0","aria-label":"Tranparency","aria-valuemin":"0","aria-valuenow":_vm.percent,"aria-valuemax":"100"}},[_c('b-tooltip',{attrs:{"label":(_vm.percent + "%"),"always":_vm.captureMouse}})],1)])};
    var __vue_staticRenderFns__$2$2 = [];

      /* style */
      const __vue_inject_styles__$2$2 = undefined;
      /* scoped */
      const __vue_scope_id__$2$2 = undefined;
      /* module identifier */
      const __vue_module_identifier__$2$2 = undefined;
      /* functional template */
      const __vue_is_functional_template__$2$2 = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var ColorpickerAlphaSlider = normalizeComponent_1(
        { render: __vue_render__$2$2, staticRenderFns: __vue_staticRenderFns__$2$2 },
        __vue_inject_styles__$2$2,
        __vue_script__$2$2,
        __vue_scope_id__$2$2,
        __vue_is_functional_template__$2$2,
        __vue_module_identifier__$2$2,
        undefined,
        undefined
      );

    var _components$2;

    var defaultColorFormatter = function defaultColorFormatter(color, vm) {
      if (color.alpha < 1) {
        return color.toString('hexa');
      } else {
        return color.toString('hex');
      }
    };

    var defaultColorParser = function defaultColorParser(color, vm) {
      return Color.parse(color);
    };

    var script$3$1 = {
      name: 'BColorpicker',
      components: (_components$2 = {}, _defineProperty(_components$2, ColorpickerHSLRepresentationTriangle.name, ColorpickerHSLRepresentationTriangle), _defineProperty(_components$2, ColorpickerHSLRepresentationSquare.name, ColorpickerHSLRepresentationSquare), _defineProperty(_components$2, ColorpickerAlphaSlider.name, ColorpickerAlphaSlider), _defineProperty(_components$2, Input.name, Input), _defineProperty(_components$2, Field.name, Field), _defineProperty(_components$2, Select.name, Select), _defineProperty(_components$2, Icon.name, Icon), _defineProperty(_components$2, Dropdown.name, Dropdown), _defineProperty(_components$2, DropdownItem.name, DropdownItem), _components$2),
      mixins: [FormElementMixin],
      inheritAttrs: false,
      provide: function provide() {
        return {
          $colorpicker: this
        };
      },
      props: {
        value: {
          type: [String, Object],
          validator: function validator(value) {
            return typeof value === 'string' || _typeof(value) === 'object' && typeof value.red === 'number' && typeof value.green === 'number' && typeof value.blue === 'number';
          }
        },
        representation: {
          type: String,
          default: 'triangle',
          value: function value(_value) {
            return ['triangle', 'square'].some(function (r) {
              return r === _value;
            });
          }
        },
        inline: Boolean,
        disabled: Boolean,
        horizontalColorPicker: {
          type: Boolean,
          default: false
        },
        colorFormatter: {
          type: Function,
          default: function _default(color, vm) {
            if (typeof config$2.defaultColorFormatter === 'function') {
              return config$2.defaultColorFormatter(color);
            } else {
              return defaultColorFormatter(color);
            }
          }
        },
        colorParser: {
          type: Function,
          default: function _default(color, vm) {
            if (typeof config$2.defaultColorParser === 'function') {
              return config$2.defaultColorParser(color);
            } else {
              return defaultColorParser(color);
            }
          }
        },
        alpha: {
          type: Boolean,
          default: false
        },
        expanded: Boolean,
        position: String,
        mobileModal: {
          type: Boolean,
          default: function _default() {
            return config$2.defaultDatepickerMobileModal;
          }
        },
        focusable: {
          type: Boolean,
          default: true
        },
        trapFocus: {
          type: Boolean,
          default: function _default() {
            return config$2.defaultTrapFocus;
          }
        },
        appendToBody: Boolean
      },
      data: function data() {
        var color = this.colorParser(this.value);
        return {
          colorSelected: color
        };
      },
      computed: {
        background: function background() {
          if (this.alpha) {
            return "linear-gradient(\n                    45deg,\n                    ".concat(this.colorSelected.toString('hex'), " 50%,\n                    ").concat(this.colorSelected.toString('hexa'), " 50%\n                )");
          } else {
            var hex = this.colorSelected.toString('hex');
            return "linear-gradient(\n                    45deg,\n                    ".concat(hex, " 50%,\n                    ").concat(hex, " 50%\n                )");
          }
        },
        triggerStyle: function triggerStyle() {
          var _this$colorSelected = this.colorSelected,
              red = _this$colorSelected.red,
              green = _this$colorSelected.green,
              blue = _this$colorSelected.blue;
          var light = red * 0.299 + green * 0.587 + blue * 0.114 > 186;
          return {
            backgroundColor: '#ffffff',
            backgroundImage: "\n                    ".concat(this.background, ",\n                    linear-gradient(45deg, #c7c7c7 25%, transparent 25%, transparent 75%, #c7c7c7 75%, #c7c7c7),\n                    linear-gradient(45deg, #c7c7c7 25%, transparent 25%, transparent 75%, #c7c7c7 75%, #c7c7c7)\n                "),
            backgroundSize: '100% 100%, 16px 16px, 16px 16px',
            backgroundPosition: '0 0, 8px 8px, 0 0',
            color: light ? '#000000' : '#FFFFFF',
            textShadow: "0 0 2px ".concat(light ? '#FFFFFFAA' : '#000000AA')
          };
        },
        isMobile: function isMobile$1() {
          return this.mobileNative && isMobile.any();
        },
        ariaRole: function ariaRole() {
          if (!this.inline) {
            return 'dialog';
          }
        }
      },
      watch: {
        value: function value(_value2) {
          this.colorSelected = new Color(_value2);
        }
      },
      methods: {
        updateColor: function updateColor(value) {
          value.alpha = this.colorSelected.alpha;
          this.colorSelected = value;
          this.$emit('input', value);
        },
        updateAlpha: function updateAlpha(alpha) {
          this.colorSelected.alpha = alpha;
          this.$emit('input', this.colorSelected);
        },

        /*
         * Format color into string
         */
        formatValue: function formatValue(value) {
          return value ? this.colorFormatter(value, this) : null;
        },

        /*
         * Toggle datepicker
         */
        togglePicker: function togglePicker(active) {
          if (this.$refs.dropdown) {
            var isActive = typeof active === 'boolean' ? active : !this.$refs.dropdown.isActive;

            if (isActive) {
              this.$refs.dropdown.isActive = isActive;
            } else if (this.closeOnClick) {
              this.$refs.dropdown.isActive = isActive;
            }
          }
        },

        /*
         * Call default onFocus method and show datepicker
         */
        handleOnFocus: function handleOnFocus(event) {
          this.onFocus(event);

          if (this.openOnFocus) {
            this.togglePicker(true);
          }
        },

        /*
         * Toggle dropdown
         */
        toggle: function toggle() {
          if (this.mobileNative && this.isMobile) {
            var input = this.$refs.input.$refs.input;
            input.focus();
            input.click();
            return;
          }

          this.$refs.dropdown.toggle();
        },

        /*
         * Avoid dropdown toggle when is already visible
         */
        onInputClick: function onInputClick(event) {
          if (this.$refs.dropdown.isActive) {
            event.stopPropagation();
          }
        },

        /**
         * Keypress event that is bound to the document.
         */
        keyPress: function keyPress(_ref) {
          var key = _ref.key;

          if (this.$refs.dropdown && this.$refs.dropdown.isActive && (key === 'Escape' || key === 'Esc')) {
            this.togglePicker(false);
          }
        },

        /**
         * Emit 'blur' event on dropdown is not active (closed)
         */
        onActiveChange: function onActiveChange(value) {
          if (!value) {
            this.onBlur();
          }
          /*
           * Emit 'active-change' when on dropdown active state change
           */


          this.$emit('active-change', value);
        }
      }
    };

    /* script */
    const __vue_script__$3$1 = script$3$1;

    /* template */
    var __vue_render__$3$1 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"colorpicker control",class:[_vm.size, {'is-expanded': _vm.expanded}]},[(!_vm.isMobile || _vm.inline)?_c('b-dropdown',{ref:"dropdown",attrs:{"position":_vm.position,"expanded":_vm.expanded,"disabled":_vm.disabled,"inline":_vm.inline,"mobile-modal":_vm.mobileModal,"trap-focus":_vm.trapFocus,"aria-role":_vm.ariaRole,"append-to-body":_vm.appendToBody,"append-to-body-copy-parent":""},on:{"active-change":_vm.onActiveChange},scopedSlots:_vm._u([(!_vm.inline)?{key:"trigger",fn:function(){return [_vm._t("trigger",[_c('b-button',{style:(_vm.triggerStyle),attrs:{"expanded":_vm.expanded,"disabled":_vm.disabled}},[_c('span',{staticClass:"color-name"},[_vm._v(_vm._s(_vm.colorFormatter(_vm.colorSelected)))])])])]},proxy:true}:null],null,true)},[_c('b-dropdown-item',{class:{'dropdown-horizonal-colorpicker': _vm.horizontalColorPicker},attrs:{"disabled":_vm.disabled,"focusable":_vm.focusable,"custom":""}},[_c('div',[_c('header',{staticClass:"colorpicker-header"},[(_vm.$slots.header !== undefined && _vm.$slots.header.length)?[_vm._t("header")]:_vm._e()],2),_c('div',{staticClass:"colorpicker-content"},[(_vm.representation === 'square')?_c('b-colorpicker-h-s-l-representation-square',{attrs:{"value":_vm.colorSelected},on:{"input":_vm.updateColor}}):_c('b-colorpicker-h-s-l-representation-triangle',{attrs:{"value":_vm.colorSelected},on:{"input":_vm.updateColor}})],1)]),_c('footer',{staticClass:"colorpicker-footer"},[(_vm.alpha)?_c('b-colorpicker-alpha-slider',{attrs:{"value":_vm.colorSelected.alpha,"color":_vm.colorSelected},on:{"input":_vm.updateAlpha}}):_vm._e(),_vm._t("footer",[_c('b-field',{staticClass:"colorpicker-fields",attrs:{"grouped":""}},[_c('b-field',{attrs:{"horizontal":"","label":"R"}},[_c('b-input',{attrs:{"type":"number","size":"is-small","aria-label":"Red"},model:{value:(_vm.colorSelected.red),callback:function ($$v) {_vm.$set(_vm.colorSelected, "red", _vm._n($$v));},expression:"colorSelected.red"}})],1),_c('b-field',{attrs:{"horizontal":"","label":"G"}},[_c('b-input',{attrs:{"type":"number","size":"is-small","aria-label":"Green"},model:{value:(_vm.colorSelected.green),callback:function ($$v) {_vm.$set(_vm.colorSelected, "green", _vm._n($$v));},expression:"colorSelected.green"}})],1),_c('b-field',{attrs:{"horizontal":"","label":"B"}},[_c('b-input',{attrs:{"type":"number","size":"is-small","aria-label":"Blue"},model:{value:(_vm.colorSelected.blue),callback:function ($$v) {_vm.$set(_vm.colorSelected, "blue", _vm._n($$v));},expression:"colorSelected.blue"}})],1)],1)],{"color":_vm.colorSelected})],2)])],1):_vm._e()],1)};
    var __vue_staticRenderFns__$3$1 = [];

      /* style */
      const __vue_inject_styles__$3$1 = undefined;
      /* scoped */
      const __vue_scope_id__$3$1 = undefined;
      /* module identifier */
      const __vue_module_identifier__$3$1 = undefined;
      /* functional template */
      const __vue_is_functional_template__$3$1 = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var Colorpicker = normalizeComponent_1(
        { render: __vue_render__$3$1, staticRenderFns: __vue_staticRenderFns__$3$1 },
        __vue_inject_styles__$3$1,
        __vue_script__$3$1,
        __vue_scope_id__$3$1,
        __vue_is_functional_template__$3$1,
        __vue_module_identifier__$3$1,
        undefined,
        undefined
      );

    var Plugin$7 = {
      install: function install(Vue) {
        registerComponent(Vue, Colorpicker);
      }
    };
    use(Plugin$7);

    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    var script$g = {
      name: 'BDatepickerTableRow',
      inject: {
        $datepicker: {
          name: '$datepicker',
          default: false
        }
      },
      props: {
        selectedDate: {
          type: [Date, Array]
        },
        hoveredDateRange: Array,
        day: {
          type: Number
        },
        week: {
          type: Array,
          required: true
        },
        month: {
          type: Number,
          required: true
        },
        minDate: Date,
        maxDate: Date,
        disabled: Boolean,
        unselectableDates: [Array, Function],
        unselectableDaysOfWeek: Array,
        selectableDates: [Array, Function],
        events: Array,
        indicators: String,
        dateCreator: Function,
        nearbyMonthDays: Boolean,
        nearbySelectableMonthDays: Boolean,
        showWeekNumber: Boolean,
        weekNumberClickable: Boolean,
        range: Boolean,
        multiple: Boolean,
        rulesForFirstWeek: Number,
        firstDayOfWeek: Number
      },
      watch: {
        day: function day(_day) {
          var _this = this;

          var refName = "day-".concat(this.month, "-").concat(_day);
          this.$nextTick(function () {
            if (_this.$refs[refName] && _this.$refs[refName].length > 0) {
              if (_this.$refs[refName][0]) {
                _this.$refs[refName][0].focus();
              }
            }
          }); // $nextTick needed when month is changed
        }
      },
      methods: {
        firstWeekOffset: function firstWeekOffset(year, dow, doy) {
          // first-week day -- which january is always in the first week (4 for iso, 1 for other)
          var fwd = 7 + dow - doy; // first-week day local weekday -- which local weekday is fwd

          var firstJanuary = new Date(year, 0, fwd);
          var fwdlw = (7 + firstJanuary.getDay() - dow) % 7;
          return -fwdlw + fwd - 1;
        },
        daysInYear: function daysInYear(year) {
          return this.isLeapYear(year) ? 366 : 365;
        },
        isLeapYear: function isLeapYear(year) {
          return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
        },
        getSetDayOfYear: function getSetDayOfYear(input) {
          return Math.round((input - new Date(input.getFullYear(), 0, 1)) / 864e5) + 1;
        },
        weeksInYear: function weeksInYear(year, dow, doy) {
          var weekOffset = this.firstWeekOffset(year, dow, doy);
          var weekOffsetNext = this.firstWeekOffset(year + 1, dow, doy);
          return (this.daysInYear(year) - weekOffset + weekOffsetNext) / 7;
        },
        getWeekNumber: function getWeekNumber(mom) {
          var dow = this.firstDayOfWeek; // first day of week
          // Rules for the first week : 1 for the 1st January, 4 for the 4th January

          var doy = this.rulesForFirstWeek;
          var weekOffset = this.firstWeekOffset(mom.getFullYear(), dow, doy);
          var week = Math.floor((this.getSetDayOfYear(mom) - weekOffset - 1) / 7) + 1;
          var resWeek;
          var resYear;

          if (week < 1) {
            resYear = mom.getFullYear() - 1;
            resWeek = week + this.weeksInYear(resYear, dow, doy);
          } else if (week > this.weeksInYear(mom.getFullYear(), dow, doy)) {
            resWeek = week - this.weeksInYear(mom.getFullYear(), dow, doy);
            resYear = mom.getFullYear() + 1;
          } else {
            resYear = mom.getFullYear();
            resWeek = week;
          }

          return {
            week: resWeek,
            year: resYear
          };
        },
        clickWeekNumber: function clickWeekNumber(weekData) {
          if (this.weekNumberClickable) {
            this.$datepicker.$emit('week-number-click', weekData.week, weekData.year);
          }
        },

        /*
         * Check that selected day is within earliest/latest params and
         * is within this month
         */
        selectableDate: function selectableDate(day) {
          var validity = [];

          if (this.minDate) {
            validity.push(day >= this.minDate);
          }

          if (this.maxDate) {
            validity.push(day <= this.maxDate);
          }

          if (this.nearbyMonthDays && !this.nearbySelectableMonthDays) {
            validity.push(day.getMonth() === this.month);
          }

          if (this.selectableDates) {
            if (typeof this.selectableDates === 'function') {
              if (this.selectableDates(day)) {
                return true;
              } else {
                validity.push(false);
              }
            } else {
              for (var i = 0; i < this.selectableDates.length; i++) {
                var enabledDate = this.selectableDates[i];

                if (day.getDate() === enabledDate.getDate() && day.getFullYear() === enabledDate.getFullYear() && day.getMonth() === enabledDate.getMonth()) {
                  return true;
                } else {
                  validity.push(false);
                }
              }
            }
          }

          if (this.unselectableDates) {
            if (typeof this.unselectableDates === 'function') {
              validity.push(!this.unselectableDates(day));
            } else {
              for (var _i = 0; _i < this.unselectableDates.length; _i++) {
                var disabledDate = this.unselectableDates[_i];
                validity.push(day.getDate() !== disabledDate.getDate() || day.getFullYear() !== disabledDate.getFullYear() || day.getMonth() !== disabledDate.getMonth());
              }
            }
          }

          if (this.unselectableDaysOfWeek) {
            for (var _i2 = 0; _i2 < this.unselectableDaysOfWeek.length; _i2++) {
              var dayOfWeek = this.unselectableDaysOfWeek[_i2];
              validity.push(day.getDay() !== dayOfWeek);
            }
          }

          return validity.indexOf(false) < 0;
        },

        /*
        * Emit select event with chosen date as payload
        */
        emitChosenDate: function emitChosenDate(day) {
          if (this.disabled) return;

          if (this.selectableDate(day)) {
            this.$emit('select', day);
          }
        },
        eventsDateMatch: function eventsDateMatch(day) {
          if (!this.events || !this.events.length) return false;
          var dayEvents = [];

          for (var i = 0; i < this.events.length; i++) {
            if (this.events[i].date.getDay() === day.getDay()) {
              dayEvents.push(this.events[i]);
            }
          }

          if (!dayEvents.length) {
            return false;
          }

          return dayEvents;
        },

        /*
        * Build classObject for cell using validations
        */
        classObject: function classObject(day) {
          function dateMatch(dateOne, dateTwo, multiple) {
            // if either date is null or undefined, return false
            // if using multiple flag, return false
            if (!dateOne || !dateTwo || multiple) {
              return false;
            }

            if (Array.isArray(dateTwo)) {
              return dateTwo.some(function (date) {
                return dateOne.getDate() === date.getDate() && dateOne.getFullYear() === date.getFullYear() && dateOne.getMonth() === date.getMonth();
              });
            }

            return dateOne.getDate() === dateTwo.getDate() && dateOne.getFullYear() === dateTwo.getFullYear() && dateOne.getMonth() === dateTwo.getMonth();
          }

          function dateWithin(dateOne, dates, multiple) {
            if (!Array.isArray(dates) || multiple) {
              return false;
            }

            return dateOne > dates[0] && dateOne < dates[1];
          }

          return _defineProperty({
            'is-selected': dateMatch(day, this.selectedDate) || dateWithin(day, this.selectedDate, this.multiple),
            'is-first-selected': dateMatch(day, Array.isArray(this.selectedDate) && this.selectedDate[0], this.multiple),
            'is-within-selected': dateWithin(day, this.selectedDate, this.multiple),
            'is-last-selected': dateMatch(day, Array.isArray(this.selectedDate) && this.selectedDate[1], this.multiple),
            'is-within-hovered-range': this.hoveredDateRange && this.hoveredDateRange.length === 2 && (dateMatch(day, this.hoveredDateRange) || dateWithin(day, this.hoveredDateRange)),
            'is-first-hovered': dateMatch(day, Array.isArray(this.hoveredDateRange) && this.hoveredDateRange[0]),
            'is-within-hovered': dateWithin(day, this.hoveredDateRange),
            'is-last-hovered': dateMatch(day, Array.isArray(this.hoveredDateRange) && this.hoveredDateRange[1]),
            'is-today': dateMatch(day, this.dateCreator()),
            'is-selectable': this.selectableDate(day) && !this.disabled,
            'is-unselectable': !this.selectableDate(day) || this.disabled,
            'is-invisible': !this.nearbyMonthDays && day.getMonth() !== this.month,
            'is-nearby': this.nearbySelectableMonthDays && day.getMonth() !== this.month,
            'has-event': this.eventsDateMatch(day)
          }, this.indicators, this.eventsDateMatch(day));
        },
        setRangeHoverEndDate: function setRangeHoverEndDate(day) {
          if (this.range) {
            this.$emit('rangeHoverEndDate', day);
          }
        },
        manageKeydown: function manageKeydown(event, weekDay) {
          // https://developer.mozilla.org/fr/docs/Web/API/KeyboardEvent/key/Key_Values#Navigation_keys
          var key = event.key;
          var preventDefault = true;

          switch (key) {
            case 'Tab':
              {
                preventDefault = false;
                break;
              }

            case ' ':
            case 'Space':
            case 'Spacebar':
            case 'Enter':
              {
                this.emitChosenDate(weekDay);
                break;
              }

            case 'ArrowLeft':
            case 'Left':
              {
                this.changeFocus(weekDay, -1);
                break;
              }

            case 'ArrowRight':
            case 'Right':
              {
                this.changeFocus(weekDay, 1);
                break;
              }

            case 'ArrowUp':
            case 'Up':
              {
                this.changeFocus(weekDay, -7);
                break;
              }

            case 'ArrowDown':
            case 'Down':
              {
                this.changeFocus(weekDay, 7);
                break;
              }
          }

          if (preventDefault) {
            event.preventDefault();
          }
        },
        changeFocus: function changeFocus(day, inc) {
          var nextDay = new Date(day.getTime());
          nextDay.setDate(day.getDate() + inc);

          while ((!this.minDate || nextDay > this.minDate) && (!this.maxDate || nextDay < this.maxDate) && !this.selectableDate(nextDay)) {
            nextDay.setDate(day.getDate() + Math.sign(inc));
          }

          this.setRangeHoverEndDate(nextDay);
          this.$emit('change-focus', nextDay);
        }
      }
    };

    /* script */
    const __vue_script__$g = script$g;

    /* template */
    var __vue_render__$f = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"datepicker-row"},[(_vm.showWeekNumber)?_c('a',{staticClass:"datepicker-cell is-week-number",class:{'is-clickable': _vm.weekNumberClickable },on:{"click":function($event){$event.preventDefault();_vm.clickWeekNumber(_vm.getWeekNumber(_vm.week[6]));}}},[_c('span',[_vm._v(_vm._s(_vm.getWeekNumber(_vm.week[6]).week))])]):_vm._e(),_vm._l((_vm.week),function(weekDay,index){return [(_vm.selectableDate(weekDay) && !_vm.disabled)?_c('a',{key:index,ref:("day-" + (weekDay.getMonth()) + "-" + (weekDay.getDate())),refInFor:true,staticClass:"datepicker-cell",class:_vm.classObject(weekDay),attrs:{"role":"button","href":"#","disabled":_vm.disabled,"tabindex":_vm.day === weekDay.getDate() && _vm.month === weekDay.getMonth() ? null : -1},on:{"click":function($event){$event.preventDefault();return _vm.emitChosenDate(weekDay)},"mouseenter":function($event){return _vm.setRangeHoverEndDate(weekDay)},"keydown":function($event){return _vm.manageKeydown($event, weekDay)}}},[_c('span',[_vm._v(_vm._s(weekDay.getDate()))]),(_vm.eventsDateMatch(weekDay))?_c('div',{staticClass:"events"},_vm._l((_vm.eventsDateMatch(weekDay)),function(event,index){return _c('div',{key:index,staticClass:"event",class:event.type})}),0):_vm._e()]):_c('div',{key:index,staticClass:"datepicker-cell",class:_vm.classObject(weekDay)},[_c('span',[_vm._v(_vm._s(weekDay.getDate()))]),(_vm.eventsDateMatch(weekDay))?_c('div',{staticClass:"events"},_vm._l((_vm.eventsDateMatch(weekDay)),function(event,index){return _c('div',{key:index,staticClass:"event",class:event.type})}),0):_vm._e()])]})],2)};
    var __vue_staticRenderFns__$f = [];

      /* style */
      const __vue_inject_styles__$g = undefined;
      /* scoped */
      const __vue_scope_id__$g = undefined;
      /* module identifier */
      const __vue_module_identifier__$g = undefined;
      /* functional template */
      const __vue_is_functional_template__$g = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var DatepickerTableRow = normalizeComponent_1(
        { render: __vue_render__$f, staticRenderFns: __vue_staticRenderFns__$f },
        __vue_inject_styles__$g,
        __vue_script__$g,
        __vue_scope_id__$g,
        __vue_is_functional_template__$g,
        __vue_module_identifier__$g,
        undefined,
        undefined
      );

    var script$1$7 = {
      name: 'BDatepickerTable',
      components: _defineProperty({}, DatepickerTableRow.name, DatepickerTableRow),
      props: {
        value: {
          type: [Date, Array]
        },
        dayNames: Array,
        monthNames: Array,
        firstDayOfWeek: Number,
        events: Array,
        indicators: String,
        minDate: Date,
        maxDate: Date,
        focused: Object,
        disabled: Boolean,
        dateCreator: Function,
        unselectableDates: [Array, Function],
        unselectableDaysOfWeek: Array,
        selectableDates: [Array, Function],
        nearbyMonthDays: Boolean,
        nearbySelectableMonthDays: Boolean,
        showWeekNumber: Boolean,
        weekNumberClickable: Boolean,
        rulesForFirstWeek: Number,
        range: Boolean,
        multiple: Boolean
      },
      data: function data() {
        return {
          selectedBeginDate: undefined,
          selectedEndDate: undefined,
          hoveredEndDate: undefined
        };
      },
      computed: {
        multipleSelectedDates: {
          get: function get() {
            return this.multiple && this.value ? this.value : [];
          },
          set: function set(value) {
            this.$emit('input', value);
          }
        },
        visibleDayNames: function visibleDayNames() {
          var visibleDayNames = [];
          var index = this.firstDayOfWeek;

          while (visibleDayNames.length < this.dayNames.length) {
            var currentDayName = this.dayNames[index % this.dayNames.length];
            visibleDayNames.push(currentDayName);
            index++;
          }

          if (this.showWeekNumber) visibleDayNames.unshift('');
          return visibleDayNames;
        },
        hasEvents: function hasEvents() {
          return this.events && this.events.length;
        },

        /*
        * Return array of all events in the specified month
        */
        eventsInThisMonth: function eventsInThisMonth() {
          if (!this.events) return [];
          var monthEvents = [];

          for (var i = 0; i < this.events.length; i++) {
            var event = this.events[i];

            if (!event.hasOwnProperty('date')) {
              event = {
                date: event
              };
            }

            if (!event.hasOwnProperty('type')) {
              event.type = 'is-primary';
            }

            if (event.date.getMonth() === this.focused.month && event.date.getFullYear() === this.focused.year) {
              monthEvents.push(event);
            }
          }

          return monthEvents;
        },

        /*
        * Return array of all weeks in the specified month
        */
        weeksInThisMonth: function weeksInThisMonth() {
          this.validateFocusedDay();
          var month = this.focused.month;
          var year = this.focused.year;
          var weeksInThisMonth = [];
          var startingDay = 1;

          while (weeksInThisMonth.length < 6) {
            var newWeek = this.weekBuilder(startingDay, month, year);
            weeksInThisMonth.push(newWeek);
            startingDay += 7;
          }

          return weeksInThisMonth;
        },
        hoveredDateRange: function hoveredDateRange() {
          if (!this.range) {
            return [];
          }

          if (!isNaN(this.selectedEndDate)) {
            return [];
          }

          if (this.hoveredEndDate < this.selectedBeginDate) {
            return [this.hoveredEndDate, this.selectedBeginDate].filter(isDefined);
          }

          return [this.selectedBeginDate, this.hoveredEndDate].filter(isDefined);
        }
      },
      methods: {
        /*
        * Emit input event with selected date as payload for v-model in parent
        */
        updateSelectedDate: function updateSelectedDate(date) {
          if (!this.range && !this.multiple) {
            this.$emit('input', date);
          } else if (this.range) {
            this.handleSelectRangeDate(date);
          } else if (this.multiple) {
            this.handleSelectMultipleDates(date);
          }
        },

        /*
        * If both begin and end dates are set, reset the end date and set the begin date.
        * If only begin date is selected, emit an array of the begin date and the new date.
        * If not set, only set the begin date.
        */
        handleSelectRangeDate: function handleSelectRangeDate(date) {
          if (this.selectedBeginDate && this.selectedEndDate) {
            this.selectedBeginDate = date;
            this.selectedEndDate = undefined;
            this.$emit('range-start', date);
          } else if (this.selectedBeginDate && !this.selectedEndDate) {
            if (this.selectedBeginDate > date) {
              this.selectedEndDate = this.selectedBeginDate;
              this.selectedBeginDate = date;
            } else {
              this.selectedEndDate = date;
            }

            this.$emit('range-end', date);
            this.$emit('input', [this.selectedBeginDate, this.selectedEndDate]);
          } else {
            this.selectedBeginDate = date;
            this.$emit('range-start', date);
          }
        },

        /*
        * If selected date already exists list of selected dates, remove it from the list
        * Otherwise, add date to list of selected dates
        */
        handleSelectMultipleDates: function handleSelectMultipleDates(date) {
          var multipleSelect = this.multipleSelectedDates.filter(function (selectedDate) {
            return selectedDate.getDate() === date.getDate() && selectedDate.getFullYear() === date.getFullYear() && selectedDate.getMonth() === date.getMonth();
          });

          if (multipleSelect.length) {
            this.multipleSelectedDates = this.multipleSelectedDates.filter(function (selectedDate) {
              return selectedDate.getDate() !== date.getDate() || selectedDate.getFullYear() !== date.getFullYear() || selectedDate.getMonth() !== date.getMonth();
            });
          } else {
            this.multipleSelectedDates = [].concat(_toConsumableArray(this.multipleSelectedDates), [date]);
          }
        },

        /*
         * Return array of all days in the week that the startingDate is within
         */
        weekBuilder: function weekBuilder(startingDate, month, year) {
          var thisMonth = new Date(year, month);
          var thisWeek = [];
          var dayOfWeek = new Date(year, month, startingDate).getDay();
          var end = dayOfWeek >= this.firstDayOfWeek ? dayOfWeek - this.firstDayOfWeek : 7 - this.firstDayOfWeek + dayOfWeek;
          var daysAgo = 1;

          for (var i = 0; i < end; i++) {
            thisWeek.unshift(new Date(thisMonth.getFullYear(), thisMonth.getMonth(), startingDate - daysAgo));
            daysAgo++;
          }

          thisWeek.push(new Date(year, month, startingDate));
          var daysForward = 1;

          while (thisWeek.length < 7) {
            thisWeek.push(new Date(year, month, startingDate + daysForward));
            daysForward++;
          }

          return thisWeek;
        },
        validateFocusedDay: function validateFocusedDay() {
          var focusedDate = new Date(this.focused.year, this.focused.month, this.focused.day);
          if (this.selectableDate(focusedDate)) return;
          var day = 0; // Number of days in the current month

          var monthDays = new Date(this.focused.year, this.focused.month + 1, 0).getDate();
          var firstFocusable = null;

          while (!firstFocusable && ++day < monthDays) {
            var date = new Date(this.focused.year, this.focused.month, day);

            if (this.selectableDate(date)) {
              firstFocusable = focusedDate;
              var focused = {
                day: date.getDate(),
                month: date.getMonth(),
                year: date.getFullYear()
              };
              this.$emit('update:focused', focused);
            }
          }
        },

        /*
         * Check that selected day is within earliest/latest params and
         * is within this month
         */
        selectableDate: function selectableDate(day) {
          var validity = [];

          if (this.minDate) {
            validity.push(day >= this.minDate);
          }

          if (this.maxDate) {
            validity.push(day <= this.maxDate);
          }

          if (this.nearbyMonthDays && !this.nearbySelectableMonthDays) {
            validity.push(day.getMonth() === this.focused.month);
          }

          if (this.selectableDates) {
            if (typeof this.selectableDates === 'function') {
              if (this.selectableDates(day)) {
                return true;
              } else {
                validity.push(false);
              }
            } else {
              for (var i = 0; i < this.selectableDates.length; i++) {
                var enabledDate = this.selectableDates[i];

                if (day.getDate() === enabledDate.getDate() && day.getFullYear() === enabledDate.getFullYear() && day.getMonth() === enabledDate.getMonth()) {
                  return true;
                } else {
                  validity.push(false);
                }
              }
            }
          }

          if (this.unselectableDates) {
            if (typeof this.unselectableDates === 'function') {
              validity.push(!this.unselectableDates(day));
            } else {
              for (var _i = 0; _i < this.unselectableDates.length; _i++) {
                var disabledDate = this.unselectableDates[_i];
                validity.push(day.getDate() !== disabledDate.getDate() || day.getFullYear() !== disabledDate.getFullYear() || day.getMonth() !== disabledDate.getMonth());
              }
            }
          }

          if (this.unselectableDaysOfWeek) {
            for (var _i2 = 0; _i2 < this.unselectableDaysOfWeek.length; _i2++) {
              var dayOfWeek = this.unselectableDaysOfWeek[_i2];
              validity.push(day.getDay() !== dayOfWeek);
            }
          }

          return validity.indexOf(false) < 0;
        },
        eventsInThisWeek: function eventsInThisWeek(week) {
          return this.eventsInThisMonth.filter(function (event) {
            var stripped = new Date(Date.parse(event.date));
            stripped.setHours(0, 0, 0, 0);
            var timed = stripped.getTime();
            return week.some(function (weekDate) {
              return weekDate.getTime() === timed;
            });
          });
        },
        setRangeHoverEndDate: function setRangeHoverEndDate(day) {
          this.hoveredEndDate = day;
        },
        changeFocus: function changeFocus(day) {
          var focused = {
            day: day.getDate(),
            month: day.getMonth(),
            year: day.getFullYear()
          };
          this.$emit('update:focused', focused);
        }
      }
    };

    /* script */
    const __vue_script__$1$7 = script$1$7;

    /* template */
    var __vue_render__$1$6 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('section',{staticClass:"datepicker-table"},[_c('header',{staticClass:"datepicker-header"},_vm._l((_vm.visibleDayNames),function(day,index){return _c('div',{key:index,staticClass:"datepicker-cell"},[_c('span',[_vm._v(_vm._s(day))])])}),0),_c('div',{staticClass:"datepicker-body",class:{'has-events':_vm.hasEvents}},_vm._l((_vm.weeksInThisMonth),function(week,index){return _c('b-datepicker-table-row',{key:index,attrs:{"selected-date":_vm.value,"day":_vm.focused.day,"week":week,"month":_vm.focused.month,"min-date":_vm.minDate,"max-date":_vm.maxDate,"disabled":_vm.disabled,"unselectable-dates":_vm.unselectableDates,"unselectable-days-of-week":_vm.unselectableDaysOfWeek,"selectable-dates":_vm.selectableDates,"events":_vm.eventsInThisWeek(week),"indicators":_vm.indicators,"date-creator":_vm.dateCreator,"nearby-month-days":_vm.nearbyMonthDays,"nearby-selectable-month-days":_vm.nearbySelectableMonthDays,"show-week-number":_vm.showWeekNumber,"week-number-clickable":_vm.weekNumberClickable,"first-day-of-week":_vm.firstDayOfWeek,"rules-for-first-week":_vm.rulesForFirstWeek,"range":_vm.range,"hovered-date-range":_vm.hoveredDateRange,"multiple":_vm.multiple},on:{"select":_vm.updateSelectedDate,"rangeHoverEndDate":_vm.setRangeHoverEndDate,"change-focus":_vm.changeFocus}})}),1)])};
    var __vue_staticRenderFns__$1$6 = [];

      /* style */
      const __vue_inject_styles__$1$7 = undefined;
      /* scoped */
      const __vue_scope_id__$1$7 = undefined;
      /* module identifier */
      const __vue_module_identifier__$1$7 = undefined;
      /* functional template */
      const __vue_is_functional_template__$1$7 = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var DatepickerTable = normalizeComponent_1(
        { render: __vue_render__$1$6, staticRenderFns: __vue_staticRenderFns__$1$6 },
        __vue_inject_styles__$1$7,
        __vue_script__$1$7,
        __vue_scope_id__$1$7,
        __vue_is_functional_template__$1$7,
        __vue_module_identifier__$1$7,
        undefined,
        undefined
      );

    //
    var script$2$3 = {
      name: 'BDatepickerMonth',
      props: {
        value: {
          type: [Date, Array]
        },
        monthNames: Array,
        events: Array,
        indicators: String,
        minDate: Date,
        maxDate: Date,
        focused: Object,
        disabled: Boolean,
        dateCreator: Function,
        unselectableDates: [Array, Function],
        unselectableDaysOfWeek: Array,
        selectableDates: [Array, Function],
        range: Boolean,
        multiple: Boolean
      },
      data: function data() {
        return {
          selectedBeginDate: undefined,
          selectedEndDate: undefined,
          hoveredEndDate: undefined,
          multipleSelectedDates: this.multiple && this.value ? this.value : []
        };
      },
      computed: {
        hasEvents: function hasEvents() {
          return this.events && this.events.length;
        },

        /*
        * Return array of all events in the specified month
        */
        eventsInThisYear: function eventsInThisYear() {
          if (!this.events) return [];
          var yearEvents = [];

          for (var i = 0; i < this.events.length; i++) {
            var event = this.events[i];

            if (!event.hasOwnProperty('date')) {
              event = {
                date: event
              };
            }

            if (!event.hasOwnProperty('type')) {
              event.type = 'is-primary';
            }

            if (event.date.getFullYear() === this.focused.year) {
              yearEvents.push(event);
            }
          }

          return yearEvents;
        },
        monthDates: function monthDates() {
          var year = this.focused.year;
          var months = [];

          for (var i = 0; i < 12; i++) {
            var d = new Date(year, i, 1);
            d.setHours(0, 0, 0, 0);
            months.push(d);
          }

          return months;
        },
        focusedMonth: function focusedMonth() {
          return this.focused.month;
        },
        hoveredDateRange: function hoveredDateRange() {
          if (!this.range) {
            return [];
          }

          if (!isNaN(this.selectedEndDate)) {
            return [];
          }

          if (this.hoveredEndDate < this.selectedBeginDate) {
            return [this.hoveredEndDate, this.selectedBeginDate].filter(isDefined);
          }

          return [this.selectedBeginDate, this.hoveredEndDate].filter(isDefined);
        }
      },
      watch: {
        focusedMonth: function focusedMonth(month) {
          var _this = this;

          var refName = "month-".concat(month);

          if (this.$refs[refName] && this.$refs[refName].length > 0) {
            this.$nextTick(function () {
              if (_this.$refs[refName][0]) {
                _this.$refs[refName][0].focus();
              }
            }); // $nextTick needed when year is changed
          }
        }
      },
      methods: {
        selectMultipleDates: function selectMultipleDates(date) {
          var multipleSelect = this.multipleSelectedDates.filter(function (selectedDate) {
            return selectedDate.getDate() === date.getDate() && selectedDate.getFullYear() === date.getFullYear() && selectedDate.getMonth() === date.getMonth();
          });

          if (multipleSelect.length) {
            this.multipleSelectedDates = this.multipleSelectedDates.filter(function (selectedDate) {
              return selectedDate.getDate() !== date.getDate() || selectedDate.getFullYear() !== date.getFullYear() || selectedDate.getMonth() !== date.getMonth();
            });
          } else {
            this.multipleSelectedDates.push(date);
          }

          this.$emit('input', this.multipleSelectedDates);
        },
        selectableDate: function selectableDate(day) {
          var validity = [];

          if (this.minDate) {
            validity.push(day >= this.minDate);
          }

          if (this.maxDate) {
            validity.push(day <= this.maxDate);
          }

          validity.push(day.getFullYear() === this.focused.year);

          if (this.selectableDates) {
            if (typeof this.selectableDates === 'function') {
              if (this.selectableDates(day)) {
                return true;
              } else {
                validity.push(false);
              }
            } else {
              for (var i = 0; i < this.selectableDates.length; i++) {
                var enabledDate = this.selectableDates[i];

                if (day.getFullYear() === enabledDate.getFullYear() && day.getMonth() === enabledDate.getMonth()) {
                  return true;
                } else {
                  validity.push(false);
                }
              }
            }
          }

          if (this.unselectableDates) {
            if (typeof this.unselectableDates === 'function') {
              validity.push(!this.unselectableDates(day));
            } else {
              for (var _i = 0; _i < this.unselectableDates.length; _i++) {
                var disabledDate = this.unselectableDates[_i];
                validity.push(day.getFullYear() !== disabledDate.getFullYear() || day.getMonth() !== disabledDate.getMonth());
              }
            }
          }

          if (this.unselectableDaysOfWeek) {
            for (var _i2 = 0; _i2 < this.unselectableDaysOfWeek.length; _i2++) {
              var dayOfWeek = this.unselectableDaysOfWeek[_i2];
              validity.push(day.getDay() !== dayOfWeek);
            }
          }

          return validity.indexOf(false) < 0;
        },
        eventsDateMatch: function eventsDateMatch(day) {
          if (!this.eventsInThisYear.length) return false;
          var monthEvents = [];

          for (var i = 0; i < this.eventsInThisYear.length; i++) {
            if (this.eventsInThisYear[i].date.getMonth() === day.getMonth()) {
              monthEvents.push(this.events[i]);
            }
          }

          if (!monthEvents.length) {
            return false;
          }

          return monthEvents;
        },

        /*
        * Build classObject for cell using validations
        */
        classObject: function classObject(day) {
          function dateMatch(dateOne, dateTwo, multiple) {
            // if either date is null or undefined, return false
            if (!dateOne || !dateTwo || multiple) {
              return false;
            }

            if (Array.isArray(dateTwo)) {
              return dateTwo.some(function (date) {
                return dateOne.getFullYear() === date.getFullYear() && dateOne.getMonth() === date.getMonth();
              });
            }

            return dateOne.getFullYear() === dateTwo.getFullYear() && dateOne.getMonth() === dateTwo.getMonth();
          }

          function dateWithin(dateOne, dates, multiple) {
            if (!Array.isArray(dates) || multiple) {
              return false;
            }

            return dateOne > dates[0] && dateOne < dates[1];
          }

          function dateMultipleSelected(dateOne, dates, multiple) {
            if (!Array.isArray(dates) || !multiple) {
              return false;
            }

            return dates.some(function (date) {
              return dateOne.getDate() === date.getDate() && dateOne.getFullYear() === date.getFullYear() && dateOne.getMonth() === date.getMonth();
            });
          }

          return {
            'is-selected': dateMatch(day, this.value, this.multiple) || dateWithin(day, this.value, this.multiple) || dateMultipleSelected(day, this.multipleSelectedDates, this.multiple),
            'is-first-selected': dateMatch(day, Array.isArray(this.value) && this.value[0], this.multiple),
            'is-within-selected': dateWithin(day, this.value, this.multiple),
            'is-last-selected': dateMatch(day, Array.isArray(this.value) && this.value[1], this.multiple),
            'is-within-hovered-range': this.hoveredDateRange && this.hoveredDateRange.length === 2 && (dateMatch(day, this.hoveredDateRange) || dateWithin(day, this.hoveredDateRange)),
            'is-first-hovered': dateMatch(day, Array.isArray(this.hoveredDateRange) && this.hoveredDateRange[0]),
            'is-within-hovered': dateWithin(day, this.hoveredDateRange),
            'is-last-hovered': dateMatch(day, Array.isArray(this.hoveredDateRange) && this.hoveredDateRange[1]),
            'is-today': dateMatch(day, this.dateCreator()),
            'is-selectable': this.selectableDate(day) && !this.disabled,
            'is-unselectable': !this.selectableDate(day) || this.disabled
          };
        },
        manageKeydown: function manageKeydown(_ref, date) {
          var key = _ref.key;

          // https://developer.mozilla.org/fr/docs/Web/API/KeyboardEvent/key/Key_Values#Navigation_keys
          switch (key) {
            case ' ':
            case 'Space':
            case 'Spacebar':
            case 'Enter':
              {
                this.updateSelectedDate(date);
                break;
              }

            case 'ArrowLeft':
            case 'Left':
              {
                this.changeFocus(date, -1);
                break;
              }

            case 'ArrowRight':
            case 'Right':
              {
                this.changeFocus(date, 1);
                break;
              }

            case 'ArrowUp':
            case 'Up':
              {
                this.changeFocus(date, -3);
                break;
              }

            case 'ArrowDown':
            case 'Down':
              {
                this.changeFocus(date, 3);
                break;
              }
          }
        },

        /*
        * Emit input event with selected date as payload for v-model in parent
        */
        updateSelectedDate: function updateSelectedDate(date) {
          if (!this.range && !this.multiple) {
            this.emitChosenDate(date);
          } else if (this.range) {
            this.handleSelectRangeDate(date);
          } else if (this.multiple) {
            this.selectMultipleDates(date);
          }
        },

        /*
         * Emit select event with chosen date as payload
         */
        emitChosenDate: function emitChosenDate(day) {
          if (this.disabled) return;

          if (!this.multiple) {
            if (this.selectableDate(day)) {
              this.$emit('input', day);
            }
          } else {
            this.selectMultipleDates(day);
          }
        },

        /*
        * If both begin and end dates are set, reset the end date and set the begin date.
        * If only begin date is selected, emit an array of the begin date and the new date.
        * If not set, only set the begin date.
        */
        handleSelectRangeDate: function handleSelectRangeDate(date) {
          if (this.disabled) return;

          if (this.selectedBeginDate && this.selectedEndDate) {
            this.selectedBeginDate = date;
            this.selectedEndDate = undefined;
            this.$emit('range-start', date);
          } else if (this.selectedBeginDate && !this.selectedEndDate) {
            if (this.selectedBeginDate > date) {
              this.selectedEndDate = this.selectedBeginDate;
              this.selectedBeginDate = date;
            } else {
              this.selectedEndDate = date;
            }

            this.$emit('range-end', date);
            this.$emit('input', [this.selectedBeginDate, this.selectedEndDate]);
          } else {
            this.selectedBeginDate = date;
            this.$emit('range-start', date);
          }
        },
        setRangeHoverEndDate: function setRangeHoverEndDate(day) {
          if (this.range) {
            this.hoveredEndDate = day;
          }
        },
        changeFocus: function changeFocus(month, inc) {
          var nextMonth = month;
          nextMonth.setMonth(month.getMonth() + inc);
          this.$emit('change-focus', nextMonth);
        }
      }
    };

    /* script */
    const __vue_script__$2$3 = script$2$3;

    /* template */
    var __vue_render__$2$3 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('section',{staticClass:"datepicker-table"},[_c('div',{staticClass:"datepicker-body",class:{'has-events':_vm.hasEvents}},[_c('div',{staticClass:"datepicker-months"},[_vm._l((_vm.monthDates),function(date,index){return [(_vm.selectableDate(date) && !_vm.disabled)?_c('a',{key:index,ref:("month-" + (date.getMonth())),refInFor:true,staticClass:"datepicker-cell",class:[
                            _vm.classObject(date),
                            {'has-event': _vm.eventsDateMatch(date)},
                            _vm.indicators
                        ],attrs:{"role":"button","href":"#","disabled":_vm.disabled,"tabindex":_vm.focused.month === date.getMonth() ? null : -1},on:{"click":function($event){$event.preventDefault();return _vm.updateSelectedDate(date)},"mouseenter":function($event){return _vm.setRangeHoverEndDate(date)},"keydown":function($event){$event.preventDefault();return _vm.manageKeydown($event, date)}}},[_vm._v(" "+_vm._s(_vm.monthNames[date.getMonth()])+" "),(_vm.eventsDateMatch(date))?_c('div',{staticClass:"events"},_vm._l((_vm.eventsDateMatch(date)),function(event,index){return _c('div',{key:index,staticClass:"event",class:event.type})}),0):_vm._e()]):_c('div',{key:index,staticClass:"datepicker-cell",class:_vm.classObject(date)},[_vm._v(" "+_vm._s(_vm.monthNames[date.getMonth()])+" ")])]})],2)])])};
    var __vue_staticRenderFns__$2$3 = [];

      /* style */
      const __vue_inject_styles__$2$3 = undefined;
      /* scoped */
      const __vue_scope_id__$2$3 = undefined;
      /* module identifier */
      const __vue_module_identifier__$2$3 = undefined;
      /* functional template */
      const __vue_is_functional_template__$2$3 = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var DatepickerMonth = normalizeComponent_1(
        { render: __vue_render__$2$3, staticRenderFns: __vue_staticRenderFns__$2$3 },
        __vue_inject_styles__$2$3,
        __vue_script__$2$3,
        __vue_scope_id__$2$3,
        __vue_is_functional_template__$2$3,
        __vue_module_identifier__$2$3,
        undefined,
        undefined
      );

    var _components$3;

    var defaultDateFormatter = function defaultDateFormatter(date, vm) {
      var targetDates = Array.isArray(date) ? date : [date];
      var dates = targetDates.map(function (date) {
        var d = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 12);
        return !vm.isTypeMonth ? vm.dtf.format(d) : vm.dtfMonth.format(d);
      });
      return !vm.multiple ? dates.join(' - ') : dates.join(', ');
    };

    var defaultDateParser = function defaultDateParser(date, vm) {
      if (vm.dtf.formatToParts && typeof vm.dtf.formatToParts === 'function') {
        var formatRegex = (vm.isTypeMonth ? vm.dtfMonth : vm.dtf).formatToParts(new Date(2000, 11, 25)).map(function (part) {
          if (part.type === 'literal') {
            return part.value;
          }

          return "((?!=<".concat(part.type, ">)\\d+)");
        }).join('');
        var dateGroups = matchWithGroups(formatRegex, date); // We do a simple validation for the group.
        // If it is not valid, it will fallback to Date.parse below

        if (dateGroups.year && dateGroups.year.length === 4 && dateGroups.month && dateGroups.month <= 12) {
          if (vm.isTypeMonth) return new Date(dateGroups.year, dateGroups.month - 1);else if (dateGroups.day && dateGroups.day <= 31) {
            return new Date(dateGroups.year, dateGroups.month - 1, dateGroups.day, 12);
          }
        }
      } // Fallback if formatToParts is not supported or if we were not able to parse a valid date


      if (!vm.isTypeMonth) return new Date(Date.parse(date));

      if (date) {
        var s = date.split('/');
        var year = s[0].length === 4 ? s[0] : s[1];
        var month = s[0].length === 2 ? s[0] : s[1];

        if (year && month) {
          return new Date(parseInt(year, 10), parseInt(month - 1, 10), 1, 0, 0, 0, 0);
        }
      }

      return null;
    };

    var script$3$2 = {
      name: 'BDatepicker',
      components: (_components$3 = {}, _defineProperty(_components$3, DatepickerTable.name, DatepickerTable), _defineProperty(_components$3, DatepickerMonth.name, DatepickerMonth), _defineProperty(_components$3, Input.name, Input), _defineProperty(_components$3, Field.name, Field), _defineProperty(_components$3, Select.name, Select), _defineProperty(_components$3, Icon.name, Icon), _defineProperty(_components$3, Dropdown.name, Dropdown), _defineProperty(_components$3, DropdownItem.name, DropdownItem), _components$3),
      mixins: [FormElementMixin],
      inheritAttrs: false,
      provide: function provide() {
        return {
          $datepicker: this
        };
      },
      props: {
        value: {
          type: [Date, Array]
        },
        dayNames: {
          type: Array,
          default: function _default() {
            if (!Array.isArray(config$2.defaultDayNames)) {
              return undefined;
            }

            return config$2.defaultDayNames;
          }
        },
        monthNames: {
          type: Array,
          default: function _default() {
            if (!Array.isArray(config$2.defaultMonthNames)) {
              return undefined;
            }

            return config$2.defaultMonthNames;
          }
        },
        firstDayOfWeek: {
          type: Number,
          default: function _default() {
            if (typeof config$2.defaultFirstDayOfWeek === 'number') {
              return config$2.defaultFirstDayOfWeek;
            } else {
              return 0;
            }
          }
        },
        inline: Boolean,
        minDate: Date,
        maxDate: Date,
        focusedDate: Date,
        placeholder: String,
        editable: Boolean,
        disabled: Boolean,
        horizontalTimePicker: Boolean,
        unselectableDates: [Array, Function],
        unselectableDaysOfWeek: {
          type: Array,
          default: function _default() {
            return config$2.defaultUnselectableDaysOfWeek;
          }
        },
        selectableDates: [Array, Function],
        dateFormatter: {
          type: Function,
          default: function _default(date, vm) {
            if (typeof config$2.defaultDateFormatter === 'function') {
              return config$2.defaultDateFormatter(date);
            } else {
              return defaultDateFormatter(date, vm);
            }
          }
        },
        dateParser: {
          type: Function,
          default: function _default(date, vm) {
            if (typeof config$2.defaultDateParser === 'function') {
              return config$2.defaultDateParser(date);
            } else {
              return defaultDateParser(date, vm);
            }
          }
        },
        dateCreator: {
          type: Function,
          default: function _default() {
            if (typeof config$2.defaultDateCreator === 'function') {
              return config$2.defaultDateCreator();
            } else {
              return new Date();
            }
          }
        },
        mobileNative: {
          type: Boolean,
          default: function _default() {
            return config$2.defaultDatepickerMobileNative;
          }
        },
        position: String,
        iconRight: String,
        iconRightClickable: Boolean,
        events: Array,
        indicators: {
          type: String,
          default: 'dots'
        },
        openOnFocus: Boolean,
        iconPrev: {
          type: String,
          default: function _default() {
            return config$2.defaultIconPrev;
          }
        },
        iconNext: {
          type: String,
          default: function _default() {
            return config$2.defaultIconNext;
          }
        },
        yearsRange: {
          type: Array,
          default: function _default() {
            return config$2.defaultDatepickerYearsRange;
          }
        },
        type: {
          type: String,
          validator: function validator(value) {
            return ['month'].indexOf(value) >= 0;
          }
        },
        nearbyMonthDays: {
          type: Boolean,
          default: function _default() {
            return config$2.defaultDatepickerNearbyMonthDays;
          }
        },
        nearbySelectableMonthDays: {
          type: Boolean,
          default: function _default() {
            return config$2.defaultDatepickerNearbySelectableMonthDays;
          }
        },
        showWeekNumber: {
          type: Boolean,
          default: function _default() {
            return config$2.defaultDatepickerShowWeekNumber;
          }
        },
        weekNumberClickable: {
          type: Boolean,
          default: function _default() {
            return config$2.defaultDatepickerWeekNumberClickable;
          }
        },
        rulesForFirstWeek: {
          type: Number,
          default: function _default() {
            return 4;
          }
        },
        range: {
          type: Boolean,
          default: false
        },
        closeOnClick: {
          type: Boolean,
          default: true
        },
        multiple: {
          type: Boolean,
          default: false
        },
        mobileModal: {
          type: Boolean,
          default: function _default() {
            return config$2.defaultDatepickerMobileModal;
          }
        },
        focusable: {
          type: Boolean,
          default: true
        },
        trapFocus: {
          type: Boolean,
          default: function _default() {
            return config$2.defaultTrapFocus;
          }
        },
        appendToBody: Boolean,
        ariaNextLabel: String,
        ariaPreviousLabel: String
      },
      data: function data() {
        var focusedDate = (Array.isArray(this.value) ? this.value[0] : this.value) || this.focusedDate || this.dateCreator();

        if (!this.value && this.maxDate && this.maxDate.getFullYear() < focusedDate.getFullYear()) {
          focusedDate.setFullYear(this.maxDate.getFullYear());
        }

        return {
          dateSelected: this.value,
          focusedDateData: {
            day: focusedDate.getDate(),
            month: focusedDate.getMonth(),
            year: focusedDate.getFullYear()
          },
          _elementRef: 'input',
          _isDatepicker: true
        };
      },
      computed: {
        computedValue: {
          get: function get() {
            return this.dateSelected;
          },
          set: function set(value) {
            var _this = this;

            this.updateInternalState(value);
            if (!this.multiple) this.togglePicker(false);
            this.$emit('input', value);

            if (this.useHtml5Validation) {
              this.$nextTick(function () {
                _this.checkHtml5Validity();
              });
            }
          }
        },
        formattedValue: function formattedValue() {
          return this.formatValue(this.computedValue);
        },
        localeOptions: function localeOptions() {
          return new Intl.DateTimeFormat(this.locale, {
            year: 'numeric',
            month: 'numeric'
          }).resolvedOptions();
        },
        dtf: function dtf() {
          return new Intl.DateTimeFormat(this.locale);
        },
        dtfMonth: function dtfMonth() {
          return new Intl.DateTimeFormat(this.locale, {
            year: this.localeOptions.year || 'numeric',
            month: this.localeOptions.month || '2-digit'
          });
        },
        newMonthNames: function newMonthNames() {
          if (Array.isArray(this.monthNames)) {
            return this.monthNames;
          }

          return getMonthNames(this.locale);
        },
        newDayNames: function newDayNames() {
          if (Array.isArray(this.dayNames)) {
            return this.dayNames;
          }

          return getWeekdayNames(this.locale);
        },
        listOfMonths: function listOfMonths() {
          var minMonth = 0;
          var maxMonth = 12;

          if (this.minDate && this.focusedDateData.year === this.minDate.getFullYear()) {
            minMonth = this.minDate.getMonth();
          }

          if (this.maxDate && this.focusedDateData.year === this.maxDate.getFullYear()) {
            maxMonth = this.maxDate.getMonth();
          }

          return this.newMonthNames.map(function (name, index) {
            return {
              name: name,
              index: index,
              disabled: index < minMonth || index > maxMonth
            };
          });
        },

        /*
         * Returns an array of years for the year dropdown. If earliest/latest
         * dates are set by props, range of years will fall within those dates.
         */
        listOfYears: function listOfYears() {
          var latestYear = this.focusedDateData.year + this.yearsRange[1];

          if (this.maxDate && this.maxDate.getFullYear() < latestYear) {
            latestYear = Math.max(this.maxDate.getFullYear(), this.focusedDateData.year);
          }

          var earliestYear = this.focusedDateData.year + this.yearsRange[0];

          if (this.minDate && this.minDate.getFullYear() > earliestYear) {
            earliestYear = Math.min(this.minDate.getFullYear(), this.focusedDateData.year);
          }

          var arrayOfYears = [];

          for (var i = earliestYear; i <= latestYear; i++) {
            arrayOfYears.push(i);
          }

          return arrayOfYears.reverse();
        },
        showPrev: function showPrev() {
          if (!this.minDate) return false;

          if (this.isTypeMonth) {
            return this.focusedDateData.year <= this.minDate.getFullYear();
          }

          var dateToCheck = new Date(this.focusedDateData.year, this.focusedDateData.month);
          var date = new Date(this.minDate.getFullYear(), this.minDate.getMonth());
          return dateToCheck <= date;
        },
        showNext: function showNext() {
          if (!this.maxDate) return false;

          if (this.isTypeMonth) {
            return this.focusedDateData.year >= this.maxDate.getFullYear();
          }

          var dateToCheck = new Date(this.focusedDateData.year, this.focusedDateData.month);
          var date = new Date(this.maxDate.getFullYear(), this.maxDate.getMonth());
          return dateToCheck >= date;
        },
        isMobile: function isMobile$1() {
          return this.mobileNative && isMobile.any();
        },
        isTypeMonth: function isTypeMonth() {
          return this.type === 'month';
        },
        ariaRole: function ariaRole() {
          if (!this.inline) {
            return 'dialog';
          }
        }
      },
      watch: {
        /**
         * When v-model is changed:
         *   1. Update internal value.
         *   2. If it's invalid, validate again.
         */
        value: function value(_value) {
          this.updateInternalState(_value);
          if (!this.multiple) this.togglePicker(false);
        },
        focusedDate: function focusedDate(value) {
          if (value) {
            this.focusedDateData = {
              day: value.getDate(),
              month: value.getMonth(),
              year: value.getFullYear()
            };
          }
        },

        /*
         * Emit input event on month and/or year change
         */
        'focusedDateData.month': function focusedDateDataMonth(value) {
          this.$emit('change-month', value);
        },
        'focusedDateData.year': function focusedDateDataYear(value) {
          this.$emit('change-year', value);
        }
      },
      methods: {
        /*
         * Parse string into date
         */
        onChange: function onChange(value) {
          var date = this.dateParser(value, this);

          if (date && (!isNaN(date) || Array.isArray(date) && date.length === 2 && !isNaN(date[0]) && !isNaN(date[1]))) {
            this.computedValue = date;
          } else {
            // Force refresh input value when not valid date
            this.computedValue = null;

            if (this.$refs.input) {
              this.$refs.input.newValue = this.computedValue;
            }
          }
        },

        /*
         * Format date into string
         */
        formatValue: function formatValue(value) {
          if (Array.isArray(value)) {
            var isArrayWithValidDates = Array.isArray(value) && value.every(function (v) {
              return !isNaN(v);
            });
            return isArrayWithValidDates ? this.dateFormatter(_toConsumableArray(value), this) : null;
          }

          return value && !isNaN(value) ? this.dateFormatter(value, this) : null;
        },

        /*
         * Either decrement month by 1 if not January or decrement year by 1
         * and set month to 11 (December) or decrement year when 'month'
         */
        prev: function prev() {
          if (this.disabled) return;

          if (this.isTypeMonth) {
            this.focusedDateData.year -= 1;
          } else {
            if (this.focusedDateData.month > 0) {
              this.focusedDateData.month -= 1;
            } else {
              this.focusedDateData.month = 11;
              this.focusedDateData.year -= 1;
            }
          }
        },

        /*
         * Either increment month by 1 if not December or increment year by 1
         * and set month to 0 (January) or increment year when 'month'
         */
        next: function next() {
          if (this.disabled) return;

          if (this.isTypeMonth) {
            this.focusedDateData.year += 1;
          } else {
            if (this.focusedDateData.month < 11) {
              this.focusedDateData.month += 1;
            } else {
              this.focusedDateData.month = 0;
              this.focusedDateData.year += 1;
            }
          }
        },
        formatNative: function formatNative(value) {
          return this.isTypeMonth ? this.formatYYYYMM(value) : this.formatYYYYMMDD(value);
        },

        /*
         * Format date into string 'YYYY-MM-DD'
         */
        formatYYYYMMDD: function formatYYYYMMDD(value) {
          var date = new Date(value);

          if (value && !isNaN(date)) {
            var year = date.getFullYear();
            var month = date.getMonth() + 1;
            var day = date.getDate();
            return year + '-' + ((month < 10 ? '0' : '') + month) + '-' + ((day < 10 ? '0' : '') + day);
          }

          return '';
        },

        /*
         * Format date into string 'YYYY-MM'
         */
        formatYYYYMM: function formatYYYYMM(value) {
          var date = new Date(value);

          if (value && !isNaN(date)) {
            var year = date.getFullYear();
            var month = date.getMonth() + 1;
            return year + '-' + ((month < 10 ? '0' : '') + month);
          }

          return '';
        },

        /*
         * Parse date from string
         */
        onChangeNativePicker: function onChangeNativePicker(event) {
          var date = event.target.value;
          var s = date ? date.split('-') : [];

          if (s.length === 3) {
            var year = parseInt(s[0], 10);
            var month = parseInt(s[1]) - 1;
            var day = parseInt(s[2]);
            this.computedValue = new Date(year, month, day);
          } else {
            this.computedValue = null;
          }
        },
        updateInternalState: function updateInternalState(value) {
          if (this.dateSelected === value) return;
          var isArray = Array.isArray(value);
          var currentDate = isArray ? !value.length ? this.dateCreator() : value[value.length - 1] : !value ? this.dateCreator() : value;

          if (!isArray || isArray && this.dateSelected && value.length > this.dateSelected.length) {
            this.focusedDateData = {
              day: currentDate.getDate(),
              month: currentDate.getMonth(),
              year: currentDate.getFullYear()
            };
          }

          this.dateSelected = value;
        },

        /*
         * Toggle datepicker
         */
        togglePicker: function togglePicker(active) {
          if (this.$refs.dropdown) {
            var isActive = typeof active === 'boolean' ? active : !this.$refs.dropdown.isActive;

            if (isActive) {
              this.$refs.dropdown.isActive = isActive;
            } else if (this.closeOnClick) {
              this.$refs.dropdown.isActive = isActive;
            }
          }
        },

        /*
         * Call default onFocus method and show datepicker
         */
        handleOnFocus: function handleOnFocus(event) {
          this.onFocus(event);

          if (this.openOnFocus) {
            this.togglePicker(true);
          }
        },

        /*
         * Toggle dropdown
         */
        toggle: function toggle() {
          if (this.mobileNative && this.isMobile) {
            var input = this.$refs.input.$refs.input;
            input.focus();
            input.click();
            return;
          }

          this.$refs.dropdown.toggle();
        },

        /*
         * Avoid dropdown toggle when is already visible
         */
        onInputClick: function onInputClick(event) {
          if (this.$refs.dropdown.isActive) {
            event.stopPropagation();
          }
        },

        /**
         * Keypress event that is bound to the document.
         */
        keyPress: function keyPress(_ref) {
          var key = _ref.key;

          if (this.$refs.dropdown && this.$refs.dropdown.isActive && (key === 'Escape' || key === 'Esc')) {
            this.togglePicker(false);
          }
        },

        /**
         * Emit 'blur' event on dropdown is not active (closed)
         */
        onActiveChange: function onActiveChange(value) {
          if (!value) {
            this.onBlur();
          }
          /*
           * Emit 'active-change' when on dropdown active state change
           */


          this.$emit('active-change', value);
        },
        changeFocus: function changeFocus(day) {
          this.focusedDateData = {
            day: day.getDate(),
            month: day.getMonth(),
            year: day.getFullYear()
          };
        }
      },
      created: function created() {
        if (typeof window !== 'undefined') {
          document.addEventListener('keyup', this.keyPress);
        }
      },
      beforeDestroy: function beforeDestroy() {
        if (typeof window !== 'undefined') {
          document.removeEventListener('keyup', this.keyPress);
        }
      }
    };

    /* script */
    const __vue_script__$3$2 = script$3$2;

    /* template */
    var __vue_render__$3$2 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"datepicker control",class:[_vm.size, {'is-expanded': _vm.expanded}]},[(!_vm.isMobile || _vm.inline)?_c('b-dropdown',{ref:"dropdown",attrs:{"position":_vm.position,"disabled":_vm.disabled,"inline":_vm.inline,"mobile-modal":_vm.mobileModal,"trap-focus":_vm.trapFocus,"aria-role":_vm.ariaRole,"append-to-body":_vm.appendToBody,"append-to-body-copy-parent":""},on:{"active-change":_vm.onActiveChange},scopedSlots:_vm._u([(!_vm.inline)?{key:"trigger",fn:function(){return [_vm._t("trigger",[_c('b-input',_vm._b({ref:"input",attrs:{"autocomplete":"off","value":_vm.formattedValue,"placeholder":_vm.placeholder,"size":_vm.size,"icon":_vm.icon,"icon-right":_vm.iconRight,"icon-right-clickable":_vm.iconRightClickable,"icon-pack":_vm.iconPack,"rounded":_vm.rounded,"loading":_vm.loading,"disabled":_vm.disabled,"readonly":!_vm.editable,"use-html5-validation":false},on:{"icon-right-click":function($event){return _vm.$emit('icon-right-click', $event)},"focus":_vm.handleOnFocus},nativeOn:{"click":function($event){return _vm.onInputClick($event)},"keyup":function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"enter",13,$event.key,"Enter")){ return null; }return _vm.togglePicker(true)},"change":function($event){return _vm.onChange($event.target.value)}}},'b-input',_vm.$attrs,false))])]},proxy:true}:null],null,true)},[_c('b-dropdown-item',{class:{'dropdown-horizonal-timepicker': _vm.horizontalTimePicker},attrs:{"disabled":_vm.disabled,"focusable":_vm.focusable,"custom":""}},[_c('div',[_c('header',{staticClass:"datepicker-header"},[(_vm.$slots.header !== undefined && _vm.$slots.header.length)?[_vm._t("header")]:_c('div',{staticClass:"pagination field is-centered",class:_vm.size},[_c('a',{directives:[{name:"show",rawName:"v-show",value:(!_vm.showPrev && !_vm.disabled),expression:"!showPrev && !disabled"}],staticClass:"pagination-previous",attrs:{"role":"button","href":"#","disabled":_vm.disabled,"aria-label":_vm.ariaPreviousLabel},on:{"click":function($event){$event.preventDefault();return _vm.prev($event)},"keydown":[function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"enter",13,$event.key,"Enter")){ return null; }$event.preventDefault();return _vm.prev($event)},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"space",32,$event.key,[" ","Spacebar"])){ return null; }$event.preventDefault();return _vm.prev($event)}]}},[_c('b-icon',{attrs:{"icon":_vm.iconPrev,"pack":_vm.iconPack,"both":"","type":"is-primary is-clickable"}})],1),_c('a',{directives:[{name:"show",rawName:"v-show",value:(!_vm.showNext && !_vm.disabled),expression:"!showNext && !disabled"}],staticClass:"pagination-next",attrs:{"role":"button","href":"#","disabled":_vm.disabled,"aria-label":_vm.ariaNextLabel},on:{"click":function($event){$event.preventDefault();return _vm.next($event)},"keydown":[function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"enter",13,$event.key,"Enter")){ return null; }$event.preventDefault();return _vm.next($event)},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"space",32,$event.key,[" ","Spacebar"])){ return null; }$event.preventDefault();return _vm.next($event)}]}},[_c('b-icon',{attrs:{"icon":_vm.iconNext,"pack":_vm.iconPack,"both":"","type":"is-primary is-clickable"}})],1),_c('div',{staticClass:"pagination-list"},[_c('b-field',[(!_vm.isTypeMonth)?_c('b-select',{attrs:{"disabled":_vm.disabled,"size":_vm.size},model:{value:(_vm.focusedDateData.month),callback:function ($$v) {_vm.$set(_vm.focusedDateData, "month", $$v);},expression:"focusedDateData.month"}},_vm._l((_vm.listOfMonths),function(month){return _c('option',{key:month.name,attrs:{"disabled":month.disabled},domProps:{"value":month.index}},[_vm._v(" "+_vm._s(month.name)+" ")])}),0):_vm._e(),_c('b-select',{attrs:{"disabled":_vm.disabled,"size":_vm.size},model:{value:(_vm.focusedDateData.year),callback:function ($$v) {_vm.$set(_vm.focusedDateData, "year", $$v);},expression:"focusedDateData.year"}},_vm._l((_vm.listOfYears),function(year){return _c('option',{key:year,domProps:{"value":year}},[_vm._v(" "+_vm._s(year)+" ")])}),0)],1)],1)])],2),(!_vm.isTypeMonth)?_c('div',{staticClass:"datepicker-content",class:{'content-horizonal-timepicker': _vm.horizontalTimePicker}},[_c('b-datepicker-table',{attrs:{"day-names":_vm.newDayNames,"month-names":_vm.newMonthNames,"first-day-of-week":_vm.firstDayOfWeek,"rules-for-first-week":_vm.rulesForFirstWeek,"min-date":_vm.minDate,"max-date":_vm.maxDate,"focused":_vm.focusedDateData,"disabled":_vm.disabled,"unselectable-dates":_vm.unselectableDates,"unselectable-days-of-week":_vm.unselectableDaysOfWeek,"selectable-dates":_vm.selectableDates,"events":_vm.events,"indicators":_vm.indicators,"date-creator":_vm.dateCreator,"type-month":_vm.isTypeMonth,"nearby-month-days":_vm.nearbyMonthDays,"nearby-selectable-month-days":_vm.nearbySelectableMonthDays,"show-week-number":_vm.showWeekNumber,"week-number-clickable":_vm.weekNumberClickable,"range":_vm.range,"multiple":_vm.multiple},on:{"range-start":function (date) { return _vm.$emit('range-start', date); },"range-end":function (date) { return _vm.$emit('range-end', date); },"close":function($event){return _vm.togglePicker(false)},"update:focused":function($event){_vm.focusedDateData = $event;}},model:{value:(_vm.computedValue),callback:function ($$v) {_vm.computedValue=$$v;},expression:"computedValue"}})],1):_c('div',[_c('b-datepicker-month',{attrs:{"month-names":_vm.newMonthNames,"min-date":_vm.minDate,"max-date":_vm.maxDate,"focused":_vm.focusedDateData,"disabled":_vm.disabled,"unselectable-dates":_vm.unselectableDates,"unselectable-days-of-week":_vm.unselectableDaysOfWeek,"selectable-dates":_vm.selectableDates,"events":_vm.events,"indicators":_vm.indicators,"date-creator":_vm.dateCreator,"range":_vm.range,"multiple":_vm.multiple},on:{"range-start":function (date) { return _vm.$emit('range-start', date); },"range-end":function (date) { return _vm.$emit('range-end', date); },"close":function($event){return _vm.togglePicker(false)},"change-focus":_vm.changeFocus,"update:focused":function($event){_vm.focusedDateData = $event;}},model:{value:(_vm.computedValue),callback:function ($$v) {_vm.computedValue=$$v;},expression:"computedValue"}})],1)]),(_vm.$slots.default !== undefined && _vm.$slots.default.length)?_c('footer',{staticClass:"datepicker-footer",class:{'footer-horizontal-timepicker': _vm.horizontalTimePicker}},[_vm._t("default")],2):_vm._e()])],1):_c('b-input',_vm._b({ref:"input",attrs:{"type":!_vm.isTypeMonth ? 'date' : 'month',"autocomplete":"off","value":_vm.formatNative(_vm.computedValue),"placeholder":_vm.placeholder,"size":_vm.size,"icon":_vm.icon,"icon-pack":_vm.iconPack,"rounded":_vm.rounded,"loading":_vm.loading,"max":_vm.formatNative(_vm.maxDate),"min":_vm.formatNative(_vm.minDate),"disabled":_vm.disabled,"readonly":false,"use-html5-validation":false},on:{"focus":_vm.onFocus,"blur":_vm.onBlur},nativeOn:{"change":function($event){return _vm.onChangeNativePicker($event)}}},'b-input',_vm.$attrs,false))],1)};
    var __vue_staticRenderFns__$3$2 = [];

      /* style */
      const __vue_inject_styles__$3$2 = undefined;
      /* scoped */
      const __vue_scope_id__$3$2 = undefined;
      /* module identifier */
      const __vue_module_identifier__$3$2 = undefined;
      /* functional template */
      const __vue_is_functional_template__$3$2 = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var Datepicker = normalizeComponent_1(
        { render: __vue_render__$3$2, staticRenderFns: __vue_staticRenderFns__$3$2 },
        __vue_inject_styles__$3$2,
        __vue_script__$3$2,
        __vue_scope_id__$3$2,
        __vue_is_functional_template__$3$2,
        __vue_module_identifier__$3$2,
        undefined,
        undefined
      );

    var Plugin$8 = {
      install: function install(Vue) {
        registerComponent(Vue, Datepicker);
      }
    };
    use(Plugin$8);

    var _components$4;
    var script$h = {
      name: 'BTimepicker',
      components: (_components$4 = {}, _defineProperty(_components$4, Input.name, Input), _defineProperty(_components$4, Field.name, Field), _defineProperty(_components$4, Select.name, Select), _defineProperty(_components$4, Icon.name, Icon), _defineProperty(_components$4, Dropdown.name, Dropdown), _defineProperty(_components$4, DropdownItem.name, DropdownItem), _components$4),
      mixins: [TimepickerMixin],
      inheritAttrs: false,
      data: function data() {
        return {
          _isTimepicker: true
        };
      },
      computed: {
        nativeStep: function nativeStep() {
          if (this.enableSeconds) return '1';
        }
      }
    };

    /* script */
    const __vue_script__$h = script$h;

    /* template */
    var __vue_render__$g = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"timepicker control",class:[_vm.size, {'is-expanded': _vm.expanded}]},[(!_vm.isMobile || _vm.inline)?_c('b-dropdown',{ref:"dropdown",attrs:{"position":_vm.position,"disabled":_vm.disabled,"inline":_vm.inline,"append-to-body":_vm.appendToBody,"append-to-body-copy-parent":""},on:{"active-change":_vm.onActiveChange},scopedSlots:_vm._u([(!_vm.inline)?{key:"trigger",fn:function(){return [_vm._t("trigger",[_c('b-input',_vm._b({ref:"input",attrs:{"autocomplete":"off","value":_vm.formatValue(_vm.computedValue),"placeholder":_vm.placeholder,"size":_vm.size,"icon":_vm.icon,"icon-pack":_vm.iconPack,"loading":_vm.loading,"disabled":_vm.disabled,"readonly":!_vm.editable,"rounded":_vm.rounded,"use-html5-validation":_vm.useHtml5Validation},on:{"focus":_vm.handleOnFocus},nativeOn:{"keyup":function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"enter",13,$event.key,"Enter")){ return null; }return _vm.toggle(true)},"change":function($event){return _vm.onChange($event.target.value)}}},'b-input',_vm.$attrs,false))])]},proxy:true}:null],null,true)},[_c('b-dropdown-item',{attrs:{"disabled":_vm.disabled,"focusable":_vm.focusable,"custom":""}},[_c('b-field',{attrs:{"grouped":"","position":"is-centered"}},[_c('b-select',{attrs:{"disabled":_vm.disabled,"placeholder":"00"},nativeOn:{"change":function($event){return _vm.onHoursChange($event.target.value)}},model:{value:(_vm.hoursSelected),callback:function ($$v) {_vm.hoursSelected=$$v;},expression:"hoursSelected"}},_vm._l((_vm.hours),function(hour){return _c('option',{key:hour.value,attrs:{"disabled":_vm.isHourDisabled(hour.value)},domProps:{"value":hour.value}},[_vm._v(" "+_vm._s(hour.label)+" ")])}),0),_c('span',{staticClass:"control is-colon"},[_vm._v(_vm._s(_vm.hourLiteral))]),_c('b-select',{attrs:{"disabled":_vm.disabled,"placeholder":"00"},nativeOn:{"change":function($event){return _vm.onMinutesChange($event.target.value)}},model:{value:(_vm.minutesSelected),callback:function ($$v) {_vm.minutesSelected=$$v;},expression:"minutesSelected"}},_vm._l((_vm.minutes),function(minute){return _c('option',{key:minute.value,attrs:{"disabled":_vm.isMinuteDisabled(minute.value)},domProps:{"value":minute.value}},[_vm._v(" "+_vm._s(minute.label)+" ")])}),0),(_vm.enableSeconds)?[_c('span',{staticClass:"control is-colon"},[_vm._v(_vm._s(_vm.minuteLiteral))]),_c('b-select',{attrs:{"disabled":_vm.disabled,"placeholder":"00"},nativeOn:{"change":function($event){return _vm.onSecondsChange($event.target.value)}},model:{value:(_vm.secondsSelected),callback:function ($$v) {_vm.secondsSelected=$$v;},expression:"secondsSelected"}},_vm._l((_vm.seconds),function(second){return _c('option',{key:second.value,attrs:{"disabled":_vm.isSecondDisabled(second.value)},domProps:{"value":second.value}},[_vm._v(" "+_vm._s(second.label)+" ")])}),0),_c('span',{staticClass:"control is-colon"},[_vm._v(_vm._s(_vm.secondLiteral))])]:_vm._e(),(!_vm.isHourFormat24)?_c('b-select',{attrs:{"disabled":_vm.disabled},nativeOn:{"change":function($event){return _vm.onMeridienChange($event.target.value)}},model:{value:(_vm.meridienSelected),callback:function ($$v) {_vm.meridienSelected=$$v;},expression:"meridienSelected"}},_vm._l((_vm.meridiens),function(meridien){return _c('option',{key:meridien,domProps:{"value":meridien}},[_vm._v(" "+_vm._s(meridien)+" ")])}),0):_vm._e()],2),(_vm.$slots.default !== undefined && _vm.$slots.default.length)?_c('footer',{staticClass:"timepicker-footer"},[_vm._t("default")],2):_vm._e()],1)],1):_c('b-input',_vm._b({ref:"input",attrs:{"type":"time","step":_vm.nativeStep,"autocomplete":"off","value":_vm.formatHHMMSS(_vm.computedValue),"placeholder":_vm.placeholder,"size":_vm.size,"icon":_vm.icon,"icon-pack":_vm.iconPack,"rounded":_vm.rounded,"loading":_vm.loading,"max":_vm.formatHHMMSS(_vm.maxTime),"min":_vm.formatHHMMSS(_vm.minTime),"disabled":_vm.disabled,"readonly":false,"use-html5-validation":_vm.useHtml5Validation},on:{"focus":_vm.handleOnFocus,"blur":function($event){_vm.onBlur() && _vm.checkHtml5Validity();}},nativeOn:{"change":function($event){return _vm.onChange($event.target.value)}}},'b-input',_vm.$attrs,false))],1)};
    var __vue_staticRenderFns__$g = [];

      /* style */
      const __vue_inject_styles__$h = undefined;
      /* scoped */
      const __vue_scope_id__$h = undefined;
      /* module identifier */
      const __vue_module_identifier__$h = undefined;
      /* functional template */
      const __vue_is_functional_template__$h = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var Timepicker = normalizeComponent_1(
        { render: __vue_render__$g, staticRenderFns: __vue_staticRenderFns__$g },
        __vue_inject_styles__$h,
        __vue_script__$h,
        __vue_scope_id__$h,
        __vue_is_functional_template__$h,
        __vue_module_identifier__$h,
        undefined,
        undefined
      );

    var _components$5;
    var AM$1 = 'AM';
    var PM$1 = 'PM';
    var script$i = {
      name: 'BDatetimepicker',
      components: (_components$5 = {}, _defineProperty(_components$5, Datepicker.name, Datepicker), _defineProperty(_components$5, Timepicker.name, Timepicker), _components$5),
      mixins: [FormElementMixin],
      inheritAttrs: false,
      props: {
        value: {
          type: Date
        },
        editable: {
          type: Boolean,
          default: false
        },
        placeholder: String,
        horizontalTimePicker: Boolean,
        disabled: Boolean,
        firstDayOfWeek: {
          type: Number,
          default: function _default() {
            if (typeof config$2.defaultFirstDayOfWeek === 'number') {
              return config$2.defaultFirstDayOfWeek;
            } else {
              return 0;
            }
          }
        },
        rulesForFirstWeek: {
          type: Number,
          default: function _default() {
            return 4;
          }
        },
        icon: String,
        iconRight: String,
        iconRightClickable: Boolean,
        iconPack: String,
        inline: Boolean,
        openOnFocus: Boolean,
        position: String,
        mobileNative: {
          type: Boolean,
          default: true
        },
        minDatetime: Date,
        maxDatetime: Date,
        datetimeFormatter: {
          type: Function
        },
        datetimeParser: {
          type: Function
        },
        datetimeCreator: {
          type: Function,
          default: function _default(date) {
            if (typeof config$2.defaultDatetimeCreator === 'function') {
              return config$2.defaultDatetimeCreator(date);
            } else {
              return date;
            }
          }
        },
        datepicker: Object,
        timepicker: Object,
        tzOffset: {
          type: Number,
          default: 0
        },
        focusable: {
          type: Boolean,
          default: true
        },
        appendToBody: Boolean
      },
      data: function data() {
        return {
          newValue: this.adjustValue(this.value)
        };
      },
      computed: {
        computedValue: {
          get: function get() {
            return this.newValue;
          },
          set: function set(value) {
            if (value) {
              var val = new Date(value.getTime());

              if (this.newValue) {
                // restore time part
                if ((value.getDate() !== this.newValue.getDate() || value.getMonth() !== this.newValue.getMonth() || value.getFullYear() !== this.newValue.getFullYear()) && value.getHours() === 0 && value.getMinutes() === 0 && value.getSeconds() === 0) {
                  val.setHours(this.newValue.getHours(), this.newValue.getMinutes(), this.newValue.getSeconds(), 0);
                }
              } else {
                val = this.datetimeCreator(value);
              } // check min and max range


              if (this.minDatetime && val < this.adjustValue(this.minDatetime)) {
                val = this.adjustValue(this.minDatetime);
              } else if (this.maxDatetime && val > this.adjustValue(this.maxDatetime)) {
                val = this.adjustValue(this.maxDatetime);
              }

              this.newValue = new Date(val.getTime());
            } else {
              this.newValue = this.adjustValue(value);
            }

            var adjustedValue = this.adjustValue(this.newValue, true); // reverse adjust

            this.$emit('input', adjustedValue);
          }
        },
        localeOptions: function localeOptions() {
          return new Intl.DateTimeFormat(this.locale, {
            year: 'numeric',
            month: 'numeric',
            day: 'numeric',
            hour: 'numeric',
            minute: 'numeric',
            second: this.enableSeconds() ? 'numeric' : undefined
          }).resolvedOptions();
        },
        dtf: function dtf() {
          return new Intl.DateTimeFormat(this.locale, {
            year: this.localeOptions.year || 'numeric',
            month: this.localeOptions.month || 'numeric',
            day: this.localeOptions.day || 'numeric',
            hour: this.localeOptions.hour || 'numeric',
            minute: this.localeOptions.minute || 'numeric',
            second: this.enableSeconds() ? this.localeOptions.second || 'numeric' : undefined,
            hourCycle: !this.isHourFormat24() ? 'h12' : 'h23'
          });
        },
        isMobileNative: function isMobileNative() {
          return this.mobileNative && this.tzOffset === 0;
        },
        isMobile: function isMobile$1() {
          return this.isMobileNative && isMobile.any();
        },
        minDate: function minDate() {
          if (!this.minDatetime) {
            return this.datepicker ? this.adjustValue(this.datepicker.minDate) : null;
          }

          var adjMinDatetime = this.adjustValue(this.minDatetime);
          return new Date(adjMinDatetime.getFullYear(), adjMinDatetime.getMonth(), adjMinDatetime.getDate(), 0, 0, 0, 0);
        },
        maxDate: function maxDate() {
          if (!this.maxDatetime) {
            return this.datepicker ? this.adjustValue(this.datepicker.maxDate) : null;
          }

          var adjMaxDatetime = this.adjustValue(this.maxDatetime);
          return new Date(adjMaxDatetime.getFullYear(), adjMaxDatetime.getMonth(), adjMaxDatetime.getDate(), 0, 0, 0, 0);
        },
        minTime: function minTime() {
          if (!this.minDatetime || this.newValue === null || typeof this.newValue === 'undefined') {
            return this.timepicker ? this.adjustValue(this.timepicker.minTime) : null;
          }

          var adjMinDatetime = this.adjustValue(this.minDatetime);

          if (adjMinDatetime.getFullYear() === this.newValue.getFullYear() && adjMinDatetime.getMonth() === this.newValue.getMonth() && adjMinDatetime.getDate() === this.newValue.getDate()) {
            return adjMinDatetime;
          }
        },
        maxTime: function maxTime() {
          if (!this.maxDatetime || this.newValue === null || typeof this.newValue === 'undefined') {
            return this.timepicker ? this.adjustValue(this.timepicker.maxTime) : null;
          }

          var adjMaxDatetime = this.adjustValue(this.maxDatetime);

          if (adjMaxDatetime.getFullYear() === this.newValue.getFullYear() && adjMaxDatetime.getMonth() === this.newValue.getMonth() && adjMaxDatetime.getDate() === this.newValue.getDate()) {
            return adjMaxDatetime;
          }
        },
        datepickerSize: function datepickerSize() {
          return this.datepicker && this.datepicker.size ? this.datepicker.size : this.size;
        },
        timepickerSize: function timepickerSize() {
          return this.timepicker && this.timepicker.size ? this.timepicker.size : this.size;
        },
        timepickerDisabled: function timepickerDisabled() {
          return this.timepicker && this.timepicker.disabled ? this.timepicker.disabled : this.disabled;
        }
      },
      watch: {
        value: function value() {
          this.newValue = this.adjustValue(this.value);
        },
        tzOffset: function tzOffset() {
          this.newValue = this.adjustValue(this.value);
        }
      },
      methods: {
        enableSeconds: function enableSeconds() {
          if (this.$refs.timepicker) {
            return this.$refs.timepicker.enableSeconds;
          }

          return false;
        },
        isHourFormat24: function isHourFormat24() {
          if (this.$refs.timepicker) {
            return this.$refs.timepicker.isHourFormat24;
          }

          return !this.localeOptions.hour12;
        },
        adjustValue: function adjustValue(value) {
          var reverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          if (!value) return value;

          if (reverse) {
            return new Date(value.getTime() - this.tzOffset * 60000);
          } else {
            return new Date(value.getTime() + this.tzOffset * 60000);
          }
        },
        defaultDatetimeParser: function defaultDatetimeParser(date) {
          if (typeof this.datetimeParser === 'function') {
            return this.datetimeParser(date);
          } else if (typeof config$2.defaultDatetimeParser === 'function') {
            return config$2.defaultDatetimeParser(date);
          } else {
            if (this.dtf.formatToParts && typeof this.dtf.formatToParts === 'function') {
              var dayPeriods = [AM$1, PM$1, AM$1.toLowerCase(), PM$1.toLowerCase()];

              if (this.$refs.timepicker) {
                dayPeriods.push(this.$refs.timepicker.amString);
                dayPeriods.push(this.$refs.timepicker.pmString);
              }

              var parts = this.dtf.formatToParts(new Date());
              var formatRegex = parts.map(function (part, idx) {
                if (part.type === 'literal') {
                  if (idx + 1 < parts.length && parts[idx + 1].type === 'hour') {
                    return "[^\\d]+";
                  }

                  return part.value.replace(/ /g, '\\s?');
                } else if (part.type === 'dayPeriod') {
                  return "((?!=<".concat(part.type, ">)(").concat(dayPeriods.join('|'), ")?)");
                }

                return "((?!=<".concat(part.type, ">)\\d+)");
              }).join('');
              var datetimeGroups = matchWithGroups(formatRegex, date); // We do a simple validation for the group.
              // If it is not valid, it will fallback to Date.parse below

              if (datetimeGroups.year && datetimeGroups.year.length === 4 && datetimeGroups.month && datetimeGroups.month <= 12 && datetimeGroups.day && datetimeGroups.day <= 31 && datetimeGroups.hour && datetimeGroups.hour >= 0 && datetimeGroups.hour < 24 && datetimeGroups.minute && datetimeGroups.minute >= 0 && datetimeGroups.minute <= 59) {
                var d = new Date(datetimeGroups.year, datetimeGroups.month - 1, datetimeGroups.day, datetimeGroups.hour, datetimeGroups.minute, datetimeGroups.second || 0);
                return d;
              }
            }

            return new Date(Date.parse(date));
          }
        },
        defaultDatetimeFormatter: function defaultDatetimeFormatter(date) {
          if (typeof this.datetimeFormatter === 'function') {
            return this.datetimeFormatter(date);
          } else if (typeof config$2.defaultDatetimeFormatter === 'function') {
            return config$2.defaultDatetimeFormatter(date);
          } else {
            return this.dtf.format(date);
          }
        },

        /*
        * Parse date from string
        */
        onChangeNativePicker: function onChangeNativePicker(event) {
          var date = event.target.value;
          var s = date ? date.split(/\D/) : [];

          if (s.length >= 5) {
            var year = parseInt(s[0], 10);
            var month = parseInt(s[1], 10) - 1;
            var day = parseInt(s[2], 10);
            var hours = parseInt(s[3], 10);
            var minutes = parseInt(s[4], 10); // Seconds are omitted intentionally; they are unsupported by input
            // type=datetime-local and cause the control to fail native validation

            this.computedValue = new Date(year, month, day, hours, minutes);
          } else {
            this.computedValue = null;
          }
        },

        /*
         * Emit 'active-change' on datepicker active state change
         */
        onActiveChange: function onActiveChange(value) {
          this.$emit('active-change', value);
        },
        formatNative: function formatNative(value) {
          var date = new Date(value);

          if (value && !isNaN(date)) {
            var year = date.getFullYear();
            var month = date.getMonth() + 1;
            var day = date.getDate();
            var hours = date.getHours();
            var minutes = date.getMinutes();
            var seconds = date.getSeconds();
            return year + '-' + ((month < 10 ? '0' : '') + month) + '-' + ((day < 10 ? '0' : '') + day) + 'T' + ((hours < 10 ? '0' : '') + hours) + ':' + ((minutes < 10 ? '0' : '') + minutes) + ':' + ((seconds < 10 ? '0' : '') + seconds);
          }

          return '';
        },
        toggle: function toggle() {
          this.$refs.datepicker.toggle();
        }
      },
      mounted: function mounted() {
        if (!this.isMobile || this.inline) {
          // $refs attached, it's time to refresh datepicker (input)
          if (this.newValue) {
            this.$refs.datepicker.$forceUpdate();
          }
        }
      }
    };

    /* script */
    const __vue_script__$i = script$i;

    /* template */
    var __vue_render__$h = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return (!_vm.isMobile || _vm.inline)?_c('b-datepicker',_vm._b({ref:"datepicker",attrs:{"rounded":_vm.rounded,"open-on-focus":_vm.openOnFocus,"position":_vm.position,"loading":_vm.loading,"inline":_vm.inline,"editable":_vm.editable,"expanded":_vm.expanded,"close-on-click":false,"first-day-of-week":_vm.firstDayOfWeek,"rules-for-first-week":_vm.rulesForFirstWeek,"date-formatter":_vm.defaultDatetimeFormatter,"date-parser":_vm.defaultDatetimeParser,"min-date":_vm.minDate,"max-date":_vm.maxDate,"icon":_vm.icon,"icon-right":_vm.iconRight,"icon-right-clickable":_vm.iconRightClickable,"icon-pack":_vm.iconPack,"size":_vm.datepickerSize,"placeholder":_vm.placeholder,"horizontal-time-picker":_vm.horizontalTimePicker,"range":false,"disabled":_vm.disabled,"mobile-native":_vm.isMobileNative,"locale":_vm.locale,"focusable":_vm.focusable,"append-to-body":_vm.appendToBody},on:{"focus":_vm.onFocus,"blur":_vm.onBlur,"active-change":_vm.onActiveChange,"icon-right-click":function($event){return _vm.$emit('icon-right-click')},"change-month":function($event){return _vm.$emit('change-month', $event)},"change-year":function($event){return _vm.$emit('change-year', $event)}},model:{value:(_vm.computedValue),callback:function ($$v) {_vm.computedValue=$$v;},expression:"computedValue"}},'b-datepicker',_vm.datepicker,false),[_c('nav',{staticClass:"level is-mobile"},[(_vm.$slots.left !== undefined)?_c('div',{staticClass:"level-item has-text-centered"},[_vm._t("left")],2):_vm._e(),_c('div',{staticClass:"level-item has-text-centered"},[_c('b-timepicker',_vm._b({ref:"timepicker",attrs:{"inline":"","editable":_vm.editable,"min-time":_vm.minTime,"max-time":_vm.maxTime,"size":_vm.timepickerSize,"disabled":_vm.timepickerDisabled,"focusable":_vm.focusable,"mobile-native":_vm.isMobileNative,"locale":_vm.locale},model:{value:(_vm.computedValue),callback:function ($$v) {_vm.computedValue=$$v;},expression:"computedValue"}},'b-timepicker',_vm.timepicker,false))],1),(_vm.$slots.right !== undefined)?_c('div',{staticClass:"level-item has-text-centered"},[_vm._t("right")],2):_vm._e()])]):_c('b-input',_vm._b({ref:"input",attrs:{"type":"datetime-local","autocomplete":"off","value":_vm.formatNative(_vm.computedValue),"placeholder":_vm.placeholder,"size":_vm.size,"icon":_vm.icon,"icon-pack":_vm.iconPack,"rounded":_vm.rounded,"loading":_vm.loading,"max":_vm.formatNative(_vm.maxDate),"min":_vm.formatNative(_vm.minDate),"disabled":_vm.disabled,"readonly":false,"use-html5-validation":_vm.useHtml5Validation},on:{"focus":_vm.onFocus,"blur":_vm.onBlur},nativeOn:{"change":function($event){return _vm.onChangeNativePicker($event)}}},'b-input',_vm.$attrs,false))};
    var __vue_staticRenderFns__$h = [];

      /* style */
      const __vue_inject_styles__$i = undefined;
      /* scoped */
      const __vue_scope_id__$i = undefined;
      /* module identifier */
      const __vue_module_identifier__$i = undefined;
      /* functional template */
      const __vue_is_functional_template__$i = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var Datetimepicker = normalizeComponent_1(
        { render: __vue_render__$h, staticRenderFns: __vue_staticRenderFns__$h },
        __vue_inject_styles__$i,
        __vue_script__$i,
        __vue_scope_id__$i,
        __vue_is_functional_template__$i,
        __vue_module_identifier__$i,
        undefined,
        undefined
      );

    var Plugin$9 = {
      install: function install(Vue) {
        registerComponent(Vue, Datetimepicker);
      }
    };
    use(Plugin$9);

    //
    var script$j = {
      name: 'BModal',
      directives: {
        trapFocus: directive$1
      },
      // deprecated, to replace with default 'value' in the next breaking change
      model: {
        prop: 'active',
        event: 'update:active'
      },
      props: {
        active: Boolean,
        component: [Object, Function, String],
        content: [String, Array],
        programmatic: Boolean,
        props: Object,
        events: Object,
        width: {
          type: [String, Number],
          default: 960
        },
        hasModalCard: Boolean,
        animation: {
          type: String,
          default: 'zoom-out'
        },
        canCancel: {
          type: [Array, Boolean],
          default: function _default() {
            return config$2.defaultModalCanCancel;
          }
        },
        onCancel: {
          type: Function,
          default: function _default() {}
        },
        scroll: {
          type: String,
          default: function _default() {
            return config$2.defaultModalScroll ? config$2.defaultModalScroll : 'clip';
          },
          validator: function validator(value) {
            return ['clip', 'keep'].indexOf(value) >= 0;
          }
        },
        fullScreen: Boolean,
        trapFocus: {
          type: Boolean,
          default: function _default() {
            return config$2.defaultTrapFocus;
          }
        },
        autoFocus: {
          type: Boolean,
          default: function _default() {
            return config$2.defaultAutoFocus;
          }
        },
        customClass: String,
        ariaRole: {
          type: String,
          validator: function validator(value) {
            return ['dialog', 'alertdialog'].indexOf(value) >= 0;
          }
        },
        ariaModal: Boolean,
        ariaLabel: {
          type: String,
          validator: function validator(value) {
            return Boolean(value);
          }
        },
        closeButtonAriaLabel: String,
        destroyOnHide: {
          type: Boolean,
          default: true
        }
      },
      data: function data() {
        return {
          isActive: this.active || false,
          savedScrollTop: null,
          newWidth: typeof this.width === 'number' ? this.width + 'px' : this.width,
          animating: !this.active,
          destroyed: !this.active
        };
      },
      computed: {
        cancelOptions: function cancelOptions() {
          return typeof this.canCancel === 'boolean' ? this.canCancel ? config$2.defaultModalCanCancel : [] : this.canCancel;
        },
        showX: function showX() {
          return this.cancelOptions.indexOf('x') >= 0;
        },
        customStyle: function customStyle() {
          if (!this.fullScreen) {
            return {
              maxWidth: this.newWidth
            };
          }

          return null;
        }
      },
      watch: {
        active: function active(value) {
          this.isActive = value;
        },
        isActive: function isActive(value) {
          var _this = this;

          if (value) this.destroyed = false;
          this.handleScroll();
          this.$nextTick(function () {
            if (value && _this.$el && _this.$el.focus && _this.autoFocus) {
              _this.$el.focus();
            }
          });
        }
      },
      methods: {
        handleScroll: function handleScroll() {
          if (typeof window === 'undefined') return;

          if (this.scroll === 'clip') {
            if (this.isActive) {
              document.documentElement.classList.add('is-clipped');
            } else {
              document.documentElement.classList.remove('is-clipped');
            }

            return;
          }

          this.savedScrollTop = !this.savedScrollTop ? document.documentElement.scrollTop : this.savedScrollTop;

          if (this.isActive) {
            document.body.classList.add('is-noscroll');
          } else {
            document.body.classList.remove('is-noscroll');
          }

          if (this.isActive) {
            document.body.style.top = "-".concat(this.savedScrollTop, "px");
            return;
          }

          document.documentElement.scrollTop = this.savedScrollTop;
          document.body.style.top = null;
          this.savedScrollTop = null;
        },

        /**
        * Close the Modal if canCancel and call the onCancel prop (function).
        */
        cancel: function cancel(method) {
          if (this.cancelOptions.indexOf(method) < 0) return;
          this.$emit('cancel', arguments);
          this.onCancel.apply(null, arguments);
          this.close();
        },

        /**
        * Call the onCancel prop (function).
        * Emit events, and destroy modal if it's programmatic.
        */
        close: function close() {
          var _this2 = this;

          this.$emit('close');
          this.$emit('update:active', false); // Timeout for the animation complete before destroying

          if (this.programmatic) {
            this.isActive = false;
            setTimeout(function () {
              _this2.$destroy();

              removeElement(_this2.$el);
            }, 150);
          }
        },

        /**
        * Keypress event that is bound to the document.
        */
        keyPress: function keyPress(_ref) {
          var key = _ref.key;
          if (this.isActive && (key === 'Escape' || key === 'Esc')) this.cancel('escape');
        },

        /**
        * Transition after-enter hook
        */
        afterEnter: function afterEnter() {
          this.animating = false;
          this.$emit('after-enter');
        },

        /**
        * Transition before-leave hook
        */
        beforeLeave: function beforeLeave() {
          this.animating = true;
        },

        /**
        * Transition after-leave hook
        */
        afterLeave: function afterLeave() {
          if (this.destroyOnHide) {
            this.destroyed = true;
          }

          this.$emit('after-leave');
        }
      },
      created: function created() {
        if (typeof window !== 'undefined') {
          document.addEventListener('keyup', this.keyPress);
        }
      },
      beforeMount: function beforeMount() {
        // Insert the Modal component in body tag
        // only if it's programmatic
        this.programmatic && document.body.appendChild(this.$el);
      },
      mounted: function mounted() {
        if (this.programmatic) this.isActive = true;else if (this.isActive) this.handleScroll();
      },
      beforeDestroy: function beforeDestroy() {
        if (typeof window !== 'undefined') {
          document.removeEventListener('keyup', this.keyPress); // reset scroll

          document.documentElement.classList.remove('is-clipped');
          var savedScrollTop = !this.savedScrollTop ? document.documentElement.scrollTop : this.savedScrollTop;
          document.body.classList.remove('is-noscroll');
          document.documentElement.scrollTop = savedScrollTop;
          document.body.style.top = null;
        }
      }
    };

    /* script */
    const __vue_script__$j = script$j;

    /* template */
    var __vue_render__$i = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":_vm.animation},on:{"after-enter":_vm.afterEnter,"before-leave":_vm.beforeLeave,"after-leave":_vm.afterLeave}},[(!_vm.destroyed)?_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.isActive),expression:"isActive"},{name:"trap-focus",rawName:"v-trap-focus",value:(_vm.trapFocus),expression:"trapFocus"}],staticClass:"modal is-active",class:[{'is-full-screen': _vm.fullScreen}, _vm.customClass],attrs:{"tabindex":"-1","role":_vm.ariaRole,"aria-label":_vm.ariaLabel,"aria-modal":_vm.ariaModal}},[_c('div',{staticClass:"modal-background",on:{"click":function($event){return _vm.cancel('outside')}}}),_c('div',{staticClass:"animation-content",class:{ 'modal-content': !_vm.hasModalCard },style:(_vm.customStyle)},[(_vm.component)?_c(_vm.component,_vm._g(_vm._b({tag:"component",attrs:{"can-cancel":_vm.canCancel},on:{"close":_vm.close}},'component',_vm.props,false),_vm.events)):(_vm.content)?[_c('div',{domProps:{"innerHTML":_vm._s(_vm.content)}})]:_vm._t("default",null,{"canCancel":_vm.canCancel,"close":_vm.close}),(_vm.showX)?_c('button',{directives:[{name:"show",rawName:"v-show",value:(!_vm.animating),expression:"!animating"}],staticClass:"modal-close is-large",attrs:{"type":"button","aria-label":_vm.closeButtonAriaLabel},on:{"click":function($event){return _vm.cancel('x')}}}):_vm._e()],2)]):_vm._e()])};
    var __vue_staticRenderFns__$i = [];

      /* style */
      const __vue_inject_styles__$j = undefined;
      /* scoped */
      const __vue_scope_id__$j = undefined;
      /* module identifier */
      const __vue_module_identifier__$j = undefined;
      /* functional template */
      const __vue_is_functional_template__$j = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var Modal = normalizeComponent_1(
        { render: __vue_render__$i, staticRenderFns: __vue_staticRenderFns__$i },
        __vue_inject_styles__$j,
        __vue_script__$j,
        __vue_scope_id__$j,
        __vue_is_functional_template__$j,
        __vue_module_identifier__$j,
        undefined,
        undefined
      );

    var _components$6;
    var script$k = {
      name: 'BDialog',
      components: (_components$6 = {}, _defineProperty(_components$6, Icon.name, Icon), _defineProperty(_components$6, Button.name, Button), _components$6),
      directives: {
        trapFocus: directive$1
      },
      extends: Modal,
      props: {
        title: String,
        message: [String, Array],
        icon: String,
        iconPack: String,
        hasIcon: Boolean,
        type: {
          type: String,
          default: 'is-primary'
        },
        size: String,
        confirmText: {
          type: String,
          default: function _default() {
            return config$2.defaultDialogConfirmText ? config$2.defaultDialogConfirmText : 'OK';
          }
        },
        cancelText: {
          type: String,
          default: function _default() {
            return config$2.defaultDialogCancelText ? config$2.defaultDialogCancelText : 'Cancel';
          }
        },
        hasInput: Boolean,
        // Used internally to know if it's prompt
        inputAttrs: {
          type: Object,
          default: function _default() {
            return {};
          }
        },
        onConfirm: {
          type: Function,
          default: function _default() {}
        },
        closeOnConfirm: {
          type: Boolean,
          default: true
        },
        container: {
          type: String,
          default: function _default() {
            return config$2.defaultContainerElement;
          }
        },
        focusOn: {
          type: String,
          default: 'confirm'
        },
        trapFocus: {
          type: Boolean,
          default: function _default() {
            return config$2.defaultTrapFocus;
          }
        },
        ariaRole: {
          type: String,
          validator: function validator(value) {
            return ['dialog', 'alertdialog'].indexOf(value) >= 0;
          }
        },
        ariaModal: Boolean
      },
      data: function data() {
        var prompt = this.hasInput ? this.inputAttrs.value || '' : '';
        return {
          prompt: prompt,
          isActive: false,
          validationMessage: '',
          isCompositing: false
        };
      },
      computed: {
        dialogClass: function dialogClass() {
          return [this.size, {
            'has-custom-container': this.container !== null
          }];
        },

        /**
        * Icon name (MDI) based on the type.
        */
        iconByType: function iconByType() {
          switch (this.type) {
            case 'is-info':
              return 'information';

            case 'is-success':
              return 'check-circle';

            case 'is-warning':
              return 'alert';

            case 'is-danger':
              return 'alert-circle';

            default:
              return null;
          }
        },
        showCancel: function showCancel() {
          return this.cancelOptions.indexOf('button') >= 0;
        }
      },
      methods: {
        /**
        * If it's a prompt Dialog, validate the input.
        * Call the onConfirm prop (function) and close the Dialog.
        */
        confirm: function confirm() {
          var _this = this;

          if (this.$refs.input !== undefined) {
            if (this.isCompositing) return;

            if (!this.$refs.input.checkValidity()) {
              this.validationMessage = this.$refs.input.validationMessage;
              this.$nextTick(function () {
                return _this.$refs.input.select();
              });
              return;
            }
          }

          this.$emit('confirm', this.prompt);
          this.onConfirm(this.prompt, this);
          if (this.closeOnConfirm) this.close();
        },

        /**
        * Close the Dialog.
        */
        close: function close() {
          var _this2 = this;

          this.isActive = false; // Timeout for the animation complete before destroying

          setTimeout(function () {
            _this2.$destroy();

            removeElement(_this2.$el);
          }, 150);
        }
      },
      beforeMount: function beforeMount() {
        var _this3 = this;

        // Insert the Dialog component in the element container
        if (typeof window !== 'undefined') {
          this.$nextTick(function () {
            var container = document.querySelector(_this3.container) || document.body;
            container.appendChild(_this3.$el);
          });
        }
      },
      mounted: function mounted() {
        var _this4 = this;

        this.isActive = true;

        if (typeof this.inputAttrs.required === 'undefined') {
          this.$set(this.inputAttrs, 'required', true);
        }

        this.$nextTick(function () {
          // Handle which element receives focus
          if (_this4.hasInput) {
            _this4.$refs.input.focus();
          } else if (_this4.focusOn === 'cancel' && _this4.showCancel) {
            _this4.$refs.cancelButton.$el.focus();
          } else {
            _this4.$refs.confirmButton.$el.focus();
          }
        });
      }
    };

    /* script */
    const __vue_script__$k = script$k;

    /* template */
    var __vue_render__$j = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":_vm.animation}},[(_vm.isActive)?_c('div',{directives:[{name:"trap-focus",rawName:"v-trap-focus",value:(_vm.trapFocus),expression:"trapFocus"}],staticClass:"dialog modal is-active",class:_vm.dialogClass,attrs:{"role":_vm.ariaRole,"aria-modal":_vm.ariaModal}},[_c('div',{staticClass:"modal-background",on:{"click":function($event){return _vm.cancel('outside')}}}),_c('div',{staticClass:"modal-card animation-content"},[(_vm.title)?_c('header',{staticClass:"modal-card-head"},[_c('p',{staticClass:"modal-card-title"},[_vm._v(_vm._s(_vm.title))])]):_vm._e(),_c('section',{staticClass:"modal-card-body",class:{ 'is-titleless': !_vm.title, 'is-flex': _vm.hasIcon }},[_c('div',{staticClass:"media"},[(_vm.hasIcon && (_vm.icon || _vm.iconByType))?_c('div',{staticClass:"media-left"},[_c('b-icon',{attrs:{"icon":_vm.icon ? _vm.icon : _vm.iconByType,"pack":_vm.iconPack,"type":_vm.type,"both":!_vm.icon,"size":"is-large"}})],1):_vm._e(),_c('div',{staticClass:"media-content"},[_c('p',[(_vm.$slots.default)?[_vm._t("default")]:[_c('div',{domProps:{"innerHTML":_vm._s(_vm.message)}})]],2),(_vm.hasInput)?_c('div',{staticClass:"field"},[_c('div',{staticClass:"control"},[(((_vm.inputAttrs).type)==='checkbox')?_c('input',_vm._b({directives:[{name:"model",rawName:"v-model",value:(_vm.prompt),expression:"prompt"}],ref:"input",staticClass:"input",class:{ 'is-danger': _vm.validationMessage },attrs:{"type":"checkbox"},domProps:{"checked":Array.isArray(_vm.prompt)?_vm._i(_vm.prompt,null)>-1:(_vm.prompt)},on:{"compositionstart":function($event){_vm.isCompositing = true;},"compositionend":function($event){_vm.isCompositing = false;},"keydown":function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"enter",13,$event.key,"Enter")){ return null; }return _vm.confirm($event)},"change":function($event){var $$a=_vm.prompt,$$el=$event.target,$$c=$$el.checked?(true):(false);if(Array.isArray($$a)){var $$v=null,$$i=_vm._i($$a,$$v);if($$el.checked){$$i<0&&(_vm.prompt=$$a.concat([$$v]));}else {$$i>-1&&(_vm.prompt=$$a.slice(0,$$i).concat($$a.slice($$i+1)));}}else {_vm.prompt=$$c;}}}},'input',_vm.inputAttrs,false)):(((_vm.inputAttrs).type)==='radio')?_c('input',_vm._b({directives:[{name:"model",rawName:"v-model",value:(_vm.prompt),expression:"prompt"}],ref:"input",staticClass:"input",class:{ 'is-danger': _vm.validationMessage },attrs:{"type":"radio"},domProps:{"checked":_vm._q(_vm.prompt,null)},on:{"compositionstart":function($event){_vm.isCompositing = true;},"compositionend":function($event){_vm.isCompositing = false;},"keydown":function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"enter",13,$event.key,"Enter")){ return null; }return _vm.confirm($event)},"change":function($event){_vm.prompt=null;}}},'input',_vm.inputAttrs,false)):_c('input',_vm._b({directives:[{name:"model",rawName:"v-model",value:(_vm.prompt),expression:"prompt"}],ref:"input",staticClass:"input",class:{ 'is-danger': _vm.validationMessage },attrs:{"type":(_vm.inputAttrs).type},domProps:{"value":(_vm.prompt)},on:{"compositionstart":function($event){_vm.isCompositing = true;},"compositionend":function($event){_vm.isCompositing = false;},"keydown":function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"enter",13,$event.key,"Enter")){ return null; }return _vm.confirm($event)},"input":function($event){if($event.target.composing){ return; }_vm.prompt=$event.target.value;}}},'input',_vm.inputAttrs,false))]),_c('p',{staticClass:"help is-danger"},[_vm._v(_vm._s(_vm.validationMessage))])]):_vm._e()])])]),_c('footer',{staticClass:"modal-card-foot"},[(_vm.showCancel)?_c('b-button',{ref:"cancelButton",on:{"click":function($event){return _vm.cancel('button')}}},[_vm._v(_vm._s(_vm.cancelText))]):_vm._e(),_c('b-button',{ref:"confirmButton",attrs:{"type":_vm.type},on:{"click":_vm.confirm}},[_vm._v(_vm._s(_vm.confirmText))])],1)])]):_vm._e()])};
    var __vue_staticRenderFns__$j = [];

      /* style */
      const __vue_inject_styles__$k = undefined;
      /* scoped */
      const __vue_scope_id__$k = undefined;
      /* module identifier */
      const __vue_module_identifier__$k = undefined;
      /* functional template */
      const __vue_is_functional_template__$k = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var Dialog = normalizeComponent_1(
        { render: __vue_render__$j, staticRenderFns: __vue_staticRenderFns__$j },
        __vue_inject_styles__$k,
        __vue_script__$k,
        __vue_scope_id__$k,
        __vue_is_functional_template__$k,
        __vue_module_identifier__$k,
        undefined,
        undefined
      );

    var localVueInstance;

    function open(propsData) {
      var slot;

      if (Array.isArray(propsData.message)) {
        slot = propsData.message;
        delete propsData.message;
      }

      var vm = typeof window !== 'undefined' && window.Vue ? window.Vue : localVueInstance || VueInstance;
      var DialogComponent = vm.extend(Dialog);
      var component = new DialogComponent({
        el: document.createElement('div'),
        propsData: propsData
      });

      if (slot) {
        component.$slots.default = slot;
        component.$forceUpdate();
      }

      if (!config$2.defaultProgrammaticPromise) {
        return component;
      } else {
        return new Promise(function (resolve) {
          component.$on('confirm', function (event) {
            return resolve({
              result: event || true,
              dialog: component
            });
          });
          component.$on('cancel', function () {
            return resolve({
              result: false,
              dialog: component
            });
          });
        });
      }
    }

    var DialogProgrammatic = {
      alert: function alert(params) {
        if (typeof params === 'string') {
          params = {
            message: params
          };
        }

        var defaultParam = {
          canCancel: false
        };
        var propsData = merge$1(defaultParam, params);
        return open(propsData);
      },
      confirm: function confirm(params) {
        var defaultParam = {};
        var propsData = merge$1(defaultParam, params);
        return open(propsData);
      },
      prompt: function prompt(params) {
        var defaultParam = {
          hasInput: true
        };
        var propsData = merge$1(defaultParam, params);
        return open(propsData);
      }
    };
    var Plugin$a = {
      install: function install(Vue) {
        localVueInstance = Vue;
        registerComponent(Vue, Dialog);
        registerComponentProgrammatic(Vue, 'dialog', DialogProgrammatic);
      }
    };
    use(Plugin$a);

    var Plugin$b = {
      install: function install(Vue) {
        registerComponent(Vue, Dropdown);
        registerComponent(Vue, DropdownItem);
      }
    };
    use(Plugin$b);

    var Plugin$c = {
      install: function install(Vue) {
        registerComponent(Vue, Field);
      }
    };
    use(Plugin$c);

    var Plugin$d = {
      install: function install(Vue) {
        registerComponent(Vue, Icon);
      }
    };
    use(Plugin$d);

    var Plugin$e = {
      install: function install(Vue) {
        registerComponent(Vue, Image$1);
      }
    };
    use(Plugin$e);

    var Plugin$f = {
      install: function install(Vue) {
        registerComponent(Vue, Input);
      }
    };
    use(Plugin$f);

    // Polyfills for SSR
    var isSSR = typeof window === 'undefined';
    var HTMLElement = isSSR ? Object : window.HTMLElement;
    var File$1 = isSSR ? Object : window.File;

    //
    var script$l = {
      name: 'BLoading',
      // deprecated, to replace with default 'value' in the next breaking change
      model: {
        prop: 'active',
        event: 'update:active'
      },
      props: {
        active: Boolean,
        programmatic: Boolean,
        container: [Object, Function, HTMLElement],
        isFullPage: {
          type: Boolean,
          default: true
        },
        animation: {
          type: String,
          default: 'fade'
        },
        canCancel: {
          type: Boolean,
          default: false
        },
        onCancel: {
          type: Function,
          default: function _default() {}
        }
      },
      data: function data() {
        return {
          isActive: this.active || false,
          displayInFullPage: this.isFullPage
        };
      },
      watch: {
        active: function active(value) {
          this.isActive = value;
        },
        isFullPage: function isFullPage(value) {
          this.displayInFullPage = value;
        }
      },
      methods: {
        /**
        * Close the Modal if canCancel.
        */
        cancel: function cancel() {
          if (!this.canCancel || !this.isActive) return;
          this.close();
        },

        /**
        * Emit events, and destroy modal if it's programmatic.
        */
        close: function close() {
          var _this = this;

          this.onCancel.apply(null, arguments);
          this.$emit('close');
          this.$emit('update:active', false); // Timeout for the animation complete before destroying

          if (this.programmatic) {
            this.isActive = false;
            setTimeout(function () {
              _this.$destroy();

              removeElement(_this.$el);
            }, 150);
          }
        },

        /**
        * Keypress event that is bound to the document.
        */
        keyPress: function keyPress(_ref) {
          var key = _ref.key;
          if (key === 'Escape' || key === 'Esc') this.cancel();
        }
      },
      created: function created() {
        if (typeof window !== 'undefined') {
          document.addEventListener('keyup', this.keyPress);
        }
      },
      beforeMount: function beforeMount() {
        // Insert the Loading component in body tag
        // only if it's programmatic
        if (this.programmatic) {
          if (!this.container) {
            document.body.appendChild(this.$el);
          } else {
            this.displayInFullPage = false;
            this.$emit('update:is-full-page', false);
            this.container.appendChild(this.$el);
          }
        }
      },
      mounted: function mounted() {
        if (this.programmatic) this.isActive = true;
      },
      beforeDestroy: function beforeDestroy() {
        if (typeof window !== 'undefined') {
          document.removeEventListener('keyup', this.keyPress);
        }
      }
    };

    /* script */
    const __vue_script__$l = script$l;

    /* template */
    var __vue_render__$k = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":_vm.animation}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.isActive),expression:"isActive"}],staticClass:"loading-overlay is-active",class:{ 'is-full-page': _vm.displayInFullPage }},[_c('div',{staticClass:"loading-background",on:{"click":_vm.cancel}}),_vm._t("default",[_c('div',{staticClass:"loading-icon"})])],2)])};
    var __vue_staticRenderFns__$k = [];

      /* style */
      const __vue_inject_styles__$l = undefined;
      /* scoped */
      const __vue_scope_id__$l = undefined;
      /* module identifier */
      const __vue_module_identifier__$l = undefined;
      /* functional template */
      const __vue_is_functional_template__$l = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var Loading = normalizeComponent_1(
        { render: __vue_render__$k, staticRenderFns: __vue_staticRenderFns__$k },
        __vue_inject_styles__$l,
        __vue_script__$l,
        __vue_scope_id__$l,
        __vue_is_functional_template__$l,
        __vue_module_identifier__$l,
        undefined,
        undefined
      );

    var localVueInstance$1;
    var LoadingProgrammatic = {
      open: function open(params) {
        var defaultParam = {
          programmatic: true
        };
        var propsData = merge$1(defaultParam, params);
        var vm = typeof window !== 'undefined' && window.Vue ? window.Vue : localVueInstance$1 || VueInstance;
        var LoadingComponent = vm.extend(Loading);
        return new LoadingComponent({
          el: document.createElement('div'),
          propsData: propsData
        });
      }
    };
    var Plugin$g = {
      install: function install(Vue) {
        localVueInstance$1 = Vue;
        registerComponent(Vue, Loading);
        registerComponentProgrammatic(Vue, 'loading', LoadingProgrammatic);
      }
    };
    use(Plugin$g);

    //
    //
    //
    //
    //
    //
    var script$m = {
      name: 'BMenu',
      props: {
        accordion: {
          type: Boolean,
          default: true
        },
        activable: {
          type: Boolean,
          default: true
        }
      },
      data: function data() {
        return {
          _isMenu: true // Used by MenuItem

        };
      }
    };

    /* script */
    const __vue_script__$m = script$m;

    /* template */
    var __vue_render__$l = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"menu"},[_vm._t("default")],2)};
    var __vue_staticRenderFns__$l = [];

      /* style */
      const __vue_inject_styles__$m = undefined;
      /* scoped */
      const __vue_scope_id__$m = undefined;
      /* module identifier */
      const __vue_module_identifier__$m = undefined;
      /* functional template */
      const __vue_is_functional_template__$m = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var Menu = normalizeComponent_1(
        { render: __vue_render__$l, staticRenderFns: __vue_staticRenderFns__$l },
        __vue_inject_styles__$m,
        __vue_script__$m,
        __vue_scope_id__$m,
        __vue_is_functional_template__$m,
        __vue_module_identifier__$m,
        undefined,
        undefined
      );

    var script$1$8 = {
      name: 'BMenuList',
      functional: true,
      props: {
        label: String,
        icon: String,
        iconPack: String,
        ariaRole: {
          type: String,
          default: ''
        },
        size: {
          type: String,
          default: 'is-small'
        }
      },
      render: function render(createElement, context) {
        var vlabel = null;
        var slots = context.slots();

        if (context.props.label || slots.label) {
          vlabel = createElement('p', {
            attrs: {
              'class': 'menu-label'
            }
          }, context.props.label ? context.props.icon ? [createElement('b-icon', {
            props: {
              'icon': context.props.icon,
              'pack': context.props.iconPack,
              'size': context.props.size
            }
          }), createElement('span', {}, context.props.label)] : context.props.label : slots.label);
        }

        var vnode = createElement('ul', {
          attrs: {
            'class': 'menu-list',
            'role': context.props.ariaRole === 'menu' ? context.props.ariaRole : null
          }
        }, slots.default);
        return vlabel ? [vlabel, vnode] : vnode;
      }
    };

    /* script */
    const __vue_script__$1$8 = script$1$8;

    /* template */

      /* style */
      const __vue_inject_styles__$1$8 = undefined;
      /* scoped */
      const __vue_scope_id__$1$8 = undefined;
      /* module identifier */
      const __vue_module_identifier__$1$8 = undefined;
      /* functional template */
      const __vue_is_functional_template__$1$8 = undefined;
      /* style inject */
      
      /* style inject SSR */
      

      
      var MenuList = normalizeComponent_1(
        {},
        __vue_inject_styles__$1$8,
        __vue_script__$1$8,
        __vue_scope_id__$1$8,
        __vue_is_functional_template__$1$8,
        __vue_module_identifier__$1$8,
        undefined,
        undefined
      );

    var script$2$4 = {
      name: 'BMenuItem',
      components: _defineProperty({}, Icon.name, Icon),
      inheritAttrs: false,
      // deprecated, to replace with default 'value' in the next breaking change
      model: {
        prop: 'active',
        event: 'update:active'
      },
      props: {
        label: String,
        active: Boolean,
        expanded: Boolean,
        disabled: Boolean,
        iconPack: String,
        icon: String,
        animation: {
          type: String,
          default: 'slide'
        },
        tag: {
          type: String,
          default: 'a',
          validator: function validator(value) {
            return config$2.defaultLinkTags.indexOf(value) >= 0;
          }
        },
        ariaRole: {
          type: String,
          default: ''
        },
        size: {
          type: String,
          default: 'is-small'
        }
      },
      data: function data() {
        return {
          newActive: this.active,
          newExpanded: this.expanded
        };
      },
      computed: {
        ariaRoleMenu: function ariaRoleMenu() {
          return this.ariaRole === 'menuitem' ? this.ariaRole : null;
        }
      },
      watch: {
        active: function active(value) {
          this.newActive = value;
        },
        expanded: function expanded(value) {
          this.newExpanded = value;
        }
      },
      methods: {
        onClick: function onClick(event) {
          if (this.disabled) return;
          var menu = this.getMenu();
          this.reset(this.$parent, menu);
          this.newExpanded = this.$props.expanded || !this.newExpanded;
          this.$emit('update:expanded', this.newExpanded);

          if (menu && menu.activable) {
            this.newActive = true;
            this.$emit('update:active', this.newActive);
          }
        },
        reset: function reset(parent, menu) {
          var _this = this;

          var items = parent.$children.filter(function (c) {
            return c.name === _this.name;
          });
          items.forEach(function (item) {
            if (item !== _this) {
              _this.reset(item, menu);

              if (!parent.$data._isMenu || parent.$data._isMenu && parent.accordion) {
                item.newExpanded = false;
                item.$emit('update:expanded', item.newActive);
              }

              if (menu && menu.activable) {
                item.newActive = false;
                item.$emit('update:active', item.newActive);
              }
            }
          });
        },
        getMenu: function getMenu() {
          var parent = this.$parent;

          while (parent && !parent.$data._isMenu) {
            parent = parent.$parent;
          }

          return parent;
        }
      }
    };

    /* script */
    const __vue_script__$2$4 = script$2$4;

    /* template */
    var __vue_render__$1$7 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('li',{attrs:{"role":_vm.ariaRoleMenu}},[_c(_vm.tag,_vm._g(_vm._b({tag:"component",class:{
                'is-active': _vm.newActive,
                'is-expanded': _vm.newExpanded,
                'is-disabled': _vm.disabled,
                'icon-text': _vm.icon,
            },on:{"click":function($event){return _vm.onClick($event)}}},'component',_vm.$attrs,false),_vm.$listeners),[(_vm.icon)?_c('b-icon',{attrs:{"icon":_vm.icon,"pack":_vm.iconPack,"size":_vm.size}}):_vm._e(),(_vm.label)?_c('span',[_vm._v(" "+_vm._s(_vm.label)+" ")]):_vm._t("label",null,{"expanded":_vm.newExpanded,"active":_vm.newActive})],2),(_vm.$slots.default)?[_c('transition',{attrs:{"name":_vm.animation}},[_c('ul',{directives:[{name:"show",rawName:"v-show",value:(_vm.newExpanded),expression:"newExpanded"}]},[_vm._t("default")],2)])]:_vm._e()],2)};
    var __vue_staticRenderFns__$1$7 = [];

      /* style */
      const __vue_inject_styles__$2$4 = undefined;
      /* scoped */
      const __vue_scope_id__$2$4 = undefined;
      /* module identifier */
      const __vue_module_identifier__$2$4 = undefined;
      /* functional template */
      const __vue_is_functional_template__$2$4 = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var MenuItem = normalizeComponent_1(
        { render: __vue_render__$1$7, staticRenderFns: __vue_staticRenderFns__$1$7 },
        __vue_inject_styles__$2$4,
        __vue_script__$2$4,
        __vue_scope_id__$2$4,
        __vue_is_functional_template__$2$4,
        __vue_module_identifier__$2$4,
        undefined,
        undefined
      );

    var Plugin$h = {
      install: function install(Vue) {
        registerComponent(Vue, Menu);
        registerComponent(Vue, MenuList);
        registerComponent(Vue, MenuItem);
      }
    };
    use(Plugin$h);

    var MessageMixin = {
      components: _defineProperty({}, Icon.name, Icon),
      // deprecated, to replace with default 'value' in the next breaking change
      model: {
        prop: 'active',
        event: 'update:active'
      },
      props: {
        active: {
          type: Boolean,
          default: true
        },
        title: String,
        closable: {
          type: Boolean,
          default: true
        },
        message: String,
        type: String,
        hasIcon: Boolean,
        size: String,
        icon: String,
        iconPack: String,
        iconSize: String,
        autoClose: {
          type: Boolean,
          default: false
        },
        duration: {
          type: Number,
          default: 2000
        },
        progressBar: {
          type: Boolean,
          default: false
        }
      },
      data: function data() {
        return {
          isActive: this.active,
          remainingTime: this.duration / 1000,
          // in seconds
          newIconSize: this.iconSize || this.size || 'is-large'
        };
      },
      watch: {
        active: function active(value) {
          this.isActive = value;
        },
        isActive: function isActive(value) {
          if (value) {
            this.setAutoClose();
            this.setDurationProgress();
          } else {
            if (this.timer) {
              clearTimeout(this.timer);
            }
          }
        }
      },
      computed: {
        /**
         * Icon name (MDI) based on type.
         */
        computedIcon: function computedIcon() {
          if (this.icon) {
            return this.icon;
          }

          switch (this.type) {
            case 'is-info':
              return 'information';

            case 'is-success':
              return 'check-circle';

            case 'is-warning':
              return 'alert';

            case 'is-danger':
              return 'alert-circle';

            default:
              return null;
          }
        }
      },
      methods: {
        /**
         * Close the Message and emit events.
         */
        close: function close() {
          this.isActive = false;
          this.resetDurationProgress();
          this.$emit('close');
          this.$emit('update:active', false);
        },
        click: function click() {
          this.$emit('click');
        },

        /**
         * Set timer to auto close message
         */
        setAutoClose: function setAutoClose() {
          var _this = this;

          if (this.autoClose) {
            this.timer = setTimeout(function () {
              if (_this.isActive) {
                _this.close();
              }
            }, this.duration);
          }
        },
        setDurationProgress: function setDurationProgress() {
          var _this2 = this;

          if (this.progressBar) {
            /**
             * Runs every one second to set the duration passed before
             * the alert will auto close to show it in the progress bar (Remaining Time)
             */
            this.$buefy.globalNoticeInterval = setInterval(function () {
              if (_this2.remainingTime !== 0) {
                _this2.remainingTime -= 1;
              } else {
                _this2.resetDurationProgress();
              }
            }, 1000);
          }
        },
        resetDurationProgress: function resetDurationProgress() {
          var _this3 = this;

          /**
           * Wait until the component get closed and then reset
           **/
          setTimeout(function () {
            _this3.remainingTime = _this3.duration / 1000;
            clearInterval(_this3.$buefy.globalNoticeInterval);
          }, 100);
        }
      },
      mounted: function mounted() {
        this.setAutoClose();
      }
    };

    //
    var script$n = {
      name: 'BMessage',
      mixins: [MessageMixin],
      props: {
        ariaCloseLabel: String
      }
    };

    /* script */
    const __vue_script__$n = script$n;

    /* template */
    var __vue_render__$m = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":"fade"}},[_c('article',{directives:[{name:"show",rawName:"v-show",value:(_vm.isActive),expression:"isActive"}],staticClass:"message",class:[_vm.type, _vm.size]},[(_vm.$slots.header || _vm.title)?_c('header',{staticClass:"message-header"},[(_vm.$slots.header)?_c('div',[_vm._t("header")],2):(_vm.title)?_c('p',[_vm._v(_vm._s(_vm.title))]):_vm._e(),(_vm.closable)?_c('button',{staticClass:"delete",attrs:{"type":"button","aria-label":_vm.ariaCloseLabel},on:{"click":_vm.close}}):_vm._e()]):_vm._e(),(_vm.$slots.default)?_c('section',{staticClass:"message-body"},[_c('div',{staticClass:"media"},[(_vm.computedIcon && _vm.hasIcon)?_c('div',{staticClass:"media-left"},[_c('b-icon',{class:_vm.type,attrs:{"icon":_vm.computedIcon,"pack":_vm.iconPack,"both":"","size":_vm.newIconSize}})],1):_vm._e(),_c('div',{staticClass:"media-content"},[_vm._t("default")],2)])]):_vm._e(),(_vm.autoClose && _vm.progressBar)?_c('b-progress',{attrs:{"value":_vm.remainingTime - 1,"max":_vm.duration / 1000 - 1,"type":_vm.type,"rounded":false}}):_vm._e()],1)])};
    var __vue_staticRenderFns__$m = [];

      /* style */
      const __vue_inject_styles__$n = undefined;
      /* scoped */
      const __vue_scope_id__$n = undefined;
      /* module identifier */
      const __vue_module_identifier__$n = undefined;
      /* functional template */
      const __vue_is_functional_template__$n = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var Message = normalizeComponent_1(
        { render: __vue_render__$m, staticRenderFns: __vue_staticRenderFns__$m },
        __vue_inject_styles__$n,
        __vue_script__$n,
        __vue_scope_id__$n,
        __vue_is_functional_template__$n,
        __vue_module_identifier__$n,
        undefined,
        undefined
      );

    var Plugin$i = {
      install: function install(Vue) {
        registerComponent(Vue, Message);
      }
    };
    use(Plugin$i);

    var localVueInstance$2;
    var ModalProgrammatic = {
      open: function open(params) {
        var parent;

        if (typeof params === 'string') {
          params = {
            content: params
          };
        }

        var defaultParam = {
          programmatic: true
        };

        if (params.parent) {
          parent = params.parent;
          delete params.parent;
        }

        var slot;

        if (Array.isArray(params.content)) {
          slot = params.content;
          delete params.content;
        }

        var propsData = merge$1(defaultParam, params);
        var vm = typeof window !== 'undefined' && window.Vue ? window.Vue : localVueInstance$2 || VueInstance;
        var ModalComponent = vm.extend(Modal);
        var component = new ModalComponent({
          parent: parent,
          el: document.createElement('div'),
          propsData: propsData
        });

        if (slot) {
          component.$slots.default = slot;
          component.$forceUpdate();
        }

        return component;
      }
    };
    var Plugin$j = {
      install: function install(Vue) {
        localVueInstance$2 = Vue;
        registerComponent(Vue, Modal);
        registerComponentProgrammatic(Vue, 'modal', ModalProgrammatic);
      }
    };
    use(Plugin$j);

    var NoticeMixin = {
      props: {
        type: {
          type: String,
          default: 'is-dark'
        },
        message: [String, Array],
        duration: Number,
        queue: {
          type: Boolean,
          default: undefined
        },
        indefinite: {
          type: Boolean,
          default: false
        },
        pauseOnHover: {
          type: Boolean,
          default: false
        },
        position: {
          type: String,
          default: 'is-top',
          validator: function validator(value) {
            return ['is-top-right', 'is-top', 'is-top-left', 'is-bottom-right', 'is-bottom', 'is-bottom-left'].indexOf(value) > -1;
          }
        },
        container: String
      },
      data: function data() {
        return {
          isActive: false,
          isPaused: false,
          parentTop: null,
          parentBottom: null,
          newContainer: this.container || config$2.defaultContainerElement
        };
      },
      computed: {
        correctParent: function correctParent() {
          switch (this.position) {
            case 'is-top-right':
            case 'is-top':
            case 'is-top-left':
              return this.parentTop;

            case 'is-bottom-right':
            case 'is-bottom':
            case 'is-bottom-left':
              return this.parentBottom;
          }
        },
        transition: function transition() {
          switch (this.position) {
            case 'is-top-right':
            case 'is-top':
            case 'is-top-left':
              return {
                enter: 'fadeInDown',
                leave: 'fadeOut'
              };

            case 'is-bottom-right':
            case 'is-bottom':
            case 'is-bottom-left':
              return {
                enter: 'fadeInUp',
                leave: 'fadeOut'
              };
          }
        }
      },
      methods: {
        pause: function pause() {
          if (this.pauseOnHover && !this.indefinite) {
            this.isPaused = true;
            clearInterval(this.$buefy.globalNoticeInterval);
          }
        },
        removePause: function removePause() {
          if (this.pauseOnHover && !this.indefinite) {
            this.isPaused = false;
            this.close();
          }
        },
        shouldQueue: function shouldQueue() {
          var queue = this.queue !== undefined ? this.queue : config$2.defaultNoticeQueue;
          if (!queue) return false;
          return this.parentTop.childElementCount > 0 || this.parentBottom.childElementCount > 0;
        },
        click: function click() {
          this.$emit('click');
        },
        close: function close() {
          var _this = this;

          if (!this.isPaused) {
            clearTimeout(this.timer);
            this.isActive = false;
            this.$emit('close'); // Timeout for the animation complete before destroying

            setTimeout(function () {
              _this.$destroy();

              removeElement(_this.$el);
            }, 150);
          }
        },
        timeoutCallback: function timeoutCallback() {
          return this.close();
        },
        showNotice: function showNotice() {
          var _this2 = this;

          if (this.shouldQueue()) this.correctParent.innerHTML = '';
          this.correctParent.insertAdjacentElement('afterbegin', this.$el);
          this.isActive = true;

          if (!this.indefinite) {
            this.timer = setTimeout(function () {
              return _this2.timeoutCallback();
            }, this.newDuration);
          }
        },
        setupContainer: function setupContainer() {
          this.parentTop = document.querySelector((this.newContainer ? this.newContainer : 'body') + '>.notices.is-top');
          this.parentBottom = document.querySelector((this.newContainer ? this.newContainer : 'body') + '>.notices.is-bottom');
          if (this.parentTop && this.parentBottom) return;

          if (!this.parentTop) {
            this.parentTop = document.createElement('div');
            this.parentTop.className = 'notices is-top';
          }

          if (!this.parentBottom) {
            this.parentBottom = document.createElement('div');
            this.parentBottom.className = 'notices is-bottom';
          }

          var container = document.querySelector(this.newContainer) || document.body;
          container.appendChild(this.parentTop);
          container.appendChild(this.parentBottom);

          if (this.newContainer) {
            this.parentTop.classList.add('has-custom-container');
            this.parentBottom.classList.add('has-custom-container');
          }
        }
      },
      beforeMount: function beforeMount() {
        this.setupContainer();
      },
      mounted: function mounted() {
        this.showNotice();
      }
    };

    //
    var script$o = {
      name: 'BNotification',
      mixins: [MessageMixin],
      props: {
        position: String,
        ariaCloseLabel: String,
        animation: {
          type: String,
          default: 'fade'
        }
      }
    };

    /* script */
    const __vue_script__$o = script$o;

    /* template */
    var __vue_render__$n = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":_vm.animation}},[_c('article',{directives:[{name:"show",rawName:"v-show",value:(_vm.isActive),expression:"isActive"}],staticClass:"notification",class:[_vm.type, _vm.position],on:{"click":_vm.click}},[(_vm.closable)?_c('button',{staticClass:"delete",attrs:{"type":"button","aria-label":_vm.ariaCloseLabel},on:{"click":_vm.close}}):_vm._e(),(_vm.$slots.default || _vm.message)?_c('div',{staticClass:"media"},[(_vm.computedIcon && _vm.hasIcon)?_c('div',{staticClass:"media-left"},[_c('b-icon',{attrs:{"icon":_vm.computedIcon,"pack":_vm.iconPack,"size":_vm.newIconSize,"both":"","aria-hidden":""}})],1):_vm._e(),_c('div',{staticClass:"media-content"},[(_vm.$slots.default)?[_vm._t("default")]:[_c('p',{staticClass:"text",domProps:{"innerHTML":_vm._s(_vm.message)}})]],2)]):_vm._e(),(_vm.progressBar)?_c('b-progress',{attrs:{"value":_vm.remainingTime - 1,"max":_vm.duration / 1000 - 1,"type":_vm.type,"rounded":false}}):_vm._e()],1)])};
    var __vue_staticRenderFns__$n = [];

      /* style */
      const __vue_inject_styles__$o = undefined;
      /* scoped */
      const __vue_scope_id__$o = undefined;
      /* module identifier */
      const __vue_module_identifier__$o = undefined;
      /* functional template */
      const __vue_is_functional_template__$o = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var Notification = normalizeComponent_1(
        { render: __vue_render__$n, staticRenderFns: __vue_staticRenderFns__$n },
        __vue_inject_styles__$o,
        __vue_script__$o,
        __vue_scope_id__$o,
        __vue_is_functional_template__$o,
        __vue_module_identifier__$o,
        undefined,
        undefined
      );

    //
    var script$1$9 = {
      name: 'BNotificationNotice',
      mixins: [NoticeMixin],
      data: function data() {
        return {
          newDuration: this.duration || config$2.defaultNotificationDuration
        };
      },
      methods: {
        close: function close() {
          var _this = this;

          if (!this.isPaused) {
            clearTimeout(this.timer);
            this.$refs.notification.isActive = false;
            this.$emit('close'); // Timeout for the animation complete before destroying

            setTimeout(function () {
              _this.$destroy();

              removeElement(_this.$el);
            }, 150);
          }
        }
      }
    };

    /* script */
    const __vue_script__$1$9 = script$1$9;

    /* template */
    var __vue_render__$1$8 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('b-notification',_vm._b({ref:"notification",on:{"click":_vm.click,"close":_vm.close},nativeOn:{"mouseenter":function($event){return _vm.pause($event)},"mouseleave":function($event){return _vm.removePause($event)}}},'b-notification',_vm.$options.propsData,false),[_vm._t("default")],2)};
    var __vue_staticRenderFns__$1$8 = [];

      /* style */
      const __vue_inject_styles__$1$9 = undefined;
      /* scoped */
      const __vue_scope_id__$1$9 = undefined;
      /* module identifier */
      const __vue_module_identifier__$1$9 = undefined;
      /* functional template */
      const __vue_is_functional_template__$1$9 = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var NotificationNotice = normalizeComponent_1(
        { render: __vue_render__$1$8, staticRenderFns: __vue_staticRenderFns__$1$8 },
        __vue_inject_styles__$1$9,
        __vue_script__$1$9,
        __vue_scope_id__$1$9,
        __vue_is_functional_template__$1$9,
        __vue_module_identifier__$1$9,
        undefined,
        undefined
      );

    var localVueInstance$3;
    var NotificationProgrammatic = {
      open: function open(params) {
        var parent;

        if (typeof params === 'string') {
          params = {
            message: params
          };
        }

        var defaultParam = {
          position: config$2.defaultNotificationPosition || 'is-top-right'
        };

        if (params.parent) {
          parent = params.parent;
          delete params.parent;
        }

        var slot;

        if (Array.isArray(params.message)) {
          slot = params.message;
          delete params.message;
        } // fix animation


        params.active = false;
        var propsData = merge$1(defaultParam, params);
        var vm = typeof window !== 'undefined' && window.Vue ? window.Vue : localVueInstance$3 || VueInstance;
        var NotificationNoticeComponent = vm.extend(NotificationNotice);
        var component = new NotificationNoticeComponent({
          parent: parent,
          el: document.createElement('div'),
          propsData: propsData
        });

        if (slot) {
          component.$slots.default = slot;
          component.$forceUpdate();
        } // fix animation


        component.$children[0].isActive = true;
        return component;
      }
    };
    var Plugin$k = {
      install: function install(Vue) {
        localVueInstance$3 = Vue;
        registerComponent(Vue, Notification);
        registerComponentProgrammatic(Vue, 'notification', NotificationProgrammatic);
      }
    };
    use(Plugin$k);

    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    var script$p = {
      name: 'NavbarBurger',
      props: {
        isOpened: {
          type: Boolean,
          default: false
        }
      }
    };

    /* script */
    const __vue_script__$p = script$p;

    /* template */
    var __vue_render__$o = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('a',_vm._g({staticClass:"navbar-burger burger",class:{ 'is-active': _vm.isOpened },attrs:{"role":"button","aria-label":"menu","aria-expanded":_vm.isOpened,"tabindex":"0"}},_vm.$listeners),[_c('span',{attrs:{"aria-hidden":"true"}}),_c('span',{attrs:{"aria-hidden":"true"}}),_c('span',{attrs:{"aria-hidden":"true"}})])};
    var __vue_staticRenderFns__$o = [];

      /* style */
      const __vue_inject_styles__$p = undefined;
      /* scoped */
      const __vue_scope_id__$p = undefined;
      /* module identifier */
      const __vue_module_identifier__$p = undefined;
      /* functional template */
      const __vue_is_functional_template__$p = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var NavbarBurger = normalizeComponent_1(
        { render: __vue_render__$o, staticRenderFns: __vue_staticRenderFns__$o },
        __vue_inject_styles__$p,
        __vue_script__$p,
        __vue_scope_id__$p,
        __vue_is_functional_template__$p,
        __vue_module_identifier__$p,
        undefined,
        undefined
      );

    var isTouch = typeof window !== 'undefined' && ('ontouchstart' in window || navigator.msMaxTouchPoints > 0);
    var events$1 = isTouch ? ['touchstart', 'click'] : ['click'];
    var instances = [];

    function processArgs(bindingValue) {
      var isFunction = typeof bindingValue === 'function';

      if (!isFunction && _typeof(bindingValue) !== 'object') {
        throw new Error("v-click-outside: Binding value should be a function or an object, ".concat(_typeof(bindingValue), " given"));
      }

      return {
        handler: isFunction ? bindingValue : bindingValue.handler,
        middleware: bindingValue.middleware || function (isClickOutside) {
          return isClickOutside;
        },
        events: bindingValue.events || events$1
      };
    }

    function onEvent(_ref) {
      var el = _ref.el,
          event = _ref.event,
          handler = _ref.handler,
          middleware = _ref.middleware;
      var isClickOutside = event.target !== el && !el.contains(event.target);

      if (!isClickOutside || !middleware(event, el)) {
        return;
      }

      handler(event, el);
    }

    function toggleEventListeners() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          eventHandlers = _ref2.eventHandlers;

      var action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'add';
      eventHandlers.forEach(function (_ref3) {
        var event = _ref3.event,
            handler = _ref3.handler;
        document["".concat(action, "EventListener")](event, handler);
      });
    }

    function bind$3(el, _ref4) {
      var value = _ref4.value;

      var _processArgs = processArgs(value),
          _handler = _processArgs.handler,
          middleware = _processArgs.middleware,
          events = _processArgs.events;

      var instance = {
        el: el,
        eventHandlers: events.map(function (eventName) {
          return {
            event: eventName,
            handler: function handler(event) {
              return onEvent({
                event: event,
                el: el,
                handler: _handler,
                middleware: middleware
              });
            }
          };
        })
      };
      toggleEventListeners(instance, 'add');
      instances.push(instance);
    }

    function update(el, _ref5) {
      var value = _ref5.value;

      var _processArgs2 = processArgs(value),
          _handler2 = _processArgs2.handler,
          middleware = _processArgs2.middleware,
          events = _processArgs2.events; // `filter` instead of `find` for compat with IE


      var instance = instances.filter(function (instance) {
        return instance.el === el;
      })[0];
      toggleEventListeners(instance, 'remove');
      instance.eventHandlers = events.map(function (eventName) {
        return {
          event: eventName,
          handler: function handler(event) {
            return onEvent({
              event: event,
              el: el,
              handler: _handler2,
              middleware: middleware
            });
          }
        };
      });
      toggleEventListeners(instance, 'add');
    }

    function unbind$1(el) {
      // `filter` instead of `find` for compat with IE
      var instance = instances.filter(function (instance) {
        return instance.el === el;
      })[0];
      toggleEventListeners(instance, 'remove');
    }

    var directive$2 = {
      bind: bind$3,
      update: update,
      unbind: unbind$1,
      instances: instances
    };

    var FIXED_TOP_CLASS = 'is-fixed-top';
    var BODY_FIXED_TOP_CLASS = 'has-navbar-fixed-top';
    var BODY_SPACED_FIXED_TOP_CLASS = 'has-spaced-navbar-fixed-top';
    var FIXED_BOTTOM_CLASS = 'is-fixed-bottom';
    var BODY_FIXED_BOTTOM_CLASS = 'has-navbar-fixed-bottom';
    var BODY_SPACED_FIXED_BOTTOM_CLASS = 'has-spaced-navbar-fixed-bottom';
    var BODY_CENTERED_CLASS = 'has-navbar-centered';

    var isFilled = function isFilled(str) {
      return !!str;
    };

    var script$1$a = {
      name: 'BNavbar',
      components: {
        NavbarBurger: NavbarBurger
      },
      directives: {
        clickOutside: directive$2
      },
      // deprecated, to replace with default 'value' in the next breaking change
      model: {
        prop: 'active',
        event: 'update:active'
      },
      props: {
        type: [String, Object],
        transparent: {
          type: Boolean,
          default: false
        },
        fixedTop: {
          type: Boolean,
          default: false
        },
        fixedBottom: {
          type: Boolean,
          default: false
        },
        active: {
          type: Boolean,
          default: false
        },
        centered: {
          type: Boolean,
          default: false
        },
        wrapperClass: {
          type: [String, Array, Object]
        },
        closeOnClick: {
          type: Boolean,
          default: true
        },
        mobileBurger: {
          type: Boolean,
          default: true
        },
        spaced: Boolean,
        shadow: Boolean
      },
      data: function data() {
        return {
          internalIsActive: this.active,
          _isNavBar: true // Used internally by NavbarItem

        };
      },
      computed: {
        isOpened: function isOpened() {
          return this.internalIsActive;
        },
        computedClasses: function computedClasses() {
          var _ref;

          return [this.type, (_ref = {}, _defineProperty(_ref, FIXED_TOP_CLASS, this.fixedTop), _defineProperty(_ref, FIXED_BOTTOM_CLASS, this.fixedBottom), _defineProperty(_ref, BODY_CENTERED_CLASS, this.centered), _defineProperty(_ref, 'is-spaced', this.spaced), _defineProperty(_ref, 'has-shadow', this.shadow), _defineProperty(_ref, 'is-transparent', this.transparent), _ref)];
        }
      },
      watch: {
        active: {
          handler: function handler(active) {
            this.internalIsActive = active;
          },
          immediate: true
        },
        fixedTop: function fixedTop(isSet) {
          // toggle body class only on update to handle multiple navbar
          this.setBodyFixedTopClass(isSet);
        },
        bottomTop: function bottomTop(isSet) {
          // toggle body class only on update to handle multiple navbar
          this.setBodyFixedBottomClass(isSet);
        }
      },
      methods: {
        toggleActive: function toggleActive() {
          this.internalIsActive = !this.internalIsActive;
          this.emitUpdateParentEvent();
        },
        closeMenu: function closeMenu() {
          if (this.closeOnClick && this.internalIsActive) {
            this.internalIsActive = false;
            this.emitUpdateParentEvent();
          }
        },
        emitUpdateParentEvent: function emitUpdateParentEvent() {
          this.$emit('update:active', this.internalIsActive);
        },
        setBodyClass: function setBodyClass(className) {
          if (typeof window !== 'undefined') {
            document.body.classList.add(className);
          }
        },
        removeBodyClass: function removeBodyClass(className) {
          if (typeof window !== 'undefined') {
            document.body.classList.remove(className);
          }
        },
        checkIfFixedPropertiesAreColliding: function checkIfFixedPropertiesAreColliding() {
          var areColliding = this.fixedTop && this.fixedBottom;

          if (areColliding) {
            throw new Error('You should choose if the BNavbar is fixed bottom or fixed top, but not both');
          }
        },
        genNavbar: function genNavbar(createElement) {
          var navBarSlots = [this.genNavbarBrandNode(createElement), this.genNavbarSlotsNode(createElement)];

          if (!isFilled(this.wrapperClass)) {
            return this.genNavbarSlots(createElement, navBarSlots);
          } // It wraps the slots into a div with the provided wrapperClass prop


          var navWrapper = createElement('div', {
            class: this.wrapperClass
          }, navBarSlots);
          return this.genNavbarSlots(createElement, [navWrapper]);
        },
        genNavbarSlots: function genNavbarSlots(createElement, slots) {
          return createElement('nav', {
            staticClass: 'navbar',
            class: this.computedClasses,
            attrs: {
              role: 'navigation',
              'aria-label': 'main navigation'
            },
            directives: [{
              name: 'click-outside',
              value: this.closeMenu
            }]
          }, slots);
        },
        genNavbarBrandNode: function genNavbarBrandNode(createElement) {
          return createElement('div', {
            class: 'navbar-brand'
          }, [this.$slots.brand, this.genBurgerNode(createElement)]);
        },
        genBurgerNode: function genBurgerNode(createElement) {
          var _this = this;

          if (this.mobileBurger) {
            var defaultBurgerNode = createElement('navbar-burger', {
              props: {
                isOpened: this.isOpened
              },
              on: {
                click: this.toggleActive,
                keyup: function keyup(event) {
                  if (event.keyCode !== 13) return;

                  _this.toggleActive();
                }
              }
            });
            var hasBurgerSlot = !!this.$scopedSlots.burger;
            return hasBurgerSlot ? this.$scopedSlots.burger({
              isOpened: this.isOpened,
              toggleActive: this.toggleActive
            }) : defaultBurgerNode;
          }
        },
        genNavbarSlotsNode: function genNavbarSlotsNode(createElement) {
          return createElement('div', {
            staticClass: 'navbar-menu',
            class: {
              'is-active': this.isOpened
            }
          }, [this.genMenuPosition(createElement, 'start'), this.genMenuPosition(createElement, 'end')]);
        },
        genMenuPosition: function genMenuPosition(createElement, positionName) {
          return createElement('div', {
            staticClass: "navbar-".concat(positionName)
          }, this.$slots[positionName]);
        },
        setBodyFixedTopClass: function setBodyFixedTopClass(isSet) {
          this.checkIfFixedPropertiesAreColliding();

          if (isSet) {
            // TODO Apply only one of the classes once PR is merged in Bulma:
            // https://github.com/jgthms/bulma/pull/2737
            this.setBodyClass(BODY_FIXED_TOP_CLASS);
            this.spaced && this.setBodyClass(BODY_SPACED_FIXED_TOP_CLASS);
          } else {
            this.removeBodyClass(BODY_FIXED_TOP_CLASS);
            this.removeBodyClass(BODY_SPACED_FIXED_TOP_CLASS);
          }
        },
        setBodyFixedBottomClass: function setBodyFixedBottomClass(isSet) {
          this.checkIfFixedPropertiesAreColliding();

          if (isSet) {
            // TODO Apply only one of the classes once PR is merged in Bulma:
            // https://github.com/jgthms/bulma/pull/2737
            this.setBodyClass(BODY_FIXED_BOTTOM_CLASS);
            this.spaced && this.setBodyClass(BODY_SPACED_FIXED_BOTTOM_CLASS);
          } else {
            this.removeBodyClass(BODY_FIXED_BOTTOM_CLASS);
            this.removeBodyClass(BODY_SPACED_FIXED_BOTTOM_CLASS);
          }
        }
      },
      beforeMount: function beforeMount() {
        this.fixedTop && this.setBodyFixedTopClass(true);
        this.fixedBottom && this.setBodyFixedBottomClass(true);
      },
      beforeDestroy: function beforeDestroy() {
        if (this.fixedTop) {
          var className = this.spaced ? BODY_SPACED_FIXED_TOP_CLASS : BODY_FIXED_TOP_CLASS;
          this.removeBodyClass(className);
        } else if (this.fixedBottom) {
          var _className = this.spaced ? BODY_SPACED_FIXED_BOTTOM_CLASS : BODY_FIXED_BOTTOM_CLASS;

          this.removeBodyClass(_className);
        }
      },
      render: function render(createElement, fn) {
        return this.genNavbar(createElement);
      }
    };

    /* script */
    const __vue_script__$1$a = script$1$a;

    /* template */

      /* style */
      const __vue_inject_styles__$1$a = undefined;
      /* scoped */
      const __vue_scope_id__$1$a = undefined;
      /* module identifier */
      const __vue_module_identifier__$1$a = undefined;
      /* functional template */
      const __vue_is_functional_template__$1$a = undefined;
      /* style inject */
      
      /* style inject SSR */
      

      
      var Navbar = normalizeComponent_1(
        {},
        __vue_inject_styles__$1$a,
        __vue_script__$1$a,
        __vue_scope_id__$1$a,
        __vue_is_functional_template__$1$a,
        __vue_module_identifier__$1$a,
        undefined,
        undefined
      );

    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    var clickableWhiteList = ['div', 'span', 'input'];
    var script$2$5 = {
      name: 'BNavbarItem',
      inheritAttrs: false,
      props: {
        tag: {
          type: String,
          default: 'a'
        },
        active: Boolean
      },
      methods: {
        /**
         * Keypress event that is bound to the document
         */
        keyPress: function keyPress(_ref) {
          var key = _ref.key;

          if (key === 'Escape' || key === 'Esc') {
            this.closeMenuRecursive(this, ['NavBar']);
          }
        },

        /**
         * Close parent if clicked outside.
         */
        handleClickEvent: function handleClickEvent(event) {
          var isOnWhiteList = clickableWhiteList.some(function (item) {
            return item === event.target.localName;
          });

          if (!isOnWhiteList) {
            var parent = this.closeMenuRecursive(this, ['NavbarDropdown', 'NavBar']);
            if (parent && parent.$data._isNavbarDropdown) this.closeMenuRecursive(parent, ['NavBar']);
          }
        },

        /**
         * Close parent recursively
         */
        closeMenuRecursive: function closeMenuRecursive(current, targetComponents) {
          if (!current.$parent) return null;
          var foundItem = targetComponents.reduce(function (acc, item) {
            if (current.$parent.$data["_is".concat(item)]) {
              current.$parent.closeMenu();
              return current.$parent;
            }

            return acc;
          }, null);
          return foundItem || this.closeMenuRecursive(current.$parent, targetComponents);
        }
      },
      mounted: function mounted() {
        if (typeof window !== 'undefined') {
          this.$el.addEventListener('click', this.handleClickEvent);
          document.addEventListener('keyup', this.keyPress);
        }
      },
      beforeDestroy: function beforeDestroy() {
        if (typeof window !== 'undefined') {
          this.$el.removeEventListener('click', this.handleClickEvent);
          document.removeEventListener('keyup', this.keyPress);
        }
      }
    };

    /* script */
    const __vue_script__$2$5 = script$2$5;

    /* template */
    var __vue_render__$1$9 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(_vm.tag,_vm._g(_vm._b({tag:"component",staticClass:"navbar-item",class:{
            'is-active': _vm.active
        }},'component',_vm.$attrs,false),_vm.$listeners),[_vm._t("default")],2)};
    var __vue_staticRenderFns__$1$9 = [];

      /* style */
      const __vue_inject_styles__$2$5 = undefined;
      /* scoped */
      const __vue_scope_id__$2$5 = undefined;
      /* module identifier */
      const __vue_module_identifier__$2$5 = undefined;
      /* functional template */
      const __vue_is_functional_template__$2$5 = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var NavbarItem = normalizeComponent_1(
        { render: __vue_render__$1$9, staticRenderFns: __vue_staticRenderFns__$1$9 },
        __vue_inject_styles__$2$5,
        __vue_script__$2$5,
        __vue_scope_id__$2$5,
        __vue_is_functional_template__$2$5,
        __vue_module_identifier__$2$5,
        undefined,
        undefined
      );

    //
    var script$3$3 = {
      name: 'BNavbarDropdown',
      directives: {
        clickOutside: directive$2
      },
      inheritAttrs: false,
      props: {
        label: String,
        hoverable: Boolean,
        active: Boolean,
        right: Boolean,
        arrowless: Boolean,
        boxed: Boolean,
        closeOnClick: {
          type: Boolean,
          default: true
        },
        collapsible: Boolean,
        tag: {
          type: String,
          default: 'a'
        }
      },
      data: function data() {
        return {
          newActive: this.active,
          isHoverable: this.hoverable,
          _isNavbarDropdown: true // Used internally by NavbarItem

        };
      },
      watch: {
        active: function active(value) {
          this.newActive = value;
        },
        newActive: function newActive(value) {
          this.$emit('active-change', value);
        }
      },
      methods: {
        toggleMenu: function toggleMenu() {
          this.newActive = !this.newActive;
        },
        showMenu: function showMenu() {
          this.newActive = true;
        },

        /**
        * See naming convetion of navbaritem
        */
        closeMenu: function closeMenu() {
          this.newActive = !this.closeOnClick;

          if (this.hoverable && this.closeOnClick) {
            this.isHoverable = false;
          }
        },
        checkHoverable: function checkHoverable() {
          if (this.hoverable) {
            this.isHoverable = true;
          }
        }
      }
    };

    /* script */
    const __vue_script__$3$3 = script$3$3;

    /* template */
    var __vue_render__$2$4 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{directives:[{name:"click-outside",rawName:"v-click-outside",value:(_vm.closeMenu),expression:"closeMenu"}],staticClass:"navbar-item has-dropdown",class:{
            'is-hoverable': _vm.isHoverable,
            'is-active': _vm.newActive
        },on:{"mouseenter":_vm.checkHoverable}},[_c(_vm.tag,_vm._g(_vm._b({tag:"component",staticClass:"navbar-link",class:{
                'is-arrowless': _vm.arrowless,
                'is-active': _vm.newActive && _vm.collapsible
            },attrs:{"aria-haspopup":"true","tabindex":"0"},on:{"click":function($event){$event.preventDefault();return _vm.toggleMenu($event)},"keyup":function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"enter",13,$event.key,"Enter")){ return null; }return _vm.toggleMenu($event)}}},'component',_vm.$attrs,false),_vm.$listeners),[(_vm.label)?[_vm._v(_vm._s(_vm.label))]:_vm._t("label")],2),_c('div',{directives:[{name:"show",rawName:"v-show",value:(!_vm.collapsible || (_vm.collapsible && _vm.newActive)),expression:"!collapsible || (collapsible && newActive)"}],staticClass:"navbar-dropdown",class:{
                'is-right': _vm.right,
                'is-boxed': _vm.boxed,
            }},[_vm._t("default")],2)],1)};
    var __vue_staticRenderFns__$2$4 = [];

      /* style */
      const __vue_inject_styles__$3$3 = undefined;
      /* scoped */
      const __vue_scope_id__$3$3 = undefined;
      /* module identifier */
      const __vue_module_identifier__$3$3 = undefined;
      /* functional template */
      const __vue_is_functional_template__$3$3 = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var NavbarDropdown = normalizeComponent_1(
        { render: __vue_render__$2$4, staticRenderFns: __vue_staticRenderFns__$2$4 },
        __vue_inject_styles__$3$3,
        __vue_script__$3$3,
        __vue_scope_id__$3$3,
        __vue_is_functional_template__$3$3,
        __vue_module_identifier__$3$3,
        undefined,
        undefined
      );

    var Plugin$l = {
      install: function install(Vue) {
        registerComponent(Vue, Navbar);
        registerComponent(Vue, NavbarItem);
        registerComponent(Vue, NavbarDropdown);
      }
    };
    use(Plugin$l);

    var _components$7;
    var script$q = {
      name: 'BNumberinput',
      components: (_components$7 = {}, _defineProperty(_components$7, Icon.name, Icon), _defineProperty(_components$7, Input.name, Input), _components$7),
      mixins: [FormElementMixin],
      inheritAttrs: false,
      props: {
        value: Number,
        min: {
          type: [Number, String]
        },
        max: [Number, String],
        step: [Number, String],
        minStep: [Number, String],
        exponential: [Boolean, Number],
        disabled: Boolean,
        type: {
          type: String,
          default: 'is-primary'
        },
        editable: {
          type: Boolean,
          default: true
        },
        controls: {
          type: Boolean,
          default: true
        },
        controlsAlignment: {
          type: String,
          default: 'center',
          validator: function validator(value) {
            return ['left', 'right', 'center'].indexOf(value) >= 0;
          }
        },
        controlsRounded: {
          type: Boolean,
          default: false
        },
        controlsPosition: String,
        placeholder: [Number, String],
        ariaMinusLabel: String,
        ariaPlusLabel: String
      },
      data: function data() {
        return {
          newValue: this.value,
          newStep: this.step || 1,
          newMinStep: this.minStep,
          timesPressed: 1,
          _elementRef: 'input'
        };
      },
      computed: {
        computedValue: {
          get: function get() {
            return this.newValue;
          },
          set: function set(value) {
            var _this = this;

            // Parses the number, so that "0" => 0, and "invalid" => null
            var newValue = Number(value) === 0 ? 0 : Number(value) || null;

            if (value === '' || value === undefined || value === null) {
              if (this.minNumber !== undefined) {
                newValue = this.minNumber;
              } else {
                newValue = null;
              }
            }

            this.newValue = newValue;

            if (newValue === null) {
              this.$emit('input', newValue);
            } else if (!isNaN(newValue) && newValue !== '-0') {
              this.$emit('input', Number(newValue));
            }

            this.$nextTick(function () {
              if (_this.$refs.input) {
                _this.$refs.input.checkHtml5Validity();
              }
            });
          }
        },
        controlsLeft: function controlsLeft() {
          if (this.controls && this.controlsAlignment !== 'right') {
            return this.controlsAlignment === 'left' ? ['minus', 'plus'] : ['minus'];
          }

          return [];
        },
        controlsRight: function controlsRight() {
          if (this.controls && this.controlsAlignment !== 'left') {
            return this.controlsAlignment === 'right' ? ['minus', 'plus'] : ['plus'];
          }

          return [];
        },
        fieldClasses: function fieldClasses() {
          return [{
            'has-addons': this.controlsPosition === 'compact'
          }, {
            'is-grouped': this.controlsPosition !== 'compact'
          }, {
            'is-expanded': this.expanded
          }];
        },
        buttonClasses: function buttonClasses() {
          return [this.type, this.size, {
            'is-rounded': this.controlsRounded
          }];
        },
        minNumber: function minNumber() {
          return typeof this.min === 'string' ? parseFloat(this.min) : this.min;
        },
        maxNumber: function maxNumber() {
          return typeof this.max === 'string' ? parseFloat(this.max) : this.max;
        },
        stepNumber: function stepNumber() {
          if (this.newStep === 'any') {
            return 1;
          }

          return typeof this.newStep === 'string' ? parseFloat(this.newStep) : this.newStep;
        },
        minStepNumber: function minStepNumber() {
          if (this.newStep === 'any' && typeof this.newMinStep === 'undefined') {
            return 'any';
          }

          var step = typeof this.newMinStep !== 'undefined' ? this.newMinStep : this.newStep;
          return typeof step === 'string' ? parseFloat(step) : step;
        },
        disabledMin: function disabledMin() {
          return this.computedValue - this.stepNumber < this.minNumber;
        },
        disabledMax: function disabledMax() {
          return this.computedValue + this.stepNumber > this.maxNumber;
        },
        stepDecimals: function stepDecimals() {
          var step = this.minStepNumber.toString();
          var index = step.indexOf('.');

          if (index >= 0) {
            return step.substring(index + 1).length;
          }

          return 0;
        }
      },
      watch: {
        /**
         * When v-model is changed:
         *   1. Set internal value.
         */
        value: {
          immediate: true,
          handler: function handler(value) {
            this.newValue = value;
          }
        },
        step: function step(value) {
          this.newStep = value;
        },
        minStep: function minStep(value) {
          this.newMinStep = value;
        }
      },
      methods: {
        isDisabled: function isDisabled(control) {
          return this.disabled || (control === 'plus' ? this.disabledMax : this.disabledMin);
        },
        decrement: function decrement() {
          if (this.computedValue === null || typeof this.computedValue === 'undefined') {
            if (this.maxNumber !== null && typeof this.maxNumber !== 'undefined') {
              this.computedValue = this.maxNumber;
              return;
            }

            this.computedValue = 0;
          }

          if (typeof this.minNumber === 'undefined' || this.computedValue - this.stepNumber >= this.minNumber) {
            var value = this.computedValue - this.stepNumber;
            this.computedValue = parseFloat(value.toFixed(this.stepDecimals));
          }
        },
        increment: function increment() {
          if (this.computedValue === null || typeof this.computedValue === 'undefined') {
            if (this.minNumber !== null && typeof this.minNumber !== 'undefined') {
              this.computedValue = this.minNumber;
              return;
            }

            this.computedValue = 0;
          }

          if (typeof this.maxNumber === 'undefined' || this.computedValue + this.stepNumber <= this.maxNumber) {
            var value = this.computedValue + this.stepNumber;
            this.computedValue = parseFloat(value.toFixed(this.stepDecimals));
          }
        },
        onControlClick: function onControlClick(event, inc) {
          // IE 11 -> filter click event
          if (event.detail !== 0 || event.type !== 'click') return;
          if (inc) this.increment();else this.decrement();
        },
        longPressTick: function longPressTick(inc) {
          var _this2 = this;

          if (inc) this.increment();else this.decrement();
          this._$intervalRef = setTimeout(function () {
            _this2.longPressTick(inc);
          }, this.exponential ? 250 / (this.exponential * this.timesPressed++) : 250);
        },
        onStartLongPress: function onStartLongPress(event, inc) {
          if (event.button !== 0 && event.type !== 'touchstart') return;
          clearTimeout(this._$intervalRef);
          this.longPressTick(inc);
        },
        onStopLongPress: function onStopLongPress() {
          if (!this._$intervalRef) return;
          this.timesPressed = 1;
          clearTimeout(this._$intervalRef);
          this._$intervalRef = null;
        }
      }
    };

    /* script */
    const __vue_script__$q = script$q;

    /* template */
    var __vue_render__$p = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"b-numberinput field",class:_vm.fieldClasses},[_vm._l((_vm.controlsLeft),function(control){return _c('p',{key:control,class:['control', control],on:{"mouseup":_vm.onStopLongPress,"mouseleave":_vm.onStopLongPress,"touchend":_vm.onStopLongPress,"touchcancel":_vm.onStopLongPress}},[_c('button',{staticClass:"button",class:_vm.buttonClasses,attrs:{"type":"button","disabled":_vm.isDisabled(control),"aria-label":control === 'plus' ? _vm.ariaPlusLabel : _vm.ariaMinusLabel},on:{"mousedown":function($event){!_vm.isDisabled(control) && _vm.onStartLongPress($event, control === 'plus');},"touchstart":function($event){$event.preventDefault();!_vm.isDisabled(control) && _vm.onStartLongPress($event, control === 'plus');},"click":function($event){!_vm.isDisabled(control) && _vm.onControlClick($event, control === 'plus');}}},[_c('b-icon',{attrs:{"both":"","icon":control,"pack":_vm.iconPack,"size":_vm.iconSize}})],1)])}),_c('b-input',_vm._b({ref:"input",attrs:{"type":"number","step":_vm.minStepNumber,"max":_vm.max,"min":_vm.min,"size":_vm.size,"disabled":_vm.disabled,"readonly":!_vm.editable,"loading":_vm.loading,"rounded":_vm.rounded,"icon":_vm.icon,"icon-pack":_vm.iconPack,"autocomplete":_vm.autocomplete,"expanded":_vm.expanded,"placeholder":_vm.placeholder,"use-html5-validation":_vm.useHtml5Validation},on:{"focus":function($event){return _vm.$emit('focus', $event)},"blur":function($event){return _vm.$emit('blur', $event)}},model:{value:(_vm.computedValue),callback:function ($$v) {_vm.computedValue=$$v;},expression:"computedValue"}},'b-input',_vm.$attrs,false)),_vm._l((_vm.controlsRight),function(control){return _c('p',{key:control,class:['control', control],on:{"mouseup":_vm.onStopLongPress,"mouseleave":_vm.onStopLongPress,"touchend":_vm.onStopLongPress,"touchcancel":_vm.onStopLongPress}},[_c('button',{staticClass:"button",class:_vm.buttonClasses,attrs:{"type":"button","disabled":_vm.isDisabled(control),"aria-label":control === 'plus' ? _vm.ariaPlusLabel : _vm.ariaMinusLabel},on:{"mousedown":function($event){!_vm.isDisabled(control) && _vm.onStartLongPress($event, control === 'plus');},"touchstart":function($event){$event.preventDefault();!_vm.isDisabled(control) && _vm.onStartLongPress($event, control === 'plus');},"click":function($event){!_vm.isDisabled(control) && _vm.onControlClick($event, control === 'plus');}}},[_c('b-icon',{attrs:{"both":"","icon":control,"pack":_vm.iconPack,"size":_vm.iconSize}})],1)])})],2)};
    var __vue_staticRenderFns__$p = [];

      /* style */
      const __vue_inject_styles__$q = undefined;
      /* scoped */
      const __vue_scope_id__$q = undefined;
      /* module identifier */
      const __vue_module_identifier__$q = undefined;
      /* functional template */
      const __vue_is_functional_template__$q = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var Numberinput = normalizeComponent_1(
        { render: __vue_render__$p, staticRenderFns: __vue_staticRenderFns__$p },
        __vue_inject_styles__$q,
        __vue_script__$q,
        __vue_scope_id__$q,
        __vue_is_functional_template__$q,
        __vue_module_identifier__$q,
        undefined,
        undefined
      );

    var Plugin$m = {
      install: function install(Vue) {
        registerComponent(Vue, Numberinput);
      }
    };
    use(Plugin$m);

    //
    var script$r = {
      name: 'BPaginationButton',
      props: {
        page: {
          type: Object,
          required: true
        },
        tag: {
          type: String,
          default: 'a',
          validator: function validator(value) {
            return config$2.defaultLinkTags.indexOf(value) >= 0;
          }
        },
        disabled: {
          type: Boolean,
          default: false
        }
      },
      computed: {
        href: function href() {
          if (this.tag === 'a') {
            return '#';
          }
        },
        isDisabled: function isDisabled() {
          return this.disabled || this.page.disabled;
        }
      }
    };

    /* script */
    const __vue_script__$r = script$r;

    /* template */
    var __vue_render__$q = function () {
    var _obj;
    var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(_vm.tag,_vm._b({tag:"component",staticClass:"pagination-link",class:( _obj = { 'is-current': _vm.page.isCurrent }, _obj[_vm.page.class] = true, _obj ),attrs:{"role":"button","href":_vm.href,"disabled":_vm.isDisabled,"aria-label":_vm.page['aria-label'],"aria-current":_vm.page.isCurrent},on:{"click":function($event){$event.preventDefault();return _vm.page.click($event)}}},'component',_vm.$attrs,false),[_vm._t("default",[_vm._v(_vm._s(_vm.page.number))])],2)};
    var __vue_staticRenderFns__$q = [];

      /* style */
      const __vue_inject_styles__$r = undefined;
      /* scoped */
      const __vue_scope_id__$r = undefined;
      /* module identifier */
      const __vue_module_identifier__$r = undefined;
      /* functional template */
      const __vue_is_functional_template__$r = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var PaginationButton = normalizeComponent_1(
        { render: __vue_render__$q, staticRenderFns: __vue_staticRenderFns__$q },
        __vue_inject_styles__$r,
        __vue_script__$r,
        __vue_scope_id__$r,
        __vue_is_functional_template__$r,
        __vue_module_identifier__$r,
        undefined,
        undefined
      );

    function debounce (func, wait, immediate) {
      var timeout;
      return function () {
        var context = this;
        var args = arguments;

        var later = function later() {
          timeout = null;
          if (!immediate) func.apply(context, args);
        };

        var callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow) func.apply(context, args);
      };
    }

    var _components$8;
    var script$1$b = {
      name: 'BPagination',
      components: (_components$8 = {}, _defineProperty(_components$8, Icon.name, Icon), _defineProperty(_components$8, PaginationButton.name, PaginationButton), _components$8),
      // deprecated, to replace with default 'value' in the next breaking change
      model: {
        prop: 'current',
        event: 'update:current'
      },
      props: {
        total: [Number, String],
        perPage: {
          type: [Number, String],
          default: 20
        },
        current: {
          type: [Number, String],
          default: 1
        },
        rangeBefore: {
          type: [Number, String],
          default: 1
        },
        rangeAfter: {
          type: [Number, String],
          default: 1
        },
        size: String,
        simple: Boolean,
        rounded: Boolean,
        order: String,
        iconPack: String,
        iconPrev: {
          type: String,
          default: function _default() {
            return config$2.defaultIconPrev;
          }
        },
        iconNext: {
          type: String,
          default: function _default() {
            return config$2.defaultIconNext;
          }
        },
        ariaNextLabel: String,
        ariaPreviousLabel: String,
        ariaPageLabel: String,
        ariaCurrentLabel: String,
        pageInput: {
          type: Boolean,
          default: false
        },
        pageInputPosition: String,
        debouncePageInput: [Number, String]
      },
      data: function data() {
        return {
          inputValue: this.current
        };
      },
      computed: {
        rootClasses: function rootClasses() {
          return [this.order, this.size, this.pageInputPosition, {
            'is-simple': this.simple,
            'is-rounded': this.rounded,
            'has-input': this.pageInput
          }];
        },
        beforeCurrent: function beforeCurrent() {
          return parseInt(this.rangeBefore);
        },
        afterCurrent: function afterCurrent() {
          return parseInt(this.rangeAfter);
        },

        /**
        * Total page size (count).
        */
        pageCount: function pageCount() {
          return Math.ceil(this.total / this.perPage);
        },

        /**
        * First item of the page (count).
        */
        firstItem: function firstItem() {
          var firstItem = this.current * this.perPage - this.perPage + 1;
          return firstItem >= 0 ? firstItem : 0;
        },

        /**
        * Check if previous button is available.
        */
        hasPrev: function hasPrev() {
          return this.current > 1;
        },

        /**
         * Check if first page button should be visible.
        */
        hasFirst: function hasFirst() {
          return this.current >= 2 + this.beforeCurrent;
        },

        /**
        * Check if first ellipsis should be visible.
        */
        hasFirstEllipsis: function hasFirstEllipsis() {
          return this.current >= this.beforeCurrent + 4;
        },

        /**
        * Check if last page button should be visible.
        */
        hasLast: function hasLast() {
          return this.current <= this.pageCount - (1 + this.afterCurrent);
        },

        /**
        * Check if last ellipsis should be visible.
        */
        hasLastEllipsis: function hasLastEllipsis() {
          return this.current < this.pageCount - (2 + this.afterCurrent);
        },

        /**
        * Check if next button is available.
        */
        hasNext: function hasNext() {
          return this.current < this.pageCount;
        },

        /**
        * Get near pages, 1 before and 1 after the current.
        * Also add the click event to the array.
        */
        pagesInRange: function pagesInRange() {
          if (this.simple) return;
          var left = Math.max(1, this.current - this.beforeCurrent);

          if (left - 1 === 2) {
            left--; // Do not show the ellipsis if there is only one to hide
          }

          var right = Math.min(this.current + this.afterCurrent, this.pageCount);

          if (this.pageCount - right === 2) {
            right++; // Do not show the ellipsis if there is only one to hide
          }

          var pages = [];

          for (var i = left; i <= right; i++) {
            pages.push(this.getPage(i));
          }

          return pages;
        }
      },
      watch: {
        /**
        * If current page is trying to be greater than page count, set to last.
        */
        pageCount: function pageCount(value) {
          if (this.current > value) this.last();
        },
        current: function current(value) {
          this.inputValue = value;
        },
        debouncePageInput: {
          handler: function handler(value) {
            this.debounceHandlePageInput = debounce(this.handleOnInputPageChange, value);
          },
          immediate: true
        }
      },
      methods: {
        /**
        * Previous button click listener.
        */
        prev: function prev(event) {
          this.changePage(this.current - 1, event);
        },

        /**
         * Next button click listener.
        */
        next: function next(event) {
          this.changePage(this.current + 1, event);
        },

        /**
         * First button click listener.
        */
        first: function first(event) {
          this.changePage(1, event);
        },

        /**
        * Last button click listener.
        */
        last: function last(event) {
          this.changePage(this.pageCount, event);
        },
        changePage: function changePage(num, event) {
          if (this.current === num || num < 1 || num > this.pageCount) return;
          this.$emit('update:current', num);
          this.$emit('change', num); // Set focus on element to keep tab order

          if (event && event.target) {
            this.$nextTick(function () {
              return event.target.focus();
            });
          }
        },
        getPage: function getPage(num) {
          var _this = this;

          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          return {
            number: num,
            isCurrent: this.current === num,
            click: function click(event) {
              return _this.changePage(num, event);
            },
            input: function input(event, inputNum) {
              return _this.changePage(+inputNum, event);
            },
            disabled: options.disabled || false,
            class: options.class || '',
            'aria-label': options['aria-label'] || this.getAriaPageLabel(num, this.current === num)
          };
        },

        /**
        * Get text for aria-label according to page number.
        */
        getAriaPageLabel: function getAriaPageLabel(pageNumber, isCurrent) {
          if (this.ariaPageLabel && (!isCurrent || !this.ariaCurrentLabel)) {
            return this.ariaPageLabel + ' ' + pageNumber + '.';
          } else if (this.ariaPageLabel && isCurrent && this.ariaCurrentLabel) {
            return this.ariaCurrentLabel + ', ' + this.ariaPageLabel + ' ' + pageNumber + '.';
          }

          return null;
        },
        handleOnInputPageChange: function handleOnInputPageChange(event) {
          this.getPage(this.inputValue).input(event, this.inputValue);
        },
        handleOnInputDebounce: function handleOnInputDebounce(event) {
          if (this.debouncePageInput) {
            this.debounceHandlePageInput(event);
          } else {
            this.handleOnInputPageChange(event);
          }
        },
        handleOnKeyPress: function handleOnKeyPress(event) {
          // --- This is required to only allow numeric inputs for the page input - --- //
          // --- size attribute does not work with input type number. --- //
          var ASCIICode = event.which || event.keyCode;

          if (ASCIICode >= 48 && ASCIICode <= 57) {
            return true;
          } else {
            return event.preventDefault();
          }
        },
        handleAllowableInputPageRange: function handleAllowableInputPageRange(event) {
          if (+event.target.value > 0 && +event.target.value <= this.pageCount) {
            this.handleOnInputValue(event);
          } else {
            // --- It is nessacery to set inputValue to 1 and then to '' so that the DOM- --- //
            // --- will update the input component even when Backspace is used and then-
            // --- 0 us entered. --- //
            this.inputValue = 1;
            this.inputValue = '';
          }
        },
        handleOnInputValue: function handleOnInputValue(event) {
          var inputValue = +event.target.value;
          this.inputValue = inputValue;

          if (Number.isInteger(this.inputValue)) {
            this.handleOnInputDebounce(event);
          } else {
            // --- if NaN, then set inputValue back to current --- //
            this.inputValue = this.current;
          }
        }
      }
    };

    /* script */
    const __vue_script__$1$b = script$1$b;

    /* template */
    var __vue_render__$1$a = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('nav',{staticClass:"pagination",class:_vm.rootClasses},[(_vm.$scopedSlots.previous)?_vm._t("previous",[_c('b-icon',{attrs:{"icon":_vm.iconPrev,"pack":_vm.iconPack,"both":"","aria-hidden":"true"}})],{"page":_vm.getPage(_vm.current - 1, {
                    disabled: !_vm.hasPrev,
                    class: 'pagination-previous',
                    'aria-label': _vm.ariaPreviousLabel,
                })}):_c('BPaginationButton',{staticClass:"pagination-previous",attrs:{"disabled":!_vm.hasPrev,"page":_vm.getPage(_vm.current - 1),"aria-label":_vm.ariaPreviousLabel}},[_c('b-icon',{attrs:{"icon":_vm.iconPrev,"pack":_vm.iconPack,"both":"","aria-hidden":"true"}})],1),(_vm.$scopedSlots.next)?_vm._t("next",[_c('b-icon',{attrs:{"icon":_vm.iconNext,"pack":_vm.iconPack,"both":"","aria-hidden":"true"}})],{"page":_vm.getPage(_vm.current + 1, {
                    disabled: !_vm.hasNext,
                    class: 'pagination-next',
                    'aria-label': _vm.ariaNextLabel,
                })}):_c('BPaginationButton',{staticClass:"pagination-next",attrs:{"disabled":!_vm.hasNext,"page":_vm.getPage(_vm.current + 1),"aria-label":_vm.ariaNextLabel}},[_c('b-icon',{attrs:{"icon":_vm.iconNext,"pack":_vm.iconPack,"both":"","aria-hidden":"true"}})],1),_c('div',{staticClass:"control pagination-input"},[(_vm.pageInput)?_c('input',{staticClass:"input",attrs:{"size":_vm.pageCount.toString().length,"maxlength":_vm.pageCount.toString().length},domProps:{"value":_vm.inputValue},on:{"input":_vm.handleAllowableInputPageRange,"keypress":_vm.handleOnKeyPress}}):_vm._e()]),(_vm.simple)?_c('small',{staticClass:"info"},[(_vm.perPage == 1)?[_vm._v(" "+_vm._s(_vm.firstItem)+" / "+_vm._s(_vm.total)+" ")]:[_vm._v(" "+_vm._s(_vm.firstItem)+"-"+_vm._s(Math.min(_vm.current * _vm.perPage, _vm.total))+" / "+_vm._s(_vm.total)+" ")]],2):_c('ul',{staticClass:"pagination-list"},[(_vm.hasFirst)?_c('li',[(_vm.$scopedSlots.default)?_vm._t("default",null,{"page":_vm.getPage(1)}):_c('BPaginationButton',{attrs:{"page":_vm.getPage(1)}})],2):_vm._e(),(_vm.hasFirstEllipsis)?_c('li',[_c('span',{staticClass:"pagination-ellipsis"},[_vm._v("…")])]):_vm._e(),_vm._l((_vm.pagesInRange),function(page){return _c('li',{key:page.number},[(_vm.$scopedSlots.default)?_vm._t("default",null,{"page":page}):_c('BPaginationButton',{attrs:{"page":page}})],2)}),(_vm.hasLastEllipsis)?_c('li',[_c('span',{staticClass:"pagination-ellipsis"},[_vm._v("…")])]):_vm._e(),(_vm.hasLast)?_c('li',[(_vm.$scopedSlots.default)?_vm._t("default",null,{"page":_vm.getPage(_vm.pageCount)}):_c('BPaginationButton',{attrs:{"page":_vm.getPage(_vm.pageCount)}})],2):_vm._e()],2)],2)};
    var __vue_staticRenderFns__$1$a = [];

      /* style */
      const __vue_inject_styles__$1$b = undefined;
      /* scoped */
      const __vue_scope_id__$1$b = undefined;
      /* module identifier */
      const __vue_module_identifier__$1$b = undefined;
      /* functional template */
      const __vue_is_functional_template__$1$b = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var Pagination = normalizeComponent_1(
        { render: __vue_render__$1$a, staticRenderFns: __vue_staticRenderFns__$1$a },
        __vue_inject_styles__$1$b,
        __vue_script__$1$b,
        __vue_scope_id__$1$b,
        __vue_is_functional_template__$1$b,
        __vue_module_identifier__$1$b,
        undefined,
        undefined
      );

    var Plugin$n = {
      install: function install(Vue) {
        registerComponent(Vue, Pagination);
        registerComponent(Vue, PaginationButton);
      }
    };
    use(Plugin$n);

    var script$s = {
      name: 'BProgress',
      mixins: [ProviderParentMixin('progress')],
      props: {
        type: {
          type: [String, Object],
          default: 'is-darkgrey'
        },
        size: String,
        rounded: {
          type: Boolean,
          default: true
        },
        value: {
          type: Number,
          default: undefined
        },
        max: {
          type: Number,
          default: 100
        },
        showValue: {
          type: Boolean,
          default: false
        },
        format: {
          type: String,
          default: 'raw',
          validator: function validator(value) {
            return ['raw', 'percent'].indexOf(value) >= 0;
          }
        },
        precision: {
          type: Number,
          default: 2
        },
        keepTrailingZeroes: {
          type: Boolean,
          default: false
        },
        locale: {
          type: [String, Array],
          default: function _default() {
            return config$2.defaultLocale;
          }
        }
      },
      computed: {
        isIndeterminate: function isIndeterminate() {
          return this.value === undefined || this.value === null;
        },
        newType: function newType() {
          return [this.size, this.type, {
            'is-more-than-half': this.value && this.value > this.max / 2
          }];
        },
        newValue: function newValue() {
          return this.calculateValue(this.value);
        },
        isNative: function isNative() {
          return this.$slots.bar === undefined;
        },
        wrapperClasses: function wrapperClasses() {
          return _defineProperty({
            'is-not-native': !this.isNative
          }, this.size, typeof this.size === 'string' && !this.isNative);
        }
      },
      watch: {
        /**
         * When value is changed back to undefined, value of native progress get reset to 0.
         * Need to add and remove the value attribute to have the indeterminate or not.
         */
        isIndeterminate: function isIndeterminate(indeterminate) {
          var _this = this;

          this.$nextTick(function () {
            if (_this.$refs.progress) {
              if (indeterminate) {
                _this.$refs.progress.removeAttribute('value');
              } else {
                _this.$refs.progress.setAttribute('value', _this.value);
              }
            }
          });
        }
      },
      methods: {
        calculateValue: function calculateValue(value) {
          if (value === undefined || value === null || isNaN(value)) {
            return undefined;
          }

          var minimumFractionDigits = this.keepTrailingZeroes ? this.precision : 0;
          var maximumFractionDigits = this.precision;

          if (this.format === 'percent') {
            return new Intl.NumberFormat(this.locale, {
              style: 'percent',
              minimumFractionDigits: minimumFractionDigits,
              maximumFractionDigits: maximumFractionDigits
            }).format(value / this.max);
          }

          return new Intl.NumberFormat(this.locale, {
            minimumFractionDigits: minimumFractionDigits,
            maximumFractionDigits: maximumFractionDigits
          }).format(value);
        }
      }
    };

    /* script */
    const __vue_script__$s = script$s;

    /* template */
    var __vue_render__$r = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"progress-wrapper",class:[_vm.wrapperClasses, { 'is-squared': !_vm.rounded }]},[(_vm.isNative)?_c('progress',{ref:"progress",staticClass:"progress",class:[_vm.newType, { 'is-squared': !_vm.rounded }],attrs:{"max":_vm.max},domProps:{"value":_vm.value}},[_vm._v(_vm._s(_vm.newValue))]):_vm._t("bar"),(_vm.isNative && _vm.showValue)?_c('p',{staticClass:"progress-value"},[_vm._t("default",[_vm._v(_vm._s(_vm.newValue))])],2):_vm._e()],2)};
    var __vue_staticRenderFns__$r = [];

      /* style */
      const __vue_inject_styles__$s = undefined;
      /* scoped */
      const __vue_scope_id__$s = undefined;
      /* module identifier */
      const __vue_module_identifier__$s = undefined;
      /* functional template */
      const __vue_is_functional_template__$s = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var Progress = normalizeComponent_1(
        { render: __vue_render__$r, staticRenderFns: __vue_staticRenderFns__$r },
        __vue_inject_styles__$s,
        __vue_script__$s,
        __vue_scope_id__$s,
        __vue_is_functional_template__$s,
        __vue_module_identifier__$s,
        undefined,
        undefined
      );

    //
    var script$1$c = {
      name: 'BProgressBar',
      mixins: [InjectedChildMixin('progress')],
      props: {
        type: {
          type: [String, Object],
          default: undefined
        },
        value: {
          type: Number,
          default: undefined
        },
        showValue: {
          type: Boolean,
          default: false
        }
      },
      computed: {
        newType: function newType() {
          return [this.parent.size, this.type || this.parent.type];
        },
        newShowValue: function newShowValue() {
          return this.showValue || this.parent.showValue;
        },
        newValue: function newValue() {
          return this.parent.calculateValue(this.value);
        },
        barWidth: function barWidth() {
          return "".concat(this.value * 100 / this.parent.max, "%");
        }
      }
    };

    /* script */
    const __vue_script__$1$c = script$1$c;

    /* template */
    var __vue_render__$1$b = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"progress-bar",class:_vm.newType,style:({width: _vm.barWidth}),attrs:{"role":"progressbar","aria-valuenow":_vm.value,"aria-valuemax":_vm.parent.max,"aria-valuemin":"0"}},[(_vm.newShowValue)?_c('p',{staticClass:"progress-value"},[_vm._t("default",[_vm._v(_vm._s(_vm.newValue))])],2):_vm._e()])};
    var __vue_staticRenderFns__$1$b = [];

      /* style */
      const __vue_inject_styles__$1$c = undefined;
      /* scoped */
      const __vue_scope_id__$1$c = undefined;
      /* module identifier */
      const __vue_module_identifier__$1$c = undefined;
      /* functional template */
      const __vue_is_functional_template__$1$c = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var ProgressBar = normalizeComponent_1(
        { render: __vue_render__$1$b, staticRenderFns: __vue_staticRenderFns__$1$b },
        __vue_inject_styles__$1$c,
        __vue_script__$1$c,
        __vue_scope_id__$1$c,
        __vue_is_functional_template__$1$c,
        __vue_module_identifier__$1$c,
        undefined,
        undefined
      );

    var Plugin$o = {
      install: function install(Vue) {
        registerComponent(Vue, Progress);
        registerComponent(Vue, ProgressBar);
      }
    };
    use(Plugin$o);

    //
    var script$t = {
      name: 'BRadio',
      mixins: [CheckRadioMixin]
    };

    /* script */
    const __vue_script__$t = script$t;

    /* template */
    var __vue_render__$s = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('label',{ref:"label",staticClass:"b-radio radio",class:[_vm.size, { 'is-disabled': _vm.disabled }],attrs:{"disabled":_vm.disabled},on:{"click":_vm.focus,"keydown":function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"enter",13,$event.key,"Enter")){ return null; }$event.preventDefault();return _vm.$refs.label.click()}}},[_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.computedValue),expression:"computedValue"}],ref:"input",attrs:{"type":"radio","disabled":_vm.disabled,"required":_vm.required,"name":_vm.name},domProps:{"value":_vm.nativeValue,"checked":_vm._q(_vm.computedValue,_vm.nativeValue)},on:{"click":function($event){$event.stopPropagation();},"change":function($event){_vm.computedValue=_vm.nativeValue;}}}),_c('span',{staticClass:"check",class:_vm.type}),_c('span',{staticClass:"control-label"},[_vm._t("default")],2)])};
    var __vue_staticRenderFns__$s = [];

      /* style */
      const __vue_inject_styles__$t = undefined;
      /* scoped */
      const __vue_scope_id__$t = undefined;
      /* module identifier */
      const __vue_module_identifier__$t = undefined;
      /* functional template */
      const __vue_is_functional_template__$t = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var Radio = normalizeComponent_1(
        { render: __vue_render__$s, staticRenderFns: __vue_staticRenderFns__$s },
        __vue_inject_styles__$t,
        __vue_script__$t,
        __vue_scope_id__$t,
        __vue_is_functional_template__$t,
        __vue_module_identifier__$t,
        undefined,
        undefined
      );

    //
    var script$1$d = {
      name: 'BRadioButton',
      mixins: [CheckRadioMixin],
      props: {
        type: {
          type: String,
          default: 'is-primary'
        },
        expanded: Boolean
      },
      data: function data() {
        return {
          isFocused: false
        };
      },
      computed: {
        isSelected: function isSelected() {
          return this.newValue === this.nativeValue;
        },
        labelClass: function labelClass() {
          return [this.isSelected ? this.type : null, this.size, {
            'is-selected': this.isSelected,
            'is-disabled': this.disabled,
            'is-focused': this.isFocused
          }];
        }
      }
    };

    /* script */
    const __vue_script__$1$d = script$1$d;

    /* template */
    var __vue_render__$1$c = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"control",class:{ 'is-expanded': _vm.expanded }},[_c('label',{ref:"label",staticClass:"b-radio radio button",class:_vm.labelClass,attrs:{"disabled":_vm.disabled},on:{"click":_vm.focus,"keydown":function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"enter",13,$event.key,"Enter")){ return null; }$event.preventDefault();return _vm.$refs.label.click()}}},[_vm._t("default"),_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.computedValue),expression:"computedValue"}],ref:"input",attrs:{"type":"radio","disabled":_vm.disabled,"required":_vm.required,"name":_vm.name},domProps:{"value":_vm.nativeValue,"checked":_vm._q(_vm.computedValue,_vm.nativeValue)},on:{"click":function($event){$event.stopPropagation();},"focus":function($event){_vm.isFocused = true;},"blur":function($event){_vm.isFocused = false;},"change":function($event){_vm.computedValue=_vm.nativeValue;}}})],2)])};
    var __vue_staticRenderFns__$1$c = [];

      /* style */
      const __vue_inject_styles__$1$d = undefined;
      /* scoped */
      const __vue_scope_id__$1$d = undefined;
      /* module identifier */
      const __vue_module_identifier__$1$d = undefined;
      /* functional template */
      const __vue_is_functional_template__$1$d = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var RadioButton = normalizeComponent_1(
        { render: __vue_render__$1$c, staticRenderFns: __vue_staticRenderFns__$1$c },
        __vue_inject_styles__$1$d,
        __vue_script__$1$d,
        __vue_scope_id__$1$d,
        __vue_is_functional_template__$1$d,
        __vue_module_identifier__$1$d,
        undefined,
        undefined
      );

    var Plugin$p = {
      install: function install(Vue) {
        registerComponent(Vue, Radio);
        registerComponent(Vue, RadioButton);
      }
    };
    use(Plugin$p);

    var script$u = {
      name: 'BRate',
      components: _defineProperty({}, Icon.name, Icon),
      props: {
        value: {
          type: Number,
          default: 0
        },
        max: {
          type: Number,
          default: 5
        },
        icon: {
          type: String,
          default: 'star'
        },
        iconPack: String,
        size: String,
        spaced: Boolean,
        rtl: Boolean,
        disabled: Boolean,
        showScore: Boolean,
        showText: Boolean,
        customText: String,
        texts: Array,
        locale: {
          type: [String, Array],
          default: function _default() {
            return config$2.defaultLocale;
          }
        }
      },
      data: function data() {
        return {
          newValue: this.value,
          hoverValue: 0
        };
      },
      computed: {
        halfStyle: function halfStyle() {
          return "width:".concat(this.valueDecimal, "%");
        },
        showMe: function showMe() {
          var result = '';

          if (this.showScore) {
            result = this.disabled ? this.value : this.newValue;

            if (result === 0) {
              result = '';
            } else {
              result = new Intl.NumberFormat(this.locale).format(this.value);
            }
          } else if (this.showText) {
            result = this.texts[Math.ceil(this.newValue) - 1];
          }

          return result;
        },
        valueDecimal: function valueDecimal() {
          return this.value * 100 - Math.floor(this.value) * 100;
        }
      },
      watch: {
        // When v-model is changed set the new value.
        value: function value(_value) {
          this.newValue = _value;
        }
      },
      methods: {
        resetNewValue: function resetNewValue() {
          if (this.disabled) return;
          this.hoverValue = 0;
        },
        previewRate: function previewRate(index, event) {
          if (this.disabled) return;
          this.hoverValue = index;
          event.stopPropagation();
        },
        confirmValue: function confirmValue(index) {
          if (this.disabled) return;
          this.newValue = index;
          this.$emit('change', this.newValue);
          this.$emit('input', this.newValue);
        },
        checkHalf: function checkHalf(index) {
          var showWhenDisabled = this.disabled && this.valueDecimal > 0 && index - 1 < this.value && index > this.value;
          return showWhenDisabled;
        },
        rateClass: function rateClass(index) {
          var output = '';
          var currentValue = this.hoverValue !== 0 ? this.hoverValue : this.newValue;

          if (index <= currentValue) {
            output = 'set-on';
          } else if (this.disabled && Math.ceil(this.value) === index) {
            output = 'set-half';
          }

          return output;
        }
      }
    };

    /* script */
    const __vue_script__$u = script$u;

    /* template */
    var __vue_render__$t = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"rate",class:{ 'is-disabled': _vm.disabled, 'is-spaced': _vm.spaced, 'is-rtl': _vm.rtl }},[_vm._l((_vm.max),function(item,index){return _c('div',{key:index,staticClass:"rate-item",class:_vm.rateClass(item),on:{"mousemove":function($event){return _vm.previewRate(item, $event)},"mouseleave":_vm.resetNewValue,"click":function($event){$event.preventDefault();return _vm.confirmValue(item)}}},[_c('b-icon',{attrs:{"pack":_vm.iconPack,"icon":_vm.icon,"size":_vm.size}}),(_vm.checkHalf(item))?_c('b-icon',{staticClass:"is-half",style:(_vm.halfStyle),attrs:{"pack":_vm.iconPack,"icon":_vm.icon,"size":_vm.size}}):_vm._e()],1)}),(_vm.showText || _vm.showScore || _vm.customText)?_c('div',{staticClass:"rate-text",class:_vm.size},[_c('span',[_vm._v(_vm._s(_vm.showMe))]),(_vm.customText && !_vm.showText)?_c('span',[_vm._v(_vm._s(_vm.customText))]):_vm._e()]):_vm._e()],2)};
    var __vue_staticRenderFns__$t = [];

      /* style */
      const __vue_inject_styles__$u = undefined;
      /* scoped */
      const __vue_scope_id__$u = undefined;
      /* module identifier */
      const __vue_module_identifier__$u = undefined;
      /* functional template */
      const __vue_is_functional_template__$u = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var Rate = normalizeComponent_1(
        { render: __vue_render__$t, staticRenderFns: __vue_staticRenderFns__$t },
        __vue_inject_styles__$u,
        __vue_script__$u,
        __vue_scope_id__$u,
        __vue_is_functional_template__$u,
        __vue_module_identifier__$u,
        undefined,
        undefined
      );

    var Plugin$q = {
      install: function install(Vue) {
        registerComponent(Vue, Rate);
      }
    };
    use(Plugin$q);

    var Plugin$r = {
      install: function install(Vue) {
        registerComponent(Vue, Select);
      }
    };
    use(Plugin$r);

    var script$v = {
      name: 'BSkeleton',
      functional: true,
      props: {
        active: {
          type: Boolean,
          default: true
        },
        animated: {
          type: Boolean,
          default: true
        },
        width: [Number, String],
        height: [Number, String],
        circle: Boolean,
        rounded: {
          type: Boolean,
          default: true
        },
        count: {
          type: Number,
          default: 1
        },
        position: {
          type: String,
          default: '',
          validator: function validator(value) {
            return ['', 'is-centered', 'is-right'].indexOf(value) > -1;
          }
        },
        size: String
      },
      render: function render(createElement, context) {
        if (!context.props.active) return;
        var items = [];
        var width = context.props.width;
        var height = context.props.height;

        for (var i = 0; i < context.props.count; i++) {
          items.push(createElement('div', {
            staticClass: 'b-skeleton-item',
            class: {
              'is-rounded': context.props.rounded
            },
            key: i,
            style: {
              height: height === undefined ? null : isNaN(height) ? height : height + 'px',
              width: width === undefined ? null : isNaN(width) ? width : width + 'px',
              borderRadius: context.props.circle ? '50%' : null
            }
          }));
        }

        return createElement('div', {
          staticClass: 'b-skeleton',
          class: [context.props.size, context.props.position, {
            'is-animated': context.props.animated
          }]
        }, items);
      }
    };

    /* script */
    const __vue_script__$v = script$v;

    /* template */

      /* style */
      const __vue_inject_styles__$v = undefined;
      /* scoped */
      const __vue_scope_id__$v = undefined;
      /* module identifier */
      const __vue_module_identifier__$v = undefined;
      /* functional template */
      const __vue_is_functional_template__$v = undefined;
      /* style inject */
      
      /* style inject SSR */
      

      
      var Skeleton = normalizeComponent_1(
        {},
        __vue_inject_styles__$v,
        __vue_script__$v,
        __vue_scope_id__$v,
        __vue_is_functional_template__$v,
        __vue_module_identifier__$v,
        undefined,
        undefined
      );

    var Plugin$s = {
      install: function install(Vue) {
        registerComponent(Vue, Skeleton);
      }
    };
    use(Plugin$s);

    //
    var script$w = {
      name: 'BSidebar',
      model: {
        prop: 'open',
        event: 'update:open'
      },
      props: {
        open: Boolean,
        type: [String, Object],
        overlay: Boolean,
        position: {
          type: String,
          default: 'fixed',
          validator: function validator(value) {
            return ['fixed', 'absolute', 'static'].indexOf(value) >= 0;
          }
        },
        fullheight: Boolean,
        fullwidth: Boolean,
        right: Boolean,
        mobile: {
          type: String
        },
        reduce: Boolean,
        expandOnHover: Boolean,
        expandOnHoverFixed: Boolean,
        delay: {
          type: Number,
          default: function _default() {
            return config$2.defaultSidebarDelay;
          }
        },
        canCancel: {
          type: [Array, Boolean],
          default: function _default() {
            return ['escape', 'outside'];
          }
        },
        onCancel: {
          type: Function,
          default: function _default() {}
        },
        scroll: {
          type: String,
          default: function _default() {
            return config$2.defaultModalScroll ? config$2.defaultModalScroll : 'clip';
          },
          validator: function validator(value) {
            return ['clip', 'keep'].indexOf(value) >= 0;
          }
        }
      },
      data: function data() {
        return {
          isOpen: this.open,
          isDelayOver: false,
          transitionName: null,
          animating: true,
          savedScrollTop: null,
          hasLeaved: false,
          whiteList: []
        };
      },
      computed: {
        rootClasses: function rootClasses() {
          return [this.type, {
            'is-fixed': this.isFixed,
            'is-static': this.isStatic,
            'is-absolute': this.isAbsolute,
            'is-fullheight': this.fullheight,
            'is-fullwidth': this.fullwidth,
            'is-right': this.right,
            'is-mini': this.reduce && !this.isDelayOver,
            'is-mini-expand': this.expandOnHover || this.isDelayOver,
            'is-mini-expand-fixed': this.expandOnHover && this.expandOnHoverFixed || this.isDelayOver,
            'is-mini-delayed': this.delay !== null,
            'is-mini-mobile': this.mobile === 'reduce',
            'is-hidden-mobile': this.mobile === 'hide',
            'is-fullwidth-mobile': this.mobile === 'fullwidth'
          }];
        },
        cancelOptions: function cancelOptions() {
          return typeof this.canCancel === 'boolean' ? this.canCancel ? ['escape', 'outside'] : [] : this.canCancel;
        },
        isStatic: function isStatic() {
          return this.position === 'static';
        },
        isFixed: function isFixed() {
          return this.position === 'fixed';
        },
        isAbsolute: function isAbsolute() {
          return this.position === 'absolute';
        }
      },
      watch: {
        open: {
          handler: function handler(value) {
            this.isOpen = value;

            if (this.overlay) {
              this.handleScroll();
            }

            var open = this.right ? !value : value;
            this.transitionName = !open ? 'slide-prev' : 'slide-next';
          },
          immediate: true
        }
      },
      methods: {
        /**
        * Keypress event that is bound to the document.
        */
        keyPress: function keyPress(_ref) {
          var key = _ref.key;

          if (this.isFixed) {
            if (this.isOpen && (key === 'Escape' || key === 'Esc')) this.cancel('escape');
          }
        },

        /**
        * Close the Sidebar if canCancel and call the onCancel prop (function).
        */
        cancel: function cancel(method) {
          if (this.cancelOptions.indexOf(method) < 0) return;
          if (this.isStatic) return;
          this.onCancel.apply(null, arguments);
          this.close();
        },

        /**
        * Call the onCancel prop (function) and emit events
        */
        close: function close() {
          this.isOpen = false;
          this.$emit('close');
          this.$emit('update:open', false);
        },

        /**
         * Close fixed sidebar if clicked outside.
         */
        clickedOutside: function clickedOutside(event) {
          if (this.isFixed) {
            if (this.isOpen && !this.animating) {
              var target = isCustomElement(this) ? event.composedPath()[0] : event.target;

              if (this.whiteList.indexOf(target) < 0) {
                this.cancel('outside');
              }
            }
          }
        },

        /**
        * Transition before-enter hook
        */
        beforeEnter: function beforeEnter() {
          this.animating = true;
        },

        /**
        * Transition after-leave hook
        */
        afterEnter: function afterEnter() {
          this.animating = false;
        },
        handleScroll: function handleScroll() {
          if (typeof window === 'undefined') return;

          if (this.scroll === 'clip') {
            if (this.open) {
              document.documentElement.classList.add('is-clipped');
            } else {
              document.documentElement.classList.remove('is-clipped');
            }

            return;
          }

          this.savedScrollTop = !this.savedScrollTop ? document.documentElement.scrollTop : this.savedScrollTop;

          if (this.open) {
            document.body.classList.add('is-noscroll');
          } else {
            document.body.classList.remove('is-noscroll');
          }

          if (this.open) {
            document.body.style.top = "-".concat(this.savedScrollTop, "px");
            return;
          }

          document.documentElement.scrollTop = this.savedScrollTop;
          document.body.style.top = null;
          this.savedScrollTop = null;
        },
        onHover: function onHover() {
          var _this = this;

          if (this.delay) {
            this.hasLeaved = false;
            this.timer = setTimeout(function () {
              if (!_this.hasLeaved) {
                _this.isDelayOver = true;
              }

              _this.timer = null;
            }, this.delay);
          } else {
            this.isDelayOver = false;
          }
        },
        onHoverLeave: function onHoverLeave() {
          this.hasLeaved = true;
          this.timer = null;
          this.isDelayOver = false;
        }
      },
      created: function created() {
        if (typeof window !== 'undefined') {
          document.addEventListener('keyup', this.keyPress);
          document.addEventListener('click', this.clickedOutside);
        }
      },
      mounted: function mounted() {
        if (typeof window !== 'undefined') {
          if (this.isFixed) {
            document.body.appendChild(this.$el);
          }
        }

        if (this.overlay && this.open) {
          this.handleScroll();
        }
      },
      beforeDestroy: function beforeDestroy() {
        if (typeof window !== 'undefined') {
          document.removeEventListener('keyup', this.keyPress);
          document.removeEventListener('click', this.clickedOutside);

          if (this.overlay) {
            // reset scroll
            document.documentElement.classList.remove('is-clipped');
            var savedScrollTop = !this.savedScrollTop ? document.documentElement.scrollTop : this.savedScrollTop;
            document.body.classList.remove('is-noscroll');
            document.documentElement.scrollTop = savedScrollTop;
            document.body.style.top = null;
          }
        }

        if (this.isFixed) {
          removeElement(this.$el);
        }
      },
      beforeUpdate: function beforeUpdate() {
        /**
        * White-listed items to not close when clicked.
        * Add sidebar content and all children.
        */
        this.whiteList = [];
        this.whiteList.push(this.$refs.sidebarContent); // Add all chidren from sidebar

        if (this.$refs.sidebarContent !== undefined) {
          var children = this.$refs.sidebarContent.querySelectorAll('*');
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var child = _step.value;
              this.whiteList.push(child);
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }
      }
    };

    /* script */
    const __vue_script__$w = script$w;

    /* template */
    var __vue_render__$u = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"b-sidebar"},[(_vm.overlay && _vm.isOpen)?_c('div',{staticClass:"sidebar-background"}):_vm._e(),_c('transition',{attrs:{"name":_vm.transitionName},on:{"before-enter":_vm.beforeEnter,"after-enter":_vm.afterEnter}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.isOpen),expression:"isOpen"}],ref:"sidebarContent",staticClass:"sidebar-content",class:_vm.rootClasses,on:{"mouseenter":_vm.onHover,"mouseleave":_vm.onHoverLeave}},[_vm._t("default")],2)])],1)};
    var __vue_staticRenderFns__$u = [];

      /* style */
      const __vue_inject_styles__$w = undefined;
      /* scoped */
      const __vue_scope_id__$w = undefined;
      /* module identifier */
      const __vue_module_identifier__$w = undefined;
      /* functional template */
      const __vue_is_functional_template__$w = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var Sidebar = normalizeComponent_1(
        { render: __vue_render__$u, staticRenderFns: __vue_staticRenderFns__$u },
        __vue_inject_styles__$w,
        __vue_script__$w,
        __vue_scope_id__$w,
        __vue_is_functional_template__$w,
        __vue_module_identifier__$w,
        undefined,
        undefined
      );

    var Plugin$t = {
      install: function install(Vue) {
        registerComponent(Vue, Sidebar);
      }
    };
    use(Plugin$t);

    var script$x = {
      name: 'BSliderThumb',
      components: _defineProperty({}, Tooltip.name, Tooltip),
      inheritAttrs: false,
      props: {
        value: {
          type: Number,
          default: 0
        },
        type: {
          type: String,
          default: ''
        },
        tooltip: {
          type: Boolean,
          default: true
        },
        indicator: {
          type: Boolean,
          default: false
        },
        customFormatter: Function,
        format: {
          type: String,
          default: 'raw',
          validator: function validator(value) {
            return ['raw', 'percent'].indexOf(value) >= 0;
          }
        },
        locale: {
          type: [String, Array],
          default: function _default() {
            return config$2.defaultLocale;
          }
        },
        tooltipAlways: {
          type: Boolean,
          default: false
        }
      },
      data: function data() {
        return {
          isFocused: false,
          dragging: false,
          startX: 0,
          startPosition: 0,
          newPosition: null,
          oldValue: this.value
        };
      },
      computed: {
        disabled: function disabled() {
          return this.$parent.disabled;
        },
        max: function max() {
          return this.$parent.max;
        },
        min: function min() {
          return this.$parent.min;
        },
        step: function step() {
          return this.$parent.step;
        },
        precision: function precision() {
          return this.$parent.precision;
        },
        currentPosition: function currentPosition() {
          return "".concat((this.value - this.min) / (this.max - this.min) * 100, "%");
        },
        wrapperStyle: function wrapperStyle() {
          return {
            left: this.currentPosition
          };
        },
        formattedValue: function formattedValue() {
          if (typeof this.customFormatter !== 'undefined') {
            return this.customFormatter(this.value);
          }

          if (this.format === 'percent') {
            return new Intl.NumberFormat(this.locale, {
              style: 'percent'
            }).format((this.value - this.min) / (this.max - this.min));
          }

          return new Intl.NumberFormat(this.locale).format(this.value);
        }
      },
      methods: {
        onFocus: function onFocus() {
          this.isFocused = true;
        },
        onBlur: function onBlur() {
          this.isFocused = false;
        },
        onButtonDown: function onButtonDown(event) {
          if (this.disabled) return;
          event.preventDefault();
          this.onDragStart(event);

          if (typeof window !== 'undefined') {
            document.addEventListener('mousemove', this.onDragging);
            document.addEventListener('touchmove', this.onDragging);
            document.addEventListener('mouseup', this.onDragEnd);
            document.addEventListener('touchend', this.onDragEnd);
            document.addEventListener('contextmenu', this.onDragEnd);
          }
        },
        onLeftKeyDown: function onLeftKeyDown() {
          if (this.disabled || this.value === this.min) return;
          this.newPosition = parseFloat(this.currentPosition) - this.step / (this.max - this.min) * 100;
          this.setPosition(this.newPosition);
          this.$parent.emitValue('change');
        },
        onRightKeyDown: function onRightKeyDown() {
          if (this.disabled || this.value === this.max) return;
          this.newPosition = parseFloat(this.currentPosition) + this.step / (this.max - this.min) * 100;
          this.setPosition(this.newPosition);
          this.$parent.emitValue('change');
        },
        onHomeKeyDown: function onHomeKeyDown() {
          if (this.disabled || this.value === this.min) return;
          this.newPosition = 0;
          this.setPosition(this.newPosition);
          this.$parent.emitValue('change');
        },
        onEndKeyDown: function onEndKeyDown() {
          if (this.disabled || this.value === this.max) return;
          this.newPosition = 100;
          this.setPosition(this.newPosition);
          this.$parent.emitValue('change');
        },
        onDragStart: function onDragStart(event) {
          this.dragging = true;
          this.$emit('dragstart');

          if (event.type === 'touchstart') {
            event.clientX = event.touches[0].clientX;
          }

          this.startX = event.clientX;
          this.startPosition = parseFloat(this.currentPosition);
          this.newPosition = this.startPosition;
        },
        onDragging: function onDragging(event) {
          if (this.dragging) {
            if (event.type === 'touchmove') {
              event.clientX = event.touches[0].clientX;
            }

            var diff = (event.clientX - this.startX) / this.$parent.sliderSize() * 100;
            this.newPosition = this.startPosition + diff;
            this.setPosition(this.newPosition);
          }
        },
        onDragEnd: function onDragEnd() {
          this.dragging = false;
          this.$emit('dragend');

          if (this.value !== this.oldValue) {
            this.$parent.emitValue('change');
          }

          this.setPosition(this.newPosition);

          if (typeof window !== 'undefined') {
            document.removeEventListener('mousemove', this.onDragging);
            document.removeEventListener('touchmove', this.onDragging);
            document.removeEventListener('mouseup', this.onDragEnd);
            document.removeEventListener('touchend', this.onDragEnd);
            document.removeEventListener('contextmenu', this.onDragEnd);
          }
        },
        setPosition: function setPosition(percent) {
          if (percent === null || isNaN(percent)) return;

          if (percent < 0) {
            percent = 0;
          } else if (percent > 100) {
            percent = 100;
          }

          var stepLength = 100 / ((this.max - this.min) / this.step);
          var steps = Math.round(percent / stepLength);
          var value = steps * stepLength / 100 * (this.max - this.min) + this.min;
          value = parseFloat(value.toFixed(this.precision));
          this.$emit('input', value);

          if (!this.dragging && value !== this.oldValue) {
            this.oldValue = value;
          }
        }
      }
    };

    /* script */
    const __vue_script__$x = script$x;

    /* template */
    var __vue_render__$v = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"b-slider-thumb-wrapper",class:{ 'is-dragging': _vm.dragging, 'has-indicator': _vm.indicator},style:(_vm.wrapperStyle)},[_c('b-tooltip',{attrs:{"label":_vm.formattedValue,"type":_vm.type,"always":_vm.dragging || _vm.isFocused || _vm.tooltipAlways,"active":!_vm.disabled && _vm.tooltip}},[_c('div',_vm._b({staticClass:"b-slider-thumb",attrs:{"tabindex":_vm.disabled ? false : 0},on:{"mousedown":_vm.onButtonDown,"touchstart":_vm.onButtonDown,"focus":_vm.onFocus,"blur":_vm.onBlur,"keydown":[function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"left",37,$event.key,["Left","ArrowLeft"])){ return null; }if('button' in $event && $event.button !== 0){ return null; }$event.preventDefault();return _vm.onLeftKeyDown($event)},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"right",39,$event.key,["Right","ArrowRight"])){ return null; }if('button' in $event && $event.button !== 2){ return null; }$event.preventDefault();return _vm.onRightKeyDown($event)},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"down",40,$event.key,["Down","ArrowDown"])){ return null; }$event.preventDefault();return _vm.onLeftKeyDown($event)},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"up",38,$event.key,["Up","ArrowUp"])){ return null; }$event.preventDefault();return _vm.onRightKeyDown($event)},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"home",undefined,$event.key,undefined)){ return null; }$event.preventDefault();return _vm.onHomeKeyDown($event)},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"end",undefined,$event.key,undefined)){ return null; }$event.preventDefault();return _vm.onEndKeyDown($event)}]}},'div',_vm.$attrs,false),[(_vm.indicator)?_c('span',[_vm._v(_vm._s(_vm.formattedValue))]):_vm._e()])])],1)};
    var __vue_staticRenderFns__$v = [];

      /* style */
      const __vue_inject_styles__$x = undefined;
      /* scoped */
      const __vue_scope_id__$x = undefined;
      /* module identifier */
      const __vue_module_identifier__$x = undefined;
      /* functional template */
      const __vue_is_functional_template__$x = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var SliderThumb = normalizeComponent_1(
        { render: __vue_render__$v, staticRenderFns: __vue_staticRenderFns__$v },
        __vue_inject_styles__$x,
        __vue_script__$x,
        __vue_scope_id__$x,
        __vue_is_functional_template__$x,
        __vue_module_identifier__$x,
        undefined,
        undefined
      );

    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    var script$1$e = {
      name: 'BSliderTick',
      props: {
        value: {
          type: Number,
          default: 0
        }
      },
      computed: {
        position: function position() {
          var pos = (this.value - this.$parent.min) / (this.$parent.max - this.$parent.min) * 100;
          return pos >= 0 && pos <= 100 ? pos : 0;
        },
        hidden: function hidden() {
          return this.value === this.$parent.min || this.value === this.$parent.max;
        }
      },
      methods: {
        getTickStyle: function getTickStyle(position) {
          return {
            'left': position + '%'
          };
        }
      },
      created: function created() {
        if (!this.$parent.$data._isSlider) {
          this.$destroy();
          throw new Error('You should wrap bSliderTick on a bSlider');
        }
      }
    };

    /* script */
    const __vue_script__$1$e = script$1$e;

    /* template */
    var __vue_render__$1$d = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"b-slider-tick",class:{ 'is-tick-hidden': _vm.hidden },style:(_vm.getTickStyle(_vm.position))},[(_vm.$slots.default)?_c('span',{staticClass:"b-slider-tick-label"},[_vm._t("default")],2):_vm._e()])};
    var __vue_staticRenderFns__$1$d = [];

      /* style */
      const __vue_inject_styles__$1$e = undefined;
      /* scoped */
      const __vue_scope_id__$1$e = undefined;
      /* module identifier */
      const __vue_module_identifier__$1$e = undefined;
      /* functional template */
      const __vue_is_functional_template__$1$e = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var SliderTick = normalizeComponent_1(
        { render: __vue_render__$1$d, staticRenderFns: __vue_staticRenderFns__$1$d },
        __vue_inject_styles__$1$e,
        __vue_script__$1$e,
        __vue_scope_id__$1$e,
        __vue_is_functional_template__$1$e,
        __vue_module_identifier__$1$e,
        undefined,
        undefined
      );

    var _components$9;
    var script$2$6 = {
      name: 'BSlider',
      components: (_components$9 = {}, _defineProperty(_components$9, SliderThumb.name, SliderThumb), _defineProperty(_components$9, SliderTick.name, SliderTick), _components$9),
      props: {
        value: {
          type: [Number, Array],
          default: 0
        },
        min: {
          type: Number,
          default: 0
        },
        max: {
          type: Number,
          default: 100
        },
        step: {
          type: Number,
          default: 1
        },
        type: {
          type: String,
          default: 'is-primary'
        },
        size: String,
        ticks: {
          type: Boolean,
          default: false
        },
        tooltip: {
          type: Boolean,
          default: true
        },
        tooltipType: String,
        rounded: {
          type: Boolean,
          default: false
        },
        disabled: {
          type: Boolean,
          default: false
        },
        lazy: {
          type: Boolean,
          default: false
        },
        customFormatter: Function,
        ariaLabel: [String, Array],
        biggerSliderFocus: {
          type: Boolean,
          default: false
        },
        indicator: {
          type: Boolean,
          default: false
        },
        format: {
          type: String,
          default: 'raw',
          validator: function validator(value) {
            return ['raw', 'percent'].indexOf(value) >= 0;
          }
        },
        locale: {
          type: [String, Array],
          default: function _default() {
            return config$2.defaultLocale;
          }
        },
        tooltipAlways: {
          type: Boolean,
          default: false
        }
      },
      data: function data() {
        return {
          value1: null,
          value2: null,
          dragging: false,
          isRange: false,
          _isSlider: true // Used by Thumb and Tick

        };
      },
      computed: {
        newTooltipType: function newTooltipType() {
          return this.tooltipType ? this.tooltipType : this.type;
        },
        tickValues: function tickValues() {
          if (!this.ticks || this.min > this.max || this.step === 0) return [];
          var result = [];

          for (var i = this.min + this.step; i < this.max; i = i + this.step) {
            result.push(i);
          }

          return result;
        },
        minValue: function minValue() {
          return Math.min(this.value1, this.value2);
        },
        maxValue: function maxValue() {
          return Math.max(this.value1, this.value2);
        },
        barSize: function barSize() {
          return this.isRange ? "".concat(100 * (this.maxValue - this.minValue) / (this.max - this.min), "%") : "".concat(100 * (this.value1 - this.min) / (this.max - this.min), "%");
        },
        barStart: function barStart() {
          return this.isRange ? "".concat(100 * (this.minValue - this.min) / (this.max - this.min), "%") : '0%';
        },
        precision: function precision() {
          var precisions = [this.min, this.max, this.step].map(function (item) {
            var decimal = ('' + item).split('.')[1];
            return decimal ? decimal.length : 0;
          });
          return Math.max.apply(Math, _toConsumableArray(precisions));
        },
        barStyle: function barStyle() {
          return {
            width: this.barSize,
            left: this.barStart
          };
        },
        rootClasses: function rootClasses() {
          return {
            'is-rounded': this.rounded,
            'is-dragging': this.dragging,
            'is-disabled': this.disabled,
            'slider-focus': this.biggerSliderFocus
          };
        }
      },
      watch: {
        /**
        * When v-model is changed set the new active step.
        */
        value: function value(_value) {
          this.setValues(_value);
        },
        value1: function value1() {
          this.onInternalValueUpdate();
        },
        value2: function value2() {
          this.onInternalValueUpdate();
        },
        min: function min() {
          this.setValues(this.value);
        },
        max: function max() {
          this.setValues(this.value);
        }
      },
      methods: {
        setValues: function setValues(newValue) {
          if (this.min > this.max) {
            return;
          }

          if (Array.isArray(newValue)) {
            this.isRange = true;
            var smallValue = typeof newValue[0] !== 'number' || isNaN(newValue[0]) ? this.min : bound(newValue[0], this.min, this.max);
            var largeValue = typeof newValue[1] !== 'number' || isNaN(newValue[1]) ? this.max : bound(newValue[1], this.min, this.max);
            this.value1 = this.isThumbReversed ? largeValue : smallValue;
            this.value2 = this.isThumbReversed ? smallValue : largeValue;
          } else {
            this.isRange = false;
            this.value1 = isNaN(newValue) ? this.min : bound(newValue, this.min, this.max);
            this.value2 = null;
          }
        },
        onInternalValueUpdate: function onInternalValueUpdate() {
          if (this.isRange) {
            this.isThumbReversed = this.value1 > this.value2;
          }

          if (!this.lazy || !this.dragging) {
            this.emitValue('input');
          }

          if (this.dragging) {
            this.emitValue('dragging');
          }
        },
        sliderSize: function sliderSize() {
          return this.$refs.slider.getBoundingClientRect().width;
        },
        onSliderClick: function onSliderClick(event) {
          if (this.disabled || this.isTrackClickDisabled) return;
          var sliderOffsetLeft = this.$refs.slider.getBoundingClientRect().left;
          var percent = (event.clientX - sliderOffsetLeft) / this.sliderSize() * 100;
          var targetValue = this.min + percent * (this.max - this.min) / 100;
          var diffFirst = Math.abs(targetValue - this.value1);

          if (!this.isRange) {
            if (diffFirst < this.step / 2) return;
            this.$refs.button1.setPosition(percent);
          } else {
            var diffSecond = Math.abs(targetValue - this.value2);

            if (diffFirst <= diffSecond) {
              if (diffFirst < this.step / 2) return;
              this.$refs['button1'].setPosition(percent);
            } else {
              if (diffSecond < this.step / 2) return;
              this.$refs['button2'].setPosition(percent);
            }
          }

          this.emitValue('change');
        },
        onDragStart: function onDragStart() {
          this.dragging = true;
          this.$emit('dragstart');
        },
        onDragEnd: function onDragEnd() {
          var _this = this;

          this.isTrackClickDisabled = true;
          setTimeout(function () {
            // avoid triggering onSliderClick after dragend
            _this.isTrackClickDisabled = false;
          }, 0);
          this.dragging = false;
          this.$emit('dragend');

          if (this.lazy) {
            this.emitValue('input');
          }
        },
        emitValue: function emitValue(type) {
          this.$emit(type, this.isRange ? [this.minValue, this.maxValue] : this.value1);
        }
      },
      created: function created() {
        this.isThumbReversed = false;
        this.isTrackClickDisabled = false;
        this.setValues(this.value);
      }
    };

    /* script */
    const __vue_script__$2$6 = script$2$6;

    /* template */
    var __vue_render__$2$5 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"b-slider",class:[_vm.size, _vm.type, _vm.rootClasses ],on:{"click":_vm.onSliderClick}},[_c('div',{ref:"slider",staticClass:"b-slider-track"},[_c('div',{staticClass:"b-slider-fill",style:(_vm.barStyle)}),(_vm.ticks)?_vm._l((_vm.tickValues),function(val,key){return _c('b-slider-tick',{key:key,attrs:{"value":val}})}):_vm._e(),_vm._t("default"),_c('b-slider-thumb',{ref:"button1",attrs:{"tooltip-always":_vm.tooltipAlways,"type":_vm.newTooltipType,"tooltip":_vm.tooltip,"custom-formatter":_vm.customFormatter,"indicator":_vm.indicator,"format":_vm.format,"locale":_vm.locale,"role":"slider","aria-valuenow":_vm.value1,"aria-valuemin":_vm.min,"aria-valuemax":_vm.max,"aria-orientation":"horizontal","aria-label":Array.isArray(_vm.ariaLabel) ? _vm.ariaLabel[0] : _vm.ariaLabel,"aria-disabled":_vm.disabled},on:{"dragstart":_vm.onDragStart,"dragend":_vm.onDragEnd},model:{value:(_vm.value1),callback:function ($$v) {_vm.value1=$$v;},expression:"value1"}}),(_vm.isRange)?_c('b-slider-thumb',{ref:"button2",attrs:{"tooltip-always":_vm.tooltipAlways,"type":_vm.newTooltipType,"tooltip":_vm.tooltip,"custom-formatter":_vm.customFormatter,"indicator":_vm.indicator,"format":_vm.format,"locale":_vm.locale,"role":"slider","aria-valuenow":_vm.value2,"aria-valuemin":_vm.min,"aria-valuemax":_vm.max,"aria-orientation":"horizontal","aria-label":Array.isArray(_vm.ariaLabel) ? _vm.ariaLabel[1] : '',"aria-disabled":_vm.disabled},on:{"dragstart":_vm.onDragStart,"dragend":_vm.onDragEnd},model:{value:(_vm.value2),callback:function ($$v) {_vm.value2=$$v;},expression:"value2"}}):_vm._e()],2)])};
    var __vue_staticRenderFns__$2$5 = [];

      /* style */
      const __vue_inject_styles__$2$6 = undefined;
      /* scoped */
      const __vue_scope_id__$2$6 = undefined;
      /* module identifier */
      const __vue_module_identifier__$2$6 = undefined;
      /* functional template */
      const __vue_is_functional_template__$2$6 = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var Slider = normalizeComponent_1(
        { render: __vue_render__$2$5, staticRenderFns: __vue_staticRenderFns__$2$5 },
        __vue_inject_styles__$2$6,
        __vue_script__$2$6,
        __vue_scope_id__$2$6,
        __vue_is_functional_template__$2$6,
        __vue_module_identifier__$2$6,
        undefined,
        undefined
      );

    var Plugin$u = {
      install: function install(Vue) {
        registerComponent(Vue, Slider);
        registerComponent(Vue, SliderTick);
      }
    };
    use(Plugin$u);

    //
    var script$y = {
      name: 'BSnackbar',
      mixins: [NoticeMixin],
      props: {
        actionText: {
          type: String,
          default: 'OK'
        },
        onAction: {
          type: Function,
          default: function _default() {}
        },
        cancelText: {
          type: String | null,
          default: null
        }
      },
      data: function data() {
        return {
          newDuration: this.duration || config$2.defaultSnackbarDuration
        };
      },
      methods: {
        /**
        * Click listener.
        * Call action prop before closing (from Mixin).
        */
        action: function action() {
          this.onAction();
          this.close();
        }
      }
    };

    /* script */
    const __vue_script__$y = script$y;

    /* template */
    var __vue_render__$w = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"enter-active-class":_vm.transition.enter,"leave-active-class":_vm.transition.leave}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.isActive),expression:"isActive"}],staticClass:"snackbar",class:[_vm.type,_vm.position],attrs:{"role":_vm.actionText ? 'alertdialog' : 'alert'},on:{"mouseenter":_vm.pause,"mouseleave":_vm.removePause}},[(_vm.$slots.default)?[_vm._t("default")]:[_c('div',{staticClass:"text",domProps:{"innerHTML":_vm._s(_vm.message)}})],(_vm.cancelText)?_c('div',{staticClass:"action is-light is-cancel",on:{"click":_vm.close}},[_c('button',{staticClass:"button"},[_vm._v(_vm._s(_vm.cancelText))])]):_vm._e(),(_vm.actionText)?_c('div',{staticClass:"action",class:_vm.type,on:{"click":_vm.action}},[_c('button',{staticClass:"button"},[_vm._v(_vm._s(_vm.actionText))])]):_vm._e()],2)])};
    var __vue_staticRenderFns__$w = [];

      /* style */
      const __vue_inject_styles__$y = undefined;
      /* scoped */
      const __vue_scope_id__$y = undefined;
      /* module identifier */
      const __vue_module_identifier__$y = undefined;
      /* functional template */
      const __vue_is_functional_template__$y = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var Snackbar = normalizeComponent_1(
        { render: __vue_render__$w, staticRenderFns: __vue_staticRenderFns__$w },
        __vue_inject_styles__$y,
        __vue_script__$y,
        __vue_scope_id__$y,
        __vue_is_functional_template__$y,
        __vue_module_identifier__$y,
        undefined,
        undefined
      );

    var localVueInstance$4;
    var SnackbarProgrammatic = {
      open: function open(params) {
        var parent;

        if (typeof params === 'string') {
          params = {
            message: params
          };
        }

        var defaultParam = {
          type: 'is-success',
          position: config$2.defaultSnackbarPosition || 'is-bottom-right',
          queue: true
        };

        if (params.parent) {
          parent = params.parent;
          delete params.parent;
        }

        var slot;

        if (Array.isArray(params.message)) {
          slot = params.message;
          delete params.message;
        }

        var propsData = merge$1(defaultParam, params);
        var vm = typeof window !== 'undefined' && window.Vue ? window.Vue : localVueInstance$4 || VueInstance;
        var SnackbarComponent = vm.extend(Snackbar);
        var component = new SnackbarComponent({
          parent: parent,
          el: document.createElement('div'),
          propsData: propsData
        });

        if (slot) {
          component.$slots.default = slot;
          component.$forceUpdate();
        }

        return component;
      }
    };
    var Plugin$v = {
      install: function install(Vue) {
        localVueInstance$4 = Vue;
        registerComponentProgrammatic(Vue, 'snackbar', SnackbarProgrammatic);
      }
    };
    use(Plugin$v);

    var SlotComponent = {
      name: 'BSlotComponent',
      props: {
        component: {
          type: Object,
          required: true
        },
        name: {
          type: String,
          default: 'default'
        },
        scoped: {
          type: Boolean
        },
        props: {
          type: Object
        },
        tag: {
          type: String,
          default: 'div'
        },
        event: {
          type: String,
          default: 'hook:updated'
        }
      },
      methods: {
        refresh: function refresh() {
          this.$forceUpdate();
        }
      },
      created: function created() {
        if (isVueComponent(this.component)) {
          this.component.$on(this.event, this.refresh);
        }
      },
      beforeDestroy: function beforeDestroy() {
        if (isVueComponent(this.component)) {
          this.component.$off(this.event, this.refresh);
        }
      },
      render: function render(createElement) {
        if (isVueComponent(this.component)) {
          return createElement(this.tag, {}, this.scoped ? this.component.$scopedSlots[this.name](this.props) : this.component.$slots[this.name]);
        }
      }
    };

    var TabbedMixin = (function (cmp) {
      var _components;

      return {
        mixins: [ProviderParentMixin(cmp, Sorted)],
        components: (_components = {}, _defineProperty(_components, Icon.name, Icon), _defineProperty(_components, SlotComponent.name, SlotComponent), _components),
        props: {
          value: {
            type: [String, Number],
            default: undefined
          },
          size: String,
          animated: {
            type: Boolean,
            default: true
          },
          animation: String,
          animateInitially: Boolean,
          vertical: {
            type: Boolean,
            default: false
          },
          position: String,
          destroyOnHide: {
            type: Boolean,
            default: false
          }
        },
        data: function data() {
          return {
            activeId: this.value,
            // Internal state
            defaultSlots: [],
            contentHeight: 0,
            isTransitioning: false
          };
        },
        mounted: function mounted() {
          if (typeof this.value === 'number') {
            // Backward compatibility: converts the index value to an id
            var value = bound(this.value, 0, this.items.length - 1);
            this.activeId = this.items[value].value;
          } else {
            this.activeId = this.value;
          }
        },
        computed: {
          activeItem: function activeItem() {
            var _this = this;

            return this.activeId === undefined ? this.items[0] : this.activeId === null ? null : this.childItems.find(function (i) {
              return i.value === _this.activeId;
            });
          },
          items: function items() {
            return this.sortedItems;
          }
        },
        watch: {
          /**
           * When v-model is changed set the new active tab.
           */
          value: function value(_value) {
            if (typeof _value === 'number') {
              // Backward compatibility: converts the index value to an id
              _value = bound(_value, 0, this.items.length - 1);
              this.activeId = this.items[_value].value;
            } else {
              this.activeId = _value;
            }
          },

          /**
           * Sync internal state with external state
           */
          activeId: function activeId(val, oldValue) {
            var oldTab = oldValue !== undefined && oldValue !== null ? this.childItems.find(function (i) {
              return i.value === oldValue;
            }) : null;

            if (oldTab && this.activeItem) {
              oldTab.deactivate(this.activeItem.index);
              this.activeItem.activate(oldTab.index);
            }

            val = this.activeItem ? typeof this.value === 'number' ? this.items.indexOf(this.activeItem) : this.activeItem.value : undefined;

            if (val !== this.value) {
              this.$emit('input', val);
            }
          }
        },
        methods: {
          /**
          * Child click listener, emit input event and change active child.
          */
          childClick: function childClick(child) {
            this.activeId = child.value;
          },
          getNextItemIdx: function getNextItemIdx(fromIdx) {
            var skipDisabled = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            var nextItemIdx = null;
            var idx = fromIdx + 1;

            for (; idx < this.items.length; idx++) {
              var item = this.items[idx];

              if (item.visible && (!skipDisabled || skipDisabled && !item.disabled)) {
                nextItemIdx = idx;
                break;
              }
            }

            return nextItemIdx;
          },
          getPrevItemIdx: function getPrevItemIdx(fromIdx) {
            var skipDisabled = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            var prevItemIdx = null;

            for (var idx = fromIdx - 1; idx >= 0; idx--) {
              var item = this.items[idx];

              if (item.visible && (!skipDisabled || skipDisabled && !item.disabled)) {
                prevItemIdx = idx;
                break;
              }
            }

            return prevItemIdx;
          }
        }
      };
    });

    var TabbedChildMixin = (function (parentCmp) {
      return {
        mixins: [InjectedChildMixin(parentCmp, Sorted$1)],
        props: {
          label: String,
          icon: String,
          iconPack: String,
          visible: {
            type: Boolean,
            default: true
          },
          value: {
            type: String,
            default: function _default() {
              return this._uid.toString();
            }
          },
          headerClass: {
            type: [String, Array, Object],
            default: null
          }
        },
        data: function data() {
          return {
            transitionName: null,
            elementClass: 'item',
            elementRole: null
          };
        },
        computed: {
          isActive: function isActive() {
            return this.parent.activeItem === this;
          }
        },
        methods: {
          /**
           * Activate element, alter animation name based on the index.
           */
          activate: function activate(oldIndex) {
            this.transitionName = this.index < oldIndex ? this.parent.vertical ? 'slide-down' : 'slide-next' : this.parent.vertical ? 'slide-up' : 'slide-prev';
          },

          /**
           * Deactivate element, alter animation name based on the index.
           */
          deactivate: function deactivate(newIndex) {
            this.transitionName = newIndex < this.index ? this.parent.vertical ? 'slide-down' : 'slide-next' : this.parent.vertical ? 'slide-up' : 'slide-prev';
          }
        },
        render: function render(createElement) {
          var _this = this;

          // if destroy apply v-if
          if (this.parent.destroyOnHide) {
            if (!this.isActive || !this.visible) {
              return;
            }
          }

          var vnode = createElement('div', {
            directives: [{
              name: 'show',
              value: this.isActive && this.visible
            }],
            attrs: {
              'class': this.elementClass,
              'role': this.elementRole,
              'id': "".concat(this.value, "-content"),
              'aria-labelledby': this.elementRole ? "".concat(this.value, "-label") : null,
              'tabindex': this.isActive ? 0 : -1
            }
          }, this.$slots.default); // check animated prop

          if (this.parent.animated) {
            return createElement('transition', {
              props: {
                'name': this.parent.animation || this.transitionName,
                'appear': this.parent.animateInitially === true || undefined
              },
              on: {
                'before-enter': function beforeEnter() {
                  _this.parent.isTransitioning = true;
                },
                'after-enter': function afterEnter() {
                  _this.parent.isTransitioning = false;
                }
              }
            }, [vnode]);
          }

          return vnode;
        }
      };
    });

    var script$z = {
      name: 'BSteps',
      components: _defineProperty({}, Icon.name, Icon),
      mixins: [TabbedMixin('step')],
      props: {
        type: [String, Object],
        iconPack: String,
        iconPrev: {
          type: String,
          default: function _default() {
            return config$2.defaultIconPrev;
          }
        },
        iconNext: {
          type: String,
          default: function _default() {
            return config$2.defaultIconNext;
          }
        },
        hasNavigation: {
          type: Boolean,
          default: true
        },
        labelPosition: {
          type: String,
          validator: function validator(value) {
            return ['bottom', 'right', 'left'].indexOf(value) > -1;
          },
          default: 'bottom'
        },
        rounded: {
          type: Boolean,
          default: true
        },
        mobileMode: {
          type: String,
          validator: function validator(value) {
            return ['minimalist', 'compact'].indexOf(value) > -1;
          },
          default: 'minimalist'
        },
        ariaNextLabel: String,
        ariaPreviousLabel: String
      },
      computed: {
        // Override mixin implementation to always have a value
        activeItem: function activeItem() {
          var _this = this;

          return this.childItems.filter(function (i) {
            return i.value === _this.activeId;
          })[0] || this.items[0];
        },
        wrapperClasses: function wrapperClasses() {
          return [this.size, _defineProperty({
            'is-vertical': this.vertical
          }, this.position, this.position && this.vertical)];
        },
        mainClasses: function mainClasses() {
          return [this.type, _defineProperty({
            'has-label-right': this.labelPosition === 'right',
            'has-label-left': this.labelPosition === 'left',
            'is-animated': this.animated,
            'is-rounded': this.rounded
          }, "mobile-".concat(this.mobileMode), this.mobileMode !== null)];
        },

        /**
         * Check if previous button is available.
         */
        hasPrev: function hasPrev() {
          return this.prevItemIdx !== null;
        },

        /**
         * Retrieves the next visible item index
         */
        nextItemIdx: function nextItemIdx() {
          var idx = this.activeItem ? this.items.indexOf(this.activeItem) : 0;
          return this.getNextItemIdx(idx);
        },

        /**
         * Retrieves the next visible item
         */
        nextItem: function nextItem() {
          var nextItem = null;

          if (this.nextItemIdx !== null) {
            nextItem = this.items[this.nextItemIdx];
          }

          return nextItem;
        },

        /**
        * Retrieves the next visible item index
        */
        prevItemIdx: function prevItemIdx() {
          if (!this.activeItem) {
            return null;
          }

          var idx = this.items.indexOf(this.activeItem);
          return this.getPrevItemIdx(idx);
        },

        /**
         * Retrieves the previous visible item
         */
        prevItem: function prevItem() {
          if (!this.activeItem) {
            return null;
          }

          var prevItem = null;

          if (this.prevItemIdx !== null) {
            prevItem = this.items[this.prevItemIdx];
          }

          return prevItem;
        },

        /**
         * Check if next button is available.
         */
        hasNext: function hasNext() {
          return this.nextItemIdx !== null;
        },
        navigationProps: function navigationProps() {
          return {
            previous: {
              disabled: !this.hasPrev,
              action: this.prev
            },
            next: {
              disabled: !this.hasNext,
              action: this.next
            }
          };
        }
      },
      methods: {
        /**
         * Return if the step should be clickable or not.
         */
        isItemClickable: function isItemClickable(stepItem) {
          if (stepItem.clickable === undefined) {
            return stepItem.index < this.activeItem.index;
          }

          return stepItem.clickable;
        },

        /**
         * Previous button click listener.
         */
        prev: function prev() {
          if (this.hasPrev) {
            this.activeId = this.prevItem.value;
          }
        },

        /**
         * Previous button click listener.
         */
        next: function next() {
          if (this.hasNext) {
            this.activeId = this.nextItem.value;
          }
        }
      }
    };

    /* script */
    const __vue_script__$z = script$z;

    /* template */
    var __vue_render__$x = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"b-steps",class:_vm.wrapperClasses},[_c('nav',{staticClass:"steps",class:_vm.mainClasses},[_c('ul',{staticClass:"step-items"},_vm._l((_vm.items),function(childItem){return _c('li',{directives:[{name:"show",rawName:"v-show",value:(childItem.visible),expression:"childItem.visible"}],key:childItem.value,staticClass:"step-item",class:[childItem.type || _vm.type, childItem.headerClass, {
                        'is-active': childItem.isActive,
                        'is-previous': _vm.activeItem.index > childItem.index
                }]},[_c('a',{staticClass:"step-link",class:{'is-clickable': _vm.isItemClickable(childItem)},on:{"click":function($event){_vm.isItemClickable(childItem) && _vm.childClick(childItem);}}},[_c('div',{staticClass:"step-marker"},[(childItem.icon)?_c('b-icon',{attrs:{"icon":childItem.icon,"pack":childItem.iconPack,"size":_vm.size}}):(childItem.step)?_c('span',[_vm._v(_vm._s(childItem.step))]):_vm._e()],1),_c('div',{staticClass:"step-details"},[_c('span',{staticClass:"step-title"},[_vm._v(_vm._s(childItem.label))])])])])}),0)]),_c('section',{staticClass:"step-content",class:{'is-transitioning': _vm.isTransitioning}},[_vm._t("default")],2),_vm._t("navigation",[(_vm.hasNavigation)?_c('nav',{staticClass:"step-navigation"},[_c('a',{staticClass:"pagination-previous",attrs:{"role":"button","disabled":_vm.navigationProps.previous.disabled,"aria-label":_vm.ariaPreviousLabel},on:{"click":function($event){$event.preventDefault();return _vm.navigationProps.previous.action($event)}}},[_c('b-icon',{attrs:{"icon":_vm.iconPrev,"pack":_vm.iconPack,"both":"","aria-hidden":"true"}})],1),_c('a',{staticClass:"pagination-next",attrs:{"role":"button","disabled":_vm.navigationProps.next.disabled,"aria-label":_vm.ariaNextLabel},on:{"click":function($event){$event.preventDefault();return _vm.navigationProps.next.action($event)}}},[_c('b-icon',{attrs:{"icon":_vm.iconNext,"pack":_vm.iconPack,"both":"","aria-hidden":"true"}})],1)]):_vm._e()],{"previous":_vm.navigationProps.previous,"next":_vm.navigationProps.next})],2)};
    var __vue_staticRenderFns__$x = [];

      /* style */
      const __vue_inject_styles__$z = undefined;
      /* scoped */
      const __vue_scope_id__$z = undefined;
      /* module identifier */
      const __vue_module_identifier__$z = undefined;
      /* functional template */
      const __vue_is_functional_template__$z = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var Steps = normalizeComponent_1(
        { render: __vue_render__$x, staticRenderFns: __vue_staticRenderFns__$x },
        __vue_inject_styles__$z,
        __vue_script__$z,
        __vue_scope_id__$z,
        __vue_is_functional_template__$z,
        __vue_module_identifier__$z,
        undefined,
        undefined
      );

    var script$1$f = {
      name: 'BStepItem',
      mixins: [TabbedChildMixin('step')],
      props: {
        step: [String, Number],
        type: [String, Object],
        clickable: {
          type: Boolean,
          default: undefined
        }
      },
      data: function data() {
        return {
          elementClass: 'step-item'
        };
      }
    };

    /* script */
    const __vue_script__$1$f = script$1$f;

    /* template */

      /* style */
      const __vue_inject_styles__$1$f = undefined;
      /* scoped */
      const __vue_scope_id__$1$f = undefined;
      /* module identifier */
      const __vue_module_identifier__$1$f = undefined;
      /* functional template */
      const __vue_is_functional_template__$1$f = undefined;
      /* style inject */
      
      /* style inject SSR */
      

      
      var StepItem = normalizeComponent_1(
        {},
        __vue_inject_styles__$1$f,
        __vue_script__$1$f,
        __vue_scope_id__$1$f,
        __vue_is_functional_template__$1$f,
        __vue_module_identifier__$1$f,
        undefined,
        undefined
      );

    var Plugin$w = {
      install: function install(Vue) {
        registerComponent(Vue, Steps);
        registerComponent(Vue, StepItem);
      }
    };
    use(Plugin$w);

    //
    var script$A = {
      name: 'BSwitch',
      props: {
        value: [String, Number, Boolean, Function, Object, Array, Date],
        nativeValue: [String, Number, Boolean, Function, Object, Array, Date],
        disabled: Boolean,
        type: String,
        passiveType: String,
        name: String,
        required: Boolean,
        size: String,
        ariaLabelledby: String,
        trueValue: {
          type: [String, Number, Boolean, Function, Object, Array, Date],
          default: true
        },
        falseValue: {
          type: [String, Number, Boolean, Function, Object, Array, Date],
          default: false
        },
        rounded: {
          type: Boolean,
          default: function _default() {
            return config$2.defaultSwitchRounded;
          }
        },
        outlined: {
          type: Boolean,
          default: false
        },
        leftLabel: {
          type: Boolean,
          default: false
        }
      },
      data: function data() {
        return {
          newValue: this.value,
          isMouseDown: false
        };
      },
      computed: {
        computedValue: {
          get: function get() {
            return this.newValue;
          },
          set: function set(value) {
            this.newValue = value;
            this.$emit('input', value);
          }
        },
        newClass: function newClass() {
          return [this.size, {
            'is-disabled': this.disabled,
            'is-rounded': this.rounded,
            'is-outlined': this.outlined,
            'has-left-label': this.leftLabel
          }];
        },
        checkClasses: function checkClasses() {
          return [{
            'is-elastic': this.isMouseDown && !this.disabled
          }, this.passiveType && "".concat(this.passiveType, "-passive"), this.type];
        },
        showControlLabel: function showControlLabel() {
          return !!this.$slots.default;
        }
      },
      watch: {
        /**
        * When v-model change, set internal value.
        */
        value: function value(_value) {
          this.newValue = _value;
        }
      },
      methods: {
        focus: function focus() {
          // MacOS FireFox and Safari do not focus when clicked
          this.$refs.input.focus();
        }
      }
    };

    /* script */
    const __vue_script__$A = script$A;

    /* template */
    var __vue_render__$y = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('label',{ref:"label",staticClass:"switch",class:_vm.newClass,attrs:{"disabled":_vm.disabled},on:{"click":_vm.focus,"keydown":function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"enter",13,$event.key,"Enter")){ return null; }$event.preventDefault();return _vm.$refs.label.click()},"mousedown":function($event){_vm.isMouseDown = true;},"mouseup":function($event){_vm.isMouseDown = false;},"mouseout":function($event){_vm.isMouseDown = false;},"blur":function($event){_vm.isMouseDown = false;}}},[_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.computedValue),expression:"computedValue"}],ref:"input",attrs:{"type":"checkbox","disabled":_vm.disabled,"name":_vm.name,"required":_vm.required,"true-value":_vm.trueValue,"false-value":_vm.falseValue,"aria-labelledby":_vm.ariaLabelledby},domProps:{"value":_vm.nativeValue,"checked":Array.isArray(_vm.computedValue)?_vm._i(_vm.computedValue,_vm.nativeValue)>-1:_vm._q(_vm.computedValue,_vm.trueValue)},on:{"click":function($event){$event.stopPropagation();},"change":function($event){var $$a=_vm.computedValue,$$el=$event.target,$$c=$$el.checked?(_vm.trueValue):(_vm.falseValue);if(Array.isArray($$a)){var $$v=_vm.nativeValue,$$i=_vm._i($$a,$$v);if($$el.checked){$$i<0&&(_vm.computedValue=$$a.concat([$$v]));}else {$$i>-1&&(_vm.computedValue=$$a.slice(0,$$i).concat($$a.slice($$i+1)));}}else {_vm.computedValue=$$c;}}}}),_c('span',{staticClass:"check",class:_vm.checkClasses}),(_vm.showControlLabel)?_c('span',{staticClass:"control-label",attrs:{"id":_vm.ariaLabelledby}},[_vm._t("default")],2):_vm._e()])};
    var __vue_staticRenderFns__$y = [];

      /* style */
      const __vue_inject_styles__$A = undefined;
      /* scoped */
      const __vue_scope_id__$A = undefined;
      /* module identifier */
      const __vue_module_identifier__$A = undefined;
      /* functional template */
      const __vue_is_functional_template__$A = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var Switch = normalizeComponent_1(
        { render: __vue_render__$y, staticRenderFns: __vue_staticRenderFns__$y },
        __vue_inject_styles__$A,
        __vue_script__$A,
        __vue_scope_id__$A,
        __vue_is_functional_template__$A,
        __vue_module_identifier__$A,
        undefined,
        undefined
      );

    var Plugin$x = {
      install: function install(Vue) {
        registerComponent(Vue, Switch);
      }
    };
    use(Plugin$x);

    var _components$a;
    var script$B = {
      name: 'BTableMobileSort',
      components: (_components$a = {}, _defineProperty(_components$a, Select.name, Select), _defineProperty(_components$a, Icon.name, Icon), _components$a),
      props: {
        currentSortColumn: Object,
        sortMultipleData: Array,
        isAsc: Boolean,
        columns: Array,
        placeholder: String,
        iconPack: String,
        sortIcon: {
          type: String,
          default: 'arrow-up'
        },
        sortIconSize: {
          type: String,
          default: 'is-small'
        },
        sortMultiple: {
          type: Boolean,
          default: false
        }
      },
      data: function data() {
        return {
          sortMultipleSelect: '',
          mobileSort: this.currentSortColumn,
          defaultEvent: {
            shiftKey: true,
            altKey: true,
            ctrlKey: true
          },
          ignoreSort: false
        };
      },
      computed: {
        showPlaceholder: function showPlaceholder() {
          var _this = this;

          return !this.columns || !this.columns.some(function (column) {
            return column === _this.mobileSort;
          });
        }
      },
      watch: {
        sortMultipleSelect: function sortMultipleSelect(column) {
          if (this.ignoreSort) {
            this.ignoreSort = false;
          } else {
            this.$emit('sort', column, this.defaultEvent);
          }
        },
        mobileSort: function mobileSort(column) {
          if (this.currentSortColumn === column) return;
          this.$emit('sort', column, this.defaultEvent);
        },
        currentSortColumn: function currentSortColumn(column) {
          this.mobileSort = column;
        }
      },
      methods: {
        removePriority: function removePriority() {
          var _this2 = this;

          this.$emit('removePriority', this.sortMultipleSelect); // ignore the watcher to sort when we just change whats displayed in the select
          // otherwise the direction will be flipped
          // The sort event is already triggered by the emit

          this.ignoreSort = true; // Select one of the other options when we reset one

          var remainingFields = this.sortMultipleData.filter(function (data) {
            return data.field !== _this2.sortMultipleSelect.field;
          }).map(function (data) {
            return data.field;
          });
          this.sortMultipleSelect = this.columns.filter(function (column) {
            return remainingFields.includes(column.field);
          })[0];
        },
        getSortingObjectOfColumn: function getSortingObjectOfColumn(column) {
          return this.sortMultipleData.filter(function (i) {
            return i.field === column.field;
          })[0];
        },
        columnIsDesc: function columnIsDesc(column) {
          var sortingObject = this.getSortingObjectOfColumn(column);

          if (sortingObject) {
            return !!(sortingObject.order && sortingObject.order === 'desc');
          }

          return true;
        },
        getLabel: function getLabel(column) {
          var sortingObject = this.getSortingObjectOfColumn(column);

          if (sortingObject) {
            return column.label + '(' + (this.sortMultipleData.indexOf(sortingObject) + 1) + ')';
          }

          return column.label;
        },
        sort: function sort() {
          this.$emit('sort', this.sortMultiple ? this.sortMultipleSelect : this.mobileSort, this.defaultEvent);
        }
      }
    };

    /* script */
    const __vue_script__$B = script$B;

    /* template */
    var __vue_render__$z = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"field table-mobile-sort"},[_c('div',{staticClass:"field has-addons"},[(_vm.sortMultiple)?_c('b-select',{attrs:{"expanded":""},model:{value:(_vm.sortMultipleSelect),callback:function ($$v) {_vm.sortMultipleSelect=$$v;},expression:"sortMultipleSelect"}},_vm._l((_vm.columns),function(column,index){return (column.sortable)?_c('option',{key:index,domProps:{"value":column}},[_vm._v(" "+_vm._s(_vm.getLabel(column))+" "),(_vm.getSortingObjectOfColumn(column))?[(_vm.columnIsDesc(column))?[_vm._v(" ↓ ")]:[_vm._v(" ↑ ")]]:_vm._e()],2):_vm._e()}),0):_c('b-select',{attrs:{"expanded":""},model:{value:(_vm.mobileSort),callback:function ($$v) {_vm.mobileSort=$$v;},expression:"mobileSort"}},[(_vm.placeholder)?[_c('option',{directives:[{name:"show",rawName:"v-show",value:(_vm.showPlaceholder),expression:"showPlaceholder"}],attrs:{"selected":"","disabled":"","hidden":""},domProps:{"value":{}}},[_vm._v(" "+_vm._s(_vm.placeholder)+" ")])]:_vm._e(),_vm._l((_vm.columns),function(column,index){return (column.sortable)?_c('option',{key:index,domProps:{"value":column}},[_vm._v(" "+_vm._s(column.label)+" ")]):_vm._e()})],2),_c('div',{staticClass:"control"},[(_vm.sortMultiple && _vm.sortMultipleData.length > 0)?[_c('button',{staticClass:"button is-primary",on:{"click":_vm.sort}},[_c('b-icon',{class:{ 'is-desc': _vm.columnIsDesc(_vm.sortMultipleSelect) },attrs:{"icon":_vm.sortIcon,"pack":_vm.iconPack,"size":_vm.sortIconSize,"both":""}})],1),_c('button',{staticClass:"button is-primary",on:{"click":_vm.removePriority}},[_c('b-icon',{attrs:{"icon":"delete","size":_vm.sortIconSize,"both":""}})],1)]:(!_vm.sortMultiple)?_c('button',{staticClass:"button is-primary",on:{"click":_vm.sort}},[_c('b-icon',{directives:[{name:"show",rawName:"v-show",value:(_vm.currentSortColumn === _vm.mobileSort),expression:"currentSortColumn === mobileSort"}],class:{ 'is-desc': !_vm.isAsc },attrs:{"icon":_vm.sortIcon,"pack":_vm.iconPack,"size":_vm.sortIconSize,"both":""}})],1):_vm._e()],2)],1)])};
    var __vue_staticRenderFns__$z = [];

      /* style */
      const __vue_inject_styles__$B = undefined;
      /* scoped */
      const __vue_scope_id__$B = undefined;
      /* module identifier */
      const __vue_module_identifier__$B = undefined;
      /* functional template */
      const __vue_is_functional_template__$B = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var TableMobileSort = normalizeComponent_1(
        { render: __vue_render__$z, staticRenderFns: __vue_staticRenderFns__$z },
        __vue_inject_styles__$B,
        __vue_script__$B,
        __vue_scope_id__$B,
        __vue_is_functional_template__$B,
        __vue_module_identifier__$B,
        undefined,
        undefined
      );

    var script$1$g = {
      name: 'BTableColumn',
      inject: {
        $table: {
          name: '$table',
          default: false
        }
      },
      props: {
        label: String,
        customKey: [String, Number],
        field: String,
        meta: [String, Number, Boolean, Function, Object, Array],
        width: [Number, String],
        numeric: Boolean,
        centered: Boolean,
        searchable: Boolean,
        sortable: Boolean,
        visible: {
          type: Boolean,
          default: true
        },
        subheading: [String, Number],
        customSort: Function,
        customSearch: Function,
        sticky: Boolean,
        headerSelectable: Boolean,
        headerClass: String,
        cellClass: String,
        thAttrs: {
          type: Function,
          default: function _default() {
            return {};
          }
        },
        tdAttrs: {
          type: Function,
          default: function _default() {
            return {};
          }
        }
      },
      data: function data() {
        return {
          newKey: this.customKey || this.label,
          _isTableColumn: true
        };
      },
      computed: {
        thClasses: function thClasses() {
          var attrs = this.thAttrs(this);
          var classes = [this.headerClass, {
            'is-sortable': this.sortable,
            'is-sticky': this.sticky,
            'is-unselectable': this.isHeaderUnSelectable
          }];

          if (attrs && attrs.class) {
            classes.push(attrs.class);
          }

          return classes;
        },
        thStyle: function thStyle() {
          var attrs = this.thAttrs(this);
          var style = [this.style];

          if (attrs && attrs.style) {
            style.push(attrs.style);
          }

          return style;
        },
        rootClasses: function rootClasses() {
          return [this.cellClass, {
            'has-text-right': this.numeric && !this.centered,
            'has-text-centered': this.centered,
            'is-sticky': this.sticky
          }];
        },
        style: function style() {
          return {
            width: toCssWidth(this.width)
          };
        },
        hasDefaultSlot: function hasDefaultSlot() {
          return !!this.$scopedSlots.default;
        },

        /**
         * Return if column header is un-selectable
         */
        isHeaderUnSelectable: function isHeaderUnSelectable() {
          return !this.headerSelectable && this.sortable;
        }
      },
      methods: {
        getRootClasses: function getRootClasses(row) {
          var attrs = this.tdAttrs(row, this);
          var classes = [this.rootClasses];

          if (attrs && attrs.class) {
            classes.push(attrs.class);
          }

          return classes;
        },
        getRootStyle: function getRootStyle(row) {
          var attrs = this.tdAttrs(row, this);
          var style = [];

          if (attrs && attrs.style) {
            style.push(attrs.style);
          }

          return style;
        }
      },
      created: function created() {
        if (!this.$table) {
          this.$destroy();
          throw new Error('You should wrap bTableColumn on a bTable');
        }

        this.$table.refreshSlots();
      },
      render: function render(createElement) {
        // renderless
        return null;
      }
    };

    /* script */
    const __vue_script__$1$g = script$1$g;

    /* template */

      /* style */
      const __vue_inject_styles__$1$g = undefined;
      /* scoped */
      const __vue_scope_id__$1$g = undefined;
      /* module identifier */
      const __vue_module_identifier__$1$g = undefined;
      /* functional template */
      const __vue_is_functional_template__$1$g = undefined;
      /* style inject */
      
      /* style inject SSR */
      

      
      var TableColumn = normalizeComponent_1(
        {},
        __vue_inject_styles__$1$g,
        __vue_script__$1$g,
        __vue_scope_id__$1$g,
        __vue_is_functional_template__$1$g,
        __vue_module_identifier__$1$g,
        undefined,
        undefined
      );

    var script$2$7 = {
      name: 'BTablePagination',
      components: _defineProperty({}, Pagination.name, Pagination),
      props: {
        paginated: Boolean,
        total: [Number, String],
        perPage: [Number, String],
        currentPage: [Number, String],
        paginationSimple: Boolean,
        paginationSize: String,
        rounded: Boolean,
        iconPack: String,
        ariaNextLabel: String,
        ariaPreviousLabel: String,
        ariaPageLabel: String,
        ariaCurrentLabel: String,
        pageInput: Boolean,
        paginationOrder: String,
        pageInputPosition: String,
        debouncePageInput: [Number, String]
      },
      data: function data() {
        return {
          newCurrentPage: this.currentPage
        };
      },
      watch: {
        currentPage: function currentPage(newVal) {
          this.newCurrentPage = newVal;
        }
      },
      methods: {
        /**
        * Paginator change listener.
        */
        pageChanged: function pageChanged(page) {
          this.newCurrentPage = page > 0 ? page : 1;
          this.$emit('update:currentPage', this.newCurrentPage);
          this.$emit('page-change', this.newCurrentPage);
        }
      }
    };

    /* script */
    const __vue_script__$2$7 = script$2$7;

    /* template */
    var __vue_render__$1$e = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"top level"},[_c('div',{staticClass:"level-left"},[_vm._t("default")],2),_c('div',{staticClass:"level-right"},[(_vm.paginated)?_c('div',{staticClass:"level-item"},[_c('b-pagination',{attrs:{"icon-pack":_vm.iconPack,"total":_vm.total,"per-page":_vm.perPage,"simple":_vm.paginationSimple,"size":_vm.paginationSize,"current":_vm.newCurrentPage,"rounded":_vm.rounded,"aria-next-label":_vm.ariaNextLabel,"aria-previous-label":_vm.ariaPreviousLabel,"aria-page-label":_vm.ariaPageLabel,"aria-current-label":_vm.ariaCurrentLabel,"page-input":_vm.pageInput,"order":_vm.paginationOrder,"page-input-position":_vm.pageInputPosition,"debounce-page-input":_vm.debouncePageInput},on:{"change":_vm.pageChanged}})],1):_vm._e()])])};
    var __vue_staticRenderFns__$1$e = [];

      /* style */
      const __vue_inject_styles__$2$7 = undefined;
      /* scoped */
      const __vue_scope_id__$2$7 = undefined;
      /* module identifier */
      const __vue_module_identifier__$2$7 = undefined;
      /* functional template */
      const __vue_is_functional_template__$2$7 = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var TablePagination = normalizeComponent_1(
        { render: __vue_render__$1$e, staticRenderFns: __vue_staticRenderFns__$1$e },
        __vue_inject_styles__$2$7,
        __vue_script__$2$7,
        __vue_scope_id__$2$7,
        __vue_is_functional_template__$2$7,
        __vue_module_identifier__$2$7,
        undefined,
        undefined
      );

    var _components$1$1;
    var script$3$4 = {
      name: 'BTable',
      components: (_components$1$1 = {}, _defineProperty(_components$1$1, Checkbox.name, Checkbox), _defineProperty(_components$1$1, Icon.name, Icon), _defineProperty(_components$1$1, Input.name, Input), _defineProperty(_components$1$1, Loading.name, Loading), _defineProperty(_components$1$1, SlotComponent.name, SlotComponent), _defineProperty(_components$1$1, TableMobileSort.name, TableMobileSort), _defineProperty(_components$1$1, TableColumn.name, TableColumn), _defineProperty(_components$1$1, TablePagination.name, TablePagination), _components$1$1),
      inheritAttrs: false,
      provide: function provide() {
        return {
          $table: this
        };
      },
      props: {
        data: {
          type: Array,
          default: function _default() {
            return [];
          }
        },
        columns: {
          type: Array,
          default: function _default() {
            return [];
          }
        },
        bordered: Boolean,
        striped: Boolean,
        narrowed: Boolean,
        hoverable: Boolean,
        loading: Boolean,
        detailed: Boolean,
        checkable: Boolean,
        headerCheckable: {
          type: Boolean,
          default: true
        },
        checkboxType: {
          type: String,
          default: 'is-primary'
        },
        checkboxPosition: {
          type: String,
          default: 'left',
          validator: function validator(value) {
            return ['left', 'right'].indexOf(value) >= 0;
          }
        },
        stickyCheckbox: {
          type: Boolean,
          default: false
        },
        selected: Object,
        isRowSelectable: {
          type: Function,
          default: function _default() {
            return true;
          }
        },
        focusable: Boolean,
        customIsChecked: Function,
        isRowCheckable: {
          type: Function,
          default: function _default() {
            return true;
          }
        },
        checkedRows: {
          type: Array,
          default: function _default() {
            return [];
          }
        },
        mobileCards: {
          type: Boolean,
          default: true
        },
        defaultSort: [String, Array],
        defaultSortDirection: {
          type: String,
          default: 'asc'
        },
        sortIcon: {
          type: String,
          default: 'arrow-up'
        },
        sortIconSize: {
          type: String,
          default: 'is-small'
        },
        sortMultiple: {
          type: Boolean,
          default: false
        },
        sortMultipleData: {
          type: Array,
          default: function _default() {
            return [];
          }
        },
        sortMultipleKey: {
          type: String,
          default: null
        },
        paginated: Boolean,
        currentPage: {
          type: Number,
          default: 1
        },
        perPage: {
          type: [Number, String],
          default: 20
        },
        showDetailIcon: {
          type: Boolean,
          default: true
        },
        detailIcon: {
          type: String,
          default: 'chevron-right'
        },
        paginationPosition: {
          type: String,
          default: 'bottom',
          validator: function validator(value) {
            return ['bottom', 'top', 'both'].indexOf(value) >= 0;
          }
        },
        paginationRounded: Boolean,
        backendSorting: Boolean,
        backendFiltering: Boolean,
        rowClass: {
          type: Function,
          default: function _default() {
            return '';
          }
        },
        openedDetailed: {
          type: Array,
          default: function _default() {
            return [];
          }
        },
        hasDetailedVisible: {
          type: Function,
          default: function _default() {
            return true;
          }
        },
        detailKey: {
          type: String,
          default: ''
        },
        detailTransition: {
          type: String,
          default: ''
        },
        customDetailRow: {
          type: Boolean,
          default: false
        },
        backendPagination: Boolean,
        total: {
          type: [Number, String],
          default: 0
        },
        iconPack: String,
        mobileSortPlaceholder: String,
        customRowKey: String,
        draggable: {
          type: Boolean,
          default: false
        },
        draggableColumn: {
          type: Boolean,
          default: false
        },
        scrollable: Boolean,
        ariaNextLabel: String,
        ariaPreviousLabel: String,
        ariaPageLabel: String,
        ariaCurrentLabel: String,
        stickyHeader: Boolean,
        height: [Number, String],
        filtersEvent: {
          type: String,
          default: ''
        },
        cardLayout: Boolean,
        showHeader: {
          type: Boolean,
          default: true
        },
        debounceSearch: Number,
        caption: String,
        showCaption: {
          type: Boolean,
          default: true
        },
        pageInput: {
          type: Boolean,
          default: false
        },
        paginationOrder: String,
        pageInputPosition: String,
        debouncePageInput: [Number, String]
      },
      data: function data() {
        return {
          sortMultipleDataLocal: [],
          getValueByPath: getValueByPath,
          visibleDetailRows: this.openedDetailed,
          newData: this.data,
          newDataTotal: this.backendPagination ? this.total : this.data.length,
          newCheckedRows: _toConsumableArray(this.checkedRows),
          lastCheckedRowIndex: null,
          newCurrentPage: this.currentPage,
          currentSortColumn: {},
          isAsc: true,
          filters: {},
          defaultSlots: [],
          firstTimeSort: true,
          // Used by first time initSort
          _isTable: true,
          // Used by TableColumn
          isDraggingRow: false,
          isDraggingColumn: false
        };
      },
      computed: {
        sortMultipleDataComputed: function sortMultipleDataComputed() {
          return this.backendSorting ? this.sortMultipleData : this.sortMultipleDataLocal;
        },
        tableClasses: function tableClasses() {
          return {
            'is-bordered': this.bordered,
            'is-striped': this.striped,
            'is-narrow': this.narrowed,
            'is-hoverable': (this.hoverable || this.focusable) && this.visibleData.length
          };
        },
        tableWrapperClasses: function tableWrapperClasses() {
          return {
            'has-mobile-cards': this.mobileCards,
            'has-sticky-header': this.stickyHeader,
            'is-card-list': this.cardLayout,
            'table-container': this.isScrollable
          };
        },
        tableStyle: function tableStyle() {
          return {
            height: toCssWidth(this.height)
          };
        },

        /**
        * Splitted data based on the pagination.
        */
        visibleData: function visibleData() {
          if (!this.paginated) return this.newData;
          var currentPage = this.newCurrentPage;
          var perPage = this.perPage;

          if (this.newData.length <= perPage) {
            return this.newData;
          } else {
            var start = (currentPage - 1) * perPage;
            var end = parseInt(start, 10) + parseInt(perPage, 10);
            return this.newData.slice(start, end);
          }
        },
        visibleColumns: function visibleColumns() {
          if (!this.newColumns) return this.newColumns;
          return this.newColumns.filter(function (column) {
            return column.visible || column.visible === undefined;
          });
        },

        /**
        * Check if all rows in the page are checked.
        */
        isAllChecked: function isAllChecked() {
          var _this = this;

          var validVisibleData = this.visibleData.filter(function (row) {
            return _this.isRowCheckable(row);
          });
          if (validVisibleData.length === 0) return false;
          var isAllChecked = validVisibleData.some(function (currentVisibleRow) {
            return indexOf(_this.newCheckedRows, currentVisibleRow, _this.customIsChecked) < 0;
          });
          return !isAllChecked;
        },

        /**
        * Check if all rows in the page are checkable.
        */
        isAllUncheckable: function isAllUncheckable() {
          var _this2 = this;

          var validVisibleData = this.visibleData.filter(function (row) {
            return _this2.isRowCheckable(row);
          });
          return validVisibleData.length === 0;
        },

        /**
        * Check if has any sortable column.
        */
        hasSortablenewColumns: function hasSortablenewColumns() {
          return this.newColumns.some(function (column) {
            return column.sortable;
          });
        },

        /**
        * Check if has any searchable column.
        */
        hasSearchablenewColumns: function hasSearchablenewColumns() {
          return this.newColumns.some(function (column) {
            return column.searchable;
          });
        },

        /**
        * Check if has any column using subheading.
        */
        hasCustomSubheadings: function hasCustomSubheadings() {
          if (this.$scopedSlots && this.$scopedSlots.subheading) return true;
          return this.newColumns.some(function (column) {
            return column.subheading || column.$scopedSlots && column.$scopedSlots.subheading;
          });
        },

        /**
        * Return total column count based if it's checkable or expanded
        */
        columnCount: function columnCount() {
          var count = this.visibleColumns.length;
          count += this.checkable ? 1 : 0;
          count += this.detailed && this.showDetailIcon ? 1 : 0;
          return count;
        },

        /**
        * return if detailed row tabled
        * will be with chevron column & icon or not
        */
        showDetailRowIcon: function showDetailRowIcon() {
          return this.detailed && this.showDetailIcon;
        },

        /**
        * return if scrollable table
        */
        isScrollable: function isScrollable() {
          if (this.scrollable) return true;
          if (!this.newColumns) return false;
          return this.newColumns.some(function (column) {
            return column.sticky;
          });
        },
        newColumns: function newColumns() {
          var _this3 = this;

          if (this.columns && this.columns.length) {
            return this.columns.map(function (column) {
              var TableColumnComponent = VueInstance.extend(TableColumn);
              var component = new TableColumnComponent({
                parent: _this3,
                propsData: column
              });
              component.$scopedSlots = {
                default: function _default(props) {
                  var vnode = component.$createElement('span', {
                    domProps: {
                      innerHTML: getValueByPath(props.row, column.field)
                    }
                  });
                  return [vnode];
                }
              };
              return component;
            });
          }

          return this.defaultSlots.filter(function (vnode) {
            return vnode.componentInstance && vnode.componentInstance.$data && vnode.componentInstance.$data._isTableColumn;
          }).map(function (vnode) {
            return vnode.componentInstance;
          });
        },
        canDragRow: function canDragRow() {
          return this.draggable && !this.isDraggingColumn;
        },
        canDragColumn: function canDragColumn() {
          return this.draggableColumn && !this.isDraggingRow;
        }
      },
      watch: {
        /**
        * When data prop change:
        *   1. Update internal value.
        *   2. Filter data if it's not backend-filtered.
        *   3. Sort again if it's not backend-sorted.
        *   4. Set new total if it's not backend-paginated.
        */
        data: function data(value) {
          var _this4 = this;

          this.newData = value;

          if (!this.backendFiltering) {
            this.newData = value.filter(function (row) {
              return _this4.isRowFiltered(row);
            });
          }

          if (!this.backendSorting) {
            this.sort(this.currentSortColumn, true);
          }

          if (!this.backendPagination) {
            this.newDataTotal = this.newData.length;
          }
        },

        /**
        * When Pagination total change, update internal total
        * only if it's backend-paginated.
        */
        total: function total(newTotal) {
          if (!this.backendPagination) return;
          this.newDataTotal = newTotal;
        },
        currentPage: function currentPage(newVal) {
          this.newCurrentPage = newVal;
        },
        newCurrentPage: function newCurrentPage(newVal) {
          this.$emit('update:currentPage', newVal);
        },

        /**
        * When checkedRows prop change, update internal value without
        * mutating original data.
        */
        checkedRows: function checkedRows(rows) {
          this.newCheckedRows = _toConsumableArray(rows);
        },

        /*
        newColumns(value) {
            this.checkSort()
        },
        */
        debounceSearch: {
          handler: function handler(value) {
            this.debouncedHandleFiltersChange = debounce(this.handleFiltersChange, value);
          },
          immediate: true
        },
        filters: {
          handler: function handler(value) {
            if (this.debounceSearch) {
              this.debouncedHandleFiltersChange(value);
            } else {
              this.handleFiltersChange(value);
            }
          },
          deep: true
        },

        /**
        * When the user wants to control the detailed rows via props.
        * Or wants to open the details of certain row with the router for example.
        */
        openedDetailed: function openedDetailed(expandedRows) {
          this.visibleDetailRows = expandedRows;
        }
      },
      methods: {
        onFiltersEvent: function onFiltersEvent(event) {
          this.$emit("filters-event-".concat(this.filtersEvent), {
            event: event,
            filters: this.filters
          });
        },
        handleFiltersChange: function handleFiltersChange(value) {
          var _this5 = this;

          if (this.backendFiltering) {
            this.$emit('filters-change', value);
          } else {
            this.newData = this.data.filter(function (row) {
              return _this5.isRowFiltered(row);
            });

            if (!this.backendPagination) {
              this.newDataTotal = this.newData.length;
            }

            if (!this.backendSorting) {
              if (this.sortMultiple && this.sortMultipleDataLocal && this.sortMultipleDataLocal.length > 0) {
                this.doSortMultiColumn();
              } else if (Object.keys(this.currentSortColumn).length > 0) {
                this.doSortSingleColumn(this.currentSortColumn);
              }
            }
          }
        },
        findIndexOfSortData: function findIndexOfSortData(column) {
          var sortObj = this.sortMultipleDataComputed.filter(function (i) {
            return i.field === column.field;
          })[0];
          return this.sortMultipleDataComputed.indexOf(sortObj) + 1;
        },
        removeSortingPriority: function removeSortingPriority(column) {
          if (this.backendSorting) {
            this.$emit('sorting-priority-removed', column.field);
          } else {
            this.sortMultipleDataLocal = this.sortMultipleDataLocal.filter(function (priority) {
              return priority.field !== column.field;
            });
            var formattedSortingPriority = this.sortMultipleDataLocal.map(function (i) {
              return (i.order && i.order === 'desc' ? '-' : '') + i.field;
            });

            if (formattedSortingPriority.length === 0) {
              this.resetMultiSorting();
            } else {
              this.newData = multiColumnSort(this.newData, formattedSortingPriority);
            }
          }
        },
        resetMultiSorting: function resetMultiSorting() {
          this.sortMultipleDataLocal = [];
          this.currentSortColumn = {};
          this.newData = this.data;
        },

        /**
        * Sort an array by key without mutating original data.
        * Call the user sort function if it was passed.
        */
        sortBy: function sortBy(array, key, fn, isAsc) {
          var sorted = []; // Sorting without mutating original data

          if (fn && typeof fn === 'function') {
            sorted = _toConsumableArray(array).sort(function (a, b) {
              return fn(a, b, isAsc);
            });
          } else {
            sorted = _toConsumableArray(array).sort(function (a, b) {
              // Get nested values from objects
              var newA = getValueByPath(a, key);
              var newB = getValueByPath(b, key); // sort boolean type

              if (typeof newA === 'boolean' && typeof newB === 'boolean') {
                return isAsc ? newA - newB : newB - newA;
              } // sort null values to the bottom when in asc order
              // and to the top when in desc order


              if (!isNil(newB) && isNil(newA)) return isAsc ? 1 : -1;
              if (!isNil(newA) && isNil(newB)) return isAsc ? -1 : 1;
              if (newA === newB) return 0;
              newA = typeof newA === 'string' ? newA.toUpperCase() : newA;
              newB = typeof newB === 'string' ? newB.toUpperCase() : newB;
              return isAsc ? newA > newB ? 1 : -1 : newA > newB ? -1 : 1;
            });
          }

          return sorted;
        },
        sortMultiColumn: function sortMultiColumn(column) {
          this.currentSortColumn = {};

          if (!this.backendSorting) {
            var existingPriority = this.sortMultipleDataLocal.filter(function (i) {
              return i.field === column.field;
            })[0];

            if (existingPriority) {
              existingPriority.order = existingPriority.order === 'desc' ? 'asc' : 'desc';
            } else {
              this.sortMultipleDataLocal.push({
                field: column.field,
                order: column.isAsc
              });
            }

            this.doSortMultiColumn();
          }
        },
        doSortMultiColumn: function doSortMultiColumn() {
          var formattedSortingPriority = this.sortMultipleDataLocal.map(function (i) {
            return (i.order && i.order === 'desc' ? '-' : '') + i.field;
          });
          this.newData = multiColumnSort(this.newData, formattedSortingPriority);
        },

        /**
        * Sort the column.
        * Toggle current direction on column if it's sortable
        * and not just updating the prop.
        */
        sort: function sort(column) {
          var updatingData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          var event = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          if (!column || !column.sortable) return;

          if ( // if backend sorting is enabled, just emit the sort press like usual
          // if the correct key combination isnt pressed, sort like usual
          !this.backendSorting && this.sortMultiple && (this.sortMultipleKey && event[this.sortMultipleKey] || !this.sortMultipleKey)) {
            if (updatingData) {
              this.doSortMultiColumn();
            } else {
              this.sortMultiColumn(column);
            }
          } else {
            // sort multiple is enabled but the correct key combination isnt pressed so reset
            if (this.sortMultiple) {
              this.sortMultipleDataLocal = [];
            }

            if (!updatingData) {
              this.isAsc = column === this.currentSortColumn ? !this.isAsc : this.defaultSortDirection.toLowerCase() !== 'desc';
            }

            if (!this.firstTimeSort) {
              this.$emit('sort', column.field, this.isAsc ? 'asc' : 'desc', event);
            }

            if (!this.backendSorting) {
              this.doSortSingleColumn(column);
            }

            this.currentSortColumn = column;
          }
        },
        doSortSingleColumn: function doSortSingleColumn(column) {
          this.newData = this.sortBy(this.newData, column.field, column.customSort, this.isAsc);
        },
        isRowSelected: function isRowSelected(row, selected) {
          if (!selected) {
            return false;
          }

          if (this.customRowKey) {
            return row[this.customRowKey] === selected[this.customRowKey];
          }

          return row === selected;
        },

        /**
        * Check if the row is checked (is added to the array).
        */
        isRowChecked: function isRowChecked(row) {
          return indexOf(this.newCheckedRows, row, this.customIsChecked) >= 0;
        },

        /**
        * Remove a checked row from the array.
        */
        removeCheckedRow: function removeCheckedRow(row) {
          var index = indexOf(this.newCheckedRows, row, this.customIsChecked);

          if (index >= 0) {
            this.newCheckedRows.splice(index, 1);
          }
        },

        /**
        * Header checkbox click listener.
        * Add or remove all rows in current page.
        */
        checkAll: function checkAll() {
          var _this6 = this;

          var isAllChecked = this.isAllChecked;
          this.visibleData.forEach(function (currentRow) {
            if (_this6.isRowCheckable(currentRow)) {
              _this6.removeCheckedRow(currentRow);
            }

            if (!isAllChecked) {
              if (_this6.isRowCheckable(currentRow)) {
                _this6.newCheckedRows.push(currentRow);
              }
            }
          });
          this.$emit('check', this.newCheckedRows);
          this.$emit('check-all', this.newCheckedRows); // Emit checked rows to update user variable

          this.$emit('update:checkedRows', this.newCheckedRows);
        },

        /**
        * Row checkbox click listener.
        */
        checkRow: function checkRow(row, index, event) {
          if (!this.isRowCheckable(row)) return;
          var lastIndex = this.lastCheckedRowIndex;
          this.lastCheckedRowIndex = index;

          if (event.shiftKey && lastIndex !== null && index !== lastIndex) {
            this.shiftCheckRow(row, index, lastIndex);
          } else if (!this.isRowChecked(row)) {
            this.newCheckedRows.push(row);
          } else {
            this.removeCheckedRow(row);
          }

          this.$emit('check', this.newCheckedRows, row); // Emit checked rows to update user variable

          this.$emit('update:checkedRows', this.newCheckedRows);
        },

        /**
         * Check row when shift is pressed.
         */
        shiftCheckRow: function shiftCheckRow(row, index, lastCheckedRowIndex) {
          var _this7 = this;

          // Get the subset of the list between the two indicies
          var subset = this.visibleData.slice(Math.min(index, lastCheckedRowIndex), Math.max(index, lastCheckedRowIndex) + 1); // Determine the operation based on the state of the clicked checkbox

          var shouldCheck = !this.isRowChecked(row);
          subset.forEach(function (item) {
            _this7.removeCheckedRow(item);

            if (shouldCheck && _this7.isRowCheckable(item)) {
              _this7.newCheckedRows.push(item);
            }
          });
        },

        /**
        * Row click listener.
        * Emit all necessary events.
        */
        selectRow: function selectRow(row, index) {
          this.$emit('click', row);
          if (this.selected === row) return;
          if (!this.isRowSelectable(row)) return; // Emit new and old row

          this.$emit('select', row, this.selected); // Emit new row to update user variable

          this.$emit('update:selected', row);
        },

        /**
        * Toggle to show/hide details slot
        */
        toggleDetails: function toggleDetails(obj) {
          var found = this.isVisibleDetailRow(obj);

          if (found) {
            this.closeDetailRow(obj);
            this.$emit('details-close', obj);
          } else {
            this.openDetailRow(obj);
            this.$emit('details-open', obj);
          } // Syncs the detailed rows with the parent component


          this.$emit('update:openedDetailed', this.visibleDetailRows);
        },
        openDetailRow: function openDetailRow(obj) {
          var index = this.handleDetailKey(obj);
          this.visibleDetailRows.push(index);
        },
        closeDetailRow: function closeDetailRow(obj) {
          var index = this.handleDetailKey(obj);
          var i = this.visibleDetailRows.indexOf(index);

          if (i >= 0) {
            this.visibleDetailRows.splice(i, 1);
          }
        },
        isVisibleDetailRow: function isVisibleDetailRow(obj) {
          var index = this.handleDetailKey(obj);
          return this.visibleDetailRows.indexOf(index) >= 0;
        },
        isActiveDetailRow: function isActiveDetailRow(row) {
          return this.detailed && !this.customDetailRow && this.isVisibleDetailRow(row);
        },
        isActiveCustomDetailRow: function isActiveCustomDetailRow(row) {
          return this.detailed && this.customDetailRow && this.isVisibleDetailRow(row);
        },
        isRowFiltered: function isRowFiltered(row) {
          var _this8 = this;

          var _loop = function _loop(key) {
            if (!_this8.filters[key]) return "continue";
            var input = _this8.filters[key];

            var column = _this8.newColumns.filter(function (c) {
              return c.field === key;
            })[0];

            if (column && column.customSearch && typeof column.customSearch === 'function') {
              if (!column.customSearch(row, input)) return {
                v: false
              };
            } else {
              var value = _this8.getValueByPath(row, key);

              if (value == null) return {
                v: false
              };

              if (Number.isInteger(value)) {
                if (value !== Number(input)) return {
                  v: false
                };
              } else {
                var re = new RegExp(escapeRegExpChars(input), 'i');

                if (Array.isArray(value)) {
                  var valid = value.some(function (val) {
                    return re.test(removeDiacriticsFromString(val)) || re.test(val);
                  });
                  if (!valid) return {
                    v: false
                  };
                } else {
                  if (!re.test(removeDiacriticsFromString(value)) && !re.test(value)) {
                    return {
                      v: false
                    };
                  }
                }
              }
            }
          };

          for (var key in this.filters) {
            var _ret = _loop(key);

            switch (_ret) {
              case "continue":
                continue;

              default:
                if (_typeof(_ret) === "object") return _ret.v;
            }
          }

          return true;
        },

        /**
        * When the detailKey is defined we use the object[detailKey] as index.
        * If not, use the object reference by default.
        */
        handleDetailKey: function handleDetailKey(index) {
          var key = this.detailKey;
          return !key.length || !index ? index : index[key];
        },
        checkPredefinedDetailedRows: function checkPredefinedDetailedRows() {
          var defaultExpandedRowsDefined = this.openedDetailed.length > 0;

          if (defaultExpandedRowsDefined && !this.detailKey.length) {
            throw new Error('If you set a predefined opened-detailed, you must provide a unique key using the prop "detail-key"');
          }
        },

        /**
        * Call initSort only first time (For example async data).
        */
        checkSort: function checkSort() {
          if (this.newColumns.length && this.firstTimeSort) {
            this.initSort();
            this.firstTimeSort = false;
          } else if (this.newColumns.length) {
            if (Object.keys(this.currentSortColumn).length > 0) {
              for (var i = 0; i < this.newColumns.length; i++) {
                if (this.newColumns[i].field === this.currentSortColumn.field) {
                  this.currentSortColumn = this.newColumns[i];
                  break;
                }
              }
            }
          }
        },

        /**
        * Check if footer slot has custom content.
        */
        hasCustomFooterSlot: function hasCustomFooterSlot() {
          if (this.$slots.footer.length > 1) return true;
          var tag = this.$slots.footer[0].tag;
          if (tag !== 'th' && tag !== 'td') return false;
          return true;
        },

        /**
        * Check if bottom-left slot exists.
        */
        hasBottomLeftSlot: function hasBottomLeftSlot() {
          return typeof this.$slots['bottom-left'] !== 'undefined';
        },

        /**
        * Table arrow keys listener, change selection.
        */
        pressedArrow: function pressedArrow(pos) {
          if (!this.visibleData.length) return;
          var index = this.visibleData.indexOf(this.selected) + pos; // Prevent from going up from first and down from last

          index = index < 0 ? 0 : index > this.visibleData.length - 1 ? this.visibleData.length - 1 : index;
          var row = this.visibleData[index];

          if (!this.isRowSelectable(row)) {
            var newIndex = null;

            if (pos > 0) {
              for (var i = index; i < this.visibleData.length && newIndex === null; i++) {
                if (this.isRowSelectable(this.visibleData[i])) newIndex = i;
              }
            } else {
              for (var _i = index; _i >= 0 && newIndex === null; _i--) {
                if (this.isRowSelectable(this.visibleData[_i])) newIndex = _i;
              }
            }

            if (newIndex >= 0) {
              this.selectRow(this.visibleData[newIndex]);
            }
          } else {
            this.selectRow(row);
          }
        },

        /**
        * Focus table element if has selected prop.
        */
        focus: function focus() {
          if (!this.focusable) return;
          this.$el.querySelector('table').focus();
        },

        /**
        * Initial sorted column based on the default-sort prop.
        */
        initSort: function initSort() {
          var _this9 = this;

          if (this.sortMultiple && this.sortMultipleData) {
            this.sortMultipleData.forEach(function (column) {
              _this9.sortMultiColumn(column);
            });
          } else {
            if (!this.defaultSort) return;
            var sortField = '';
            var sortDirection = this.defaultSortDirection;

            if (Array.isArray(this.defaultSort)) {
              sortField = this.defaultSort[0];

              if (this.defaultSort[1]) {
                sortDirection = this.defaultSort[1];
              }
            } else {
              sortField = this.defaultSort;
            }

            var sortColumn = this.newColumns.filter(function (column) {
              return column.field === sortField;
            })[0];

            if (sortColumn) {
              this.isAsc = sortDirection.toLowerCase() !== 'desc';
              this.sort(sortColumn, true);
            }
          }
        },

        /**
        * Emits drag start event (row)
        */
        handleDragStart: function handleDragStart(event, row, index) {
          if (!this.canDragRow) return;
          this.isDraggingRow = true;
          this.$emit('dragstart', {
            event: event,
            row: row,
            index: index
          });
        },

        /**
        * Emits drag leave event (row)
        */
        handleDragEnd: function handleDragEnd(event, row, index) {
          if (!this.canDragRow) return;
          this.isDraggingRow = false;
          this.$emit('dragend', {
            event: event,
            row: row,
            index: index
          });
        },

        /**
        * Emits drop event (row)
        */
        handleDrop: function handleDrop(event, row, index) {
          if (!this.canDragRow) return;
          this.$emit('drop', {
            event: event,
            row: row,
            index: index
          });
        },

        /**
        * Emits drag over event (row)
        */
        handleDragOver: function handleDragOver(event, row, index) {
          if (!this.canDragRow) return;
          this.$emit('dragover', {
            event: event,
            row: row,
            index: index
          });
        },

        /**
        * Emits drag leave event (row)
        */
        handleDragLeave: function handleDragLeave(event, row, index) {
          if (!this.canDragRow) return;
          this.$emit('dragleave', {
            event: event,
            row: row,
            index: index
          });
        },
        emitEventForRow: function emitEventForRow(eventName, event, row) {
          return this.$listeners[eventName] ? this.$emit(eventName, row, event) : null;
        },

        /**
        * Emits drag start event (column)
        */
        handleColumnDragStart: function handleColumnDragStart(event, column, index) {
          if (!this.canDragColumn) return;
          this.isDraggingColumn = true;
          this.$emit('columndragstart', {
            event: event,
            column: column,
            index: index
          });
        },

        /**
        * Emits drag leave event (column)
        */
        handleColumnDragEnd: function handleColumnDragEnd(event, column, index) {
          if (!this.canDragColumn) return;
          this.isDraggingColumn = false;
          this.$emit('columndragend', {
            event: event,
            column: column,
            index: index
          });
        },

        /**
        * Emits drop event (column)
        */
        handleColumnDrop: function handleColumnDrop(event, column, index) {
          if (!this.canDragColumn) return;
          this.$emit('columndrop', {
            event: event,
            column: column,
            index: index
          });
        },

        /**
        * Emits drag over event (column)
        */
        handleColumnDragOver: function handleColumnDragOver(event, column, index) {
          if (!this.canDragColumn) return;
          this.$emit('columndragover', {
            event: event,
            column: column,
            index: index
          });
        },

        /**
        * Emits drag leave event (column)
        */
        handleColumnDragLeave: function handleColumnDragLeave(event, column, index) {
          if (!this.canDragColumn) return;
          this.$emit('columndragleave', {
            event: event,
            column: column,
            index: index
          });
        },
        refreshSlots: function refreshSlots() {
          this.defaultSlots = this.$slots.default || [];
        }
      },
      mounted: function mounted() {
        this.refreshSlots();
        this.checkPredefinedDetailedRows();
        this.checkSort();
      }
    };

    /* script */
    const __vue_script__$3$4 = script$3$4;

    /* template */
    var __vue_render__$2$6 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"b-table"},[_vm._t("default"),(_vm.mobileCards && _vm.hasSortablenewColumns)?_c('b-table-mobile-sort',{attrs:{"current-sort-column":_vm.currentSortColumn,"sort-multiple":_vm.sortMultiple,"sort-multiple-data":_vm.sortMultipleDataComputed,"is-asc":_vm.isAsc,"columns":_vm.newColumns,"placeholder":_vm.mobileSortPlaceholder,"icon-pack":_vm.iconPack,"sort-icon":_vm.sortIcon,"sort-icon-size":_vm.sortIconSize},on:{"sort":function (column, event) { return _vm.sort(column, null, event); },"removePriority":function (column) { return _vm.removeSortingPriority(column); }}}):_vm._e(),(_vm.paginated && (_vm.paginationPosition === 'top' || _vm.paginationPosition === 'both'))?[_vm._t("pagination",[_c('b-table-pagination',_vm._b({attrs:{"per-page":_vm.perPage,"paginated":_vm.paginated,"rounded":_vm.paginationRounded,"icon-pack":_vm.iconPack,"total":_vm.newDataTotal,"current-page":_vm.newCurrentPage,"aria-next-label":_vm.ariaNextLabel,"aria-previous-label":_vm.ariaPreviousLabel,"aria-page-label":_vm.ariaPageLabel,"aria-current-label":_vm.ariaCurrentLabel,"page-input":_vm.pageInput,"pagination-order":_vm.paginationOrder,"page-input-position":_vm.pageInputPosition,"debounce-page-input":_vm.debouncePageInput},on:{"update:currentPage":function($event){_vm.newCurrentPage=$event;},"update:current-page":function($event){_vm.newCurrentPage=$event;},"page-change":function (event) { return _vm.$emit('page-change', event); }}},'b-table-pagination',_vm.$attrs,false),[_vm._t("top-left")],2)])]:_vm._e(),_c('div',{staticClass:"table-wrapper",class:_vm.tableWrapperClasses,style:(_vm.tableStyle)},[_c('table',{staticClass:"table",class:_vm.tableClasses,attrs:{"tabindex":!_vm.focusable ? false : 0},on:{"keydown":[function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"up",38,$event.key,["Up","ArrowUp"])){ return null; }if($event.target !== $event.currentTarget){ return null; }$event.preventDefault();return _vm.pressedArrow(-1)},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"down",40,$event.key,["Down","ArrowDown"])){ return null; }if($event.target !== $event.currentTarget){ return null; }$event.preventDefault();return _vm.pressedArrow(1)}]}},[(_vm.caption)?_c('caption',{directives:[{name:"show",rawName:"v-show",value:(_vm.showCaption),expression:"showCaption"}]},[_vm._v(_vm._s(_vm.caption))]):_vm._e(),(_vm.newColumns.length && _vm.showHeader)?_c('thead',[_c('tr',[(_vm.showDetailRowIcon)?_c('th',{attrs:{"width":"40px"}}):_vm._e(),(_vm.checkable && _vm.checkboxPosition === 'left')?_c('th',{class:['checkbox-cell', { 'is-sticky': _vm.stickyCheckbox } ]},[(_vm.headerCheckable)?[_c('b-checkbox',{attrs:{"autocomplete":"off","value":_vm.isAllChecked,"type":_vm.checkboxType,"disabled":_vm.isAllUncheckable},nativeOn:{"change":function($event){return _vm.checkAll($event)}}})]:_vm._e()],2):_vm._e(),_vm._l((_vm.visibleColumns),function(column,index){return _c('th',_vm._b({key:column.newKey + ':' + index + 'header',class:[column.thClasses, {
                                'is-current-sort': !_vm.sortMultiple && _vm.currentSortColumn === column,
                            }],style:(column.thStyle),attrs:{"draggable":_vm.canDragColumn},on:{"click":function($event){$event.stopPropagation();return _vm.sort(column, null, $event)},"dragstart":function($event){return _vm.handleColumnDragStart($event, column, index)},"dragend":function($event){return _vm.handleColumnDragEnd($event, column, index)},"drop":function($event){return _vm.handleColumnDrop($event, column, index)},"dragover":function($event){return _vm.handleColumnDragOver($event, column, index)},"dragleave":function($event){return _vm.handleColumnDragLeave($event, column, index)}}},'th',column.thAttrs(column),false),[_c('div',{staticClass:"th-wrap",class:{
                                    'is-numeric': column.numeric,
                                    'is-centered': column.centered
                            }},[(column.$scopedSlots && column.$scopedSlots.header)?[_c('b-slot-component',{attrs:{"component":column,"scoped":"","name":"header","tag":"span","props":{ column: column, index: index }}})]:[_c('span',{staticClass:"is-relative"},[_vm._v(" "+_vm._s(column.label)+" "),(_vm.sortMultiple &&
                                                _vm.sortMultipleDataComputed &&
                                                _vm.sortMultipleDataComputed.length > 0 &&
                                                _vm.sortMultipleDataComputed.filter(function (i) { return i.field === column.field; }).length > 0)?[_c('b-icon',{class:{
                                                    'is-desc': _vm.sortMultipleDataComputed.filter(function (i) { return i.field === column.field; })[0].order === 'desc'},attrs:{"icon":_vm.sortIcon,"pack":_vm.iconPack,"both":"","size":_vm.sortIconSize}}),_vm._v(" "+_vm._s(_vm.findIndexOfSortData(column))+" "),_c('button',{staticClass:"delete is-small multi-sort-cancel-icon",attrs:{"type":"button"},on:{"click":function($event){$event.stopPropagation();return _vm.removeSortingPriority(column)}}})]:_c('b-icon',{staticClass:"sort-icon",class:{
                                                'is-desc': !_vm.isAsc,
                                                'is-invisible': _vm.currentSortColumn !== column
                                            },attrs:{"icon":_vm.sortIcon,"pack":_vm.iconPack,"both":"","size":_vm.sortIconSize}})],2)]],2)])}),(_vm.checkable && _vm.checkboxPosition === 'right')?_c('th',{class:['checkbox-cell', { 'is-sticky': _vm.stickyCheckbox } ]},[(_vm.headerCheckable)?[_c('b-checkbox',{attrs:{"autocomplete":"off","value":_vm.isAllChecked,"type":_vm.checkboxType,"disabled":_vm.isAllUncheckable},nativeOn:{"change":function($event){return _vm.checkAll($event)}}})]:_vm._e()],2):_vm._e()],2),(_vm.hasCustomSubheadings)?_c('tr',{staticClass:"is-subheading"},[(_vm.showDetailRowIcon)?_c('th',{attrs:{"width":"40px"}}):_vm._e(),(_vm.checkable && _vm.checkboxPosition === 'left')?_c('th'):_vm._e(),_vm._l((_vm.visibleColumns),function(column,index){return _c('th',{key:column.newKey + ':' + index + 'subheading',style:(column.style)},[_c('div',{staticClass:"th-wrap",class:{
                                    'is-numeric': column.numeric,
                                    'is-centered': column.centered
                            }},[(column.$scopedSlots && column.$scopedSlots.subheading)?[_c('b-slot-component',{attrs:{"component":column,"scoped":"","name":"subheading","tag":"span","props":{ column: column, index: index }}})]:[_vm._v(_vm._s(column.subheading))]],2)])}),(_vm.checkable && _vm.checkboxPosition === 'right')?_c('th'):_vm._e()],2):_vm._e(),(_vm.hasSearchablenewColumns)?_c('tr',[(_vm.showDetailRowIcon)?_c('th',{attrs:{"width":"40px"}}):_vm._e(),(_vm.checkable && _vm.checkboxPosition === 'left')?_c('th'):_vm._e(),_vm._l((_vm.visibleColumns),function(column,index){return _c('th',_vm._b({key:column.newKey + ':' + index + 'searchable',class:{'is-sticky': column.sticky},style:(column.thStyle)},'th',column.thAttrs(column),false),[_c('div',{staticClass:"th-wrap"},[(column.searchable)?[(column.$scopedSlots
                                        && column.$scopedSlots.searchable)?[_c('b-slot-component',{attrs:{"component":column,"scoped":true,"name":"searchable","tag":"span","props":{ column: column, filters: _vm.filters }}})]:_c('b-input',{attrs:{"type":column.numeric ? 'number' : 'text'},nativeOn:_vm._d({},[_vm.filtersEvent,function($event){return _vm.onFiltersEvent($event)}]),model:{value:(_vm.filters[column.field]),callback:function ($$v) {_vm.$set(_vm.filters, column.field, $$v);},expression:"filters[column.field]"}})]:_vm._e()],2)])}),(_vm.checkable && _vm.checkboxPosition === 'right')?_c('th'):_vm._e()],2):_vm._e()]):_vm._e(),_c('tbody',[_vm._l((_vm.visibleData),function(row,index){return [_c('tr',{key:_vm.customRowKey ? row[_vm.customRowKey] : index,class:[_vm.rowClass(row, index), {
                                'is-selected': _vm.isRowSelected(row, _vm.selected),
                                'is-checked': _vm.isRowChecked(row),
                            }],attrs:{"draggable":_vm.canDragRow},on:{"click":function($event){return _vm.selectRow(row)},"dblclick":function($event){return _vm.$emit('dblclick', row)},"mouseenter":function($event){return _vm.emitEventForRow('mouseenter', $event, row)},"mouseleave":function($event){return _vm.emitEventForRow('mouseleave', $event, row)},"contextmenu":function($event){return _vm.$emit('contextmenu', row, $event)},"dragstart":function($event){return _vm.handleDragStart($event, row, index)},"dragend":function($event){return _vm.handleDragEnd($event, row, index)},"drop":function($event){return _vm.handleDrop($event, row, index)},"dragover":function($event){return _vm.handleDragOver($event, row, index)},"dragleave":function($event){return _vm.handleDragLeave($event, row, index)}}},[(_vm.showDetailRowIcon)?_c('td',{staticClass:"chevron-cell"},[(_vm.hasDetailedVisible(row))?_c('a',{attrs:{"role":"button"},on:{"click":function($event){$event.stopPropagation();return _vm.toggleDetails(row)}}},[_c('b-icon',{class:{'is-expanded': _vm.isVisibleDetailRow(row)},attrs:{"icon":_vm.detailIcon,"pack":_vm.iconPack,"both":""}})],1):_vm._e()]):_vm._e(),(_vm.checkable && _vm.checkboxPosition === 'left')?_c('td',{class:['checkbox-cell', { 'is-sticky': _vm.stickyCheckbox } ]},[_c('b-checkbox',{attrs:{"autocomplete":"off","value":_vm.isRowChecked(row),"type":_vm.checkboxType,"disabled":!_vm.isRowCheckable(row)},nativeOn:{"click":function($event){$event.preventDefault();$event.stopPropagation();return _vm.checkRow(row, index, $event)}}})],1):_vm._e(),_vm._l((_vm.visibleColumns),function(column,colindex){return [(column.$scopedSlots && column.$scopedSlots.default)?[_c('b-slot-component',_vm._b({key:column.newKey + ':' + index + ':' + colindex,class:column.getRootClasses(row),style:(column.getRootStyle(row)),attrs:{"component":column,"scoped":"","name":"default","tag":"td","data-label":column.label,"props":{ row: row, column: column, index: index, colindex: colindex, toggleDetails: _vm.toggleDetails }},nativeOn:{"click":function($event){return _vm.$emit('cellclick',row,column,index,colindex)}}},'b-slot-component',column.tdAttrs(row, column),false))]:_vm._e()]}),(_vm.checkable && _vm.checkboxPosition === 'right')?_c('td',{class:['checkbox-cell', { 'is-sticky': _vm.stickyCheckbox } ]},[_c('b-checkbox',{attrs:{"autocomplete":"off","value":_vm.isRowChecked(row),"type":_vm.checkboxType,"disabled":!_vm.isRowCheckable(row)},nativeOn:{"click":function($event){$event.preventDefault();$event.stopPropagation();return _vm.checkRow(row, index, $event)}}})],1):_vm._e()],2),_c('transition',{key:(_vm.customRowKey ? row[_vm.customRowKey] : index) + 'detail',attrs:{"name":_vm.detailTransition}},[(_vm.isActiveDetailRow(row))?_c('tr',{staticClass:"detail"},[_c('td',{attrs:{"colspan":_vm.columnCount}},[_c('div',{staticClass:"detail-container"},[_vm._t("detail",null,{"row":row,"index":index})],2)])]):_vm._e()]),(_vm.isActiveCustomDetailRow(row))?_vm._t("detail",null,{"row":row,"index":index}):_vm._e()]}),(!_vm.visibleData.length)?_c('tr',{staticClass:"is-empty"},[_c('td',{attrs:{"colspan":_vm.columnCount}},[_vm._t("empty")],2)]):_vm._e()],2),(_vm.$slots.footer !== undefined)?_c('tfoot',[_c('tr',{staticClass:"table-footer"},[(_vm.hasCustomFooterSlot())?_vm._t("footer"):_c('th',{attrs:{"colspan":_vm.columnCount}},[_vm._t("footer")],2)],2)]):_vm._e()]),(_vm.loading)?[_vm._t("loading",[_c('b-loading',{attrs:{"is-full-page":false,"active":_vm.loading},on:{"update:active":function($event){_vm.loading=$event;}}})])]:_vm._e()],2),((_vm.checkable && _vm.hasBottomLeftSlot()) ||
            (_vm.paginated && (_vm.paginationPosition === 'bottom' || _vm.paginationPosition === 'both')))?[_vm._t("pagination",[_c('b-table-pagination',_vm._b({attrs:{"per-page":_vm.perPage,"paginated":_vm.paginated,"rounded":_vm.paginationRounded,"icon-pack":_vm.iconPack,"total":_vm.newDataTotal,"current-page":_vm.newCurrentPage,"aria-next-label":_vm.ariaNextLabel,"aria-previous-label":_vm.ariaPreviousLabel,"aria-page-label":_vm.ariaPageLabel,"aria-current-label":_vm.ariaCurrentLabel,"page-input":_vm.pageInput,"pagination-order":_vm.paginationOrder,"page-input-position":_vm.pageInputPosition,"debounce-page-input":_vm.debouncePageInput},on:{"update:currentPage":function($event){_vm.newCurrentPage=$event;},"update:current-page":function($event){_vm.newCurrentPage=$event;},"page-change":function (event) { return _vm.$emit('page-change', event); }}},'b-table-pagination',_vm.$attrs,false),[_vm._t("bottom-left")],2)])]:_vm._e()],2)};
    var __vue_staticRenderFns__$2$6 = [];

      /* style */
      const __vue_inject_styles__$3$4 = undefined;
      /* scoped */
      const __vue_scope_id__$3$4 = undefined;
      /* module identifier */
      const __vue_module_identifier__$3$4 = undefined;
      /* functional template */
      const __vue_is_functional_template__$3$4 = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var Table = normalizeComponent_1(
        { render: __vue_render__$2$6, staticRenderFns: __vue_staticRenderFns__$2$6 },
        __vue_inject_styles__$3$4,
        __vue_script__$3$4,
        __vue_scope_id__$3$4,
        __vue_is_functional_template__$3$4,
        __vue_module_identifier__$3$4,
        undefined,
        undefined
      );

    var Plugin$y = {
      install: function install(Vue) {
        // individual import + extend method into Table.vue
        if (typeof VueInstance === 'undefined') {
          setVueInstance(Vue);
        }

        registerComponent(Vue, Table);
        registerComponent(Vue, TableColumn);
      }
    };
    use(Plugin$y);

    var script$C = {
      name: 'BTabs',
      mixins: [TabbedMixin('tab')],
      props: {
        expanded: {
          type: Boolean,
          default: function _default() {
            return config$2.defaultTabsExpanded;
          }
        },
        type: {
          type: [String, Object],
          default: function _default() {
            return config$2.defaultTabsType;
          }
        },
        animated: {
          type: Boolean,
          default: function _default() {
            return config$2.defaultTabsAnimated;
          }
        },
        multiline: Boolean
      },
      data: function data() {
        return {
          currentFocus: this.value
        };
      },
      computed: {
        mainClasses: function mainClasses() {
          return _defineProperty({
            'is-fullwidth': this.expanded,
            'is-vertical': this.vertical,
            'is-multiline': this.multiline
          }, this.position, this.position && this.vertical);
        },
        navClasses: function navClasses() {
          var _ref2;

          return [this.type, this.size, (_ref2 = {}, _defineProperty(_ref2, this.position, this.position && !this.vertical), _defineProperty(_ref2, 'is-fullwidth', this.expanded), _defineProperty(_ref2, 'is-toggle', this.type === 'is-toggle-rounded'), _ref2)];
        }
      },
      methods: {
        giveFocusToTab: function giveFocusToTab(tab) {
          if (tab.$el && tab.$el.focus) {
            tab.$el.focus();
          } else if (tab.focus) {
            tab.focus();
          }
        },
        manageTablistKeydown: function manageTablistKeydown(event) {
          // https://developer.mozilla.org/fr/docs/Web/API/KeyboardEvent/key/Key_Values#Navigation_keys
          var key = event.key;

          switch (key) {
            case this.vertical ? 'ArrowUp' : 'ArrowLeft':
            case this.vertical ? 'Up' : 'Left':
              {
                var prevIdx = this.getPrevItemIdx(this.currentFocus, true);

                if (prevIdx === null) {
                  // We try to give focus back to the last visible element
                  prevIdx = this.getPrevItemIdx(this.items.length, true);
                }

                if (prevIdx !== null && this.$refs.tabLink && prevIdx < this.$refs.tabLink.length && !this.items[prevIdx].disabled) {
                  this.giveFocusToTab(this.$refs.tabLink[prevIdx]);
                }

                event.preventDefault();
                break;
              }

            case this.vertical ? 'ArrowDown' : 'ArrowRight':
            case this.vertical ? 'Down' : 'Right':
              {
                var nextIdx = this.getNextItemIdx(this.currentFocus, true);

                if (nextIdx === null) {
                  // We try to give focus back to the first visible element
                  nextIdx = this.getNextItemIdx(-1, true);
                }

                if (nextIdx !== null && this.$refs.tabLink && nextIdx < this.$refs.tabLink.length && !this.items[nextIdx].disabled) {
                  this.giveFocusToTab(this.$refs.tabLink[nextIdx]);
                }

                event.preventDefault();
                break;
              }
          }
        },
        manageTabKeydown: function manageTabKeydown(event, childItem) {
          // https://developer.mozilla.org/fr/docs/Web/API/KeyboardEvent/key/Key_Values#Navigation_keys
          var key = event.key;

          switch (key) {
            case ' ':
            case 'Space':
            case 'Spacebar':
            case 'Enter':
              {
                this.childClick(childItem);
                event.preventDefault();
                break;
              }
          }
        }
      }
    };

    /* script */
    const __vue_script__$C = script$C;

    /* template */
    var __vue_render__$A = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"b-tabs",class:_vm.mainClasses},[_c('nav',{staticClass:"tabs",class:_vm.navClasses,on:{"keydown":_vm.manageTablistKeydown}},[_vm._t("start"),_c('ul',{attrs:{"aria-orientation":_vm.vertical ? 'vertical' : 'horizontal',"role":"tablist"}},_vm._l((_vm.items),function(childItem,childIdx){return _c('li',{directives:[{name:"show",rawName:"v-show",value:(childItem.visible),expression:"childItem.visible"}],key:childItem.value,class:[ childItem.headerClass, { 'is-active': childItem.isActive,
                                                       'is-disabled': childItem.disabled }],attrs:{"role":"tab","aria-controls":((childItem.value) + "-content"),"aria-selected":("" + (childItem.isActive))}},[(childItem.$scopedSlots.header)?_c('b-slot-component',{ref:"tabLink",refInFor:true,attrs:{"component":childItem,"name":"header","tag":"a","id":((childItem.value) + "-label"),"tabindex":childItem.isActive ? 0 : -1},on:{"keydown":function($event){return _vm.manageTabKeydown($event, childItem)}},nativeOn:{"focus":function($event){_vm.currentFocus = childIdx;},"click":function($event){return _vm.childClick(childItem)}}}):_c('a',{ref:"tabLink",refInFor:true,attrs:{"id":((childItem.value) + "-label"),"tabindex":childItem.isActive ? 0 : -1},on:{"focus":function($event){_vm.currentFocus = childIdx;},"click":function($event){return _vm.childClick(childItem)},"keydown":function($event){return _vm.manageTabKeydown($event, childItem)}}},[(childItem.icon)?_c('b-icon',{attrs:{"icon":childItem.icon,"pack":childItem.iconPack,"size":_vm.size}}):_vm._e(),_c('span',[_vm._v(_vm._s(childItem.label))])],1)],1)}),0),_vm._t("end")],2),_c('section',{staticClass:"tab-content",class:{'is-transitioning': _vm.isTransitioning}},[_vm._t("default")],2)])};
    var __vue_staticRenderFns__$A = [];

      /* style */
      const __vue_inject_styles__$C = undefined;
      /* scoped */
      const __vue_scope_id__$C = undefined;
      /* module identifier */
      const __vue_module_identifier__$C = undefined;
      /* functional template */
      const __vue_is_functional_template__$C = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var Tabs = normalizeComponent_1(
        { render: __vue_render__$A, staticRenderFns: __vue_staticRenderFns__$A },
        __vue_inject_styles__$C,
        __vue_script__$C,
        __vue_scope_id__$C,
        __vue_is_functional_template__$C,
        __vue_module_identifier__$C,
        undefined,
        undefined
      );

    var script$1$h = {
      name: 'BTabItem',
      mixins: [TabbedChildMixin('tab')],
      props: {
        disabled: Boolean
      },
      data: function data() {
        return {
          elementClass: 'tab-item',
          elementRole: 'tabpanel'
        };
      }
    };

    /* script */
    const __vue_script__$1$h = script$1$h;

    /* template */

      /* style */
      const __vue_inject_styles__$1$h = undefined;
      /* scoped */
      const __vue_scope_id__$1$h = undefined;
      /* module identifier */
      const __vue_module_identifier__$1$h = undefined;
      /* functional template */
      const __vue_is_functional_template__$1$h = undefined;
      /* style inject */
      
      /* style inject SSR */
      

      
      var TabItem = normalizeComponent_1(
        {},
        __vue_inject_styles__$1$h,
        __vue_script__$1$h,
        __vue_scope_id__$1$h,
        __vue_is_functional_template__$1$h,
        __vue_module_identifier__$1$h,
        undefined,
        undefined
      );

    var Plugin$z = {
      install: function install(Vue) {
        registerComponent(Vue, Tabs);
        registerComponent(Vue, TabItem);
      }
    };
    use(Plugin$z);

    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    var script$D = {
      name: 'BTag',
      props: {
        attached: Boolean,
        closable: Boolean,
        type: String,
        size: String,
        rounded: Boolean,
        disabled: Boolean,
        ellipsis: Boolean,
        tabstop: {
          type: Boolean,
          default: true
        },
        ariaCloseLabel: String,
        icon: String,
        iconType: String,
        iconPack: String,
        closeType: String,
        closeIcon: String,
        closeIconPack: String,
        closeIconType: String
      },
      methods: {
        /**
        * Emit close event when delete button is clicked
        * or delete key is pressed.
        */
        close: function close(event) {
          if (this.disabled) return;
          this.$emit('close', event);
        },

        /**
        * Emit click event when tag is clicked.
        */
        click: function click(event) {
          if (this.disabled) return;
          this.$emit('click', event);
        }
      }
    };

    /* script */
    const __vue_script__$D = script$D;

    /* template */
    var __vue_render__$B = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return (_vm.attached && _vm.closable)?_c('div',{staticClass:"tags has-addons"},[_c('span',{staticClass:"tag",class:[_vm.type, _vm.size, { 'is-rounded': _vm.rounded }]},[(_vm.icon)?_c('b-icon',{attrs:{"icon":_vm.icon,"size":_vm.size,"type":_vm.iconType,"pack":_vm.iconPack}}):_vm._e(),_c('span',{class:{ 'has-ellipsis': _vm.ellipsis },on:{"click":_vm.click}},[_vm._t("default")],2)],1),_c('a',{staticClass:"tag",class:[_vm.size,
                     _vm.closeType,
                     {'is-rounded': _vm.rounded},
                     _vm.closeIcon ? 'has-delete-icon' : 'is-delete'],attrs:{"role":"button","aria-label":_vm.ariaCloseLabel,"tabindex":_vm.tabstop ? 0 : false,"disabled":_vm.disabled},on:{"click":_vm.close,"keyup":function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"delete",[8,46],$event.key,["Backspace","Delete","Del"])){ return null; }$event.preventDefault();return _vm.close($event)}}},[(_vm.closeIcon)?_c('b-icon',{attrs:{"custom-class":"","icon":_vm.closeIcon,"size":_vm.size,"type":_vm.closeIconType,"pack":_vm.closeIconPack}}):_vm._e()],1)]):_c('span',{staticClass:"tag",class:[_vm.type, _vm.size, { 'is-rounded': _vm.rounded }]},[(_vm.icon)?_c('b-icon',{attrs:{"icon":_vm.icon,"size":_vm.size,"type":_vm.iconType,"pack":_vm.iconPack}}):_vm._e(),_c('span',{class:{ 'has-ellipsis': _vm.ellipsis },on:{"click":_vm.click}},[_vm._t("default")],2),(_vm.closable)?_c('a',{staticClass:"delete is-small",class:_vm.closeType,attrs:{"role":"button","aria-label":_vm.ariaCloseLabel,"disabled":_vm.disabled,"tabindex":_vm.tabstop ? 0 : false},on:{"click":_vm.close,"keyup":function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"delete",[8,46],$event.key,["Backspace","Delete","Del"])){ return null; }$event.preventDefault();return _vm.close($event)}}}):_vm._e()],1)};
    var __vue_staticRenderFns__$B = [];

      /* style */
      const __vue_inject_styles__$D = undefined;
      /* scoped */
      const __vue_scope_id__$D = undefined;
      /* module identifier */
      const __vue_module_identifier__$D = undefined;
      /* functional template */
      const __vue_is_functional_template__$D = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var Tag = normalizeComponent_1(
        { render: __vue_render__$B, staticRenderFns: __vue_staticRenderFns__$B },
        __vue_inject_styles__$D,
        __vue_script__$D,
        __vue_scope_id__$D,
        __vue_is_functional_template__$D,
        __vue_module_identifier__$D,
        undefined,
        undefined
      );

    //
    //
    //
    //
    //
    //
    var script$E = {
      name: 'BTaglist',
      props: {
        attached: Boolean
      }
    };

    /* script */
    const __vue_script__$E = script$E;

    /* template */
    var __vue_render__$C = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"tags",class:{ 'has-addons': _vm.attached }},[_vm._t("default")],2)};
    var __vue_staticRenderFns__$C = [];

      /* style */
      const __vue_inject_styles__$E = undefined;
      /* scoped */
      const __vue_scope_id__$E = undefined;
      /* module identifier */
      const __vue_module_identifier__$E = undefined;
      /* functional template */
      const __vue_is_functional_template__$E = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var Taglist = normalizeComponent_1(
        { render: __vue_render__$C, staticRenderFns: __vue_staticRenderFns__$C },
        __vue_inject_styles__$E,
        __vue_script__$E,
        __vue_scope_id__$E,
        __vue_is_functional_template__$E,
        __vue_module_identifier__$E,
        undefined,
        undefined
      );

    var Plugin$A = {
      install: function install(Vue) {
        registerComponent(Vue, Tag);
        registerComponent(Vue, Taglist);
      }
    };
    use(Plugin$A);

    var _components$b;
    var script$F = {
      name: 'BTaginput',
      components: (_components$b = {}, _defineProperty(_components$b, Autocomplete.name, Autocomplete), _defineProperty(_components$b, Tag.name, Tag), _components$b),
      mixins: [FormElementMixin],
      inheritAttrs: false,
      props: {
        value: {
          type: Array,
          default: function _default() {
            return [];
          }
        },
        data: {
          type: Array,
          default: function _default() {
            return [];
          }
        },
        type: String,
        closeType: String,
        rounded: {
          type: Boolean,
          default: false
        },
        attached: {
          type: Boolean,
          default: false
        },
        maxtags: {
          type: [Number, String],
          required: false
        },
        hasCounter: {
          type: Boolean,
          default: function _default() {
            return config$2.defaultTaginputHasCounter;
          }
        },
        field: {
          type: String,
          default: 'value'
        },
        autocomplete: Boolean,
        groupField: String,
        groupOptions: String,
        nativeAutocomplete: String,
        openOnFocus: Boolean,
        keepFirst: Boolean,
        disabled: Boolean,
        ellipsis: Boolean,
        closable: {
          type: Boolean,
          default: true
        },
        ariaCloseLabel: String,
        confirmKeys: {
          type: Array,
          default: function _default() {
            return [',', 'Tab', 'Enter'];
          }
        },
        removeOnKeys: {
          type: Array,
          default: function _default() {
            return ['Backspace'];
          }
        },
        allowNew: Boolean,
        onPasteSeparators: {
          type: Array,
          default: function _default() {
            return [','];
          }
        },
        beforeAdding: {
          type: Function,
          default: function _default() {
            return true;
          }
        },
        allowDuplicates: {
          type: Boolean,
          default: false
        },
        checkInfiniteScroll: {
          type: Boolean,
          default: false
        },
        createTag: {
          type: Function,
          default: function _default(tag) {
            return tag;
          }
        },
        appendToBody: Boolean
      },
      data: function data() {
        return {
          tags: Array.isArray(this.value) ? this.value.slice(0) : this.value || [],
          newTag: '',
          isComposing: false,
          _elementRef: 'autocomplete',
          _isTaginput: true
        };
      },
      computed: {
        listeners: function listeners() {
          var _this$$listeners = this.$listeners,
              input = _this$$listeners.input,
              listeners = _objectWithoutProperties(_this$$listeners, ["input"]);

          return listeners;
        },
        rootClasses: function rootClasses() {
          return {
            'is-expanded': this.expanded
          };
        },
        containerClasses: function containerClasses() {
          return {
            'is-focused': this.isFocused,
            'is-focusable': this.hasInput
          };
        },
        valueLength: function valueLength() {
          return this.newTag.trim().length;
        },
        hasDefaultSlot: function hasDefaultSlot() {
          return !!this.$scopedSlots.default;
        },
        hasEmptySlot: function hasEmptySlot() {
          return !!this.$slots.empty;
        },
        hasHeaderSlot: function hasHeaderSlot() {
          return !!this.$slots.header;
        },
        hasFooterSlot: function hasFooterSlot() {
          return !!this.$slots.footer;
        },

        /**
         * Show the input field if a maxtags hasn't been set or reached.
         */
        hasInput: function hasInput() {
          return this.maxtags == null || this.maxtags === 1 || this.tagsLength < this.maxtags;
        },
        tagsLength: function tagsLength() {
          return this.tags.length;
        },

        /**
         * If Taginput has onPasteSeparators prop,
         * returning new RegExp used to split pasted string.
         */
        separatorsAsRegExp: function separatorsAsRegExp() {
          var sep = this.onPasteSeparators;
          return sep.length ? new RegExp(sep.map(function (s) {
            return s ? s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&') : null;
          }).join('|'), 'g') : null;
        }
      },
      watch: {
        /**
         * When v-model is changed set internal value.
         */
        value: function value(_value) {
          this.tags = Array.isArray(_value) ? _value.slice(0) : _value || [];
        },
        hasInput: function hasInput() {
          if (!this.hasInput) this.onBlur();
        }
      },
      methods: {
        addTag: function addTag(tag) {
          var _this = this;

          var tagToAdd = tag || this.newTag.trim();

          if (tagToAdd) {
            if (!this.autocomplete) {
              var reg = this.separatorsAsRegExp;

              if (reg && tagToAdd.match(reg)) {
                tagToAdd.split(reg).map(function (t) {
                  return t.trim();
                }).filter(function (t) {
                  return t.length !== 0;
                }).map(this.addTag);
                return;
              }
            } // Add the tag input if it is not blank
            // or previously added (if not allowDuplicates).


            var add = !this.allowDuplicates ? this.tags.indexOf(tagToAdd) === -1 : true;

            if (add && this.beforeAdding(tagToAdd)) {
              if (this.maxtags === 1) {
                this.tags = []; // replace existing tag if only 1 is allowed
              }

              this.tags.push(this.createTag(tagToAdd));
              this.$emit('input', this.tags);
              this.$emit('add', tagToAdd);
            } // after autocomplete events


            requestAnimationFrame(function () {
              _this.newTag = '';

              _this.$emit('typing', '');
            });
          }
        },
        getNormalizedTagText: function getNormalizedTagText(tag) {
          if (_typeof(tag) === 'object') {
            tag = getValueByPath(tag, this.field);
          }

          return "".concat(tag);
        },
        customOnBlur: function customOnBlur(event) {
          // Add tag on-blur if not select only
          if (!this.autocomplete) this.addTag();
          this.onBlur(event);
        },
        onSelect: function onSelect(option) {
          var _this2 = this;

          if (!option) return;
          this.addTag(option);
          this.$nextTick(function () {
            _this2.newTag = '';
          });
        },
        removeTag: function removeTag(index, event) {
          var tag = this.tags.splice(index, 1)[0];
          this.$emit('input', this.tags);
          this.$emit('remove', tag);
          if (event) event.stopPropagation();

          if (this.openOnFocus && this.$refs.autocomplete) {
            this.$refs.autocomplete.focus();
          }

          return tag;
        },
        removeLastTag: function removeLastTag() {
          if (this.tagsLength > 0) {
            this.removeTag(this.tagsLength - 1);
          }
        },
        keydown: function keydown(event) {
          var key = event.key; // cannot destructure preventDefault (https://stackoverflow.com/a/49616808/2774496)

          if (this.removeOnKeys.indexOf(key) !== -1 && !this.newTag.length) {
            this.removeLastTag();
          } // Stop if is to accept select only


          if (this.autocomplete && !this.allowNew) return;

          if (this.confirmKeys.indexOf(key) >= 0) {
            // Allow Tab to advance to next field regardless
            if (key !== 'Tab') event.preventDefault();
            if (key === 'Enter' && this.isComposing) return;
            this.addTag();
          }
        },
        onTyping: function onTyping(event) {
          this.$emit('typing', event.trim());
        },
        emitInfiniteScroll: function emitInfiniteScroll() {
          this.$emit('infinite-scroll');
        }
      }
    };

    /* script */
    const __vue_script__$F = script$F;

    /* template */
    var __vue_render__$D = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"taginput control",class:_vm.rootClasses},[_c('div',{staticClass:"taginput-container",class:[_vm.statusType, _vm.size, _vm.containerClasses],attrs:{"disabled":_vm.disabled},on:{"click":function($event){_vm.hasInput && _vm.focus($event);}}},[_vm._t("selected",_vm._l((_vm.tags),function(tag,index){return _c('b-tag',{key:_vm.getNormalizedTagText(tag) + index,attrs:{"type":_vm.type,"close-type":_vm.closeType,"size":_vm.size,"rounded":_vm.rounded,"attached":_vm.attached,"tabstop":false,"disabled":_vm.disabled,"ellipsis":_vm.ellipsis,"closable":_vm.closable,"aria-close-label":_vm.ariaCloseLabel,"title":_vm.ellipsis && _vm.getNormalizedTagText(tag)},on:{"close":function($event){return _vm.removeTag(index, $event)}}},[_vm._t("tag",[_vm._v(" "+_vm._s(_vm.getNormalizedTagText(tag))+" ")],{"tag":tag})],2)}),{"tags":_vm.tags}),(_vm.hasInput)?_c('b-autocomplete',_vm._g(_vm._b({ref:"autocomplete",attrs:{"data":_vm.data,"field":_vm.field,"icon":_vm.icon,"icon-pack":_vm.iconPack,"maxlength":_vm.maxlength,"has-counter":false,"size":_vm.size,"disabled":_vm.disabled,"loading":_vm.loading,"autocomplete":_vm.nativeAutocomplete,"open-on-focus":_vm.openOnFocus,"keep-open":_vm.openOnFocus,"keep-first":_vm.keepFirst,"group-field":_vm.groupField,"group-options":_vm.groupOptions,"use-html5-validation":_vm.useHtml5Validation,"check-infinite-scroll":_vm.checkInfiniteScroll,"append-to-body":_vm.appendToBody,"confirm-keys":_vm.confirmKeys},on:{"typing":_vm.onTyping,"focus":_vm.onFocus,"blur":_vm.customOnBlur,"select":_vm.onSelect,"infinite-scroll":_vm.emitInfiniteScroll},nativeOn:{"keydown":function($event){return _vm.keydown($event)},"compositionstart":function($event){_vm.isComposing = true;},"compositionend":function($event){_vm.isComposing = false;}},scopedSlots:_vm._u([(_vm.hasHeaderSlot)?{key:"header",fn:function(){return [_vm._t("header")]},proxy:true}:null,(_vm.hasDefaultSlot)?{key:"default",fn:function(props){return [_vm._t("default",null,{"option":props.option,"index":props.index})]}}:null,(_vm.hasEmptySlot)?{key:"empty",fn:function(){return [_vm._t("empty")]},proxy:true}:null,(_vm.hasFooterSlot)?{key:"footer",fn:function(){return [_vm._t("footer")]},proxy:true}:null],null,true),model:{value:(_vm.newTag),callback:function ($$v) {_vm.newTag=$$v;},expression:"newTag"}},'b-autocomplete',_vm.$attrs,false),_vm.listeners)):_vm._e()],2),(_vm.hasCounter && (_vm.maxtags || _vm.maxlength))?_c('small',{staticClass:"help counter"},[(_vm.maxlength && _vm.valueLength > 0)?[_vm._v(" "+_vm._s(_vm.valueLength)+" / "+_vm._s(_vm.maxlength)+" ")]:(_vm.maxtags)?[_vm._v(" "+_vm._s(_vm.tagsLength)+" / "+_vm._s(_vm.maxtags)+" ")]:_vm._e()],2):_vm._e()])};
    var __vue_staticRenderFns__$D = [];

      /* style */
      const __vue_inject_styles__$F = undefined;
      /* scoped */
      const __vue_scope_id__$F = undefined;
      /* module identifier */
      const __vue_module_identifier__$F = undefined;
      /* functional template */
      const __vue_is_functional_template__$F = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var Taginput = normalizeComponent_1(
        { render: __vue_render__$D, staticRenderFns: __vue_staticRenderFns__$D },
        __vue_inject_styles__$F,
        __vue_script__$F,
        __vue_scope_id__$F,
        __vue_is_functional_template__$F,
        __vue_module_identifier__$F,
        undefined,
        undefined
      );

    var Plugin$B = {
      install: function install(Vue) {
        registerComponent(Vue, Taginput);
      }
    };
    use(Plugin$B);

    var Plugin$C = {
      install: function install(Vue) {
        registerComponent(Vue, Timepicker);
      }
    };
    use(Plugin$C);

    //
    var script$G = {
      name: 'BToast',
      mixins: [NoticeMixin],
      data: function data() {
        return {
          newDuration: this.duration || config$2.defaultToastDuration
        };
      }
    };

    /* script */
    const __vue_script__$G = script$G;

    /* template */
    var __vue_render__$E = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"enter-active-class":_vm.transition.enter,"leave-active-class":_vm.transition.leave}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.isActive),expression:"isActive"}],staticClass:"toast",class:[_vm.type, _vm.position],attrs:{"aria-hidden":!_vm.isActive,"role":"alert"},on:{"mouseenter":_vm.pause,"mouseleave":_vm.removePause}},[(_vm.$slots.default)?[_vm._t("default")]:[_c('div',{domProps:{"innerHTML":_vm._s(_vm.message)}})]],2)])};
    var __vue_staticRenderFns__$E = [];

      /* style */
      const __vue_inject_styles__$G = undefined;
      /* scoped */
      const __vue_scope_id__$G = undefined;
      /* module identifier */
      const __vue_module_identifier__$G = undefined;
      /* functional template */
      const __vue_is_functional_template__$G = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var Toast = normalizeComponent_1(
        { render: __vue_render__$E, staticRenderFns: __vue_staticRenderFns__$E },
        __vue_inject_styles__$G,
        __vue_script__$G,
        __vue_scope_id__$G,
        __vue_is_functional_template__$G,
        __vue_module_identifier__$G,
        undefined,
        undefined
      );

    var localVueInstance$5;
    var ToastProgrammatic = {
      open: function open(params) {
        var parent;

        if (typeof params === 'string') {
          params = {
            message: params
          };
        }

        var defaultParam = {
          position: config$2.defaultToastPosition || 'is-top'
        };

        if (params.parent) {
          parent = params.parent;
          delete params.parent;
        }

        var slot;

        if (Array.isArray(params.message)) {
          slot = params.message;
          delete params.message;
        }

        var propsData = merge$1(defaultParam, params);
        var vm = typeof window !== 'undefined' && window.Vue ? window.Vue : localVueInstance$5 || VueInstance;
        var ToastComponent = vm.extend(Toast);
        var component = new ToastComponent({
          parent: parent,
          el: document.createElement('div'),
          propsData: propsData
        });

        if (slot) {
          component.$slots.default = slot;
          component.$forceUpdate();
        }

        return component;
      }
    };
    var Plugin$D = {
      install: function install(Vue) {
        localVueInstance$5 = Vue;
        registerComponentProgrammatic(Vue, 'toast', ToastProgrammatic);
      }
    };
    use(Plugin$D);

    var Plugin$E = {
      install: function install(Vue) {
        registerComponent(Vue, Tooltip);
      }
    };
    use(Plugin$E);

    //
    var script$H = {
      name: 'BUpload',
      mixins: [FormElementMixin],
      inheritAttrs: false,
      props: {
        value: {
          type: [Object, Function, File$1, Array]
        },
        multiple: Boolean,
        disabled: Boolean,
        accept: String,
        dragDrop: Boolean,
        type: {
          type: String,
          default: 'is-primary'
        },
        native: {
          type: Boolean,
          default: false
        },
        expanded: {
          type: Boolean,
          default: false
        },
        rounded: {
          type: Boolean,
          default: false
        }
      },
      data: function data() {
        return {
          newValue: this.value,
          dragDropFocus: false,
          _elementRef: 'input'
        };
      },
      watch: {
        /**
         *   When v-model is changed:
         *   1. Set internal value.
         *   2. Reset internal input file value
         *   3. If it's invalid, validate again.
         */
        value: function value(_value) {
          this.newValue = _value;

          if (!_value || Array.isArray(_value) && _value.length === 0) {
            this.$refs.input.value = null;
          }

          !this.isValid && !this.dragDrop && this.checkHtml5Validity();
        }
      },
      methods: {
        /**
        * Listen change event on input type 'file',
        * emit 'input' event and validate
        */
        onFileChange: function onFileChange(event) {
          if (this.disabled || this.loading) return;
          if (this.dragDrop) this.updateDragDropFocus(false);
          var value = event.target.files || event.dataTransfer.files;

          if (value.length === 0) {
            if (!this.newValue) return;
            if (this.native) this.newValue = null;
          } else if (!this.multiple) {
            // only one element in case drag drop mode and isn't multiple
            if (this.dragDrop && value.length !== 1) return;else {
              var file = value[0];
              if (this.checkType(file)) this.newValue = file;else if (this.newValue) {
                this.newValue = null;
                this.clearInput();
              } else {
                // Force input back to empty state and recheck validity
                this.clearInput();
                this.checkHtml5Validity();
                return;
              }
            }
          } else {
            // always new values if native or undefined local
            var newValues = false;

            if (this.native || !this.newValue) {
              this.newValue = [];
              newValues = true;
            }

            for (var i = 0; i < value.length; i++) {
              var _file = value[i];

              if (this.checkType(_file)) {
                this.newValue.push(_file);
                newValues = true;
              }
            }

            if (!newValues) return;
          }

          this.$emit('input', this.newValue);
          !this.dragDrop && this.checkHtml5Validity();
        },

        /*
        * Reset file input value
        */
        clearInput: function clearInput() {
          this.$refs.input.value = null;
        },

        /**
        * Listen drag-drop to update internal variable
        */
        updateDragDropFocus: function updateDragDropFocus(focus) {
          if (!this.disabled && !this.loading) {
            this.dragDropFocus = focus;
          }
        },

        /**
        * Check mime type of file
        */
        checkType: function checkType(file) {
          if (!this.accept) return true;
          var types = this.accept.split(',');
          if (types.length === 0) return true;
          var valid = false;

          for (var i = 0; i < types.length && !valid; i++) {
            var type = types[i].trim();

            if (type) {
              if (type.substring(0, 1) === '.') {
                // check extension
                var extension = file.name.toLowerCase().slice(-type.length);

                if (extension === type.toLowerCase()) {
                  valid = true;
                }
              } else {
                // check mime type
                if (file.type.match(type)) {
                  valid = true;
                }
              }
            }
          }

          if (!valid) this.$emit('invalid');
          return valid;
        }
      }
    };

    /* script */
    const __vue_script__$H = script$H;

    /* template */
    var __vue_render__$F = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('label',{staticClass:"upload control",class:{'is-expanded' : _vm.expanded, 'is-rounded' : _vm.rounded}},[(!_vm.dragDrop)?[_vm._t("default")]:_c('div',{staticClass:"upload-draggable",class:[_vm.type, {
                'is-loading': _vm.loading,
                'is-disabled': _vm.disabled,
                'is-hovered': _vm.dragDropFocus,
                'is-expanded': _vm.expanded,
            }],on:{"dragover":function($event){$event.preventDefault();return _vm.updateDragDropFocus(true)},"dragleave":function($event){$event.preventDefault();return _vm.updateDragDropFocus(false)},"dragenter":function($event){$event.preventDefault();return _vm.updateDragDropFocus(true)},"drop":function($event){$event.preventDefault();return _vm.onFileChange($event)}}},[_vm._t("default")],2),_c('input',_vm._b({ref:"input",attrs:{"type":"file","multiple":_vm.multiple,"accept":_vm.accept,"disabled":_vm.disabled},on:{"change":_vm.onFileChange}},'input',_vm.$attrs,false))],2)};
    var __vue_staticRenderFns__$F = [];

      /* style */
      const __vue_inject_styles__$H = undefined;
      /* scoped */
      const __vue_scope_id__$H = undefined;
      /* module identifier */
      const __vue_module_identifier__$H = undefined;
      /* functional template */
      const __vue_is_functional_template__$H = false;
      /* style inject */
      
      /* style inject SSR */
      

      
      var Upload = normalizeComponent_1(
        { render: __vue_render__$F, staticRenderFns: __vue_staticRenderFns__$F },
        __vue_inject_styles__$H,
        __vue_script__$H,
        __vue_scope_id__$H,
        __vue_is_functional_template__$H,
        __vue_module_identifier__$H,
        undefined,
        undefined
      );

    var Plugin$F = {
      install: function install(Vue) {
        registerComponent(Vue, Upload);
      }
    };
    use(Plugin$F);

    var ConfigComponent = {
      getOptions: function getOptions() {
        return config$2;
      },
      setOptions: function setOptions$1(options) {
        setOptions(merge$1(config$2, options, true));
      }
    };

    var components = /*#__PURE__*/Object.freeze({
        Autocomplete: Plugin,
        Breadcrumb: Plugin$1,
        Button: Plugin$2,
        Carousel: Plugin$3,
        Checkbox: Plugin$4,
        Clockpicker: Plugin$6,
        Collapse: Plugin$5,
        Colorpicker: Plugin$7,
        Datepicker: Plugin$8,
        Datetimepicker: Plugin$9,
        Dialog: Plugin$a,
        Dropdown: Plugin$b,
        Field: Plugin$c,
        Icon: Plugin$d,
        Image: Plugin$e,
        Input: Plugin$f,
        Loading: Plugin$g,
        Menu: Plugin$h,
        Message: Plugin$i,
        Modal: Plugin$j,
        Navbar: Plugin$l,
        Notification: Plugin$k,
        Numberinput: Plugin$m,
        Pagination: Plugin$n,
        Progress: Plugin$o,
        Radio: Plugin$p,
        Rate: Plugin$q,
        Select: Plugin$r,
        Skeleton: Plugin$s,
        Sidebar: Plugin$t,
        Slider: Plugin$u,
        Snackbar: Plugin$v,
        Steps: Plugin$w,
        Switch: Plugin$x,
        Table: Plugin$y,
        Tabs: Plugin$z,
        Tag: Plugin$A,
        Taginput: Plugin$B,
        Timepicker: Plugin$C,
        Toast: Plugin$D,
        Tooltip: Plugin$E,
        Upload: Plugin$F
    });

    var Buefy = {
      install: function install(Vue) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        setVueInstance(Vue); // Options

        setOptions(merge$1(config$2, options, true)); // Components

        for (var componentKey in components) {
          Vue.use(components[componentKey]);
        } // Config component


        registerComponentProgrammatic(Vue, 'config', ConfigComponent);
        Vue.prototype.$buefy.globalNoticeInterval = null;
      }
    };
    use(Buefy);

    Vue$1.use(VueRx, { Subject });
    Vue$1.use(Buefy);

    // general components
    Vue$1.component('toggle-button', {
        props: ['ontext', 'offtext'],
        template:'#toggleButtonTemplate',
        data(){
            return {
                name: "Play",
                isOn: false
            };
        },
        mounted(){
            this.name = this.ontext;
        },
        methods:
        {
            buttonclicked: function(value)
            {
                this.isOn = !this.isOn;
                this.name = this.isOn ? this.ontext : this.offtext;
                this.$emit('buttonclicked', this.isOn);
            },
            setState: function(value)
            {
                this.isOn = value;
                this.name = this.isOn ? this.ontext : this.offtext;
            }
        }
    });
    Vue$1.component('json-to-ui-template', {
        props: ['data', 'isinner'],
        template:'#jsonToUITemplate'
    });

    const app = new Vue$1({
        domStreams: ['modelChanged$', 'flavourChanged$', 'sceneChanged$', 'cameraChanged$',
            'environmentChanged$', 'debugchannelChanged$', 'tonemapChanged$', 'skinningChanged$',
            'punctualLightsChanged$', 'iblChanged$', 'blurEnvChanged$', 'morphingChanged$',
            'addEnvironment$', 'colorChanged$', 'environmentRotationChanged$', 'animationPlayChanged$', 'selectedAnimationsChanged$',
            'variantChanged$', 'exposureChanged$', "clearcoatChanged$", "sheenChanged$", "transmissionChanged$",
            'cameraExport$', 'captureCanvas$','iblIntensityChanged$',],
        data() {
            return {
                fullheight: true,
                right: true,
                models: ["DamagedHelmet"],
                flavours: ["glTF", "glTF-Binary", "glTF-Quantized", "glTF-Draco", "glTF-pbrSpecularGlossiness"],
                scenes: [{title: "0"}, {title: "1"}],
                cameras: [{title: "User Camera", index: -1}],
                materialVariants: [{title: "None"}],

                animations: [{title: "cool animation"}, {title: "even cooler"}, {title: "not cool"}, {title: "Do not click!"}],
                tonemaps: [{title: "None"}],
                debugchannels: [{title: "None"}],
                xmp: [{title: "xmp"}],
                statistics: [],

                selectedModel: "DamagedHelmet",
                selectedFlavour: "",
                selectedScene: {},
                selectedCamera: {},
                selectedVariant: "None",
                selectedAnimations: [],
                disabledAnimations: [],

                ibl: true,
                iblIntensity: 0.0,
                punctualLights: true,
                renderEnv: true,
                blurEnv: true,
                clearColor: "",
                environmentRotations: [{title: "+Z"}, {title: "-X"}, {title: "-Z"}, {title: "+X"}],
                selectedEnvironmentRotation: "+Z",
                environments: [{index: 0, name: ""}],
                selectedEnvironment: 0,

                debugChannel: "None",
                exposureSetting: 0,
                toneMap: "None",
                skinning: true,
                morphing: true,
                clearcoatEnabled: true,
                sheenEnabled: true,
                transmissionEnabled: true,
                volumeEnabled: true,
                iorEnabled: true,
                iridescenceEnabled: true,
                specularEnabled: true,
                emissiveStrengthEnabled: true,

                activeTab: 0,
                tabsHidden: false,
                loadingComponent: undefined,
                showDropDownOverlay: false,
                uploadedHDR: undefined,
                uiVisible: true,
                

                // these are handls for certain ui change related things
                environmentVisiblePrefState: true,
                volumeEnabledPrefState: true,
            };
        },
        mounted: function()
        {
            // remove input class from color picker (added by default by buefy)
            const colorPicker = document.getElementById("clearColorPicker");
            colorPicker.classList.remove("input");

            // test if webgl is present
            const context = canvas.getContext("webgl2", { alpha: false, antialias: true });
            if (context === undefined || context === null) {
                this.error("The sample viewer requires WebGL 2.0, which is not supported by this browser or device. " + 
                "Please try again with another browser, or check https://get.webgl.org/webgl2/ " +
                "if you believe you are seeing this message in error.", 15000);
            }

            // add github logo to navbar
            this.$nextTick(function () {
                // Code that will run only after the
                // entire view has been rendered
                var a = document.createElement('a');
                a.href = "https://github.com/KhronosGroup/glTF-Sample-Viewer";
                var img = document.createElement('img');
                img.src ="assets/ui/GitHub-Mark-Light-32px.png";
                img.style.width = "22px";
                img.style.height = "22px";
                document.getElementById("tabsContainer").childNodes[0].childNodes[0].appendChild(a);
                a.appendChild(img);
            });

        },
        methods:
        {
            setAnimationState: function(value)
            {
                this.$refs.animationState.setState(value);
            },
            iblTriggered: function(value)
            {
                if(this.ibl == false)
                {
                    this.environmentVisiblePrefState = this.renderEnv;
                    this.renderEnv = false;
                }
                else {
                    this.renderEnv = this.environmentVisiblePrefState;
                }
            },
            transmissionTriggered: function(value)
            {
                if(this.transmissionEnabled == false)
                {
                    this.volumeEnabledPrefState = this.volumeEnabled;
                    this.volumeEnabled = false;
                }
                else {
                    this.volumeEnabled = this.volumeEnabledPrefState;
                }
            },
            collapseActiveTab : function(event, item) {
                if (item === this.activeTab)
                {
                    this.tabsHidden = !this.tabsHidden;
                    
                    if(this.tabsHidden) {
                        // remove is-active class if tabs are hidden
                        event.stopPropagation();
                        
                        let navElements = document.getElementById("tabsContainer").childNodes[0].childNodes[0].childNodes;
                        for(let elem of navElements) {
                            elem.classList.remove('is-active');
                        }
                    } else {
                        // add is-active class to correct element
                        let activeNavElement = document.getElementById("tabsContainer").childNodes[0].childNodes[0].childNodes[item];
                        activeNavElement.classList.add('is-active');
                    }
                    return;
                }
                else {
                    // reset tab visibility
                    this.tabsHidden = false;
                }
                
            },
            warn(message) {
                this.$buefy.toast.open({
                    message: message,
                    type: 'is-warning'
                });
            },
            error(message, duration = 5000) {
                this.$buefy.toast.open({
                    message: message,
                    type: 'is-danger',
                    duration: duration
                });
            },
            goToLoadingState() {
                if(this.loadingComponent !== undefined)
                {
                    return;
                }
                this.loadingComponent = this.$buefy.loading.open({
                    container: null
                });
            },
            exitLoadingState()
            {
                if(this.loadingComponent === undefined)
                {
                    return;
                }
                this.loadingComponent.close();
                this.loadingComponent = undefined;
            },
            onFileChange(e) {
                const file = e.target.files[0];
                this.uploadedHDR = file;
            },
            hide() {
                this.uiVisible = false;
            },
            show() {
                this.uiVisible = true;
            },
        }
    }).$mount('#app');

    const canvasUI = new Vue$1({
        data() {
            return {
                fullscreen: false,
                timer: null
            };
        },
        methods:
        {
            toggleFullscreen() {
                if(this.fullscreen) {
                    app.show();
                } else {
                    app.hide();
                }
                this.fullscreen = !this.fullscreen;
            },
            mouseMove() {
                this.$refs.fullscreenIcon.style.display = "block";
                this.setFullscreenIconTimer();
            },
            setFullscreenIconTimer() {
                clearTimeout(this.timer);
                this.timer = window.setTimeout( () => {
                    this.$refs.fullscreenIcon.style.display = "none";
                }, 1000);
            }
        }

    }).$mount('#canvasUI');

    // pipe error messages to UI
    (function(){

        var originalWarn = console.warn;
        var originalError = console.error;

        console.warn = function(txt) {
            app.warn(txt);
            originalWarn.apply(console, arguments);
        };
        console.error = function(txt) {
            app.error(txt);
            originalError.apply(console, arguments);
        };

        window.onerror = function(msg, url, lineNo, columnNo, error) {
            var message = [
                'Message: ' + msg,
                'URL: ' + url,
                'Line: ' + lineNo,
                'Column: ' + columnNo,
                'Error object: ' + JSON.stringify(error)
              ].join(' - ');
            app.error(message);
        };
    })();

    var bind$4 = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };

    // utils is a library of generic helper functions non-specific to axios

    var toString$1 = Object.prototype.toString;

    /**
     * Determine if a value is an Array
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an Array, otherwise false
     */
    function isArray$1(val) {
      return toString$1.call(val) === '[object Array]';
    }

    /**
     * Determine if a value is undefined
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if the value is undefined, otherwise false
     */
    function isUndefined(val) {
      return typeof val === 'undefined';
    }

    /**
     * Determine if a value is a Buffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Buffer, otherwise false
     */
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
        && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
    }

    /**
     * Determine if a value is an ArrayBuffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an ArrayBuffer, otherwise false
     */
    function isArrayBuffer(val) {
      return toString$1.call(val) === '[object ArrayBuffer]';
    }

    /**
     * Determine if a value is a FormData
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an FormData, otherwise false
     */
    function isFormData(val) {
      return (typeof FormData !== 'undefined') && (val instanceof FormData);
    }

    /**
     * Determine if a value is a view on an ArrayBuffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
     */
    function isArrayBufferView(val) {
      var result;
      if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
        result = ArrayBuffer.isView(val);
      } else {
        result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
      }
      return result;
    }

    /**
     * Determine if a value is a String
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a String, otherwise false
     */
    function isString(val) {
      return typeof val === 'string';
    }

    /**
     * Determine if a value is a Number
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Number, otherwise false
     */
    function isNumber(val) {
      return typeof val === 'number';
    }

    /**
     * Determine if a value is an Object
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an Object, otherwise false
     */
    function isObject$3(val) {
      return val !== null && typeof val === 'object';
    }

    /**
     * Determine if a value is a plain Object
     *
     * @param {Object} val The value to test
     * @return {boolean} True if value is a plain Object, otherwise false
     */
    function isPlainObject$1(val) {
      if (toString$1.call(val) !== '[object Object]') {
        return false;
      }

      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }

    /**
     * Determine if a value is a Date
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Date, otherwise false
     */
    function isDate(val) {
      return toString$1.call(val) === '[object Date]';
    }

    /**
     * Determine if a value is a File
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a File, otherwise false
     */
    function isFile(val) {
      return toString$1.call(val) === '[object File]';
    }

    /**
     * Determine if a value is a Blob
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Blob, otherwise false
     */
    function isBlob(val) {
      return toString$1.call(val) === '[object Blob]';
    }

    /**
     * Determine if a value is a Function
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Function, otherwise false
     */
    function isFunction$1(val) {
      return toString$1.call(val) === '[object Function]';
    }

    /**
     * Determine if a value is a Stream
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Stream, otherwise false
     */
    function isStream(val) {
      return isObject$3(val) && isFunction$1(val.pipe);
    }

    /**
     * Determine if a value is a URLSearchParams object
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a URLSearchParams object, otherwise false
     */
    function isURLSearchParams(val) {
      return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
    }

    /**
     * Trim excess whitespace off the beginning and end of a string
     *
     * @param {String} str The String to trim
     * @returns {String} The String freed of excess whitespace
     */
    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
    }

    /**
     * Determine if we're running in a standard browser environment
     *
     * This allows axios to run in a web worker, and react-native.
     * Both environments support XMLHttpRequest, but not fully standard globals.
     *
     * web workers:
     *  typeof window -> undefined
     *  typeof document -> undefined
     *
     * react-native:
     *  navigator.product -> 'ReactNative'
     * nativescript
     *  navigator.product -> 'NativeScript' or 'NS'
     */
    function isStandardBrowserEnv() {
      if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                               navigator.product === 'NativeScript' ||
                                               navigator.product === 'NS')) {
        return false;
      }
      return (
        typeof window !== 'undefined' &&
        typeof document !== 'undefined'
      );
    }

    /**
     * Iterate over an Array or an Object invoking a function for each item.
     *
     * If `obj` is an Array callback will be called passing
     * the value, index, and complete array for each item.
     *
     * If 'obj' is an Object callback will be called passing
     * the value, key, and complete object for each property.
     *
     * @param {Object|Array} obj The object to iterate
     * @param {Function} fn The callback to invoke for each item
     */
    function forEach$1(obj, fn) {
      // Don't bother if no value provided
      if (obj === null || typeof obj === 'undefined') {
        return;
      }

      // Force an array if not already something iterable
      if (typeof obj !== 'object') {
        /*eslint no-param-reassign:0*/
        obj = [obj];
      }

      if (isArray$1(obj)) {
        // Iterate over array values
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        // Iterate over object keys
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }

    /**
     * Accepts varargs expecting each argument to be an object, then
     * immutably merges the properties of each object and returns result.
     *
     * When multiple objects contain the same key the later object in
     * the arguments list will take precedence.
     *
     * Example:
     *
     * ```js
     * var result = merge({foo: 123}, {foo: 456});
     * console.log(result.foo); // outputs 456
     * ```
     *
     * @param {Object} obj1 Object to merge
     * @returns {Object} Result of all merge properties
     */
    function merge$2(/* obj1, obj2, obj3, ... */) {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject$1(result[key]) && isPlainObject$1(val)) {
          result[key] = merge$2(result[key], val);
        } else if (isPlainObject$1(val)) {
          result[key] = merge$2({}, val);
        } else if (isArray$1(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }

      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach$1(arguments[i], assignValue);
      }
      return result;
    }

    /**
     * Extends object a by mutably adding to it the properties of object b.
     *
     * @param {Object} a The object to be extended
     * @param {Object} b The object to copy properties from
     * @param {Object} thisArg The object to bind function to
     * @return {Object} The resulting value of object a
     */
    function extend$1(a, b, thisArg) {
      forEach$1(b, function assignValue(val, key) {
        if (thisArg && typeof val === 'function') {
          a[key] = bind$4(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }

    /**
     * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
     *
     * @param {string} content with BOM
     * @return {string} content value without BOM
     */
    function stripBOM(content) {
      if (content.charCodeAt(0) === 0xFEFF) {
        content = content.slice(1);
      }
      return content;
    }

    var utils = {
      isArray: isArray$1,
      isArrayBuffer: isArrayBuffer,
      isBuffer: isBuffer,
      isFormData: isFormData,
      isArrayBufferView: isArrayBufferView,
      isString: isString,
      isNumber: isNumber,
      isObject: isObject$3,
      isPlainObject: isPlainObject$1,
      isUndefined: isUndefined,
      isDate: isDate,
      isFile: isFile,
      isBlob: isBlob,
      isFunction: isFunction$1,
      isStream: isStream,
      isURLSearchParams: isURLSearchParams,
      isStandardBrowserEnv: isStandardBrowserEnv,
      forEach: forEach$1,
      merge: merge$2,
      extend: extend$1,
      trim: trim,
      stripBOM: stripBOM
    };

    function encode(val) {
      return encodeURIComponent(val).
        replace(/%3A/gi, ':').
        replace(/%24/g, '$').
        replace(/%2C/gi, ',').
        replace(/%20/g, '+').
        replace(/%5B/gi, '[').
        replace(/%5D/gi, ']');
    }

    /**
     * Build a URL by appending params to the end
     *
     * @param {string} url The base of the url (e.g., http://www.google.com)
     * @param {object} [params] The params to be appended
     * @returns {string} The formatted url
     */
    var buildURL = function buildURL(url, params, paramsSerializer) {
      /*eslint no-param-reassign:0*/
      if (!params) {
        return url;
      }

      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];

        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === 'undefined') {
            return;
          }

          if (utils.isArray(val)) {
            key = key + '[]';
          } else {
            val = [val];
          }

          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + '=' + encode(v));
          });
        });

        serializedParams = parts.join('&');
      }

      if (serializedParams) {
        var hashmarkIndex = url.indexOf('#');
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }

        url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
      }

      return url;
    };

    function InterceptorManager() {
      this.handlers = [];
    }

    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */
    InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled: fulfilled,
        rejected: rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };

    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     */
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };

    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     */
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };

    var InterceptorManager_1 = InterceptorManager;

    var normalizeHeaderName = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };

    /**
     * Update an Error with the specified config, error code, and response.
     *
     * @param {Error} error The error to update.
     * @param {Object} config The config.
     * @param {string} [code] The error code (for example, 'ECONNABORTED').
     * @param {Object} [request] The request.
     * @param {Object} [response] The response.
     * @returns {Error} The error.
     */
    var enhanceError = function enhanceError(error, config, code, request, response) {
      error.config = config;
      if (code) {
        error.code = code;
      }

      error.request = request;
      error.response = response;
      error.isAxiosError = true;

      error.toJSON = function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: this.config,
          code: this.code
        };
      };
      return error;
    };

    /**
     * Create an Error with the specified message, config, error code, request and response.
     *
     * @param {string} message The error message.
     * @param {Object} config The config.
     * @param {string} [code] The error code (for example, 'ECONNABORTED').
     * @param {Object} [request] The request.
     * @param {Object} [response] The response.
     * @returns {Error} The created error.
     */
    var createError = function createError(message, config, code, request, response) {
      var error = new Error(message);
      return enhanceError(error, config, code, request, response);
    };

    /**
     * Resolve or reject a Promise based on response status.
     *
     * @param {Function} resolve A function that resolves the promise.
     * @param {Function} reject A function that rejects the promise.
     * @param {object} response The response.
     */
    var settle = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(createError(
          'Request failed with status code ' + response.status,
          response.config,
          null,
          response.request,
          response
        ));
      }
    };

    var cookies = (
      utils.isStandardBrowserEnv() ?

      // Standard browser envs support document.cookie
        (function standardBrowserEnv() {
          return {
            write: function write(name, value, expires, path, domain, secure) {
              var cookie = [];
              cookie.push(name + '=' + encodeURIComponent(value));

              if (utils.isNumber(expires)) {
                cookie.push('expires=' + new Date(expires).toGMTString());
              }

              if (utils.isString(path)) {
                cookie.push('path=' + path);
              }

              if (utils.isString(domain)) {
                cookie.push('domain=' + domain);
              }

              if (secure === true) {
                cookie.push('secure');
              }

              document.cookie = cookie.join('; ');
            },

            read: function read(name) {
              var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
              return (match ? decodeURIComponent(match[3]) : null);
            },

            remove: function remove(name) {
              this.write(name, '', Date.now() - 86400000);
            }
          };
        })() :

      // Non standard browser env (web workers, react-native) lack needed support.
        (function nonStandardBrowserEnv() {
          return {
            write: function write() {},
            read: function read() { return null; },
            remove: function remove() {}
          };
        })()
    );

    /**
     * Determines whether the specified URL is absolute
     *
     * @param {string} url The URL to test
     * @returns {boolean} True if the specified URL is absolute, otherwise false
     */
    var isAbsoluteURL = function isAbsoluteURL(url) {
      // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
      // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
      // by any combination of letters, digits, plus, period, or hyphen.
      return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
    };

    /**
     * Creates a new URL by combining the specified URLs
     *
     * @param {string} baseURL The base URL
     * @param {string} relativeURL The relative URL
     * @returns {string} The combined URL
     */
    var combineURLs = function combineURLs(baseURL, relativeURL) {
      return relativeURL
        ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
        : baseURL;
    };

    /**
     * Creates a new URL by combining the baseURL with the requestedURL,
     * only when the requestedURL is not already an absolute URL.
     * If the requestURL is absolute, this function returns the requestedURL untouched.
     *
     * @param {string} baseURL The base URL
     * @param {string} requestedURL Absolute or relative URL to combine
     * @returns {string} The combined full path
     */
    var buildFullPath = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };

    // Headers whose duplicates are ignored by node
    // c.f. https://nodejs.org/api/http.html#http_message_headers
    var ignoreDuplicateOf = [
      'age', 'authorization', 'content-length', 'content-type', 'etag',
      'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
      'last-modified', 'location', 'max-forwards', 'proxy-authorization',
      'referer', 'retry-after', 'user-agent'
    ];

    /**
     * Parse headers into an object
     *
     * ```
     * Date: Wed, 27 Aug 2014 08:58:49 GMT
     * Content-Type: application/json
     * Connection: keep-alive
     * Transfer-Encoding: chunked
     * ```
     *
     * @param {String} headers Headers needing to be parsed
     * @returns {Object} Headers parsed into an object
     */
    var parseHeaders = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;

      if (!headers) { return parsed; }

      utils.forEach(headers.split('\n'), function parser(line) {
        i = line.indexOf(':');
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));

        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === 'set-cookie') {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
          }
        }
      });

      return parsed;
    };

    var isURLSameOrigin = (
      utils.isStandardBrowserEnv() ?

      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
        (function standardBrowserEnv() {
          var msie = /(msie|trident)/i.test(navigator.userAgent);
          var urlParsingNode = document.createElement('a');
          var originURL;

          /**
        * Parse a URL to discover it's components
        *
        * @param {String} url The URL to be parsed
        * @returns {Object}
        */
          function resolveURL(url) {
            var href = url;

            if (msie) {
            // IE needs attribute set twice to normalize properties
              urlParsingNode.setAttribute('href', href);
              href = urlParsingNode.href;
            }

            urlParsingNode.setAttribute('href', href);

            // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
            return {
              href: urlParsingNode.href,
              protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
              host: urlParsingNode.host,
              search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
              hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
              hostname: urlParsingNode.hostname,
              port: urlParsingNode.port,
              pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
                urlParsingNode.pathname :
                '/' + urlParsingNode.pathname
            };
          }

          originURL = resolveURL(window.location.href);

          /**
        * Determine if a URL shares the same origin as the current location
        *
        * @param {String} requestURL The URL to test
        * @returns {boolean} True if URL shares the same origin, otherwise false
        */
          return function isURLSameOrigin(requestURL) {
            var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
            return (parsed.protocol === originURL.protocol &&
                parsed.host === originURL.host);
          };
        })() :

      // Non standard browser envs (web workers, react-native) lack needed support.
        (function nonStandardBrowserEnv() {
          return function isURLSameOrigin() {
            return true;
          };
        })()
    );

    var xhr = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        var responseType = config.responseType;

        if (utils.isFormData(requestData)) {
          delete requestHeaders['Content-Type']; // Let the browser set it
        }

        var request = new XMLHttpRequest();

        // HTTP basic authentication
        if (config.auth) {
          var username = config.auth.username || '';
          var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
          requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
        }

        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

        // Set the request timeout in MS
        request.timeout = config.timeout;

        function onloadend() {
          if (!request) {
            return;
          }
          // Prepare the response
          var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?
            request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config: config,
            request: request
          };

          settle(resolve, reject, response);

          // Clean up request
          request = null;
        }

        if ('onloadend' in request) {
          // Use onloadend if available
          request.onloadend = onloadend;
        } else {
          // Listen for ready state to emulate onloadend
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }

            // The request errored out and we didn't get a response, this will be
            // handled by onerror instead
            // With one exception: request that using file: protocol, most browsers
            // will return status as 0 even though it's a successful request
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
              return;
            }
            // readystate handler is calling before onerror or ontimeout handlers,
            // so we should call onloadend on the next 'tick'
            setTimeout(onloadend);
          };
        }

        // Handle browser request cancellation (as opposed to a manual cancellation)
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }

          reject(createError('Request aborted', config, 'ECONNABORTED', request));

          // Clean up request
          request = null;
        };

        // Handle low level network errors
        request.onerror = function handleError() {
          // Real errors are hidden from us by the browser
          // onerror should only fire if it's a network error
          reject(createError('Network Error', config, null, request));

          // Clean up request
          request = null;
        };

        // Handle timeout
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(createError(
            timeoutErrorMessage,
            config,
            config.transitional && config.transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',
            request));

          // Clean up request
          request = null;
        };

        // Add xsrf header
        // This is only done if running in a standard browser environment.
        // Specifically not if we're in a web worker, or react-native.
        if (utils.isStandardBrowserEnv()) {
          // Add xsrf header
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
            cookies.read(config.xsrfCookieName) :
            undefined;

          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }

        // Add headers to the request
        if ('setRequestHeader' in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
              // Remove Content-Type if data is undefined
              delete requestHeaders[key];
            } else {
              // Otherwise add header to the request
              request.setRequestHeader(key, val);
            }
          });
        }

        // Add withCredentials to request if needed
        if (!utils.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }

        // Add responseType to request if needed
        if (responseType && responseType !== 'json') {
          request.responseType = config.responseType;
        }

        // Handle progress if needed
        if (typeof config.onDownloadProgress === 'function') {
          request.addEventListener('progress', config.onDownloadProgress);
        }

        // Not all browsers support upload events
        if (typeof config.onUploadProgress === 'function' && request.upload) {
          request.upload.addEventListener('progress', config.onUploadProgress);
        }

        if (config.cancelToken) {
          // Handle cancellation
          config.cancelToken.promise.then(function onCanceled(cancel) {
            if (!request) {
              return;
            }

            request.abort();
            reject(cancel);
            // Clean up request
            request = null;
          });
        }

        if (!requestData) {
          requestData = null;
        }

        // Send the request
        request.send(requestData);
      });
    };

    var DEFAULT_CONTENT_TYPE = {
      'Content-Type': 'application/x-www-form-urlencoded'
    };

    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
        headers['Content-Type'] = value;
      }
    }

    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== 'undefined') {
        // For browsers use XHR adapter
        adapter = xhr;
      } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
        // For node use HTTP adapter
        adapter = xhr;
      }
      return adapter;
    }

    function stringifySafely(rawValue, parser, encoder) {
      if (utils.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils.trim(rawValue);
        } catch (e) {
          if (e.name !== 'SyntaxError') {
            throw e;
          }
        }
      }

      return (encoder || JSON.stringify)(rawValue);
    }

    var defaults = {

      transitional: {
        silentJSONParsing: true,
        forcedJSONParsing: true,
        clarifyTimeoutError: false
      },

      adapter: getDefaultAdapter(),

      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, 'Accept');
        normalizeHeaderName(headers, 'Content-Type');

        if (utils.isFormData(data) ||
          utils.isArrayBuffer(data) ||
          utils.isBuffer(data) ||
          utils.isStream(data) ||
          utils.isFile(data) ||
          utils.isBlob(data)
        ) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
          return data.toString();
        }
        if (utils.isObject(data) || (headers && headers['Content-Type'] === 'application/json')) {
          setContentTypeIfUnset(headers, 'application/json');
          return stringifySafely(data);
        }
        return data;
      }],

      transformResponse: [function transformResponse(data) {
        var transitional = this.transitional;
        var silentJSONParsing = transitional && transitional.silentJSONParsing;
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

        if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === 'SyntaxError') {
                throw enhanceError(e, this, 'E_JSON_PARSE');
              }
              throw e;
            }
          }
        }

        return data;
      }],

      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,

      xsrfCookieName: 'XSRF-TOKEN',
      xsrfHeaderName: 'X-XSRF-TOKEN',

      maxContentLength: -1,
      maxBodyLength: -1,

      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      }
    };

    defaults.headers = {
      common: {
        'Accept': 'application/json, text/plain, */*'
      }
    };

    utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });

    utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });

    var defaults_1 = defaults;

    /**
     * Transform the data for a request or a response
     *
     * @param {Object|String} data The data to be transformed
     * @param {Array} headers The headers for the request or response
     * @param {Array|Function} fns A single function or Array of functions
     * @returns {*} The resulting transformed data
     */
    var transformData = function transformData(data, headers, fns) {
      var context = this || defaults_1;
      /*eslint no-param-reassign:0*/
      utils.forEach(fns, function transform(fn) {
        data = fn.call(context, data, headers);
      });

      return data;
    };

    var isCancel = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };

    /**
     * Throws a `Cancel` if cancellation has been requested.
     */
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
    }

    /**
     * Dispatch a request to the server using the configured adapter.
     *
     * @param {object} config The config that is to be used for the request
     * @returns {Promise} The Promise to be fulfilled
     */
    var dispatchRequest = function dispatchRequest(config) {
      throwIfCancellationRequested(config);

      // Ensure headers exist
      config.headers = config.headers || {};

      // Transform request data
      config.data = transformData.call(
        config,
        config.data,
        config.headers,
        config.transformRequest
      );

      // Flatten headers
      config.headers = utils.merge(
        config.headers.common || {},
        config.headers[config.method] || {},
        config.headers
      );

      utils.forEach(
        ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
        function cleanHeaderConfig(method) {
          delete config.headers[method];
        }
      );

      var adapter = config.adapter || defaults_1.adapter;

      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);

        // Transform response data
        response.data = transformData.call(
          config,
          response.data,
          response.headers,
          config.transformResponse
        );

        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);

          // Transform response data
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              reason.response.data,
              reason.response.headers,
              config.transformResponse
            );
          }
        }

        return Promise.reject(reason);
      });
    };

    /**
     * Config-specific merge-function which creates a new config-object
     * by merging two configuration objects together.
     *
     * @param {Object} config1
     * @param {Object} config2
     * @returns {Object} New object resulting from merging config2 to config1
     */
    var mergeConfig = function mergeConfig(config1, config2) {
      // eslint-disable-next-line no-param-reassign
      config2 = config2 || {};
      var config = {};

      var valueFromConfig2Keys = ['url', 'method', 'data'];
      var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
      var defaultToConfig2Keys = [
        'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',
        'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
        'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',
        'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',
        'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'
      ];
      var directMergeKeys = ['validateStatus'];

      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }

      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(config1[prop], config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          config[prop] = getMergedValue(undefined, config1[prop]);
        }
      }

      utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(undefined, config2[prop]);
        }
      });

      utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);

      utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(undefined, config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          config[prop] = getMergedValue(undefined, config1[prop]);
        }
      });

      utils.forEach(directMergeKeys, function merge(prop) {
        if (prop in config2) {
          config[prop] = getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          config[prop] = getMergedValue(undefined, config1[prop]);
        }
      });

      var axiosKeys = valueFromConfig2Keys
        .concat(mergeDeepPropertiesKeys)
        .concat(defaultToConfig2Keys)
        .concat(directMergeKeys);

      var otherKeys = Object
        .keys(config1)
        .concat(Object.keys(config2))
        .filter(function filterAxiosKeys(key) {
          return axiosKeys.indexOf(key) === -1;
        });

      utils.forEach(otherKeys, mergeDeepProperties);

      return config;
    };

    var name$1 = "axios";
    var version = "0.21.4";
    var description = "Promise based HTTP client for the browser and node.js";
    var main = "index.js";
    var scripts = {
    	test: "grunt test",
    	start: "node ./sandbox/server.js",
    	build: "NODE_ENV=production grunt build",
    	preversion: "npm test",
    	version: "npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json",
    	postversion: "git push && git push --tags",
    	examples: "node ./examples/server.js",
    	coveralls: "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js",
    	fix: "eslint --fix lib/**/*.js"
    };
    var repository = {
    	type: "git",
    	url: "https://github.com/axios/axios.git"
    };
    var keywords = [
    	"xhr",
    	"http",
    	"ajax",
    	"promise",
    	"node"
    ];
    var author = "Matt Zabriskie";
    var license = "MIT";
    var bugs = {
    	url: "https://github.com/axios/axios/issues"
    };
    var homepage = "https://axios-http.com";
    var devDependencies = {
    	coveralls: "^3.0.0",
    	"es6-promise": "^4.2.4",
    	grunt: "^1.3.0",
    	"grunt-banner": "^0.6.0",
    	"grunt-cli": "^1.2.0",
    	"grunt-contrib-clean": "^1.1.0",
    	"grunt-contrib-watch": "^1.0.0",
    	"grunt-eslint": "^23.0.0",
    	"grunt-karma": "^4.0.0",
    	"grunt-mocha-test": "^0.13.3",
    	"grunt-ts": "^6.0.0-beta.19",
    	"grunt-webpack": "^4.0.2",
    	"istanbul-instrumenter-loader": "^1.0.0",
    	"jasmine-core": "^2.4.1",
    	karma: "^6.3.2",
    	"karma-chrome-launcher": "^3.1.0",
    	"karma-firefox-launcher": "^2.1.0",
    	"karma-jasmine": "^1.1.1",
    	"karma-jasmine-ajax": "^0.1.13",
    	"karma-safari-launcher": "^1.0.0",
    	"karma-sauce-launcher": "^4.3.6",
    	"karma-sinon": "^1.0.5",
    	"karma-sourcemap-loader": "^0.3.8",
    	"karma-webpack": "^4.0.2",
    	"load-grunt-tasks": "^3.5.2",
    	minimist: "^1.2.0",
    	mocha: "^8.2.1",
    	sinon: "^4.5.0",
    	"terser-webpack-plugin": "^4.2.3",
    	typescript: "^4.0.5",
    	"url-search-params": "^0.10.0",
    	webpack: "^4.44.2",
    	"webpack-dev-server": "^3.11.0"
    };
    var browser = {
    	"./lib/adapters/http.js": "./lib/adapters/xhr.js"
    };
    var jsdelivr = "dist/axios.min.js";
    var unpkg = "dist/axios.min.js";
    var typings = "./index.d.ts";
    var dependencies = {
    	"follow-redirects": "^1.14.0"
    };
    var bundlesize = [
    	{
    		path: "./dist/axios.min.js",
    		threshold: "5kB"
    	}
    ];
    var _package = {
    	name: name$1,
    	version: version,
    	description: description,
    	main: main,
    	scripts: scripts,
    	repository: repository,
    	keywords: keywords,
    	author: author,
    	license: license,
    	bugs: bugs,
    	homepage: homepage,
    	devDependencies: devDependencies,
    	browser: browser,
    	jsdelivr: jsdelivr,
    	unpkg: unpkg,
    	typings: typings,
    	dependencies: dependencies,
    	bundlesize: bundlesize
    };

    var _package$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        name: name$1,
        version: version,
        description: description,
        main: main,
        scripts: scripts,
        repository: repository,
        keywords: keywords,
        author: author,
        license: license,
        bugs: bugs,
        homepage: homepage,
        devDependencies: devDependencies,
        browser: browser,
        jsdelivr: jsdelivr,
        unpkg: unpkg,
        typings: typings,
        dependencies: dependencies,
        bundlesize: bundlesize,
        'default': _package
    });

    function getCjsExportFromNamespace (n) {
    	return n && n['default'] || n;
    }

    var pkg = getCjsExportFromNamespace(_package$1);

    var validators = {};

    // eslint-disable-next-line func-names
    ['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {
      validators[type] = function validator(thing) {
        return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
      };
    });

    var deprecatedWarnings = {};
    var currentVerArr = pkg.version.split('.');

    /**
     * Compare package versions
     * @param {string} version
     * @param {string?} thanVersion
     * @returns {boolean}
     */
    function isOlderVersion(version, thanVersion) {
      var pkgVersionArr = thanVersion ? thanVersion.split('.') : currentVerArr;
      var destVer = version.split('.');
      for (var i = 0; i < 3; i++) {
        if (pkgVersionArr[i] > destVer[i]) {
          return true;
        } else if (pkgVersionArr[i] < destVer[i]) {
          return false;
        }
      }
      return false;
    }

    /**
     * Transitional option validator
     * @param {function|boolean?} validator
     * @param {string?} version
     * @param {string} message
     * @returns {function}
     */
    validators.transitional = function transitional(validator, version, message) {
      var isDeprecated = version && isOlderVersion(version);

      function formatMessage(opt, desc) {
        return '[Axios v' + pkg.version + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
      }

      // eslint-disable-next-line func-names
      return function(value, opt, opts) {
        if (validator === false) {
          throw new Error(formatMessage(opt, ' has been removed in ' + version));
        }

        if (isDeprecated && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          // eslint-disable-next-line no-console
          console.warn(
            formatMessage(
              opt,
              ' has been deprecated since v' + version + ' and will be removed in the near future'
            )
          );
        }

        return validator ? validator(value, opt, opts) : true;
      };
    };

    /**
     * Assert object's properties type
     * @param {object} options
     * @param {object} schema
     * @param {boolean?} allowUnknown
     */

    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== 'object') {
        throw new TypeError('options must be an object');
      }
      var keys = Object.keys(options);
      var i = keys.length;
      while (i-- > 0) {
        var opt = keys[i];
        var validator = schema[opt];
        if (validator) {
          var value = options[opt];
          var result = value === undefined || validator(value, opt, options);
          if (result !== true) {
            throw new TypeError('option ' + opt + ' must be ' + result);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw Error('Unknown option ' + opt);
        }
      }
    }

    var validator = {
      isOlderVersion: isOlderVersion,
      assertOptions: assertOptions,
      validators: validators
    };

    var validators$1 = validator.validators;
    /**
     * Create a new instance of Axios
     *
     * @param {Object} instanceConfig The default config for the instance
     */
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager_1(),
        response: new InterceptorManager_1()
      };
    }

    /**
     * Dispatch a request
     *
     * @param {Object} config The config specific for this request (merged with this.defaults)
     */
    Axios.prototype.request = function request(config) {
      /*eslint no-param-reassign:0*/
      // Allow for axios('example/url'[, config]) a la fetch API
      if (typeof config === 'string') {
        config = arguments[1] || {};
        config.url = arguments[0];
      } else {
        config = config || {};
      }

      config = mergeConfig(this.defaults, config);

      // Set config.method
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = 'get';
      }

      var transitional = config.transitional;

      if (transitional !== undefined) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators$1.transitional(validators$1.boolean, '1.0.0'),
          forcedJSONParsing: validators$1.transitional(validators$1.boolean, '1.0.0'),
          clarifyTimeoutError: validators$1.transitional(validators$1.boolean, '1.0.0')
        }, false);
      }

      // filter out skipped interceptors
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
          return;
        }

        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });

      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });

      var promise;

      if (!synchronousRequestInterceptors) {
        var chain = [dispatchRequest, undefined];

        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);

        promise = Promise.resolve(config);
        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift());
        }

        return promise;
      }


      var newConfig = config;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected(error);
          break;
        }
      }

      try {
        promise = dispatchRequest(newConfig);
      } catch (error) {
        return Promise.reject(error);
      }

      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }

      return promise;
    };

    Axios.prototype.getUri = function getUri(config) {
      config = mergeConfig(this.defaults, config);
      return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
    };

    // Provide aliases for supported request methods
    utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
      /*eslint func-names:0*/
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method: method,
          url: url,
          data: (config || {}).data
        }));
      };
    });

    utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
      /*eslint func-names:0*/
      Axios.prototype[method] = function(url, data, config) {
        return this.request(mergeConfig(config || {}, {
          method: method,
          url: url,
          data: data
        }));
      };
    });

    var Axios_1 = Axios;

    /**
     * A `Cancel` is an object that is thrown when an operation is canceled.
     *
     * @class
     * @param {string=} message The message.
     */
    function Cancel(message) {
      this.message = message;
    }

    Cancel.prototype.toString = function toString() {
      return 'Cancel' + (this.message ? ': ' + this.message : '');
    };

    Cancel.prototype.__CANCEL__ = true;

    var Cancel_1 = Cancel;

    /**
     * A `CancelToken` is an object that can be used to request cancellation of an operation.
     *
     * @class
     * @param {Function} executor The executor function.
     */
    function CancelToken(executor) {
      if (typeof executor !== 'function') {
        throw new TypeError('executor must be a function.');
      }

      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });

      var token = this;
      executor(function cancel(message) {
        if (token.reason) {
          // Cancellation has already been requested
          return;
        }

        token.reason = new Cancel_1(message);
        resolvePromise(token.reason);
      });
    }

    /**
     * Throws a `Cancel` if cancellation has been requested.
     */
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };

    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token: token,
        cancel: cancel
      };
    };

    var CancelToken_1 = CancelToken;

    /**
     * Syntactic sugar for invoking a function and expanding an array for arguments.
     *
     * Common use case would be to use `Function.prototype.apply`.
     *
     *  ```js
     *  function f(x, y, z) {}
     *  var args = [1, 2, 3];
     *  f.apply(null, args);
     *  ```
     *
     * With `spread` this example can be re-written.
     *
     *  ```js
     *  spread(function(x, y, z) {})([1, 2, 3]);
     *  ```
     *
     * @param {Function} callback
     * @returns {Function}
     */
    var spread = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };

    /**
     * Determines whether the payload is an error thrown by Axios
     *
     * @param {*} payload The value to test
     * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
     */
    var isAxiosError = function isAxiosError(payload) {
      return (typeof payload === 'object') && (payload.isAxiosError === true);
    };

    /**
     * Create an instance of Axios
     *
     * @param {Object} defaultConfig The default config for the instance
     * @return {Axios} A new instance of Axios
     */
    function createInstance(defaultConfig) {
      var context = new Axios_1(defaultConfig);
      var instance = bind$4(Axios_1.prototype.request, context);

      // Copy axios.prototype to instance
      utils.extend(instance, Axios_1.prototype, context);

      // Copy context to instance
      utils.extend(instance, context);

      return instance;
    }

    // Create the default instance to be exported
    var axios = createInstance(defaults_1);

    // Expose Axios class to allow class inheritance
    axios.Axios = Axios_1;

    // Factory for creating new instances
    axios.create = function create(instanceConfig) {
      return createInstance(mergeConfig(axios.defaults, instanceConfig));
    };

    // Expose Cancel & CancelToken
    axios.Cancel = Cancel_1;
    axios.CancelToken = CancelToken_1;
    axios.isCancel = isCancel;

    // Expose all/spread
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = spread;

    // Expose isAxiosError
    axios.isAxiosError = isAxiosError;

    var axios_1 = axios;

    // Allow use of default import syntax in TypeScript
    var default_1 = axios;
    axios_1.default = default_1;

    var axios$1 = axios_1;

    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.

    // resolves . and .. elements in a path array with directory names there
    // must be no slashes, empty elements, or device names (c:\) in the array
    // (so also no leading and trailing slashes - it does not distinguish
    // relative and absolute paths)
    function normalizeArray(parts, allowAboveRoot) {
      // if the path tries to go above the root, `up` ends up > 0
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === '.') {
          parts.splice(i, 1);
        } else if (last === '..') {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }

      // if the path is allowed to go above the root, restore leading ..s
      if (allowAboveRoot) {
        for (; up--; up) {
          parts.unshift('..');
        }
      }

      return parts;
    }

    // Split a filename into [root, dir, basename, ext], unix version
    // 'root' is just a slash, or nothing.
    var splitPathRe =
        /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
    var splitPath = function(filename) {
      return splitPathRe.exec(filename).slice(1);
    };

    // path.resolve([from ...], to)
    // posix version
    function resolve() {
      var resolvedPath = '',
          resolvedAbsolute = false;

      for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path = (i >= 0) ? arguments[i] : '/';

        // Skip empty and invalid entries
        if (typeof path !== 'string') {
          throw new TypeError('Arguments to path.resolve must be strings');
        } else if (!path) {
          continue;
        }

        resolvedPath = path + '/' + resolvedPath;
        resolvedAbsolute = path.charAt(0) === '/';
      }

      // At this point the path should be resolved to a full absolute path, but
      // handle relative paths to be safe (might happen when process.cwd() fails)

      // Normalize the path
      resolvedPath = normalizeArray(filter$1(resolvedPath.split('/'), function(p) {
        return !!p;
      }), !resolvedAbsolute).join('/');

      return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
    }
    // path.normalize(path)
    // posix version
    function normalize$1(path) {
      var isPathAbsolute = isAbsolute(path),
          trailingSlash = substr(path, -1) === '/';

      // Normalize the path
      path = normalizeArray(filter$1(path.split('/'), function(p) {
        return !!p;
      }), !isPathAbsolute).join('/');

      if (!path && !isPathAbsolute) {
        path = '.';
      }
      if (path && trailingSlash) {
        path += '/';
      }

      return (isPathAbsolute ? '/' : '') + path;
    }
    // posix version
    function isAbsolute(path) {
      return path.charAt(0) === '/';
    }

    // posix version
    function join() {
      var paths = Array.prototype.slice.call(arguments, 0);
      return normalize$1(filter$1(paths, function(p, index) {
        if (typeof p !== 'string') {
          throw new TypeError('Arguments to path.join must be strings');
        }
        return p;
      }).join('/'));
    }


    // path.relative(from, to)
    // posix version
    function relative(from, to) {
      from = resolve(from).substr(1);
      to = resolve(to).substr(1);

      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== '') break;
        }

        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== '') break;
        }

        if (start > end) return [];
        return arr.slice(start, end - start + 1);
      }

      var fromParts = trim(from.split('/'));
      var toParts = trim(to.split('/'));

      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }

      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push('..');
      }

      outputParts = outputParts.concat(toParts.slice(samePartsLength));

      return outputParts.join('/');
    }

    var sep = '/';
    var delimiter = ':';

    function dirname(path) {
      var result = splitPath(path),
          root = result[0],
          dir = result[1];

      if (!root && !dir) {
        // No dirname whatsoever
        return '.';
      }

      if (dir) {
        // It has a dirname, strip trailing slash
        dir = dir.substr(0, dir.length - 1);
      }

      return root + dir;
    }

    function basename(path, ext) {
      var f = splitPath(path)[2];
      // TODO: make this comparison case-insensitive on windows?
      if (ext && f.substr(-1 * ext.length) === ext) {
        f = f.substr(0, f.length - ext.length);
      }
      return f;
    }


    function extname(path) {
      return splitPath(path)[3];
    }
    var path = {
      extname: extname,
      basename: basename,
      dirname: dirname,
      sep: sep,
      delimiter: delimiter,
      relative: relative,
      join: join,
      isAbsolute: isAbsolute,
      normalize: normalize$1,
      resolve: resolve
    };
    function filter$1 (xs, f) {
        if (xs.filter) return xs.filter(f);
        var res = [];
        for (var i = 0; i < xs.length; i++) {
            if (f(xs[i], i, xs)) res.push(xs[i]);
        }
        return res;
    }

    // String.prototype.substr - negative index don't work in IE8
    var substr = 'ab'.substr(-1) === 'b' ?
        function (str, start, len) { return str.substr(start, len) } :
        function (str, start, len) {
            if (start < 0) start = str.length + start;
            return str.substr(start, len);
        }
    ;

    class gltfModelPathProvider
    {
        constructor(modelIndexerPath, currentFalvour="glTF", ignoredVariants = ["glTF-Embedded"])
        {
            this.modelIndexerPath = modelIndexerPath;
            this.ignoredVariants = ignoredVariants;
            this.modelsDictionary = undefined;
        }

        async initialize()
        {
            const self = this;
            return axios$1.get(this.modelIndexerPath).then(response =>
            {
                self.populateDictionary(response.data);
            });
        }

        resolve(modelKey, flavour)
        {
            return this.modelsDictionary[modelKey][flavour];
        }

        getAllKeys()
        {
            return Object.keys(this.modelsDictionary);
        }

        populateDictionary(modelIndexer)
        {
            const modelsFolder = path.dirname(this.modelIndexerPath);
            this.modelsDictionary = {};
            for (const entry of modelIndexer)
            {
                // TODO maybe handle undefined names better
                if (entry.variants === undefined || entry.name === undefined)
                {
                    continue;
                }

                let variants = [];

                for (const variant of Object.keys(entry.variants))
                {
                    if (this.ignoredVariants.includes(variant))
                    {
                        continue;
                    }

                    const fileName = entry.variants[variant];
                    const modelPath = path.join(modelsFolder, entry.name, variant, fileName);
                    variants[variant] = modelPath;

                }
                this.modelsDictionary[entry.name] = variants;
            }
        }

        getModelFlavours(modelName)
        {
            if(this.modelsDictionary[modelName] === undefined)
            {
                return ["glTF"];
            }
            return Object.keys(this.modelsDictionary[modelName]);
        }
    }

    function fillEnvironmentWithPaths(environmentNames, environmentsBasePath)
    {
        Object.keys(environmentNames).map(function(name, index) {
            const title = environmentNames[name];
            environmentNames[name] = {
                index: index,
                title: title,
                hdr_path: environmentsBasePath + name + ".hdr",
                jpg_path: environmentsBasePath + name + ".jpg"
            };
        });
        return environmentNames;
    }

    async function main$1()
    {
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("webgl2", { alpha: false, antialias: true });
        const ui = document.getElementById("app");
        const view = new GltfView(context);
        const resourceLoader = view.createResourceLoader();
        const state = view.createState();
        state.renderingParameters.useDirectionalLightsWithDisabledIBL = true;

        const pathProvider = new gltfModelPathProvider('assets/models/2.0/model-index.json');
        await pathProvider.initialize();
        const environmentPaths = fillEnvironmentWithPaths({
            "footprint_court": "Footprint Court",
            "pisa": "Pisa",
            "doge2": "Doge's palace",
            "ennis": "Dining room",
            "field": "Field",
            "helipad": "Helipad Goldenhour",
            "papermill": "Papermill Ruins",
            "neutral": "Studio Neutral",
            "Cannon_Exterior": "Cannon Exterior",
            "Colorful_Studio": "Colorful Studio",
            "Wide_Street" : "Wide Street",
        }, "assets/environments/");

        const uiModel = new UIModel(app, pathProvider, environmentPaths);

        // whenever a new model is selected, load it and when complete pass the loaded gltf
        // into a stream back into the UI
        const gltfLoadedSubject = new Subject();
        const gltfLoadedMulticast = uiModel.model.pipe(
            mergeMap( (model) =>
            {
            	uiModel.goToLoadingState();

                // Workaround for errors in ktx lib after loading an asset with ktx2 files for the second time:
                resourceLoader.initKtxLib();

                return from(resourceLoader.loadGltf(model.mainFile, model.additionalFiles).then( (gltf) => {
                    state.gltf = gltf;
                    const defaultScene = state.gltf.scene;
                    state.sceneIndex = defaultScene === undefined ? 0 : defaultScene;
                    state.cameraIndex = undefined;
                    if (state.gltf.scenes.length != 0)
                    {
                        if(state.sceneIndex > state.gltf.scenes.length - 1)
                        {
                            state.sceneIndex = 0;
                        }
                        const scene = state.gltf.scenes[state.sceneIndex];
                        scene.applyTransformHierarchy(state.gltf);
                        state.userCamera.aspectRatio = canvas.width / canvas.height;
                        state.userCamera.fitViewToScene(state.gltf, state.sceneIndex);

                        // Try to start as many animations as possible without generating conficts.
                        state.animationIndices = [];
                        for (let i = 0; i < gltf.animations.length; i++)
                        {
                            if (!gltf.nonDisjointAnimations(state.animationIndices).includes(i))
                            {
                                state.animationIndices.push(i);
                            }
                        }
                        state.animationTimer.start();
                    }

                    uiModel.exitLoadingState();

                    return state;
                })
                );
            }),
            // transform gltf loaded observable to multicast observable to avoid multiple execution with multiple subscriptions
            multicast(gltfLoadedSubject)
        );

        uiModel.disabledAnimations(uiModel.activeAnimations.pipe(map(animationIndices => {
            // Disable all animations which are not disjoint to the current selection of animations.
            return state.gltf.nonDisjointAnimations(animationIndices);
        })));

        const sceneChangedSubject = new Subject();
        const sceneChangedObservable = uiModel.scene.pipe(map( newSceneIndex => {
            state.sceneIndex = newSceneIndex;
            state.cameraIndex = undefined;
            const scene = state.gltf.scenes[state.sceneIndex];
            if (scene !== undefined)
            {
                scene.applyTransformHierarchy(state.gltf);
                state.userCamera.fitViewToScene(state.gltf, state.sceneIndex);
            }
        }),
        multicast(sceneChangedSubject)
        );

        const statisticsUpdateObservableTemp = merge(
            gltfLoadedMulticast,
            sceneChangedObservable
        );

        const statisticsUpdateObservable = statisticsUpdateObservableTemp.pipe(
            map( (_) => view.gatherStatistics(state) )
        );

        const cameraExportChangedObservable = uiModel.cameraValuesExport.pipe( map(_ => {
            let camera = state.userCamera;
            if(state.cameraIndex !== undefined)
            {
                camera = state.gltf.cameras[state.cameraIndex];
            }
            const cameraDesc = camera.getDescription(state.gltf);
            return cameraDesc;
        }));

        const downloadDataURL = (filename, dataURL) => {
            var element = document.createElement('a');
            element.setAttribute('href', dataURL);
            element.setAttribute('download', filename);

            element.style.display = 'none';
            document.body.appendChild(element);

            element.click();

            document.body.removeChild(element);
        };

        cameraExportChangedObservable.subscribe( cameraDesc => {
            const gltf = JSON.stringify(cameraDesc, undefined, 4);
            const dataURL = 'data:text/plain;charset=utf-8,' +  encodeURIComponent(gltf);
            downloadDataURL("camera.gltf", dataURL);
        });

        uiModel.captureCanvas.subscribe( () => {
            view.renderFrame(state, canvas.width, canvas.height);
            const dataURL = canvas.toDataURL();
            downloadDataURL("capture.png", dataURL);
        });

        // Only redraw glTF view upon user inputs, or when an animation is playing.
        let redraw = false;
        const listenForRedraw = stream => stream.subscribe(() => redraw = true);
        
        uiModel.scene.pipe(filter(scene => scene === -1)).subscribe( () => {
            state.sceneIndex = undefined;
        });
        uiModel.scene.pipe(filter(scene => scene !== -1)).subscribe( scene => {
            state.sceneIndex = scene;
        });
        listenForRedraw(uiModel.scene);

        uiModel.camera.pipe(filter(camera => camera === -1)).subscribe( () => {
            state.cameraIndex = undefined;
        });
        uiModel.camera.pipe(filter(camera => camera !== -1)).subscribe( camera => {
            state.cameraIndex = camera;
        });
        listenForRedraw(uiModel.camera);

        uiModel.variant.subscribe( variant => {
            state.variant = variant;
        });
        listenForRedraw(uiModel.variant);

        uiModel.tonemap.subscribe( tonemap => {
            state.renderingParameters.toneMap = tonemap;
        });
        listenForRedraw(uiModel.tonemap);

        uiModel.debugchannel.subscribe( debugchannel => {
            state.renderingParameters.debugOutput = debugchannel;
        });
        listenForRedraw(uiModel.debugchannel);

        uiModel.skinningEnabled.subscribe( skinningEnabled => {
            state.renderingParameters.skinning = skinningEnabled;
        });
        listenForRedraw(uiModel.skinningEnabled);

        uiModel.exposure.subscribe( exposure => {
            state.renderingParameters.exposure = (1.0 / Math.pow(2.0, exposure));
        });
        listenForRedraw(uiModel.exposure);

        uiModel.morphingEnabled.subscribe( morphingEnabled => {
            state.renderingParameters.morphing = morphingEnabled;
        });
        listenForRedraw(uiModel.morphingEnabled);

        uiModel.clearcoatEnabled.subscribe( clearcoatEnabled => {
            state.renderingParameters.enabledExtensions.KHR_materials_clearcoat = clearcoatEnabled;
        });
        uiModel.sheenEnabled.subscribe( sheenEnabled => {
            state.renderingParameters.enabledExtensions.KHR_materials_sheen = sheenEnabled;
        });
        uiModel.transmissionEnabled.subscribe( transmissionEnabled => {
            state.renderingParameters.enabledExtensions.KHR_materials_transmission = transmissionEnabled;
        });
        uiModel.volumeEnabled.subscribe( volumeEnabled => {
            state.renderingParameters.enabledExtensions.KHR_materials_volume = volumeEnabled;
        });
        uiModel.iorEnabled.subscribe( iorEnabled => {
            state.renderingParameters.enabledExtensions.KHR_materials_ior = iorEnabled;
        });
        uiModel.iridescenceEnabled.subscribe( iridescenceEnabled => {
            state.renderingParameters.enabledExtensions.KHR_materials_iridescence = iridescenceEnabled;
        });
        uiModel.specularEnabled.subscribe( specularEnabled => {
            state.renderingParameters.enabledExtensions.KHR_materials_specular = specularEnabled;
        });
        uiModel.emissiveStrengthEnabled.subscribe( enabled => {
            state.renderingParameters.enabledExtensions.KHR_materials_emissive_strength = enabled;
        });
        listenForRedraw(uiModel.clearcoatEnabled);
        listenForRedraw(uiModel.sheenEnabled);
        listenForRedraw(uiModel.transmissionEnabled);
        listenForRedraw(uiModel.volumeEnabled);
        listenForRedraw(uiModel.iorEnabled);
        listenForRedraw(uiModel.specularEnabled);
        listenForRedraw(uiModel.iridescenceEnabled);
        listenForRedraw(uiModel.emissiveStrengthEnabled);

        uiModel.iblEnabled.subscribe( iblEnabled => {
            state.renderingParameters.useIBL = iblEnabled;
        });
        listenForRedraw(uiModel.iblEnabled);

        uiModel.iblIntensity.subscribe( iblIntensity => {
            state.renderingParameters.iblIntensity = Math.pow(10, iblIntensity);
        });
        listenForRedraw(uiModel.iblIntensity);

        uiModel.renderEnvEnabled.subscribe( renderEnvEnabled => {
            state.renderingParameters.renderEnvironmentMap = renderEnvEnabled;
        });
        uiModel.blurEnvEnabled.subscribe( blurEnvEnabled => {
            state.renderingParameters.blurEnvironmentMap = blurEnvEnabled;
        });
        listenForRedraw(uiModel.renderEnvEnabled);
        listenForRedraw(uiModel.blurEnvEnabled);

        uiModel.punctualLightsEnabled.subscribe( punctualLightsEnabled => {
            state.renderingParameters.usePunctual = punctualLightsEnabled;
        });
        listenForRedraw(uiModel.punctualLightsEnabled);

        uiModel.environmentRotation.subscribe( environmentRotation => {
            switch (environmentRotation)
            {
            case "+Z":
                state.renderingParameters.environmentRotation = 90.0;
                break;
            case "-X":
                state.renderingParameters.environmentRotation = 180.0;
                break;
            case "-Z":
                state.renderingParameters.environmentRotation = 270.0;
                break;
            case "+X":
                state.renderingParameters.environmentRotation = 0.0;
                break;
            }
        });
        listenForRedraw(uiModel.environmentRotation);


        uiModel.clearColor.subscribe( clearColor => {
            state.renderingParameters.clearColor = clearColor;
        });
        listenForRedraw(uiModel.clearColor);

        uiModel.animationPlay.subscribe( animationPlay => {
            if(animationPlay)
            {
                state.animationTimer.unpause();
            }
            else
            {
                state.animationTimer.pause();
            }
        });

        uiModel.activeAnimations.subscribe( animations => {
            state.animationIndices = animations;
        });
        listenForRedraw(uiModel.activeAnimations);

        uiModel.hdr.subscribe( hdrFile => {
            resourceLoader.loadEnvironment(hdrFile).then( (environment) => {
                state.environment = environment;
                //We neeed to wait until the environment is loaded to redraw
                redraw = true;
            });
        });

        uiModel.attachGltfLoaded(gltfLoadedMulticast);
        uiModel.updateStatistics(statisticsUpdateObservable);
        const sceneChangedStateObservable = uiModel.scene.pipe(map( newSceneIndex => state));
        uiModel.attachCameraChangeObservable(sceneChangedStateObservable);
        gltfLoadedMulticast.connect();

        uiModel.orbit.subscribe( orbit => {
            if (state.cameraIndex === undefined)
            {
                state.userCamera.orbit(orbit.deltaPhi, orbit.deltaTheta);
            }
        });
        listenForRedraw(uiModel.orbit);

        uiModel.pan.subscribe( pan => {
            if (state.cameraIndex === undefined)
            {
                state.userCamera.pan(pan.deltaX, -pan.deltaY);
            }
        });
        listenForRedraw(uiModel.pan);

        uiModel.zoom.subscribe( zoom => {
            if (state.cameraIndex === undefined)
            {
                state.userCamera.zoomBy(zoom.deltaZoom);
            }
        });
        listenForRedraw(uiModel.zoom);

        // configure the animation loop
        const past = {};
        const update = () =>
        {
            const devicePixelRatio = window.devicePixelRatio || 1;

            // set the size of the drawingBuffer based on the size it's displayed.
            canvas.width = Math.floor(canvas.clientWidth * devicePixelRatio);
            canvas.height = Math.floor(canvas.clientHeight * devicePixelRatio);
            redraw |= !state.animationTimer.paused && state.animationIndices.length > 0;
            redraw |= past.width != canvas.width || past.height != canvas.height;
            past.width = canvas.width;
            past.height = canvas.height;
            
            if (redraw) {
                view.renderFrame(state, canvas.width, canvas.height);
                redraw = false;
            }

            window.requestAnimationFrame(update);
        };

        // After this start executing animation loop.
        window.requestAnimationFrame(update);
    }

    exports.main = main$1;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=GltfSVApp.umd.js.map
