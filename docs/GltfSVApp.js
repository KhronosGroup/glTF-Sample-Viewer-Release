/**
 * Bundle of gltf-sample-viewer-example
 * Generated: 2025-01-28
 * Version: 1.0.0
 * License: Apache-2.0
 * Dependencies:
 *
 * @khronosgroup/gltf-viewer -- 1.1.0 -- Apache-2.0
 * 
 * Apache License
 * Version 2.0, January 2004
 * http://www.apache.org/licenses/
 *
 * TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
 *
 * 1. Definitions.
 *
 * "License" shall mean the terms and conditions for use, reproduction,
 * and distribution as defined by Sections 1 through 9 of this document.
 *
 * "Licensor" shall mean the copyright owner or entity authorized by
 * the copyright owner that is granting the License.
 *
 * "Legal Entity" shall mean the union of the acting entity and all
 * other entities that control, are controlled by, or are under common
 * control with that entity. For the purposes of this definition,
 * "control" means (i) the power, direct or indirect, to cause the
 * direction or management of such entity, whether by contract or
 * otherwise, or (ii) ownership of fifty percent (50%) or more of the
 * outstanding shares, or (iii) beneficial ownership of such entity.
 *
 * "You" (or "Your") shall mean an individual or Legal Entity
 * exercising permissions granted by this License.
 *
 * "Source" form shall mean the preferred form for making modifications,
 * including but not limited to software source code, documentation
 * source, and configuration files.
 *
 * "Object" form shall mean any form resulting from mechanical
 * transformation or translation of a Source form, including but
 * not limited to compiled object code, generated documentation,
 * and conversions to other media types.
 *
 * "Work" shall mean the work of authorship, whether in Source or
 * Object form, made available under the License, as indicated by a
 * copyright notice that is included in or attached to the work
 * (an example is provided in the Appendix below).
 *
 * "Derivative Works" shall mean any work, whether in Source or Object
 * form, that is based on (or derived from) the Work and for which the
 * editorial revisions, annotations, elaborations, or other modifications
 * represent, as a whole, an original work of authorship. For the purposes
 * of this License, Derivative Works shall not include works that remain
 * separable from, or merely link (or bind by name) to the interfaces of,
 * the Work and Derivative Works thereof.
 *
 * "Contribution" shall mean any work of authorship, including
 * the original version of the Work and any modifications or additions
 * to that Work or Derivative Works thereof, that is intentionally
 * submitted to Licensor for inclusion in the Work by the copyright owner
 * or by an individual or Legal Entity authorized to submit on behalf of
 * the copyright owner. For the purposes of this definition, "submitted"
 * means any form of electronic, verbal, or written communication sent
 * to the Licensor or its representatives, including but not limited to
 * communication on electronic mailing lists, source code control systems,
 * and issue tracking systems that are managed by, or on behalf of, the
 * Licensor for the purpose of discussing and improving the Work, but
 * excluding communication that is conspicuously marked or otherwise
 * designated in writing by the copyright owner as "Not a Contribution."
 *
 * "Contributor" shall mean Licensor and any individual or Legal Entity
 * on behalf of whom a Contribution has been received by Licensor and
 * subsequently incorporated within the Work.
 *
 * 2. Grant of Copyright License. Subject to the terms and conditions of
 * this License, each Contributor hereby grants to You a perpetual,
 * worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 * copyright license to reproduce, prepare Derivative Works of,
 * publicly display, publicly perform, sublicense, and distribute the
 * Work and such Derivative Works in Source or Object form.
 *
 * 3. Grant of Patent License. Subject to the terms and conditions of
 * this License, each Contributor hereby grants to You a perpetual,
 * worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 * (except as stated in this section) patent license to make, have made,
 * use, offer to sell, sell, import, and otherwise transfer the Work,
 * where such license applies only to those patent claims licensable
 * by such Contributor that are necessarily infringed by their
 * Contribution(s) alone or by combination of their Contribution(s)
 * with the Work to which such Contribution(s) was submitted. If You
 * institute patent litigation against any entity (including a
 * cross-claim or counterclaim in a lawsuit) alleging that the Work
 * or a Contribution incorporated within the Work constitutes direct
 * or contributory patent infringement, then any patent licenses
 * granted to You under this License for that Work shall terminate
 * as of the date such litigation is filed.
 *
 * 4. Redistribution. You may reproduce and distribute copies of the
 * Work or Derivative Works thereof in any medium, with or without
 * modifications, and in Source or Object form, provided that You
 * meet the following conditions:
 *
 * (a) You must give any other recipients of the Work or
 * Derivative Works a copy of this License; and
 *
 * (b) You must cause any modified files to carry prominent notices
 * stating that You changed the files; and
 *
 * (c) You must retain, in the Source form of any Derivative Works
 * that You distribute, all copyright, patent, trademark, and
 * attribution notices from the Source form of the Work,
 * excluding those notices that do not pertain to any part of
 * the Derivative Works; and
 *
 * (d) If the Work includes a "NOTICE" text file as part of its
 * distribution, then any Derivative Works that You distribute must
 * include a readable copy of the attribution notices contained
 * within such NOTICE file, excluding those notices that do not
 * pertain to any part of the Derivative Works, in at least one
 * of the following places: within a NOTICE text file distributed
 * as part of the Derivative Works; within the Source form or
 * documentation, if provided along with the Derivative Works; or,
 * within a display generated by the Derivative Works, if and
 * wherever such third-party notices normally appear. The contents
 * of the NOTICE file are for informational purposes only and
 * do not modify the License. You may add Your own attribution
 * notices within Derivative Works that You distribute, alongside
 * or as an addendum to the NOTICE text from the Work, provided
 * that such additional attribution notices cannot be construed
 * as modifying the License.
 *
 * You may add Your own copyright statement to Your modifications and
 * may provide additional or different license terms and conditions
 * for use, reproduction, or distribution of Your modifications, or
 * for any such Derivative Works as a whole, provided Your use,
 * reproduction, and distribution of the Work otherwise complies with
 * the conditions stated in this License.
 *
 * 5. Submission of Contributions. Unless You explicitly state otherwise,
 * any Contribution intentionally submitted for inclusion in the Work
 * by You to the Licensor shall be under the terms and conditions of
 * this License, without any additional terms or conditions.
 * Notwithstanding the above, nothing herein shall supersede or modify
 * the terms of any separate license agreement you may have executed
 * with Licensor regarding such Contributions.
 *
 * 6. Trademarks. This License does not grant permission to use the trade
 * names, trademarks, service marks, or product names of the Licensor,
 * except as required for reasonable and customary use in describing the
 * origin of the Work and reproducing the content of the NOTICE file.
 *
 * 7. Disclaimer of Warranty. Unless required by applicable law or
 * agreed to in writing, Licensor provides the Work (and each
 * Contributor provides its Contributions) on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied, including, without limitation, any warranties or conditions
 * of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
 * PARTICULAR PURPOSE. You are solely responsible for determining the
 * appropriateness of using or redistributing the Work and assume any
 * risks associated with Your exercise of permissions under this License.
 *
 * 8. Limitation of Liability. In no event and under no legal theory,
 * whether in tort (including negligence), contract, or otherwise,
 * unless required by applicable law (such as deliberate and grossly
 * negligent acts) or agreed to in writing, shall any Contributor be
 * liable to You for damages, including any direct, indirect, special,
 * incidental, or consequential damages of any character arising as a
 * result of this License or out of the use or inability to use the
 * Work (including but not limited to damages for loss of goodwill,
 * work stoppage, computer failure or malfunction, or any and all
 * other commercial damages or losses), even if such Contributor
 * has been advised of the possibility of such damages.
 *
 * 9. Accepting Warranty or Additional Liability. While redistributing
 * the Work or Derivative Works thereof, You may choose to offer,
 * and charge a fee for, acceptance of support, warranty, indemnity,
 * or other liability obligations and/or rights consistent with this
 * License. However, in accepting such obligations, You may act only
 * on Your own behalf and on Your sole responsibility, not on behalf
 * of any other Contributor, and only if You agree to indemnify,
 * defend, and hold each Contributor harmless for any liability
 * incurred by, or claims asserted against, such Contributor by reason
 * of your accepting any such warranty or additional liability.
 *
 * END OF TERMS AND CONDITIONS
 *
 * APPENDIX: How to apply the Apache License to your work.
 *
 * To apply the Apache License to your work, attach the following
 * boilerplate notice, with the fields enclosed by brackets "[]"
 * replaced with your own identifying information. (Don't include
 * the brackets!)  The text should be enclosed in the appropriate
 * comment syntax for the file format. We also recommend that a
 * file or class name and description of purpose be included on the
 * same "printed page" as the copyright notice for easier
 * identification within third-party archives.
 *
 * Copyright [yyyy] [name of copyright owner]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 *
 * tslib -- 1.14.1 -- 0BSD
 * Copyright (c) Microsoft Corporation.
 * 
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 *
 * rxjs -- 6.6.7 -- Apache-2.0
 * Apache License
 * Version 2.0, January 2004
 * http://www.apache.org/licenses/
 *
 * TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
 *
 * 1. Definitions.
 *
 * "License" shall mean the terms and conditions for use, reproduction,
 * and distribution as defined by Sections 1 through 9 of this document.
 *
 * "Licensor" shall mean the copyright owner or entity authorized by
 * the copyright owner that is granting the License.
 *
 * "Legal Entity" shall mean the union of the acting entity and all
 * other entities that control, are controlled by, or are under common
 * control with that entity. For the purposes of this definition,
 * "control" means (i) the power, direct or indirect, to cause the
 * direction or management of such entity, whether by contract or
 * otherwise, or (ii) ownership of fifty percent (50%) or more of the
 * outstanding shares, or (iii) beneficial ownership of such entity.
 *
 * "You" (or "Your") shall mean an individual or Legal Entity
 * exercising permissions granted by this License.
 *
 * "Source" form shall mean the preferred form for making modifications,
 * including but not limited to software source code, documentation
 * source, and configuration files.
 *
 * "Object" form shall mean any form resulting from mechanical
 * transformation or translation of a Source form, including but
 * not limited to compiled object code, generated documentation,
 * and conversions to other media types.
 *
 * "Work" shall mean the work of authorship, whether in Source or
 * Object form, made available under the License, as indicated by a
 * copyright notice that is included in or attached to the work
 * (an example is provided in the Appendix below).
 *
 * "Derivative Works" shall mean any work, whether in Source or Object
 * form, that is based on (or derived from) the Work and for which the
 * editorial revisions, annotations, elaborations, or other modifications
 * represent, as a whole, an original work of authorship. For the purposes
 * of this License, Derivative Works shall not include works that remain
 * separable from, or merely link (or bind by name) to the interfaces of,
 * the Work and Derivative Works thereof.
 *
 * "Contribution" shall mean any work of authorship, including
 * the original version of the Work and any modifications or additions
 * to that Work or Derivative Works thereof, that is intentionally
 * submitted to Licensor for inclusion in the Work by the copyright owner
 * or by an individual or Legal Entity authorized to submit on behalf of
 * the copyright owner. For the purposes of this definition, "submitted"
 * means any form of electronic, verbal, or written communication sent
 * to the Licensor or its representatives, including but not limited to
 * communication on electronic mailing lists, source code control systems,
 * and issue tracking systems that are managed by, or on behalf of, the
 * Licensor for the purpose of discussing and improving the Work, but
 * excluding communication that is conspicuously marked or otherwise
 * designated in writing by the copyright owner as "Not a Contribution."
 *
 * "Contributor" shall mean Licensor and any individual or Legal Entity
 * on behalf of whom a Contribution has been received by Licensor and
 * subsequently incorporated within the Work.
 *
 * 2. Grant of Copyright License. Subject to the terms and conditions of
 * this License, each Contributor hereby grants to You a perpetual,
 * worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 * copyright license to reproduce, prepare Derivative Works of,
 * publicly display, publicly perform, sublicense, and distribute the
 * Work and such Derivative Works in Source or Object form.
 *
 * 3. Grant of Patent License. Subject to the terms and conditions of
 * this License, each Contributor hereby grants to You a perpetual,
 * worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 * (except as stated in this section) patent license to make, have made,
 * use, offer to sell, sell, import, and otherwise transfer the Work,
 * where such license applies only to those patent claims licensable
 * by such Contributor that are necessarily infringed by their
 * Contribution(s) alone or by combination of their Contribution(s)
 * with the Work to which such Contribution(s) was submitted. If You
 * institute patent litigation against any entity (including a
 * cross-claim or counterclaim in a lawsuit) alleging that the Work
 * or a Contribution incorporated within the Work constitutes direct
 * or contributory patent infringement, then any patent licenses
 * granted to You under this License for that Work shall terminate
 * as of the date such litigation is filed.
 *
 * 4. Redistribution. You may reproduce and distribute copies of the
 * Work or Derivative Works thereof in any medium, with or without
 * modifications, and in Source or Object form, provided that You
 * meet the following conditions:
 *
 * (a) You must give any other recipients of the Work or
 * Derivative Works a copy of this License; and
 *
 * (b) You must cause any modified files to carry prominent notices
 * stating that You changed the files; and
 *
 * (c) You must retain, in the Source form of any Derivative Works
 * that You distribute, all copyright, patent, trademark, and
 * attribution notices from the Source form of the Work,
 * excluding those notices that do not pertain to any part of
 * the Derivative Works; and
 *
 * (d) If the Work includes a "NOTICE" text file as part of its
 * distribution, then any Derivative Works that You distribute must
 * include a readable copy of the attribution notices contained
 * within such NOTICE file, excluding those notices that do not
 * pertain to any part of the Derivative Works, in at least one
 * of the following places: within a NOTICE text file distributed
 * as part of the Derivative Works; within the Source form or
 * documentation, if provided along with the Derivative Works; or,
 * within a display generated by the Derivative Works, if and
 * wherever such third-party notices normally appear. The contents
 * of the NOTICE file are for informational purposes only and
 * do not modify the License. You may add Your own attribution
 * notices within Derivative Works that You distribute, alongside
 * or as an addendum to the NOTICE text from the Work, provided
 * that such additional attribution notices cannot be construed
 * as modifying the License.
 *
 * You may add Your own copyright statement to Your modifications and
 * may provide additional or different license terms and conditions
 * for use, reproduction, or distribution of Your modifications, or
 * for any such Derivative Works as a whole, provided Your use,
 * reproduction, and distribution of the Work otherwise complies with
 * the conditions stated in this License.
 *
 * 5. Submission of Contributions. Unless You explicitly state otherwise,
 * any Contribution intentionally submitted for inclusion in the Work
 * by You to the Licensor shall be under the terms and conditions of
 * this License, without any additional terms or conditions.
 * Notwithstanding the above, nothing herein shall supersede or modify
 * the terms of any separate license agreement you may have executed
 * with Licensor regarding such Contributions.
 *
 * 6. Trademarks. This License does not grant permission to use the trade
 * names, trademarks, service marks, or product names of the Licensor,
 * except as required for reasonable and customary use in describing the
 * origin of the Work and reproducing the content of the NOTICE file.
 *
 * 7. Disclaimer of Warranty. Unless required by applicable law or
 * agreed to in writing, Licensor provides the Work (and each
 * Contributor provides its Contributions) on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied, including, without limitation, any warranties or conditions
 * of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
 * PARTICULAR PURPOSE. You are solely responsible for determining the
 * appropriateness of using or redistributing the Work and assume any
 * risks associated with Your exercise of permissions under this License.
 *
 * 8. Limitation of Liability. In no event and under no legal theory,
 * whether in tort (including negligence), contract, or otherwise,
 * unless required by applicable law (such as deliberate and grossly
 * negligent acts) or agreed to in writing, shall any Contributor be
 * liable to You for damages, including any direct, indirect, special,
 * incidental, or consequential damages of any character arising as a
 * result of this License or out of the use or inability to use the
 * Work (including but not limited to damages for loss of goodwill,
 * work stoppage, computer failure or malfunction, or any and all
 * other commercial damages or losses), even if such Contributor
 * has been advised of the possibility of such damages.
 *
 * 9. Accepting Warranty or Additional Liability. While redistributing
 * the Work or Derivative Works thereof, You may choose to offer,
 * and charge a fee for, acceptance of support, warranty, indemnity,
 * or other liability obligations and/or rights consistent with this
 * License. However, in accepting such obligations, You may act only
 * on Your own behalf and on Your sole responsibility, not on behalf
 * of any other Contributor, and only if You agree to indemnify,
 * defend, and hold each Contributor harmless for any liability
 * incurred by, or claims asserted against, such Contributor by reason
 * of your accepting any such warranty or additional liability.
 *
 * END OF TERMS AND CONDITIONS
 *
 * APPENDIX: How to apply the Apache License to your work.
 *
 * To apply the Apache License to your work, attach the following
 * boilerplate notice, with the fields enclosed by brackets "[]"
 * replaced with your own identifying information. (Don't include
 * the brackets!)  The text should be enclosed in the appropriate
 * comment syntax for the file format. We also recommend that a
 * file or class name and description of purpose be included on the
 * same "printed page" as the copyright notice for easier
 * identification within third-party archives.
 *
 * Copyright (c) 2015-2018 Google, Inc., Netflix, Inc., Microsoft Corp. and contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * 
 *
 *
 * simple-dropzone -- 0.8.3 -- MIT
 * 
 * The MIT License (MIT)
 *
 * Copyright (c) 2018 Don McCurdy
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 *
 * gl-matrix -- 3.4.3 -- MIT
 * Copyright (c) 2015-2021, Brandon Jones, Colin MacKenzie IV.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * gltf-sample-viewer-example -- 1.0.0 -- Apache-2.0
 * 
 * Apache License
 * Version 2.0, January 2004
 * http://www.apache.org/licenses/
 *
 * TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
 *
 * 1. Definitions.
 *
 * "License" shall mean the terms and conditions for use, reproduction,
 * and distribution as defined by Sections 1 through 9 of this document.
 *
 * "Licensor" shall mean the copyright owner or entity authorized by
 * the copyright owner that is granting the License.
 *
 * "Legal Entity" shall mean the union of the acting entity and all
 * other entities that control, are controlled by, or are under common
 * control with that entity. For the purposes of this definition,
 * "control" means (i) the power, direct or indirect, to cause the
 * direction or management of such entity, whether by contract or
 * otherwise, or (ii) ownership of fifty percent (50%) or more of the
 * outstanding shares, or (iii) beneficial ownership of such entity.
 *
 * "You" (or "Your") shall mean an individual or Legal Entity
 * exercising permissions granted by this License.
 *
 * "Source" form shall mean the preferred form for making modifications,
 * including but not limited to software source code, documentation
 * source, and configuration files.
 *
 * "Object" form shall mean any form resulting from mechanical
 * transformation or translation of a Source form, including but
 * not limited to compiled object code, generated documentation,
 * and conversions to other media types.
 *
 * "Work" shall mean the work of authorship, whether in Source or
 * Object form, made available under the License, as indicated by a
 * copyright notice that is included in or attached to the work
 * (an example is provided in the Appendix below).
 *
 * "Derivative Works" shall mean any work, whether in Source or Object
 * form, that is based on (or derived from) the Work and for which the
 * editorial revisions, annotations, elaborations, or other modifications
 * represent, as a whole, an original work of authorship. For the purposes
 * of this License, Derivative Works shall not include works that remain
 * separable from, or merely link (or bind by name) to the interfaces of,
 * the Work and Derivative Works thereof.
 *
 * "Contribution" shall mean any work of authorship, including
 * the original version of the Work and any modifications or additions
 * to that Work or Derivative Works thereof, that is intentionally
 * submitted to Licensor for inclusion in the Work by the copyright owner
 * or by an individual or Legal Entity authorized to submit on behalf of
 * the copyright owner. For the purposes of this definition, "submitted"
 * means any form of electronic, verbal, or written communication sent
 * to the Licensor or its representatives, including but not limited to
 * communication on electronic mailing lists, source code control systems,
 * and issue tracking systems that are managed by, or on behalf of, the
 * Licensor for the purpose of discussing and improving the Work, but
 * excluding communication that is conspicuously marked or otherwise
 * designated in writing by the copyright owner as "Not a Contribution."
 *
 * "Contributor" shall mean Licensor and any individual or Legal Entity
 * on behalf of whom a Contribution has been received by Licensor and
 * subsequently incorporated within the Work.
 *
 * 2. Grant of Copyright License. Subject to the terms and conditions of
 * this License, each Contributor hereby grants to You a perpetual,
 * worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 * copyright license to reproduce, prepare Derivative Works of,
 * publicly display, publicly perform, sublicense, and distribute the
 * Work and such Derivative Works in Source or Object form.
 *
 * 3. Grant of Patent License. Subject to the terms and conditions of
 * this License, each Contributor hereby grants to You a perpetual,
 * worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 * (except as stated in this section) patent license to make, have made,
 * use, offer to sell, sell, import, and otherwise transfer the Work,
 * where such license applies only to those patent claims licensable
 * by such Contributor that are necessarily infringed by their
 * Contribution(s) alone or by combination of their Contribution(s)
 * with the Work to which such Contribution(s) was submitted. If You
 * institute patent litigation against any entity (including a
 * cross-claim or counterclaim in a lawsuit) alleging that the Work
 * or a Contribution incorporated within the Work constitutes direct
 * or contributory patent infringement, then any patent licenses
 * granted to You under this License for that Work shall terminate
 * as of the date such litigation is filed.
 *
 * 4. Redistribution. You may reproduce and distribute copies of the
 * Work or Derivative Works thereof in any medium, with or without
 * modifications, and in Source or Object form, provided that You
 * meet the following conditions:
 *
 * (a) You must give any other recipients of the Work or
 * Derivative Works a copy of this License; and
 *
 * (b) You must cause any modified files to carry prominent notices
 * stating that You changed the files; and
 *
 * (c) You must retain, in the Source form of any Derivative Works
 * that You distribute, all copyright, patent, trademark, and
 * attribution notices from the Source form of the Work,
 * excluding those notices that do not pertain to any part of
 * the Derivative Works; and
 *
 * (d) If the Work includes a "NOTICE" text file as part of its
 * distribution, then any Derivative Works that You distribute must
 * include a readable copy of the attribution notices contained
 * within such NOTICE file, excluding those notices that do not
 * pertain to any part of the Derivative Works, in at least one
 * of the following places: within a NOTICE text file distributed
 * as part of the Derivative Works; within the Source form or
 * documentation, if provided along with the Derivative Works; or,
 * within a display generated by the Derivative Works, if and
 * wherever such third-party notices normally appear. The contents
 * of the NOTICE file are for informational purposes only and
 * do not modify the License. You may add Your own attribution
 * notices within Derivative Works that You distribute, alongside
 * or as an addendum to the NOTICE text from the Work, provided
 * that such additional attribution notices cannot be construed
 * as modifying the License.
 *
 * You may add Your own copyright statement to Your modifications and
 * may provide additional or different license terms and conditions
 * for use, reproduction, or distribution of Your modifications, or
 * for any such Derivative Works as a whole, provided Your use,
 * reproduction, and distribution of the Work otherwise complies with
 * the conditions stated in this License.
 *
 * 5. Submission of Contributions. Unless You explicitly state otherwise,
 * any Contribution intentionally submitted for inclusion in the Work
 * by You to the Licensor shall be under the terms and conditions of
 * this License, without any additional terms or conditions.
 * Notwithstanding the above, nothing herein shall supersede or modify
 * the terms of any separate license agreement you may have executed
 * with Licensor regarding such Contributions.
 *
 * 6. Trademarks. This License does not grant permission to use the trade
 * names, trademarks, service marks, or product names of the Licensor,
 * except as required for reasonable and customary use in describing the
 * origin of the Work and reproducing the content of the NOTICE file.
 *
 * 7. Disclaimer of Warranty. Unless required by applicable law or
 * agreed to in writing, Licensor provides the Work (and each
 * Contributor provides its Contributions) on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied, including, without limitation, any warranties or conditions
 * of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
 * PARTICULAR PURPOSE. You are solely responsible for determining the
 * appropriateness of using or redistributing the Work and assume any
 * risks associated with Your exercise of permissions under this License.
 *
 * 8. Limitation of Liability. In no event and under no legal theory,
 * whether in tort (including negligence), contract, or otherwise,
 * unless required by applicable law (such as deliberate and grossly
 * negligent acts) or agreed to in writing, shall any Contributor be
 * liable to You for damages, including any direct, indirect, special,
 * incidental, or consequential damages of any character arising as a
 * result of this License or out of the use or inability to use the
 * Work (including but not limited to damages for loss of goodwill,
 * work stoppage, computer failure or malfunction, or any and all
 * other commercial damages or losses), even if such Contributor
 * has been advised of the possibility of such damages.
 *
 * 9. Accepting Warranty or Additional Liability. While redistributing
 * the Work or Derivative Works thereof, You may choose to offer,
 * and charge a fee for, acceptance of support, warranty, indemnity,
 * or other liability obligations and/or rights consistent with this
 * License. However, in accepting such obligations, You may act only
 * on Your own behalf and on Your sole responsibility, not on behalf
 * of any other Contributor, and only if You agree to indemnify,
 * defend, and hold each Contributor harmless for any liability
 * incurred by, or claims asserted against, such Contributor by reason
 * of your accepting any such warranty or additional liability.
 *
 * END OF TERMS AND CONDITIONS
 *
 * APPENDIX: How to apply the Apache License to your work.
 *
 * To apply the Apache License to your work, attach the following
 * boilerplate notice, with the fields enclosed by brackets "[]"
 * replaced with your own identifying information. (Don't include
 * the brackets!)  The text should be enclosed in the appropriate
 * comment syntax for the file format. We also recommend that a
 * file or class name and description of purpose be included on the
 * same "printed page" as the copyright notice for easier
 * identification within third-party archives.
 *
 * Copyright [yyyy] [name of copyright owner]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 *
 * normalize-wheel -- 1.0.1 -- BSD-3-Clause
 * BSD License
 *
 * For FixedDataTable software
 *
 * Copyright (c) 2015, Facebook, Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * * Neither the name Facebook nor the names of its contributors may be used to
 * endorse or promote products derived from this software without specific
 * prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * vue -- 3.5.10 -- MIT
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-present, Yuxi (Evan) You
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *
 * @vue/shared -- 3.5.10 -- MIT
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-present, Yuxi (Evan) You
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *
 * @vue/compiler-core -- 3.5.10 -- MIT
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-present, Yuxi (Evan) You
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *
 * @vue/compiler-dom -- 3.5.10 -- MIT
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-present, Yuxi (Evan) You
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *
 * @vue/reactivity -- 3.5.10 -- MIT
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-present, Yuxi (Evan) You
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *
 * @vue/runtime-core -- 3.5.10 -- MIT
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-present, Yuxi (Evan) You
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *
 * @vue/runtime-dom -- 3.5.10 -- MIT
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-present, Yuxi (Evan) You
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *
 * @ntohq/buefy-next -- 0.1.4 -- MIT
 * 
 *
 * gltf-validator -- 2.0.0-dev.3.10 -- Apache-2.0
 * 
 * Apache License
 * Version 2.0, January 2004
 * http://www.apache.org/licenses/
 * 
 * TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
 * 
 * 1. Definitions.
 * 
 * "License" shall mean the terms and conditions for use, reproduction,
 * and distribution as defined by Sections 1 through 9 of this document.
 * 
 * "Licensor" shall mean the copyright owner or entity authorized by
 * the copyright owner that is granting the License.
 * 
 * "Legal Entity" shall mean the union of the acting entity and all
 * other entities that control, are controlled by, or are under common
 * control with that entity. For the purposes of this definition,
 * "control" means (i) the power, direct or indirect, to cause the
 * direction or management of such entity, whether by contract or
 * otherwise, or (ii) ownership of fifty percent (50%) or more of the
 * outstanding shares, or (iii) beneficial ownership of such entity.
 * 
 * "You" (or "Your") shall mean an individual or Legal Entity
 * exercising permissions granted by this License.
 * 
 * "Source" form shall mean the preferred form for making modifications,
 * including but not limited to software source code, documentation
 * source, and configuration files.
 * 
 * "Object" form shall mean any form resulting from mechanical
 * transformation or translation of a Source form, including but
 * not limited to compiled object code, generated documentation,
 * and conversions to other media types.
 * 
 * "Work" shall mean the work of authorship, whether in Source or
 * Object form, made available under the License, as indicated by a
 * copyright notice that is included in or attached to the work
 * (an example is provided in the Appendix below).
 * 
 * "Derivative Works" shall mean any work, whether in Source or Object
 * form, that is based on (or derived from) the Work and for which the
 * editorial revisions, annotations, elaborations, or other modifications
 * represent, as a whole, an original work of authorship. For the purposes
 * of this License, Derivative Works shall not include works that remain
 * separable from, or merely link (or bind by name) to the interfaces of,
 * the Work and Derivative Works thereof.
 * 
 * "Contribution" shall mean any work of authorship, including
 * the original version of the Work and any modifications or additions
 * to that Work or Derivative Works thereof, that is intentionally
 * submitted to Licensor for inclusion in the Work by the copyright owner
 * or by an individual or Legal Entity authorized to submit on behalf of
 * the copyright owner. For the purposes of this definition, "submitted"
 * means any form of electronic, verbal, or written communication sent
 * to the Licensor or its representatives, including but not limited to
 * communication on electronic mailing lists, source code control systems,
 * and issue tracking systems that are managed by, or on behalf of, the
 * Licensor for the purpose of discussing and improving the Work, but
 * excluding communication that is conspicuously marked or otherwise
 * designated in writing by the copyright owner as "Not a Contribution."
 * 
 * "Contributor" shall mean Licensor and any individual or Legal Entity
 * on behalf of whom a Contribution has been received by Licensor and
 * subsequently incorporated within the Work.
 * 
 * 2. Grant of Copyright License. Subject to the terms and conditions of
 * this License, each Contributor hereby grants to You a perpetual,
 * worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 * copyright license to reproduce, prepare Derivative Works of,
 * publicly display, publicly perform, sublicense, and distribute the
 * Work and such Derivative Works in Source or Object form.
 * 
 * 3. Grant of Patent License. Subject to the terms and conditions of
 * this License, each Contributor hereby grants to You a perpetual,
 * worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 * (except as stated in this section) patent license to make, have made,
 * use, offer to sell, sell, import, and otherwise transfer the Work,
 * where such license applies only to those patent claims licensable
 * by such Contributor that are necessarily infringed by their
 * Contribution(s) alone or by combination of their Contribution(s)
 * with the Work to which such Contribution(s) was submitted. If You
 * institute patent litigation against any entity (including a
 * cross-claim or counterclaim in a lawsuit) alleging that the Work
 * or a Contribution incorporated within the Work constitutes direct
 * or contributory patent infringement, then any patent licenses
 * granted to You under this License for that Work shall terminate
 * as of the date such litigation is filed.
 * 
 * 4. Redistribution. You may reproduce and distribute copies of the
 * Work or Derivative Works thereof in any medium, with or without
 * modifications, and in Source or Object form, provided that You
 * meet the following conditions:
 * 
 * (a) You must give any other recipients of the Work or
 * Derivative Works a copy of this License; and
 * 
 * (b) You must cause any modified files to carry prominent notices
 * stating that You changed the files; and
 * 
 * (c) You must retain, in the Source form of any Derivative Works
 * that You distribute, all copyright, patent, trademark, and
 * attribution notices from the Source form of the Work,
 * excluding those notices that do not pertain to any part of
 * the Derivative Works; and
 * 
 * (d) If the Work includes a "NOTICE" text file as part of its
 * distribution, then any Derivative Works that You distribute must
 * include a readable copy of the attribution notices contained
 * within such NOTICE file, excluding those notices that do not
 * pertain to any part of the Derivative Works, in at least one
 * of the following places: within a NOTICE text file distributed
 * as part of the Derivative Works; within the Source form or
 * documentation, if provided along with the Derivative Works; or,
 * within a display generated by the Derivative Works, if and
 * wherever such third-party notices normally appear. The contents
 * of the NOTICE file are for informational purposes only and
 * do not modify the License. You may add Your own attribution
 * notices within Derivative Works that You distribute, alongside
 * or as an addendum to the NOTICE text from the Work, provided
 * that such additional attribution notices cannot be construed
 * as modifying the License.
 * 
 * You may add Your own copyright statement to Your modifications and
 * may provide additional or different license terms and conditions
 * for use, reproduction, or distribution of Your modifications, or
 * for any such Derivative Works as a whole, provided Your use,
 * reproduction, and distribution of the Work otherwise complies with
 * the conditions stated in this License.
 * 
 * 5. Submission of Contributions. Unless You explicitly state otherwise,
 * any Contribution intentionally submitted for inclusion in the Work
 * by You to the Licensor shall be under the terms and conditions of
 * this License, without any additional terms or conditions.
 * Notwithstanding the above, nothing herein shall supersede or modify
 * the terms of any separate license agreement you may have executed
 * with Licensor regarding such Contributions.
 * 
 * 6. Trademarks. This License does not grant permission to use the trade
 * names, trademarks, service marks, or product names of the Licensor,
 * except as required for reasonable and customary use in describing the
 * origin of the Work and reproducing the content of the NOTICE file.
 * 
 * 7. Disclaimer of Warranty. Unless required by applicable law or
 * agreed to in writing, Licensor provides the Work (and each
 * Contributor provides its Contributions) on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied, including, without limitation, any warranties or conditions
 * of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
 * PARTICULAR PURPOSE. You are solely responsible for determining the
 * appropriateness of using or redistributing the Work and assume any
 * risks associated with Your exercise of permissions under this License.
 * 
 * 8. Limitation of Liability. In no event and under no legal theory,
 * whether in tort (including negligence), contract, or otherwise,
 * unless required by applicable law (such as deliberate and grossly
 * negligent acts) or agreed to in writing, shall any Contributor be
 * liable to You for damages, including any direct, indirect, special,
 * incidental, or consequential damages of any character arising as a
 * result of this License or out of the use or inability to use the
 * Work (including but not limited to damages for loss of goodwill,
 * work stoppage, computer failure or malfunction, or any and all
 * other commercial damages or losses), even if such Contributor
 * has been advised of the possibility of such damages.
 * 
 * 9. Accepting Warranty or Additional Liability. While redistributing
 * the Work or Derivative Works thereof, You may choose to offer,
 * and charge a fee for, acceptance of support, warranty, indemnity,
 * or other liability obligations and/or rights consistent with this
 * License. However, in accepting such obligations, You may act only
 * on Your own behalf and on Your sole responsibility, not on behalf
 * of any other Contributor, and only if You agree to indemnify,
 * defend, and hold each Contributor harmless for any liability
 * incurred by, or claims asserted against, such Contributor by reason
 * of your accepting any such warranty or additional liability.
 * 
 * END OF TERMS AND CONDITIONS
 * 
 * APPENDIX: How to apply the Apache License to your work.
 * 
 * To apply the Apache License to your work, attach the following
 * boilerplate notice, with the fields enclosed by brackets "[]"
 * replaced with your own identifying information. (Don't include
 * the brackets!)  The text should be enclosed in the appropriate
 * comment syntax for the file format. We also recommend that a
 * file or class name and description of purpose be included on the
 * same "printed page" as the copyright notice for easier
 * identification within third-party archives.
 * 
 * Copyright [yyyy] [name of copyright owner]
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Bundle of @khronosgroup/gltf-viewer
 * Generated: 2025-01-28
 * Version: 1.1.0
 * License: Apache-2.0
 * Dependencies:
 *
 * gl-matrix -- 3.4.3 -- MIT
 * Copyright (c) 2015-2021, Brandon Jones, Colin MacKenzie IV.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * jpeg-js -- 0.4.4 -- BSD-3-Clause
 * Copyright (c) 2014, Eugene Ware
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of Eugene Ware nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY EUGENE WARE ''AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL EUGENE WARE BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * iobuffer -- 5.3.2 -- MIT
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Michaël Zasso
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 *
 *
 * pako -- 2.1.0 -- (MIT AND Zlib)
 * (The MIT License)
 *
 * Copyright (C) 2014-2017 by Vitaly Puzrin and Andrei Tuputcyn
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *
 * fast-png -- 6.2.0 -- MIT
 * MIT License
 *
 * Copyright (c) 2015 Michaël Zasso
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 *
 * json-ptr -- 3.1.1 -- MIT
 * Copyright (c) 2011-2021 Phillip Clark
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * Common utilities
 * @module glMatrix
 */
// Configuration Constants
var EPSILON = 0.000001;
var ARRAY_TYPE$1 = typeof Float32Array !== 'undefined' ? Float32Array : Array;
if (!Math.hypot) Math.hypot = function () {
  var y = 0,
      i = arguments.length;

  while (i--) {
    y += arguments[i] * arguments[i];
  }

  return Math.sqrt(y);
};

/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */

function create$4() {
  var out = new ARRAY_TYPE$1(9);

  if (ARRAY_TYPE$1 != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }

  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {ReadonlyMat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */

function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function multiply$1(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b00 = b[0],
      b01 = b[1],
      b02 = b[2];
  var b10 = b[3],
      b11 = b[4],
      b12 = b[5];
  var b20 = b[6],
      b21 = b[7],
      b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}

/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */

function create$3() {
  var out = new ARRAY_TYPE$1(16);

  if (ARRAY_TYPE$1 != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }

  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */

function clone$1(a) {
  var out = new ARRAY_TYPE$1(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */

function identity$1(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a12 = a[6],
        a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }

  return out;
}
/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
/**
 * Calculates the determinant of a mat4
 *
 * @param {ReadonlyMat4} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15]; // Cache only the current line of the second matrix

  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */

function getRotation(out, mat) {
  var scaling = new ARRAY_TYPE$1(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }

  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @returns {mat4} out
 */

function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Generates a perspective projection matrix with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
 * which matches WebGL/OpenGL's clip volume.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */

function perspectiveNO(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;

  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }

  return out;
}
/**
 * Alias for {@link mat4.perspectiveNO}
 * @function
 */

var perspective = perspectiveNO;
/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */

function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];

  if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
    return identity$1(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len = 1 / Math.hypot(z0, z1, z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.hypot(x0, x1, x2);

  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len = Math.hypot(y0, y1, y2);

  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
/**
 * Alias for {@link mat4.multiply}
 * @function
 */

var mul = multiply;

/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */

function create$2() {
  var out = new ARRAY_TYPE$1(3);

  if (ARRAY_TYPE$1 != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  return out;
}
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {ReadonlyVec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */

function clone(a) {
  var out = new ARRAY_TYPE$1(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Calculates the length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */

function fromValues$2(x, y, z) {
  var out = new ARRAY_TYPE$1(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function add$1(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} distance between a and b
 */

function distance$1(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to normalize
 * @returns {vec3} out
 */

function normalize$2(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}
/**
 * Calculates the dot product of two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  var bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec3} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec3} out
 */

function transformQuat(out, a, q) {
  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];
  var x = a[0],
      y = a[1],
      z = a[2]; // var qvec = [qx, qy, qz];
  // var uv = vec3.cross([], qvec, a);

  var uvx = qy * z - qz * y,
      uvy = qz * x - qx * z,
      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

  var uuvx = qy * uvz - qz * uvy,
      uuvy = qz * uvx - qx * uvz,
      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2; // vec3.scale(uuv, uuv, 2);

  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
/**
 * Alias for {@link vec3.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec3.length}
 * @function
 */

var len = length;
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

(function () {
  var vec = create$2();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }

    return a;
  };
})();

/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */

function create$1() {
  var out = new ARRAY_TYPE$1(4);

  if (ARRAY_TYPE$1 != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }

  return out;
}
/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */

function fromValues$1(x, y, z, w) {
  var out = new ARRAY_TYPE$1(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to normalize
 * @returns {vec4} out
 */

function normalize$1(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len = x * x + y * y + z * z + w * w;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }

  out[0] = x * len;
  out[1] = y * len;
  out[2] = z * len;
  out[3] = w * len;
  return out;
}
/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

(function () {
  var vec = create$1();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 4;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }

    return a;
  };
})();

/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */

function create$5() {
  var out = new ARRAY_TYPE$1(4);

  if (ARRAY_TYPE$1 != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  out[3] = 1;
  return out;
}
/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyVec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/

function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  var omega, cosom, sinom, scale0, scale1; // calc cosine

  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

  if (cosom < 0.0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  } // calculate coefficients


  if (1.0 - cosom > EPSILON) {
    // standard case (slerp)
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  } // calculate final values


  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyMat3} m rotation matrix
 * @returns {quat} out
 * @function
 */

function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;

  if (fTrace > 0.0) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0); // 2w

    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot; // 1/(4w)

    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    // |w| <= 1/2
    var i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }

  return out;
}
/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */

var fromValues$3 = fromValues$1;
/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */

var normalize = normalize$1;
/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {ReadonlyVec3} a the initial vector
 * @param {ReadonlyVec3} b the destination vector
 * @returns {quat} out
 */

(function () {
  var tmpvec3 = create$2();
  var xUnitVec3 = fromValues$2(1, 0, 0);
  var yUnitVec3 = fromValues$2(0, 1, 0);
  return function (out, a, b) {
    var dot$1 = dot(a, b);

    if (dot$1 < -0.999999) {
      cross(tmpvec3, xUnitVec3, a);
      if (len(tmpvec3) < 0.000001) cross(tmpvec3, yUnitVec3, a);
      normalize$2(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot$1 > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      cross(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot$1;
      return normalize(out, out);
    }
  };
})();
/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {ReadonlyQuat} c the third operand
 * @param {ReadonlyQuat} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

(function () {
  var temp1 = create$5();
  var temp2 = create$5();
  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
})();
/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {ReadonlyVec3} view  the vector representing the viewing direction
 * @param {ReadonlyVec3} right the vector representing the local "right" direction
 * @param {ReadonlyVec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */

(function () {
  var matr = create$4();
  return function (out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize(out, fromMat3(out, matr));
  };
})();

class AnimatableProperty {
    constructor(value) {
        this.restValue = value;
        this.animatedValue = null;
    }

    restAt(value) {
        this.restValue = value;
    }

    animate(value) {
        this.animatedValue = value;
    }

    rest() {
        this.animatedValue = null;
    }

    value() {
        return this.animatedValue ?? this.restValue;
    }

    isDefined() {
        return this.restValue !== undefined;
    }
}

function jsToGl(array) {
    if (array === undefined) {
        return undefined;
    }
    let tensor = new ARRAY_TYPE$1(array.length);

    for (let i = 0; i < array.length; ++i) {
        tensor[i] = array[i];
    }

    return tensor;
}

function jsToGlSlice(array, offset, stride) {
    let tensor = new ARRAY_TYPE$1(stride);

    for (let i = 0; i < stride; ++i) {
        tensor[i] = array[offset + i];
    }

    return tensor;
}

function initGlForMembers(gltfObj, gltf, webGlContext) {
    for (const name of Object.keys(gltfObj)) {
        const member = gltfObj[name];

        if (member === undefined) {
            continue;
        }
        if (member.initGl !== undefined) {
            member.initGl(gltf, webGlContext);
        }
        if (Array.isArray(member)) {
            for (const element of member) {
                if (element !== null && element !== undefined && element.initGl !== undefined) {
                    element.initGl(gltf, webGlContext);
                }
            }
        }
    }
}

function objectsFromJsons(jsonObjects, GltfType) {
    if (jsonObjects === undefined) {
        return [];
    }

    const objects = [];
    for (const jsonObject of jsonObjects) {
        objects.push(objectFromJson(jsonObject, GltfType));
    }
    return objects;
}

function objectFromJson(jsonObject, GltfType) {
    const object = new GltfType();
    object.fromJson(jsonObject);
    return object;
}

function fromKeys(target, jsonObj, ignore = []) {
    for (let k of Object.keys(jsonObj)) {
        if (ignore && ignore.find(function (elem) { return elem == k; }) !== undefined) {
            continue; // skip
        }

        let normalizedK = k.replace("^@", "");
        target[normalizedK] = structuredClone(jsonObj[k]);
    }
}

function stringHash(str, seed = 0) {
    let hash = seed;
    if (str.length === 0) return hash;
    for (let i = 0; i < str.length; i++) {
        let chr = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + chr;
        hash |= 0; // Convert to 32bit integer
    }
    return hash;
}

function clamp(number, min, max) {
    return Math.min(Math.max(number, min), max);
}

function getIsGlb(filename) {
    return getExtension(filename) == "glb";
}

function getExtension(filename) {
    const split = filename.toLowerCase().split(".");
    if (split.length == 1) {
        return undefined;
    }
    return split[split.length - 1];
}

function getContainingFolder(filePath) {
    return filePath.substring(0, filePath.lastIndexOf("/") + 1);
}

// marker interface used to for parsing the uniforms
class UniformStruct { }

class AnimationTimer {
    constructor() {
        this.startTime = 0;
        this.paused = true;
        this.fixedTime = null;
        this.pausedTime = 0;
    }

    elapsedSec() {
        if (this.paused) {
            return this.pausedTime / 1000;
        }
        else {
            return this.fixedTime || (new Date().getTime() - this.startTime) / 1000;
        }
    }

    toggle() {
        if (this.paused) {
            this.unpause();
        }
        else {
            this.pause();
        }
    }

    start() {
        this.startTime = new Date().getTime();
        this.paused = false;
    }

    pause() {
        this.pausedTime = new Date().getTime() - this.startTime;
        this.paused = true;
    }

    unpause() {
        this.startTime += new Date().getTime() - this.startTime - this.pausedTime;
        this.paused = false;
    }

    reset() {
        if (!this.paused) {
            // Animation is running.
            this.startTime = new Date().getTime();
        }
        else {
            this.startTime = 0;
        }
        this.pausedTime = 0;
    }

    setFixedTime(timeInSec) {
        this.paused = false;
        this.fixedTime = timeInSec;
    }
}

// base class for all gltf objects
class GltfObject
{
    constructor()
    {
        this.extensions = undefined;
        this.extras = undefined;
        this.animatedPropertyObjects = {};
        if (this.constructor.animatedProperties === undefined)
        {
            throw new Error("animatedProperties is not defined for " + this.constructor.name);
        }
        for (const prop of this.constructor.animatedProperties)
        {
            this.animatedPropertyObjects[prop] = new AnimatableProperty(undefined);
            Object.defineProperty(this, prop, {
                get: function() { return this.animatedPropertyObjects[prop].value(); },
                set: function(value) { this.animatedPropertyObjects[prop].restAt(value); }
            });
        }
    }
    
    static animatedProperties = undefined;

    fromJson(json)
    {
        fromKeys(this, json);
    }

    initGl(gltf, webGlContext)
    {
        initGlForMembers(this, gltf, webGlContext);
    }
}

class gltfCamera extends GltfObject
{
    static animatedProperties = [];
    constructor()
    {
        super();
        this.name = undefined;
        this.node = undefined;
        this.type = "perspective";
        this.perspective = new PerspectiveCamera();
        this.orthographic = new OrthographicCamera();
    }

    fromJson(json)
    {
        super.fromJson(json);

        if (json.perspective !== undefined)
        {
            this.perspective = new PerspectiveCamera();
            this.perspective.fromJson(json.perspective);
        }
        if (json.orthographic !== undefined)
        {
            this.orthographic = new OrthographicCamera();
            this.orthographic.fromJson(json.orthographic);
        }
    }

    initGl(gltf, webGlContext)
    {
        super.initGl(gltf, webGlContext);

        let cameraIndex = undefined;
        for (let i = 0; i < gltf.nodes.length; i++)
        {
            cameraIndex = gltf.nodes[i].camera;
            if (cameraIndex === undefined)
            {
                continue;
            }

            if (gltf.cameras[cameraIndex] === this)
            {
                this.node = i;
                break;
            }
        }

        // cameraIndex stays undefined if camera is not assigned to any node
        if(this.node === undefined && cameraIndex !== undefined)
        {
            console.error("Invalid node for camera " + cameraIndex);
        }
    }

    sortPrimitivesByDepth(gltf, drawables)
    {
        // Precompute the distances to avoid their computation during sorting.
        for (const drawable of drawables)
        {
            const modelView = create$3();
            multiply(modelView, this.getViewMatrix(gltf), drawable.node.worldTransform);

            // Transform primitive centroid to find the primitive's depth.
            const pos = transformMat4(create$2(), clone(drawable.primitive.centroid), modelView);

            drawable.depth = pos[2];
        }

        // 1. Remove primitives that are behind the camera.
        //    --> They will never be visible and it is cheap to discard them here.
        // 2. Sort primitives so that the furthest nodes are rendered first.
        //    This is required for correct transparency rendering.
        return drawables
            .sort((a, b) => a.depth - b.depth);
    }

    getProjectionMatrix(aspectRatio)
    {
        const projection = create$3();

        if (this.type === "perspective")
        {
            perspective(
                projection,
                this.perspective.yfov,
                this.perspective.aspectRatio ?? aspectRatio,
                this.perspective.znear,
                this.perspective.zfar
            );
        }
        else if (this.type === "orthographic")
        {
            const znear = this.orthographic.znear;
            const zfar = this.orthographic.zfar;
            projection[0]  = 1.0 / this.orthographic.xmag;
            projection[5]  = 1.0 / this.orthographic.ymag;
            projection[10] = 2.0 / (znear - zfar);
            projection[14] = (zfar + znear) / (znear - zfar);
        }

        return projection;
    }

    getViewMatrix(gltf)
    {
        let result = create$3();
        invert(result, this.getTransformMatrix(gltf));
        return result;
    }

    getTarget(gltf)
    {
        const target = create$2();
        const position = this.getPosition(gltf);
        const lookDirection = this.getLookDirection(gltf);
        add$1(target, lookDirection, position);
        return target;
    }

    getPosition(gltf)
    {
        const position = create$2();
        const node = this.getNode(gltf);
        getTranslation(position, node.worldTransform);
        return position;
    }

    getLookDirection(gltf)
    {
        const direction = create$2();
        const rotation = this.getRotation(gltf);
        transformQuat(direction, fromValues$2(0, 0, -1), rotation);
        return direction;
    }

    getRotation(gltf)
    {
        const rotation = create$5();
        const node = this.getNode(gltf);
        getRotation(rotation, node.worldTransform);
        return rotation;
    }

    getNode(gltf)
    {
        return gltf.nodes[this.node];
    }

    getTransformMatrix(gltf)
    {
        const node = this.getNode(gltf);
        if (node !== undefined && node.worldTransform !== undefined)
        {
            return node.worldTransform;
        }
        return create$3();

    }

    // Returns a JSON object describing the user camera's current values.
    getDescription(gltf)
    {
        const asset = {
            "generator": "gltf-sample-renderer",
            "version": "2.0"
        };

        const camera = {
            "type": this.type
        };

        if (this.name !== undefined)
        {
            camera["name"] = this.name;
        }

        if (this.type === "perspective")
        {
            camera["perspective"] = {};
            if (this.perspective.aspectRatio)
            {
                camera["perspective"]["aspectRatio"] = this.perspective.aspectRatio;
            }
            camera["perspective"]["yfov"] = this.perspective.yfov;
            if (this.perspective.zfar && this.perspective.zfar != Infinity)
            {
                camera["perspective"]["zfar"] = this.perspective.zfar;
            }
            camera["perspective"]["znear"] = this.perspective.znear;
        }
        else if (this.type === "orthographic")
        {
            camera["orthographic"] = {};
            camera["orthographic"]["xmag"] = this.orthographic.xmag;
            camera["orthographic"]["ymag"] = this.orthographic.ymag;
            camera["orthographic"]["zfar"] = this.orthographic.zfar;
            camera["orthographic"]["znear"] = this.orthographic.znear;
        }

        const mat = this.getTransformMatrix(gltf);

        const node = {
            "camera": 0,
            "matrix": [mat[0], mat[1], mat[2], mat[3],
                mat[4], mat[5], mat[6], mat[7],
                mat[8], mat[9], mat[10], mat[11],
                mat[12], mat[13], mat[14], mat[15]]
        };

        if (this.node !== undefined && gltf.nodes[this.node].name !== undefined)
        {
            node["name"] = gltf.nodes[this.node].name;
        }

        return {
            "asset": asset,
            "cameras": [camera],
            "nodes": [node]
        };
    }
}

class PerspectiveCamera extends GltfObject
{
    static animatedProperties = [
        "yfov",
        "aspectRatio",
        "znear",
        "zfar"
    ];
    constructor() {
        super();
        this.yfov = 45 * Math.PI / 180;
        this.aspectRatio = undefined;
        this.znear = 0.01;
        this.zfar = Infinity;
    }
}

class OrthographicCamera extends GltfObject
{
    static animatedProperties = [
        "xmag",
        "ymag",
        "znear",
        "zfar"
    ];
    constructor() {
        super();
        this.xmag = 1;
        this.ymag = 1;
        this.znear = 0.01;
        this.zfar = Infinity;
    }
}

const ImageMimeType = {JPEG: "image/jpeg", PNG: "image/png", WEBP: "image/webp", HDR: "image/vnd.radiance", KTX2: "image/ktx2", GLTEXTURE: "image/texture"};

let GL = undefined;

class gltfWebGl
{
    constructor(context)
    {
        this.context = context;
        if(GL === undefined)
        {
            GL = context;
        }
    }

    loadWebGlExtensions()
    {
        let EXT_texture_filter_anisotropic = this.context.getExtension("EXT_texture_filter_anisotropic");
        if (EXT_texture_filter_anisotropic)
        {
            this.context.anisotropy = EXT_texture_filter_anisotropic.TEXTURE_MAX_ANISOTROPY_EXT;
            this.context.maxAnisotropy = this.context.getParameter(EXT_texture_filter_anisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
            this.context.supports_EXT_texture_filter_anisotropic = true;
        }
        else
        {
            console.warn("Anisotropic filtering is not supported");
            this.context.supports_EXT_texture_filter_anisotropic = false;
        }
    }

    setTexture(loc, gltf, textureInfo, texSlot)
    {
        if (loc === null)
        {
            return false;
        }

        let gltfTex = gltf.textures[textureInfo.index];

        if (gltfTex === undefined)
        {
            return false;
        }

        const image = gltf.images[gltfTex.source];
        if (image === undefined)
        {
            return false;
        }

        if (gltfTex.glTexture === undefined)
        {
            if (image.mimeType === ImageMimeType.KTX2 ||
                image.mimeType === ImageMimeType.GLTEXTURE)
            {
                // these image resources are directly loaded to a GPU resource by resource loader
                gltfTex.glTexture = image.image;
            }
            else
            {
                // other images will be uploaded in a later step
                gltfTex.glTexture = this.context.createTexture();
            }
        }

        this.context.activeTexture(GL.TEXTURE0 + texSlot);
        this.context.bindTexture(gltfTex.type, gltfTex.glTexture);

        this.context.uniform1i(loc, texSlot);

        if (!gltfTex.initialized)
        {
            const gltfSampler = gltf.samplers[gltfTex.sampler];

            if (gltfSampler === undefined)
            {
                console.warn("Sampler is undefined for texture: " + textureInfo.index);
                return false;
            }

            this.context.pixelStorei(GL.UNPACK_FLIP_Y_WEBGL, false);

            // upload images that are not directly loaded as GPU resource
            if (image.mimeType === ImageMimeType.PNG ||
                image.mimeType === ImageMimeType.JPEG ||
                image.mimeType === ImageMimeType.WEBP ||
                image.mimeType === ImageMimeType.HDR)
            {
                // the check `GL.SRGB8_ALPHA8 === undefined` is needed as at the moment node-gles does not define the full format enum
                const internalformat = (textureInfo.linear || GL.SRGB8_ALPHA8 === undefined) ? GL.RGBA : GL.SRGB8_ALPHA8;
                this.context.texImage2D(image.type, image.miplevel, internalformat, GL.RGBA, GL.UNSIGNED_BYTE, image.image);
            }

            this.setSampler(gltfSampler, gltfTex.type, textureInfo.generateMips);

            if (textureInfo.generateMips)
            {
                switch (gltfSampler.minFilter)
                {
                case GL.NEAREST_MIPMAP_NEAREST:
                case GL.NEAREST_MIPMAP_LINEAR:
                case GL.LINEAR_MIPMAP_NEAREST:
                case GL.LINEAR_MIPMAP_LINEAR:
                    this.context.generateMipmap(gltfTex.type);
                    break;
                }
            }

            gltfTex.initialized = true;
        }

        return gltfTex.initialized;
    }

    setIndices(gltf, accessorIndex)
    {
        let gltfAccessor = gltf.accessors[accessorIndex];

        if (gltfAccessor.glBuffer === undefined)
        {
            gltfAccessor.glBuffer = this.context.createBuffer();

            let data = gltfAccessor.getTypedView(gltf);

            if (data === undefined)
            {
                return false;
            }

            this.context.bindBuffer(GL.ELEMENT_ARRAY_BUFFER, gltfAccessor.glBuffer);
            this.context.bufferData(GL.ELEMENT_ARRAY_BUFFER, data, GL.STATIC_DRAW);
        }
        else
        {
            this.context.bindBuffer(GL.ELEMENT_ARRAY_BUFFER, gltfAccessor.glBuffer);
        }

        return true;
    }

    enableAttribute(gltf, attributeLocation, gltfAccessor)
    {
        if (attributeLocation === null)
        {
            console.warn("Tried to access unknown attribute");
            return false;
        }

        if (gltfAccessor.glBuffer === undefined)
        {
            gltfAccessor.glBuffer = this.context.createBuffer();

            let data = gltfAccessor.getTypedView(gltf);

            if (data === undefined)
            {
                return false;
            }

            this.context.bindBuffer(GL.ARRAY_BUFFER, gltfAccessor.glBuffer);
            this.context.bufferData(GL.ARRAY_BUFFER, data, GL.STATIC_DRAW);
        }
        else
        {
            this.context.bindBuffer(GL.ARRAY_BUFFER, gltfAccessor.glBuffer);
        }

        this.context.vertexAttribPointer(attributeLocation, gltfAccessor.getComponentCount(gltfAccessor.type), gltfAccessor.componentType, gltfAccessor.normalized, gltfAccessor.byteStride(gltf), 0);
        this.context.enableVertexAttribArray(attributeLocation);

        return true;
    }

    compileShader(shaderIdentifier, isVert, shaderSource)
    {
        const shader = this.context.createShader(isVert ? GL.VERTEX_SHADER : GL.FRAGMENT_SHADER);
        this.context.shaderSource(shader, shaderSource);
        this.context.compileShader(shader);
        const compiled = this.context.getShaderParameter(shader, GL.COMPILE_STATUS);

        if (!compiled)
        {
            // output surrounding source code
            let info = "";
            const messages = this.context.getShaderInfoLog(shader).split("\n");
            for(const message of messages)
            {
                
                const matches = message.match(/(WARNING|ERROR): ([0-9]*):([0-9]*):(.*)/i);
                if (matches && matches.length == 5)
                {
                    const lineNumber = parseInt(matches[3]) - 1;
                    const lines = shaderSource.split("\n");

                    info += `${matches[1]}: ${shaderIdentifier}+includes:${lineNumber}: ${matches[4]}`;

                    for(let i = Math.max(0, lineNumber - 2); i < Math.min(lines.length, lineNumber + 3); i++)
                    {
                        if (lineNumber === i)
                        {
                            info += "->";
                        }
                        info += "\t" + lines[i] + "\n";
                    }
                }
                else
                {
                    info += message + "\n";
                }
            }

            throw new Error("Could not compile WebGL program '" + shaderIdentifier + "': " + info);
        }

        return shader;
    }

    linkProgram(vertex, fragment)
    {
        let program = this.context.createProgram();
        this.context.attachShader(program, vertex);
        this.context.attachShader(program, fragment);
        this.context.linkProgram(program);

        if (!this.context.getProgramParameter(program, GL.LINK_STATUS))
        {
            var info = this.context.getProgramInfoLog(program);
            throw new Error('Could not link WebGL program. \n\n' + info);
        }

        return program;
    }

    //https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants
    setSampler(gltfSamplerObj, type, generateMipmaps) // TEXTURE_2D
    {
        if (generateMipmaps)
        {
            this.context.texParameteri(type, GL.TEXTURE_WRAP_S, gltfSamplerObj.wrapS);
            this.context.texParameteri(type, GL.TEXTURE_WRAP_T, gltfSamplerObj.wrapT);
        }
        else
        {
            this.context.texParameteri(type, GL.TEXTURE_WRAP_S, GL.CLAMP_TO_EDGE);
            this.context.texParameteri(type, GL.TEXTURE_WRAP_T, GL.CLAMP_TO_EDGE);
        }

        // If not mip-mapped, force to non-mip-mapped sampler.
        if (!generateMipmaps && (gltfSamplerObj.minFilter != GL.NEAREST) && (gltfSamplerObj.minFilter != GL.LINEAR))
        {
            if ((gltfSamplerObj.minFilter == GL.NEAREST_MIPMAP_NEAREST) || (gltfSamplerObj.minFilter == GL.NEAREST_MIPMAP_LINEAR))
            {
                this.context.texParameteri(type, GL.TEXTURE_MIN_FILTER, GL.NEAREST);
            }
            else
            {
                this.context.texParameteri(type, GL.TEXTURE_MIN_FILTER, GL.LINEAR);
            }
        }
        else
        {
            this.context.texParameteri(type, GL.TEXTURE_MIN_FILTER, gltfSamplerObj.minFilter);
        }
        this.context.texParameteri(type, GL.TEXTURE_MAG_FILTER, gltfSamplerObj.magFilter);

        if (this.context.supports_EXT_texture_filter_anisotropic)
        {
            if ((gltfSamplerObj.magFilter !==  GL.NEAREST) 
                && (gltfSamplerObj.minFilter ===  GL.NEAREST_MIPMAP_LINEAR || gltfSamplerObj.minFilter ===  GL.LINEAR_MIPMAP_LINEAR ))
            {
                this.context.texParameterf(type, this.context.anisotropy, this.context.maxAnisotropy); // => 16xAF
            }
        }
    }
}

/* globals WebGl */


class gltfAccessor extends GltfObject
{
    static animatedProperties = [];
    constructor()
    {
        super();
        this.bufferView = undefined;
        this.byteOffset = 0;
        this.componentType = undefined;
        this.normalized = false;
        this.count = undefined;
        this.type = undefined;
        this.max = undefined;
        this.min = undefined;
        this.sparse = undefined;
        this.name = undefined;

        // non gltf
        this.glBuffer = undefined;
        this.typedView = undefined;
        this.filteredView = undefined;
        this.normalizedFilteredView = undefined;
        this.normalizedTypedView = undefined;
    }

    // getTypedView provides a view to the accessors data in form of
    // a TypedArray. This data can directly be passed to vertexAttribPointer
    getTypedView(gltf)
    {
        if (this.typedView !== undefined)
        {
            return this.typedView;
        }

        if (this.bufferView !== undefined)
        {
            const bufferView = gltf.bufferViews[this.bufferView];
            const buffer = gltf.buffers[bufferView.buffer];
            const byteOffset = this.byteOffset + bufferView.byteOffset;

            const componentSize = this.getComponentSize(this.componentType);
            let componentCount = this.getComponentCount(this.type);

            let arrayLength = 0;
            if(bufferView.byteStride !== 0)
            {
                if (componentSize !== 0)
                {
                    arrayLength = bufferView.byteStride / componentSize * (this.count - 1) + componentCount;
                }
                else
                {
                    console.warn("Invalid component type in accessor '" + (this.name ? this.name : "") + "'");
                }
            }
            else
            {
                arrayLength = this.count * componentCount;
            }

            if (arrayLength * componentSize > buffer.buffer.byteLength - byteOffset)
            {
                arrayLength = (buffer.buffer.byteLength - byteOffset) / componentSize;
                console.warn("Count in accessor '" + (this.name ? this.name : "") + "' is too large.");
            }

            switch (this.componentType)
            {
            case GL.BYTE:
                this.typedView = new Int8Array(buffer.buffer, byteOffset, arrayLength);
                break;
            case GL.UNSIGNED_BYTE:
                this.typedView = new Uint8Array(buffer.buffer, byteOffset, arrayLength);
                break;
            case GL.SHORT:
                this.typedView = new Int16Array(buffer.buffer, byteOffset, arrayLength);
                break;
            case GL.UNSIGNED_SHORT:
                this.typedView = new Uint16Array(buffer.buffer, byteOffset, arrayLength);
                break;
            case GL.UNSIGNED_INT:
                this.typedView = new Uint32Array(buffer.buffer, byteOffset, arrayLength);
                break;
            case GL.FLOAT:
                this.typedView = new Float32Array(buffer.buffer, byteOffset, arrayLength);
                break;
            }
        }
        else
        {
            this.typedView = this.createView();
        }

        if (this.sparse !== undefined)
        {
            this.applySparse(gltf, this.typedView);
        }

        return this.typedView;
    }

    // getNormalizedTypedView provides an alternative view to the accessors data,
    // where quantized data is already normalized. This is useful if the data is not passed
    // to vertexAttribPointer but used immediately (like e.g. animations)
    getNormalizedTypedView(gltf)
    {
        if(this.normalizedTypedView !== undefined)
        {
            return this.normalizedTypedView;
        }

        const typedView = this.getTypedView(gltf);
        this.normalizedTypedView = this.normalized ? gltfAccessor.dequantize(typedView, this.componentType) : typedView;
        return this.normalizedTypedView;
    }

    // getDeinterlacedView provides a view to the accessors data in form of
    // a TypedArray. In contrast to getTypedView, getDeinterlacedView deinterlaces
    // data, i.e. stripping padding and unrelated components from the array. It then
    // only contains the data of the accessor
    getDeinterlacedView(gltf)
    {
        if (this.filteredView !== undefined)
        {
            return this.filteredView;
        }

        if (this.bufferView !== undefined)
        {
            const bufferView = gltf.bufferViews[this.bufferView];
            const buffer = gltf.buffers[bufferView.buffer];

            const componentSize = this.getComponentSize(this.componentType); // E.g. GL.FLOAT -> 4
            const componentCount = this.getComponentCount(this.type); // E.g. Vec3 -> 3
            const arrayLength = this.count * componentCount;

            let stride = bufferView.byteStride !== 0 ? bufferView.byteStride : componentCount * componentSize;

            let bufferViewData = new DataView(buffer.buffer, bufferView.byteOffset, bufferView.byteLength);

            let func = 'getFloat32';
            switch (this.componentType)
            {
            case GL.BYTE:
                this.filteredView = new Int8Array(arrayLength);
                func = 'getInt8';
                break;
            case GL.UNSIGNED_BYTE:
                this.filteredView = new Uint8Array(arrayLength);
                func = 'getUint8';
                break;
            case GL.SHORT:
                this.filteredView = new Int16Array(arrayLength);
                func = 'getInt16';
                break;
            case GL.UNSIGNED_SHORT:
                this.filteredView = new Uint16Array(arrayLength);
                func = 'getUint16';
                break;
            case GL.UNSIGNED_INT:
                this.filteredView = new Uint32Array(arrayLength);
                func = 'getUint32';
                break;
            case GL.FLOAT:
                this.filteredView = new Float32Array(arrayLength);
                func = 'getFloat32';
                break;
            }

            for(let i = 0; i < arrayLength; ++i)
            {
                const vertexIndex = Math.floor(i/componentCount);
                const componentIndex = (i % componentCount) * componentSize;
                const offset = vertexIndex * stride + componentIndex + this.byteOffset; // Add Accessor byte offset
                this.filteredView[i] = bufferViewData[func](offset, true);
            }
              
        }
        else
        {
            this.filteredView = this.createView();
        }

        if (this.sparse !== undefined)
        {
            this.applySparse(gltf, this.filteredView);
        }

        return this.filteredView;
    }

    createView()
    {
        const size = this.count * this.getComponentCount(this.type);
        if (this.componentType == GL.BYTE) return new Int8Array(size);
        if (this.componentType == GL.UNSIGNED_BYTE) return new Uint8Array(size);
        if (this.componentType == GL.SHORT) return new Int16Array(size);
        if (this.componentType == GL.UNSIGNED_SHORT) return new Uint16Array(size);
        if (this.componentType == GL.UNSIGNED_INT) return new Uint32Array(size);
        if (this.componentType == GL.FLOAT) return new Float32Array(size);
        return undefined;
    }

    // getNormalizedDeinterlacedView provides an alternative view to the accessors data,
    // where quantized data is already normalized. This is useful if the data is not passed
    // to vertexAttribPointer but used immediately (like e.g. animations)
    getNormalizedDeinterlacedView(gltf)
    {
        if(this.normalizedFilteredView !== undefined)
        {
            return this.normalizedFilteredView;
        }

        const filteredView = this.getDeinterlacedView(gltf);
        this.normalizedFilteredView = this.normalized ? gltfAccessor.dequantize(filteredView, this.componentType) : filteredView;
        return this.normalizedFilteredView;
    }

    byteStride(gltf)
    {
        return gltf.bufferViews[this.bufferView]?.byteStride ??
            gltf.bufferViews[this.sparse?.values.bufferView]?.byteStride ??
            0;
    }

    applySparse(gltf, view)
    {
        // Gather indices.

        const indicesBufferView = gltf.bufferViews[this.sparse.indices.bufferView];
        const indicesBuffer = gltf.buffers[indicesBufferView.buffer];
        const indicesByteOffset = (this.sparse.indices.byteOffset ?? 0) + (indicesBufferView.byteOffset ?? 0);

        const indicesComponentSize = this.getComponentSize(this.sparse.indices.componentType);
        let indicesComponentCount = 1;

        if(indicesBufferView.byteStride !== 0)
        {
            indicesComponentCount = indicesBufferView.byteStride / indicesComponentSize;
        }

        const indicesArrayLength = this.sparse.count * indicesComponentCount;

        let indicesTypedView;
        switch (this.sparse.indices.componentType)
        {
        case GL.UNSIGNED_BYTE:
            indicesTypedView = new Uint8Array(indicesBuffer.buffer, indicesByteOffset, indicesArrayLength);
            break;
        case GL.UNSIGNED_SHORT:
            indicesTypedView = new Uint16Array(indicesBuffer.buffer, indicesByteOffset, indicesArrayLength);
            break;
        case GL.UNSIGNED_INT:
            indicesTypedView = new Uint32Array(indicesBuffer.buffer, indicesByteOffset, indicesArrayLength);
            break;
        }

        // Gather values.

        const valuesBufferView = gltf.bufferViews[this.sparse.values.bufferView];
        const valuesBuffer = gltf.buffers[valuesBufferView.buffer];
        const valuesByteOffset = (this.sparse.values.byteOffset ?? 0) + (valuesBufferView.byteOffset ?? 0);

        const valuesComponentSize = this.getComponentSize(this.componentType);
        let valuesComponentCount = this.getComponentCount(this.type);

        if(valuesBufferView.byteStride !== 0)
        {
            valuesComponentCount = valuesBufferView.byteStride / valuesComponentSize;
        }

        const valuesArrayLength = this.sparse.count * valuesComponentCount;

        let valuesTypedView;
        switch (this.componentType)
        {
        case GL.BYTE:
            valuesTypedView = new Int8Array(valuesBuffer.buffer, valuesByteOffset, valuesArrayLength);
            break;
        case GL.UNSIGNED_BYTE:
            valuesTypedView = new Uint8Array(valuesBuffer.buffer, valuesByteOffset, valuesArrayLength);
            break;
        case GL.SHORT:
            valuesTypedView = new Int16Array(valuesBuffer.buffer, valuesByteOffset, valuesArrayLength);
            break;
        case GL.UNSIGNED_SHORT:
            valuesTypedView = new Uint16Array(valuesBuffer.buffer, valuesByteOffset, valuesArrayLength);
            break;
        case GL.UNSIGNED_INT:
            valuesTypedView = new Uint32Array(valuesBuffer.buffer, valuesByteOffset, valuesArrayLength);
            break;
        case GL.FLOAT:
            valuesTypedView = new Float32Array(valuesBuffer.buffer, valuesByteOffset, valuesArrayLength);
            break;
        }

        // Overwrite values.

        for(let i = 0; i < this.sparse.count; ++i)
        {
            for(let k = 0; k < valuesComponentCount; ++k)
            {
                view[indicesTypedView[i] * valuesComponentCount + k] = valuesTypedView[i * valuesComponentCount + k];
            }
        }
    }

    // dequantize can be used to perform the normalization from WebGL2 vertexAttribPointer explicitly
    // https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md#encoding-quantized-data
    static dequantize(typedArray, componentType)
    {
        switch (componentType)
        {
        case GL.BYTE:
            return new Float32Array(typedArray).map(c => Math.max(c / 127.0, -1.0));
        case GL.UNSIGNED_BYTE:
            return new Float32Array(typedArray).map(c => c / 255.0);
        case GL.SHORT:
            return new Float32Array(typedArray).map(c => Math.max(c / 32767.0, -1.0));
        case GL.UNSIGNED_SHORT:
            return new Float32Array(typedArray).map(c => c / 65535.0);
        default:
            return typedArray;
        }
    }

    getComponentCount(type)
    {
        return CompononentCount.get(type);
    }

    getComponentSize(componentType)
    {
        switch (componentType)
        {
        case GL.BYTE:
        case GL.UNSIGNED_BYTE:
            return 1;
        case GL.SHORT:
        case GL.UNSIGNED_SHORT:
            return 2;
        case GL.UNSIGNED_INT:
        case GL.FLOAT:
            return 4;
        default:
            return 0;
        }
    }

    destroy()
    {
        if (this.glBuffer !== undefined)
        {
            // TODO: this breaks the dependency direction
            WebGl.context.deleteBuffer(this.glBuffer);
        }

        this.glBuffer = undefined;
    }
}

const CompononentCount = new Map(
    [
        ["SCALAR", 1],
        ["VEC2", 2],
        ["VEC3", 3],
        ["VEC4", 4],
        ["MAT2", 4],
        ["MAT3", 9],
        ["MAT4", 16]
    ]
);

function getSceneExtents(gltf, sceneIndex, outMin, outMax)
{
    for (const i of [0, 1, 2])
    {
        outMin[i] = Number.POSITIVE_INFINITY;
        outMax[i] = Number.NEGATIVE_INFINITY;
    }

    const scene = gltf.scenes[sceneIndex];

    let nodeIndices = scene.nodes.slice();
    while(nodeIndices.length > 0)
    {
        const node = gltf.nodes[nodeIndices.pop()];
        nodeIndices = nodeIndices.concat(node.children);

        if (node.mesh === undefined)
        {
            continue;
        }

        const mesh = gltf.meshes[node.mesh];
        if (mesh.primitives === undefined)
        {
            continue;
        }

        for (const primitive of mesh.primitives)
        {
            const attribute = primitive.glAttributes.find(a => a.attribute == "POSITION");
            if (attribute === undefined)
            {
                continue;
            }

            const accessor = gltf.accessors[attribute.accessor];
            const assetMin = create$2();
            const assetMax = create$2();
            getExtentsFromAccessor(accessor, node.worldTransform, assetMin, assetMax);

            for (const i of [0, 1, 2])
            {
                outMin[i] = Math.min(outMin[i], assetMin[i]);
                outMax[i] = Math.max(outMax[i], assetMax[i]);
            }
        }
    }
}

function getExtentsFromAccessor(accessor, worldTransform, outMin, outMax)
{
    let min = jsToGl(accessor.min);
    let max = jsToGl(accessor.max);
    
    if (accessor.normalized) {
        min = gltfAccessor.dequantize(min, accessor.componentType);
        max = gltfAccessor.dequantize(max, accessor.componentType);
    }

    // Construct all eight corners from min and max values
    let boxVertices = [
        fromValues$2(min[0], min[1], min[2]),
        fromValues$2(min[0], min[1], max[2]),
        fromValues$2(min[0], max[1], min[2]),
        fromValues$2(min[0], max[1], max[2]),

        fromValues$2(max[0], min[1], min[2]),
        fromValues$2(max[0], min[1], max[2]),
        fromValues$2(max[0], max[1], min[2]),
        fromValues$2(max[0], max[1], max[2])];


    // Transform all bounding box vertices
    for(let i in boxVertices) { 
        transformMat4(boxVertices[i], boxVertices[i], worldTransform); 
    }

    // Create new (axis-aligned) bounding box out of transformed bounding box
    const boxMin = clone(boxVertices[0]); // initialize
    const boxMax = clone(boxVertices[0]);

    for(let i in boxVertices) {
        for (const component of [0, 1, 2]) {
            boxMin[component] = Math.min(boxMin[component], boxVertices[i][component]);
            boxMax[component] = Math.max(boxMax[component], boxVertices[i][component]);
        }
    }

    const center = create$2();
    add$1(center, boxMax, boxMin);
    scale(center, center, 0.5);

    const centerToSurface = create$2();
    sub(centerToSurface, boxMax, center);

    const radius = length(centerToSurface);

    for (const i of [0, 1, 2])
    {
        outMin[i] = center[i] - radius;
        outMax[i] = center[i] + radius;
    }
}

const PanSpeedDenominator = 3500;
const MaxNearFarRatio = 10000;

class UserCamera extends gltfCamera
{
    /**
     * Create a new user camera.
     */
    constructor()
    {
        super();

        this.transform = create$3();
        this.rotAroundY = 0;
        this.rotAroundX = 0;
        this.distance = 1;
        this.baseDistance = 1.0;
        this.zoomExponent = 5.0;
        this.zoomFactor = 0.01;
        this.orbitSpeed = 1 / 180;
        this.panSpeed = 1;
        this.sceneExtents = {
            min: create$2(),
            max: create$2()
        };
    }

    getTransformMatrix()
    {
        return this.transform;
    }

    /**
     * Sets the vertical FoV of the user camera.
     * @param {number} yfov 
     */
    setVerticalFoV(yfov)
    {
        this.perspective.yfov = yfov;
    }

    /**
     * Returns the current position of the user camera as a vec3.
     */
    getPosition()
    {
        let pos = create$2();
        getTranslation(pos, this.transform);
        return pos;
    }

    /**
     * Returns the current rotation of the user camera as quat.
     */
    getRotation()
    {
        let rot = create$5();
        getRotation(rot, this.transform);
        return rot;
    }

    /**
     * Returns the normalized direction the user camera looks at as vec3.
     */
    getLookDirection()
    {
        let dir = [-this.transform[8], -this.transform[9], -this.transform[10]];
        normalize$2(dir, dir);
        return dir;
    }

    /**
     * Returns the current target the camera looks at as vec3.
     * This multiplies the viewing direction with the distance.
     * For distance 0 the normalized viewing direction is used.
     */
    getTarget()
    {
        const target = create$2();
        const position = this.getPosition();
        let lookDirection = this.getLookDirection();
        if (this.distance != 0 && this.distance != 1)
        {
            lookDirection = lookDirection.map(x => x * this.distance);
        }
        add$1(target, lookDirection, position);
        return target;
    }

    /**
     * Look from user camera to target.
     * This changes the transformation of the user camera.
     * @param {vec3} from 
     * @param {vec3} to 
     */
    lookAt(from, to)
    {
        this.transform = create$3();
        lookAt(this.transform, from, to, fromValues$2(0, 1, 0));
    }

    /**
     * Sets the position of the user camera.
     * @param {vec3} position 
     */
    setPosition(position)
    {
        this.transform[12] = position[0];
        this.transform[13] = position[1];
        this.transform[14] = position[2];
    }

    /**
     * This rotates the user camera towards the target and sets the position of the user camera
     * according to the current distance.
     * @param {vec3} target 
     */
    setTarget(target)
    {
        let pos = create$2();
        getTranslation(pos, this.transform);
        this.transform = create$3();
        lookAt(this.transform, pos, target, fromValues$2(0, 1, 0));
        this.setDistanceFromTarget(this.distance, target);
    }

    /**
     * Sets the rotation of the camera.
     * Yaw and pitch in euler angles (degrees).
     * @param {number} yaw 
     * @param {number} pitch 
     */
    setRotation(yaw, pitch)
    {
        const tmpPos = this.getPosition();
        let mat4x = create$3();
        let mat4y = create$3();
        fromXRotation(mat4x, pitch);
        fromYRotation(mat4y, yaw);
        this.transform = mat4y;
        this.setPosition(tmpPos);
        multiply(this.transform, this.transform, mat4x);
    }

    /**
     * Transforms the user camera to look at a target from a specfic distance using the current rotation.
     * This will only change the position of the user camera, not the rotation.
     * Use this function to set the distance.
     * @param {number} distance 
     * @param {vec3} target 
     */
    setDistanceFromTarget(distance, target)
    {
        const lookDirection = this.getLookDirection();
        const distVec = lookDirection.map(x => x * -distance);
        let pos = create$2();
        add$1(pos, target, distVec);
        this.setPosition(pos);
        this.distance = distance;
    }

    /**
     * Zoom exponentially according to this.zoomFactor and this.zoomExponent.
     * The default zoomFactor provides good zoom speed for values from [-1,1].
     * @param {number} value 
     */
    zoomBy(value)
    {
        let target = this.getTarget();

        // zoom exponentially
        let zoomDistance = Math.pow(this.distance / this.baseDistance, 1.0 / this.zoomExponent);
        zoomDistance += this.zoomFactor * value;
        zoomDistance = Math.max(zoomDistance, 0.0001);
        this.distance = Math.pow(zoomDistance, this.zoomExponent) * this.baseDistance;

        this.setDistanceFromTarget(this.distance, target);
        this.fitCameraPlanesToExtents(this.sceneExtents.min, this.sceneExtents.max);
    }

    /**
     * Orbit around the target.
     * x and y should be in radient and are added to the current rotation.
     * The rotation around the x-axis is limited to 180 degree.
     * The axes are inverted: e.g. if y is positive the camera will look further down.
     * @param {number} x 
     * @param {number} y 
     */
    orbit(x, y)
    {
        const target = this.getTarget();
        const rotAroundXMax = Math.PI / 2 - 0.01;
        this.rotAroundY += (-x * this.orbitSpeed);
        this.rotAroundX += (-y * this.orbitSpeed);
        this.rotAroundX = clamp(this.rotAroundX, -rotAroundXMax, rotAroundXMax);
        this.setRotation(this.rotAroundY, this.rotAroundX);
        this.setDistanceFromTarget(this.distance, target);
    }

    /**
     * Pan the user camera.
     * The axes are inverted: e.g. if y is positive the camera will move down.
     * @param {number} x 
     * @param {number} y 
     */
    pan(x, y)
    {
        const right = fromValues$2(this.transform[0], this.transform[1], this.transform[2]);
        normalize$2(right, right);
        scale(right, right, -x * this.panSpeed * (this.distance / this.baseDistance));

        const up = fromValues$2(this.transform[4], this.transform[5], this.transform[6]);
        normalize$2(up, up);
        scale(up, up, -y * this.panSpeed * (this.distance / this.baseDistance));

        let pos = this.getPosition();

        add$1(pos, pos, up);
        add$1(pos, pos, right);

        this.setPosition(pos);
    }

    fitPanSpeedToScene(min, max)
    {
        const longestDistance = distance$1(min, max);
        this.panSpeed = longestDistance / PanSpeedDenominator;
    }

    reset()
    {
        this.transform = create$3();
        this.rotAroundX = 0;
        this.rotAroundY = 0;
        this.fitDistanceToExtents(this.sceneExtents.min, this.sceneExtents.max);
        this.fitCameraTargetToExtents(this.sceneExtents.min, this.sceneExtents.max);
    }

    /**
     * Calculates a camera position which looks at the center of the scene from an appropriate distance.
     * This calculates near and far plane as well.
     * @param {Gltf} gltf 
     * @param {number} sceneIndex 
     */
    resetView(gltf, sceneIndex)
    {
        if(gltf === undefined)
        {
            return;
        }

        this.transform = create$3();
        this.rotAroundX = 0;
        this.rotAroundY = 0;
        getSceneExtents(gltf, sceneIndex, this.sceneExtents.min, this.sceneExtents.max);
        this.fitDistanceToExtents(this.sceneExtents.min, this.sceneExtents.max);
        this.fitCameraTargetToExtents(this.sceneExtents.min, this.sceneExtents.max);

        this.fitPanSpeedToScene(this.sceneExtents.min, this.sceneExtents.max);
        this.fitCameraPlanesToExtents(this.sceneExtents.min, this.sceneExtents.max);

    }

    /**
     * Fit view to updated canvas size without changing rotation if distance is incorrect
     * @param {Gltf} gltf 
     * @param {number} sceneIndex 
     */
    fitViewToScene(gltf, sceneIndex)
    {
        if(gltf === undefined)
        {
            return;
        }

        this.transform = create$3();
        getSceneExtents(gltf, sceneIndex, this.sceneExtents.min, this.sceneExtents.max);
        this.fitDistanceToExtents(this.sceneExtents.min, this.sceneExtents.max);
        this.fitCameraTargetToExtents(this.sceneExtents.min, this.sceneExtents.max);

        this.fitPanSpeedToScene(this.sceneExtents.min, this.sceneExtents.max);
        this.fitCameraPlanesToExtents(this.sceneExtents.min, this.sceneExtents.max);

    }

    fitDistanceToExtents(min, max)
    {
        const maxAxisLength = Math.max(max[0] - min[0], max[1] - min[1]);
        const yfov = this.perspective.yfov;
        const xfov = this.perspective.yfov * (this.perspective.aspectRatio ?? 1);

        const yZoom = maxAxisLength / 2 / Math.tan(yfov / 2);
        const xZoom = maxAxisLength / 2 / Math.tan(xfov / 2);

        this.distance = Math.max(xZoom, yZoom);
        this.baseDistance = this.distance;
    }

    fitCameraTargetToExtents(min, max)
    {
        let target = [0,0,0];
        for (const i of [0, 1, 2])
        {
            target[i] = (max[i] + min[i]) / 2;
        }
        this.setRotation(this.rotAroundY, this.rotAroundX);
        this.setDistanceFromTarget(this.distance, target);
    }

    fitCameraPlanesToExtents(min, max)
    {
        // depends only on scene min/max and the camera distance

        // Manually increase scene extent just for the camera planes to avoid camera clipping in most situations.
        const longestDistance = 10 * distance$1(min, max);
        let zNear = this.distance - (longestDistance * 0.6);
        let zFar = this.distance + (longestDistance * 0.6);

        // minimum near plane value needs to depend on far plane value to avoid z fighting or too large near planes
        zNear = Math.max(zNear, zFar / MaxNearFarRatio);

        this.perspective.znear = zNear;
        this.perspective.zfar = zFar;
    }
}

/**
 * GltfState containing a state for visualization in GltfView
 */
class GltfState
{
    /**
     * GltfState represents all state that can be visualized in a view. You could have
     * multiple GltfStates configured and switch between them on demand.
     * @param {*} view GltfView to which this state belongs
     */
    constructor(view)
    {
        /** loaded gltf data @see ResourceLoader.loadGltf */
        this.gltf = undefined;
        /** loaded environment data @see ResourceLoader.loadEnvironment */
        this.environment = undefined;
        /** user camera @see UserCamera, convenient camera controls */
        this.userCamera = new UserCamera();
        /** gltf scene that is visible in the view */
        this.sceneIndex = 0;
        /**
         * index of the camera that is used to render the view. a
         * value of 'undefined' enables the user camera
         */
        this.cameraIndex = undefined;
        /** indices of active animations */
        this.animationIndices = [];
        /** animation timer allows to control the animation time */
        this.animationTimer = new AnimationTimer();
        /** KHR_materials_variants */
        this.variant = undefined;

        /** parameters used to configure the rendering */
        this.renderingParameters = {
            /** morphing between vertices */
            morphing: true,
            /** skin / skeleton */
            skinning: true,

            enabledExtensions: {
                /** KHR_materials_clearcoat */
                KHR_materials_clearcoat: true,
                /** KHR_materials_sheen */
                KHR_materials_sheen: true,
                /** KHR_materials_transmission */
                KHR_materials_transmission: true,
                /** KHR_materials_volume */
                KHR_materials_volume: true,
                /** KHR_materials_ior makes the index of refraction configurable */
                KHR_materials_ior: true,
                /** KHR_materials_specular allows configuring specular color (f0 color) and amount of specular reflection */
                KHR_materials_specular: true,
                /** KHR_materials_iridescence adds a thin-film iridescence effect */
                KHR_materials_iridescence: true,
                KHR_materials_diffuse_transmission: true,
                /** KHR_materials_anisotropy defines microfacet grooves in the surface, stretching the specular reflection on the surface */
                KHR_materials_anisotropy: true,
                /** KHR_materials_dispersion defines configuring the strength of the angular separation of colors (chromatic abberation)*/
                KHR_materials_dispersion: true,
                KHR_materials_emissive_strength: true,
            },
            /** clear color expressed as list of ints in the range [0, 255] */
            clearColor: [58, 64, 74, 255],
            /** exposure factor */
            exposure: 1.0,
            /** KHR_lights_punctual */
            usePunctual: true,
            /** image based lighting */
            useIBL: true,
            /** image based lighting intensity */
            iblIntensity: 1.0,
            /** render the environment map in the background */
            renderEnvironmentMap: true,
            /** apply blur to the background environment map */
            blurEnvironmentMap: true,
            /** which tonemap to use, use KHR_PBR_NEUTRAL for best color reproduction */
            toneMap: GltfState.ToneMaps.KHR_PBR_NEUTRAL,
            /** render some debug output channes, such as for example the normals */
            debugOutput: GltfState.DebugOutput.NONE,
            /**
             * By default the front face of the environment is +Z (90)
             * Front faces:
             * +X = 0
             * +Z = 90
             * -X = 180
             * -Z = 270
             */
            environmentRotation: 90.0,
            /** If this is set to true, directional lights will be generated if IBL is disabled */
            useDirectionalLightsWithDisabledIBL: false,
            /** MSAA used for cases which are not handled by the browser (e.g. Transmission)*/
            internalMSAA: 4
        };

        // retain a reference to the view with which the state was created, so that it can be validated
        this._view = view;
    }
}

/**
 * ToneMaps enum for the different tonemappings that are supported
 * by gltf sample viewer
*/
GltfState.ToneMaps = {
    /** Khronos PBR neutral tone mapping, see https://github.com/KhronosGroup/ToneMapping, https://modelviewer.dev/examples/tone-mapping */
    KHR_PBR_NEUTRAL: "Khronos PBR Neutral",
    /** ACES sRGB RRT+ODT implementation for 3D Commerce based on Stephen Hill's implementation with a exposure factor of 1.0 / 0.6 */
    ACES_HILL_EXPOSURE_BOOST: "ACES Filmic Tone Mapping (Hill - Exposure Boost)",
    /** fast implementation of the ACES sRGB RRT+ODT based on Krzysztof Narkowicz' implementation*/
    ACES_NARKOWICZ: "ACES Filmic Tone Mapping (Narkowicz)",
    /** more accurate implementation of the ACES sRGB RRT+ODT based on Stephen Hill's implementation*/
    ACES_HILL: "ACES Filmic Tone Mapping (Hill)",
    /** Linear mapping, clamped at 1.0 per channel */
    NONE: "None (Linear mapping, clamped at 1.0)",
};

/**
 * DebugOutput enum for selecting debug output channels
 * such as "NORMAL"
 */
GltfState.DebugOutput = {
    /** standard rendering - debug output is disabled */
    NONE: "None",

    /** generic debug outputs */
    generic: {
        /** output the texture coordinates 0 */
        UV_COORDS_0: "Texture Coordinates 0",
        /** output the texture coordinates 1 */
        UV_COORDS_1: "Texture Coordinates 1",
        /** output the world space normals (i.e. with TBN applied) */
        NORMAL: "Normal Texture",
        /** output the normal from the TBN*/
        GEOMETRYNORMAL: "Geometry Normal",
        /** output the tangent from the TBN*/
        TANGENT: "Geometry Tangent",
        /** output the bitangent from the TBN */
        BITANGENT: "Geometry Bitangent",
        /** output the world space normals (i.e. with TBN applied) */
        WORLDSPACENORMAL: "Shading Normal",
        /** output the alpha value */
        ALPHA: "Alpha",
        /** output the occlusion value */
        OCCLUSION: "Occlusion",
        /** output the emissive value */
        EMISSIVE: "Emissive",
    },

    /** metallic roughness */
    mr: {
        /** output the base color value */
        BASECOLOR: "Base Color",
        /** output the metallic value from pbr metallic roughness */
        METALLIC: "Metallic",
        /** output the roughness value from pbr metallic roughness */
        ROUGHNESS: "Roughness",
    },

    /** KHR_materials_clearcoat */
    clearcoat: {
        /** output the clear coat strength */
        CLEARCOAT_FACTOR: "ClearCoat Strength",
        /** output the clear coat roughness */
        CLEARCOAT_ROUGHNESS: "ClearCoat Roughness",
        /** output the clear coat normal */
        CLEARCOAT_NORMAL: "ClearCoat Normal",
    },

    /** KHR_materials_sheen */
    sheen: {
        /** output the sheen color*/
        SHEEN_COLOR: "Sheen Color",
        /** output the sheen roughness*/
        SHEEN_ROUGHNESS: "Sheen Roughness",
    },

    /** KHR_materials_specular */
    specular: {
        /** output the specular strength*/
        SPECULAR_FACTOR: "Specular Strength",
        /** output the specular color*/
        SPECULAR_COLOR: "Specular Color",
    },

    /** KHR_materials_transmission */
    transmission: {
        /** output the transmission strength*/
        TRANSMISSION_FACTOR: "Transmission Strength",
        /** output the volume thickness*/
        VOLUME_THICKNESS: "Volume Thickness",
    },

    /** KHR_materials_diffuse_tranmission */
    diffuseTransmission: {
        /** output the diffuse tranmission strength */
        DIFFUSE_TRANSMISSION_FACTOR: "Diffuse Transmission Strength",
        /** output the diffuse tranmission color factor */
        DIFFUSE_TRANSMISSION_COLOR_FACTOR: "Diffuse Transmission Color",
    },

    /** KHR_materials_iridescence */
    iridescence: {
        /** output the iridescence strength*/
        IRIDESCENCE_FACTOR: "Iridescence Strength",
        /** output the iridescence thickness*/
        IRIDESCENCE_THICKNESS: "Iridescence Thickness",
    },

    /** KHR_materials_anisotropy */
    anisotropy: {
        /** output the anisotropic strength*/
        ANISOTROPIC_STRENGTH: "Anisotropic Strength",
        /** output final direction as defined by the anisotropyTexture and rotation*/
        ANISOTROPIC_DIRECTION: "Anisotropic Direction",
    },
};

class gltfShader
{
    constructor(program, hash, gl)
    {
        this.program = program;
        this.hash = hash;
        this.uniforms = new Map();
        this.attributes = new Map();
        this.unknownAttributes = [];
        this.unknownUniforms = [];
        this.gl = gl;

        if(this.program !== undefined)
        {
            const uniformCount = this.gl.context.getProgramParameter(this.program, GL.ACTIVE_UNIFORMS);
            for(let i = 0; i < uniformCount; ++i)
            {
                const info = this.gl.context.getActiveUniform(this.program, i);
                const loc = this.gl.context.getUniformLocation(this.program, info.name);
                this.uniforms.set(info.name, {type: info.type, loc: loc});
            }

            const attribCount = this.gl.context.getProgramParameter(this.program, GL.ACTIVE_ATTRIBUTES);
            for(let i = 0; i < attribCount; ++i)
            {
                const info = this.gl.context.getActiveAttrib(this.program, i);
                const loc = this.gl.context.getAttribLocation(this.program, info.name);
                this.attributes.set(info.name, loc);
            }
        }
    }

    destroy()
    {
        if (this.program !== undefined)
        {
            this.deleteProgram(this.program);
        }

        this.program = undefined;
    }

    getAttributeLocation(name)
    {
        const loc = this.attributes.get(name);
        if (loc === undefined)
        {
            if (this.unknownAttributes.find(n => n === name) === undefined)
            {
                console.log("Attribute '%s' does not exist", name);
                this.unknownAttributes.push(name);
            }
            return -1;
        }
        return loc;
    }

    getUniformLocation(name)
    {
        const uniform = this.uniforms.get(name);
        if (uniform === undefined)
        {
            if (this.unknownUniforms.find(n => n === name) === undefined)
            {
                this.unknownUniforms.push(name);
            }
            return null;
        }
        return uniform.loc;
    }

    updateUniform(objectName, object, log = false)
    {
        if (object === undefined) {
            if(log) {
                console.log("update uniform: object undefined");
            }
            return;
        }
        if (object instanceof UniformStruct)
        {
            this.updateUniformStruct(objectName, object, log);
        }
        else if (Array.isArray(object))
        {
            this.updateUniformArray(objectName, object, log);
        }
        else
        {
            this.updateUniformValue(objectName, object, log);
        }
    }

    updateUniformArray(arrayName, array, log)
    {
        if(array[0] instanceof UniformStruct)
        {
            for (let i = 0; i < array.length; ++i)
            {
                let element = array[i];
                let uniformName = arrayName + "[" + i + "]";
                this.updateUniform(uniformName, element, log);
            }
        }else {
            let uniformName = arrayName + "[0]";

            let flat = [];

            if(Array.isArray(array[0]) || array[0].length !== undefined)
            {
                for (let i = 0; i < array.length; ++i)
                {
                    flat.push.apply(flat, Array.from(array[i]));
                }
            }
            else
            {
                flat = array;
            }

            if(flat.length === 0)
            {
                console.error("Failed to flatten uniform array " + uniformName);
                return;
            }

            this.updateUniformValue(uniformName, flat, log);
        }
    }

    updateUniformStruct(structName, object, log)
    {
        let memberNames = Object.keys(object);
        for (let memberName of memberNames)
        {
            let uniformName = structName + "." + memberName;
            this.updateUniform(uniformName, object[memberName], log);
        }
    }

    // upload the values of a uniform with the given name using type resolve to get correct function call
    updateUniformValue(uniformName, value, log)
    {
        const uniform = this.uniforms.get(uniformName);

        if(uniform !== undefined)
        {
            switch (uniform.type) {
            case GL.FLOAT:
            {
                if(Array.isArray(value) || value instanceof Float32Array)
                {
                    this.gl.context.uniform1fv(uniform.loc, value);
                }else {
                    this.gl.context.uniform1f(uniform.loc, value);
                }
                break;
            }
            case GL.FLOAT_VEC2: this.gl.context.uniform2fv(uniform.loc, value); break;
            case GL.FLOAT_VEC3: this.gl.context.uniform3fv(uniform.loc, value); break;
            case GL.FLOAT_VEC4: this.gl.context.uniform4fv(uniform.loc, value); break;

            case GL.INT:
            {
                if(Array.isArray(value) || value instanceof Uint32Array || value instanceof Int32Array)
                {
                    this.gl.context.uniform1iv(uniform.loc, value);
                }else {
                    this.gl.context.uniform1i(uniform.loc, value);
                }
                break;
            }
            case GL.INT_VEC2: this.gl.context.uniform2iv(uniform.loc, value); break;
            case GL.INT_VEC3: this.gl.context.uniform3iv(uniform.loc, value); break;
            case GL.INT_VEC4: this.gl.context.uniform4iv(uniform.loc, value); break;

            case GL.FLOAT_MAT2: this.gl.context.uniformMatrix2fv(uniform.loc, false, value); break;
            case GL.FLOAT_MAT3: this.gl.context.uniformMatrix3fv(uniform.loc, false, value); break;
            case GL.FLOAT_MAT4: this.gl.context.uniformMatrix4fv(uniform.loc, false, value); break;
            }
        }
        else if(log)
        {
            console.warn("Unkown uniform: " + uniformName);
        }
    }
}

// THis class generates and caches the shader source text for a given permutation
class ShaderCache
{
    constructor(sources, gl)
    {
        this.sources  = sources; // shader name -> source code
        this.shaders  = new Map(); // name & permutations hashed -> compiled shader
        this.programs = new Map(); // (vertex shader, fragment shader) -> program
        this.gl = gl;

        // resovle / expande sources (TODO: break include cycles)
        for (let [key, src] of this.sources)
        {
            let changed = false;
            for (let [includeName, includeSource] of this.sources)
            {
                //var pattern = RegExp(/#include</ + includeName + />/);
                const pattern = "#include <" + includeName + ">";

                if(src.includes(pattern))
                {
                    // only replace the first occurance
                    src = src.replace(pattern, includeSource);

                    // remove the others
                    while (src.includes(pattern))
                    {
                        src = src.replace(pattern, "");
                    }

                    changed = true;
                }
            }

            if(changed)
            {
                this.sources.set(key, src);
            }
        }
    }

    destroy()
    {
        for (let [, shader] of this.shaders.entries())
        {
            this.gl.context.deleteShader(shader);
            shader = undefined;
        }

        this.shaders.clear();

        for (let [, program] of this.programs)
        {
            program.destroy();
        }

        this.programs.clear();
    }

    // example args: "pbr.vert", ["NORMALS", "TANGENTS"]
    selectShader(shaderIdentifier, permutationDefines)
    {
        // first check shaders for the exact permutation
        // if not present, check sources and compile it
        // if not present, return null object

        const src = this.sources.get(shaderIdentifier);
        if(src === undefined)
        {
            console.log("Shader source for " + shaderIdentifier + " not found");
            return null;
        }

        const isVert = shaderIdentifier.endsWith(".vert");
        let hash = stringHash(shaderIdentifier);

        // console.log(shaderIdentifier);

        let defines = "#version 300 es\n";
        for(let define of permutationDefines)
        {
            // console.log(define);
            hash ^= stringHash(define);
            defines += "#define " + define + "\n";
        }

        let shader = this.shaders.get(hash);

        if(shader === undefined)
        {
            // console.log(defines);
            // compile this variant
            shader = this.gl.compileShader(shaderIdentifier, isVert, defines + src);
            this.shaders.set(hash, shader);
        }

        return hash;
    }

    getShaderProgram(vertexShaderHash, fragmentShaderHash)
    {
        // just use a long string for this (the javascript engine should be fast enough with comparing this)
        const hash = String(vertexShaderHash) + "," + String(fragmentShaderHash);

        let program = this.programs.get(hash);

        if (program) // program already linked
        {
            return program;
        }
        else // link this shader program type!
        {
            let linkedProg = this.gl.linkProgram(this.shaders.get(vertexShaderHash), this.shaders.get(fragmentShaderHash));
            if(linkedProg)
            {
                let program = new gltfShader(linkedProg, hash, this.gl);
                this.programs.set(hash, program);
                return program;
            }
        }

        return undefined;
    }
}

class EnvironmentRenderer
{
    constructor(webgl)
    {
        const gl = webgl.context;

        this.indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([
            1, 2, 0,
            2, 3, 0,
            6, 2, 1,
            1, 5, 6,
            6, 5, 4,
            4, 7, 6,
            6, 3, 2,
            7, 3, 6,
            3, 7, 0,
            7, 4, 0,
            5, 1, 0,
            4, 5, 0
        ]), gl.STATIC_DRAW);

        this.vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1, -1, -1,
            1, -1, -1,
            1,  1, -1,
            -1,  1, -1,
            -1, -1,  1,
            1, -1,  1,
            1,  1,  1,
            -1,  1,  1
        ]), gl.STATIC_DRAW);
    }

    drawEnvironmentMap(webGl, viewProjectionMatrix, state, shaderCache, fragDefines)
    {
        if (state.environment == undefined || state.renderingParameters.renderEnvironmentMap == false)
        {
            return;
        }

        const gl = webGl.context;

        const vertShader = shaderCache.selectShader("cubemap.vert", []);
        const fragShader = shaderCache.selectShader("cubemap.frag", fragDefines);
        const shader = shaderCache.getShaderProgram(vertShader, fragShader);

        gl.useProgram(shader.program);
        webGl.setTexture(shader.getUniformLocation("u_GGXEnvSampler"), state.environment, state.environment.specularEnvMap, 0);
        shader.updateUniform("u_MipCount", state.environment.mipCount);
        shader.updateUniform("u_EnvBlurNormalized", state.renderingParameters.blurEnvironmentMap ? 0.6 : 0.0);

        const envIntensity = state.renderingParameters.iblIntensity * state.environment.iblIntensityScale;
        shader.updateUniform("u_EnvIntensity", envIntensity, true);

        shader.updateUniform("u_ViewProjectionMatrix", viewProjectionMatrix);
        shader.updateUniform("u_Exposure", state.renderingParameters.exposure, false);

        let rotMatrix4 = create$3();
        rotateY(rotMatrix4, rotMatrix4,  state.renderingParameters.environmentRotation / 180.0 * Math.PI);
        let rotMatrix3 = create$4();
        fromMat4(rotMatrix3, rotMatrix4);
        shader.updateUniform("u_EnvRotation", rotMatrix3);

        gl.frontFace(gl.CCW);
        gl.enable(gl.CULL_FACE);
        gl.disable(gl.BLEND);
        gl.disable(gl.DEPTH_TEST);

        const positionAttributeLocation = shader.getAttributeLocation("a_position");
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.vertexAttribPointer(positionAttributeLocation, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(positionAttributeLocation);
        gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

        gl.enable(gl.DEPTH_TEST);
    }
}

var pbrShader = "precision highp float;\n#define GLSLIFY 1\n#include <tonemapping.glsl>\n#include <textures.glsl>\n#include <functions.glsl>\n#include <brdf.glsl>\n#include <punctual.glsl>\n#include <ibl.glsl>\n#include <material_info.glsl>\n#ifdef MATERIAL_IRIDESCENCE\n#include <iridescence.glsl>\n#endif\nout vec4 g_finalColor;void main(){vec4 baseColor=getBaseColor();\n#if ALPHAMODE == ALPHAMODE_OPAQUE\nbaseColor.a=1.0;\n#endif\nvec3 color=vec3(0);vec3 v=normalize(u_Camera-v_Position);NormalInfo normalInfo=getNormalInfo(v);vec3 n=normalInfo.n;vec3 t=normalInfo.t;vec3 b=normalInfo.b;float NdotV=clampedDot(n,v);float TdotV=clampedDot(t,v);float BdotV=clampedDot(b,v);MaterialInfo materialInfo;materialInfo.baseColor=baseColor.rgb;materialInfo.ior=1.5;materialInfo.f0_dielectric=vec3(0.04);materialInfo.specularWeight=1.0;materialInfo.f90=vec3(1.0);materialInfo.f90_dielectric=materialInfo.f90;\n#if DEBUG == DEBUG_METALLIC_ROUGHNESS\n#undef MATERIAL_IRIDESCENCE\n#endif\n#ifdef MATERIAL_IOR\nmaterialInfo=getIorInfo(materialInfo);\n#endif\n#ifdef MATERIAL_SPECULARGLOSSINESS\nmaterialInfo=getSpecularGlossinessInfo(materialInfo);\n#endif\n#ifdef MATERIAL_METALLICROUGHNESS\nmaterialInfo=getMetallicRoughnessInfo(materialInfo);\n#endif\n#ifdef MATERIAL_SHEEN\nmaterialInfo=getSheenInfo(materialInfo);\n#endif\n#ifdef MATERIAL_CLEARCOAT\nmaterialInfo=getClearCoatInfo(materialInfo,normalInfo);\n#endif\n#ifdef MATERIAL_SPECULAR\nmaterialInfo=getSpecularInfo(materialInfo);\n#endif\n#ifdef MATERIAL_TRANSMISSION\nmaterialInfo=getTransmissionInfo(materialInfo);\n#endif\n#ifdef MATERIAL_VOLUME\nmaterialInfo=getVolumeInfo(materialInfo);\n#endif\n#ifdef MATERIAL_IRIDESCENCE\nmaterialInfo=getIridescenceInfo(materialInfo);\n#endif\n#ifdef MATERIAL_DIFFUSE_TRANSMISSION\nmaterialInfo=getDiffuseTransmissionInfo(materialInfo);\n#endif\n#ifdef MATERIAL_ANISOTROPY\nmaterialInfo=getAnisotropyInfo(materialInfo,normalInfo);\n#endif\nmaterialInfo.perceptualRoughness=clamp(materialInfo.perceptualRoughness,0.0,1.0);materialInfo.metallic=clamp(materialInfo.metallic,0.0,1.0);materialInfo.alphaRoughness=materialInfo.perceptualRoughness*materialInfo.perceptualRoughness;vec3 f_specular_dielectric=vec3(0.0);vec3 f_specular_metal=vec3(0.0);vec3 f_diffuse=vec3(0.0);vec3 f_dielectric_brdf_ibl=vec3(0.0);vec3 f_metal_brdf_ibl=vec3(0.0);vec3 f_emissive=vec3(0.0);vec3 clearcoat_brdf=vec3(0.0);vec3 f_sheen=vec3(0.0);vec3 f_specular_transmission=vec3(0.0);vec3 f_diffuse_transmission=vec3(0.0);float clearcoatFactor=0.0;vec3 clearcoatFresnel=vec3(0);float albedoSheenScaling=1.0;float diffuseTransmissionThickness=1.0;\n#ifdef MATERIAL_IRIDESCENCE\nvec3 iridescenceFresnel_dielectric=evalIridescence(1.0,materialInfo.iridescenceIor,NdotV,materialInfo.iridescenceThickness,materialInfo.f0_dielectric);vec3 iridescenceFresnel_metallic=evalIridescence(1.0,materialInfo.iridescenceIor,NdotV,materialInfo.iridescenceThickness,baseColor.rgb);if(materialInfo.iridescenceThickness==0.0){materialInfo.iridescenceFactor=0.0;}\n#endif\n#ifdef MATERIAL_DIFFUSE_TRANSMISSION\n#ifdef MATERIAL_VOLUME\ndiffuseTransmissionThickness=materialInfo.thickness*(length(vec3(u_ModelMatrix[0].xyz))+length(vec3(u_ModelMatrix[1].xyz))+length(vec3(u_ModelMatrix[2].xyz)))/3.0;\n#endif\n#endif\n#ifdef MATERIAL_CLEARCOAT\nclearcoatFactor=materialInfo.clearcoatFactor;clearcoatFresnel=F_Schlick(materialInfo.clearcoatF0,materialInfo.clearcoatF90,clampedDot(materialInfo.clearcoatNormal,v));\n#endif\n#if defined(USE_IBL) || defined(MATERIAL_TRANSMISSION)\nf_diffuse=getDiffuseLight(n)*baseColor.rgb;\n#ifdef MATERIAL_DIFFUSE_TRANSMISSION\nvec3 diffuseTransmissionIBL=getDiffuseLight(-n)*materialInfo.diffuseTransmissionColorFactor;\n#ifdef MATERIAL_VOLUME\ndiffuseTransmissionIBL=applyVolumeAttenuation(diffuseTransmissionIBL,diffuseTransmissionThickness,materialInfo.attenuationColor,materialInfo.attenuationDistance);\n#endif\nf_diffuse=mix(f_diffuse,diffuseTransmissionIBL,materialInfo.diffuseTransmissionFactor);\n#endif\n#if defined(MATERIAL_TRANSMISSION)\nf_specular_transmission=getIBLVolumeRefraction(n,v,materialInfo.perceptualRoughness,baseColor.rgb,materialInfo.f0_dielectric,materialInfo.f90,v_Position,u_ModelMatrix,u_ViewMatrix,u_ProjectionMatrix,materialInfo.ior,materialInfo.thickness,materialInfo.attenuationColor,materialInfo.attenuationDistance,materialInfo.dispersion);f_diffuse=mix(f_diffuse,f_specular_transmission,materialInfo.transmissionFactor);\n#endif\n#ifdef MATERIAL_ANISOTROPY\nf_specular_metal=getIBLRadianceAnisotropy(n,v,materialInfo.perceptualRoughness,materialInfo.anisotropyStrength,materialInfo.anisotropicB);f_specular_dielectric=f_specular_metal;\n#else\nf_specular_metal=getIBLRadianceGGX(n,v,materialInfo.perceptualRoughness);f_specular_dielectric=f_specular_metal;\n#endif\nvec3 f_metal_fresnel_ibl=getIBLGGXFresnel(n,v,materialInfo.perceptualRoughness,baseColor.rgb,1.0);f_metal_brdf_ibl=f_metal_fresnel_ibl*f_specular_metal;vec3 f_dielectric_fresnel_ibl=getIBLGGXFresnel(n,v,materialInfo.perceptualRoughness,materialInfo.f0_dielectric,materialInfo.specularWeight);f_dielectric_brdf_ibl=mix(f_diffuse,f_specular_dielectric,f_dielectric_fresnel_ibl);\n#ifdef MATERIAL_IRIDESCENCE\nf_metal_brdf_ibl=mix(f_metal_brdf_ibl,f_specular_metal*iridescenceFresnel_metallic,materialInfo.iridescenceFactor);f_dielectric_brdf_ibl=mix(f_dielectric_brdf_ibl,rgb_mix(f_diffuse,f_specular_dielectric,iridescenceFresnel_dielectric),materialInfo.iridescenceFactor);\n#endif\n#ifdef MATERIAL_CLEARCOAT\nclearcoat_brdf=getIBLRadianceGGX(materialInfo.clearcoatNormal,v,materialInfo.clearcoatRoughness);\n#endif\n#ifdef MATERIAL_SHEEN\nf_sheen=getIBLRadianceCharlie(n,v,materialInfo.sheenRoughnessFactor,materialInfo.sheenColorFactor);albedoSheenScaling=1.0-max3(materialInfo.sheenColorFactor)*albedoSheenScalingLUT(NdotV,materialInfo.sheenRoughnessFactor);\n#endif\ncolor=mix(f_dielectric_brdf_ibl,f_metal_brdf_ibl,materialInfo.metallic);color=f_sheen+color*albedoSheenScaling;color=mix(color,clearcoat_brdf,clearcoatFactor*clearcoatFresnel);\n#ifdef HAS_OCCLUSION_MAP\nfloat ao=1.0;ao=texture(u_OcclusionSampler,getOcclusionUV()).r;color=color*(1.0+u_OcclusionStrength*(ao-1.0));\n#endif\n#endif\nf_diffuse=vec3(0.0);f_specular_dielectric=vec3(0.0);f_specular_metal=vec3(0.0);vec3 f_dielectric_brdf=vec3(0.0);vec3 f_metal_brdf=vec3(0.0);\n#ifdef USE_PUNCTUAL\nfor(int i=0;i<LIGHT_COUNT;++i){Light light=u_Lights[i];vec3 pointToLight;if(light.type!=LightType_Directional){pointToLight=light.position-v_Position;}else{pointToLight=-light.direction;}vec3 l=normalize(pointToLight);vec3 h=normalize(l+v);float NdotL=clampedDot(n,l);float NdotV=clampedDot(n,v);float NdotH=clampedDot(n,h);float LdotH=clampedDot(l,h);float VdotH=clampedDot(v,h);vec3 dielectric_fresnel=F_Schlick(materialInfo.f0_dielectric*materialInfo.specularWeight,materialInfo.f90_dielectric,abs(VdotH));vec3 metal_fresnel=F_Schlick(baseColor.rgb,vec3(1.0),abs(VdotH));vec3 lightIntensity=getLighIntensity(light,pointToLight);vec3 l_diffuse=lightIntensity*NdotL*BRDF_lambertian(baseColor.rgb);vec3 l_specular_dielectric=vec3(0.0);vec3 l_specular_metal=vec3(0.0);vec3 l_dielectric_brdf=vec3(0.0);vec3 l_metal_brdf=vec3(0.0);vec3 l_clearcoat_brdf=vec3(0.0);vec3 l_sheen=vec3(0.0);float l_albedoSheenScaling=1.0;\n#ifdef MATERIAL_DIFFUSE_TRANSMISSION\nvec3 diffuse_btdf=lightIntensity*clampedDot(-n,l)*BRDF_lambertian(materialInfo.diffuseTransmissionColorFactor);\n#ifdef MATERIAL_VOLUME\ndiffuse_btdf=applyVolumeAttenuation(diffuse_btdf,diffuseTransmissionThickness,materialInfo.attenuationColor,materialInfo.attenuationDistance);\n#endif\nl_diffuse=mix(l_diffuse,diffuse_btdf,materialInfo.diffuseTransmissionFactor);\n#endif\n#ifdef MATERIAL_TRANSMISSION\nvec3 transmissionRay=getVolumeTransmissionRay(n,v,materialInfo.thickness,materialInfo.ior,u_ModelMatrix);pointToLight-=transmissionRay;l=normalize(pointToLight);vec3 transmittedLight=lightIntensity*getPunctualRadianceTransmission(n,v,l,materialInfo.alphaRoughness,materialInfo.f0_dielectric,materialInfo.f90,baseColor.rgb,materialInfo.ior);\n#ifdef MATERIAL_VOLUME\ntransmittedLight=applyVolumeAttenuation(transmittedLight,length(transmissionRay),materialInfo.attenuationColor,materialInfo.attenuationDistance);\n#endif\nl_diffuse=mix(l_diffuse,transmittedLight,materialInfo.transmissionFactor);\n#endif\nvec3 intensity=getLighIntensity(light,pointToLight);\n#ifdef MATERIAL_ANISOTROPY\nl_specular_metal=intensity*NdotL*BRDF_specularGGXAnisotropy(materialInfo.alphaRoughness,materialInfo.anisotropyStrength,n,v,l,h,materialInfo.anisotropicT,materialInfo.anisotropicB);l_specular_dielectric=l_specular_metal;\n#else\nl_specular_metal=intensity*NdotL*BRDF_specularGGX(materialInfo.alphaRoughness,NdotL,NdotV,NdotH);l_specular_dielectric=l_specular_metal;\n#endif\nl_metal_brdf=metal_fresnel*l_specular_metal;l_dielectric_brdf=mix(l_diffuse,l_specular_dielectric,dielectric_fresnel);\n#ifdef MATERIAL_IRIDESCENCE\nl_metal_brdf=mix(l_metal_brdf,l_specular_metal*iridescenceFresnel_metallic,materialInfo.iridescenceFactor);l_dielectric_brdf=mix(l_dielectric_brdf,rgb_mix(l_diffuse,l_specular_dielectric,iridescenceFresnel_dielectric),materialInfo.iridescenceFactor);\n#endif\n#ifdef MATERIAL_CLEARCOAT\nl_clearcoat_brdf=intensity*getPunctualRadianceClearCoat(materialInfo.clearcoatNormal,v,l,h,VdotH,materialInfo.clearcoatF0,materialInfo.clearcoatF90,materialInfo.clearcoatRoughness);\n#endif\n#ifdef MATERIAL_SHEEN\nl_sheen=intensity*getPunctualRadianceSheen(materialInfo.sheenColorFactor,materialInfo.sheenRoughnessFactor,NdotL,NdotV,NdotH);l_albedoSheenScaling=min(1.0-max3(materialInfo.sheenColorFactor)*albedoSheenScalingLUT(NdotV,materialInfo.sheenRoughnessFactor),1.0-max3(materialInfo.sheenColorFactor)*albedoSheenScalingLUT(NdotL,materialInfo.sheenRoughnessFactor));\n#endif\nvec3 l_color=mix(l_dielectric_brdf,l_metal_brdf,materialInfo.metallic);l_color=l_sheen+l_color*l_albedoSheenScaling;l_color=mix(l_color,l_clearcoat_brdf,clearcoatFactor*clearcoatFresnel);color+=l_color;}\n#endif\nf_emissive=u_EmissiveFactor;\n#ifdef MATERIAL_EMISSIVE_STRENGTH\nf_emissive*=u_EmissiveStrength;\n#endif\n#ifdef HAS_EMISSIVE_MAP\nf_emissive*=texture(u_EmissiveSampler,getEmissiveUV()).rgb;\n#endif\n#ifdef MATERIAL_UNLIT\ncolor=baseColor.rgb;\n#elif defined(NOT_TRIANGLE) && !defined(HAS_NORMAL_VEC3)\ncolor=f_emissive+baseColor.rgb;\n#else\ncolor=f_emissive*(1.0-clearcoatFactor*clearcoatFresnel)+color;\n#endif\n#if DEBUG == DEBUG_NONE\n#if ALPHAMODE == ALPHAMODE_MASK\nif(baseColor.a<u_AlphaCutoff){discard;}baseColor.a=1.0;\n#endif\n#ifdef LINEAR_OUTPUT\ng_finalColor=vec4(color.rgb,baseColor.a);\n#else\ng_finalColor=vec4(toneMap(color),baseColor.a);\n#endif\n#else\ng_finalColor=vec4(1.0);{float frequency=0.02;float gray=0.9;vec2 v1=step(0.5,fract(frequency*gl_FragCoord.xy));vec2 v2=step(0.5,vec2(1.0)-fract(frequency*gl_FragCoord.xy));g_finalColor.rgb*=gray+v1.x*v1.y+v2.x*v2.y;}\n#endif\n#if DEBUG == DEBUG_UV_0 && defined(HAS_TEXCOORD_0_VEC2)\ng_finalColor.rgb=vec3(v_texcoord_0,0);\n#endif\n#if DEBUG == DEBUG_UV_1 && defined(HAS_TEXCOORD_1_VEC2)\ng_finalColor.rgb=vec3(v_texcoord_1,0);\n#endif\n#if DEBUG == DEBUG_NORMAL_TEXTURE && defined(HAS_NORMAL_MAP)\ng_finalColor.rgb=(normalInfo.ntex+1.0)/2.0;\n#endif\n#if DEBUG == DEBUG_NORMAL_SHADING\ng_finalColor.rgb=(n+1.0)/2.0;\n#endif\n#if DEBUG == DEBUG_NORMAL_GEOMETRY\ng_finalColor.rgb=(normalInfo.ng+1.0)/2.0;\n#endif\n#if DEBUG == DEBUG_TANGENT\ng_finalColor.rgb=(normalInfo.t+1.0)/2.0;\n#endif\n#if DEBUG == DEBUG_BITANGENT\ng_finalColor.rgb=(normalInfo.b+1.0)/2.0;\n#endif\n#if DEBUG == DEBUG_ALPHA\ng_finalColor.rgb=vec3(baseColor.a);\n#endif\n#if DEBUG == DEBUG_OCCLUSION && defined(HAS_OCCLUSION_MAP)\ng_finalColor.rgb=vec3(ao);\n#endif\n#if DEBUG == DEBUG_EMISSIVE\ng_finalColor.rgb=linearTosRGB(f_emissive);\n#endif\n#ifdef MATERIAL_METALLICROUGHNESS\n#if DEBUG == DEBUG_METALLIC\ng_finalColor.rgb=vec3(materialInfo.metallic);\n#endif\n#if DEBUG == DEBUG_ROUGHNESS\ng_finalColor.rgb=vec3(materialInfo.perceptualRoughness);\n#endif\n#if DEBUG == DEBUG_BASE_COLOR\ng_finalColor.rgb=linearTosRGB(materialInfo.baseColor);\n#endif\n#endif\n#ifdef MATERIAL_CLEARCOAT\n#if DEBUG == DEBUG_CLEARCOAT_FACTOR\ng_finalColor.rgb=vec3(materialInfo.clearcoatFactor);\n#endif\n#if DEBUG == DEBUG_CLEARCOAT_ROUGHNESS\ng_finalColor.rgb=vec3(materialInfo.clearcoatRoughness);\n#endif\n#if DEBUG == DEBUG_CLEARCOAT_NORMAL\ng_finalColor.rgb=(materialInfo.clearcoatNormal+vec3(1))/2.0;\n#endif\n#endif\n#ifdef MATERIAL_SHEEN\n#if DEBUG == DEBUG_SHEEN_COLOR\ng_finalColor.rgb=materialInfo.sheenColorFactor;\n#endif\n#if DEBUG == DEBUG_SHEEN_ROUGHNESS\ng_finalColor.rgb=vec3(materialInfo.sheenRoughnessFactor);\n#endif\n#endif\n#ifdef MATERIAL_SPECULAR\n#if DEBUG == DEBUG_SPECULAR_FACTOR\ng_finalColor.rgb=vec3(materialInfo.specularWeight);\n#endif\n#if DEBUG == DEBUG_SPECULAR_COLOR\nvec3 specularTexture=vec3(1.0);\n#ifdef HAS_SPECULAR_COLOR_MAP\nspecularTexture.rgb=texture(u_SpecularColorSampler,getSpecularColorUV()).rgb;\n#endif\ng_finalColor.rgb=u_KHR_materials_specular_specularColorFactor*specularTexture.rgb;\n#endif\n#endif\n#ifdef MATERIAL_TRANSMISSION\n#if DEBUG == DEBUG_TRANSMISSION_FACTOR\ng_finalColor.rgb=vec3(materialInfo.transmissionFactor);\n#endif\n#endif\n#ifdef MATERIAL_VOLUME\n#if DEBUG == DEBUG_VOLUME_THICKNESS\ng_finalColor.rgb=vec3(materialInfo.thickness/u_ThicknessFactor);\n#endif\n#endif\n#ifdef MATERIAL_IRIDESCENCE\n#if DEBUG == DEBUG_IRIDESCENCE_FACTOR\ng_finalColor.rgb=vec3(materialInfo.iridescenceFactor);\n#endif\n#if DEBUG == DEBUG_IRIDESCENCE_THICKNESS\ng_finalColor.rgb=vec3(materialInfo.iridescenceThickness/1200.0);\n#endif\n#endif\n#ifdef MATERIAL_ANISOTROPY\n#if DEBUG == DEBUG_ANISOTROPIC_STRENGTH\ng_finalColor.rgb=vec3(materialInfo.anisotropyStrength);\n#endif\n#if DEBUG == DEBUG_ANISOTROPIC_DIRECTION\nvec2 direction=vec2(1.0,0.0);\n#ifdef HAS_ANISOTROPY_MAP\ndirection=texture(u_AnisotropySampler,getAnisotropyUV()).xy;direction=direction*2.0-vec2(1.0);\n#endif\nvec2 directionRotation=u_Anisotropy.xy;mat2 rotationMatrix=mat2(directionRotation.x,directionRotation.y,-directionRotation.y,directionRotation.x);direction=(direction+vec2(1.0))*0.5;g_finalColor.rgb=vec3(direction,0.0);\n#endif\n#endif\n#ifdef MATERIAL_DIFFUSE_TRANSMISSION\n#if DEBUG == DEBUG_DIFFUSE_TRANSMISSION_FACTOR\ng_finalColor.rgb=linearTosRGB(vec3(materialInfo.diffuseTransmissionFactor));\n#endif\n#if DEBUG == DEBUG_DIFFUSE_TRANSMISSION_COLOR_FACTOR\ng_finalColor.rgb=linearTosRGB(materialInfo.diffuseTransmissionColorFactor);\n#endif\n#endif\n}"; // eslint-disable-line

var brdfShader = "#define GLSLIFY 1\nvec3 F_Schlick(vec3 f0,vec3 f90,float VdotH){return f0+(f90-f0)*pow(clamp(1.0-VdotH,0.0,1.0),5.0);}float F_Schlick(float f0,float f90,float VdotH){float x=clamp(1.0-VdotH,0.0,1.0);float x2=x*x;float x5=x*x2*x2;return f0+(f90-f0)*x5;}float F_Schlick(float f0,float VdotH){float f90=1.0;return F_Schlick(f0,f90,VdotH);}vec3 F_Schlick(vec3 f0,float f90,float VdotH){float x=clamp(1.0-VdotH,0.0,1.0);float x2=x*x;float x5=x*x2*x2;return f0+(f90-f0)*x5;}vec3 F_Schlick(vec3 f0,float VdotH){float f90=1.0;return F_Schlick(f0,f90,VdotH);}vec3 Schlick_to_F0(vec3 f,vec3 f90,float VdotH){float x=clamp(1.0-VdotH,0.0,1.0);float x2=x*x;float x5=clamp(x*x2*x2,0.0,0.9999);return(f-f90*x5)/(1.0-x5);}float Schlick_to_F0(float f,float f90,float VdotH){float x=clamp(1.0-VdotH,0.0,1.0);float x2=x*x;float x5=clamp(x*x2*x2,0.0,0.9999);return(f-f90*x5)/(1.0-x5);}vec3 Schlick_to_F0(vec3 f,float VdotH){return Schlick_to_F0(f,vec3(1.0),VdotH);}float Schlick_to_F0(float f,float VdotH){return Schlick_to_F0(f,1.0,VdotH);}float V_GGX(float NdotL,float NdotV,float alphaRoughness){float alphaRoughnessSq=alphaRoughness*alphaRoughness;float GGXV=NdotL*sqrt(NdotV*NdotV*(1.0-alphaRoughnessSq)+alphaRoughnessSq);float GGXL=NdotV*sqrt(NdotL*NdotL*(1.0-alphaRoughnessSq)+alphaRoughnessSq);float GGX=GGXV+GGXL;if(GGX>0.0){return 0.5/GGX;}return 0.0;}float D_GGX(float NdotH,float alphaRoughness){float alphaRoughnessSq=alphaRoughness*alphaRoughness;float f=(NdotH*NdotH)*(alphaRoughnessSq-1.0)+1.0;return alphaRoughnessSq/(M_PI*f*f);}float lambdaSheenNumericHelper(float x,float alphaG){float oneMinusAlphaSq=(1.0-alphaG)*(1.0-alphaG);float a=mix(21.5473,25.3245,oneMinusAlphaSq);float b=mix(3.82987,3.32435,oneMinusAlphaSq);float c=mix(0.19823,0.16801,oneMinusAlphaSq);float d=mix(-1.97760,-1.27393,oneMinusAlphaSq);float e=mix(-4.32054,-4.85967,oneMinusAlphaSq);return a/(1.0+b*pow(x,c))+d*x+e;}float lambdaSheen(float cosTheta,float alphaG){if(abs(cosTheta)<0.5){return exp(lambdaSheenNumericHelper(cosTheta,alphaG));}else{return exp(2.0*lambdaSheenNumericHelper(0.5,alphaG)-lambdaSheenNumericHelper(1.0-cosTheta,alphaG));}}float V_Sheen(float NdotL,float NdotV,float sheenRoughness){sheenRoughness=max(sheenRoughness,0.000001);float alphaG=sheenRoughness*sheenRoughness;return clamp(1.0/((1.0+lambdaSheen(NdotV,alphaG)+lambdaSheen(NdotL,alphaG))*(4.0*NdotV*NdotL)),0.0,1.0);}float D_Charlie(float sheenRoughness,float NdotH){sheenRoughness=max(sheenRoughness,0.000001);float alphaG=sheenRoughness*sheenRoughness;float invR=1.0/alphaG;float cos2h=NdotH*NdotH;float sin2h=1.0-cos2h;return(2.0+invR)*pow(sin2h,invR*0.5)/(2.0*M_PI);}vec3 BRDF_lambertian(vec3 diffuseColor){return(diffuseColor/M_PI);}vec3 BRDF_specularGGX(float alphaRoughness,float NdotL,float NdotV,float NdotH){float Vis=V_GGX(NdotL,NdotV,alphaRoughness);float D=D_GGX(NdotH,alphaRoughness);return vec3(Vis*D);}\n#ifdef MATERIAL_ANISOTROPY\nfloat D_GGX_anisotropic(float NdotH,float TdotH,float BdotH,float anisotropy,float at,float ab){float a2=at*ab;vec3 f=vec3(ab*TdotH,at*BdotH,a2*NdotH);float w2=a2/dot(f,f);return a2*w2*w2/M_PI;}float V_GGX_anisotropic(float NdotL,float NdotV,float BdotV,float TdotV,float TdotL,float BdotL,float at,float ab){float GGXV=NdotL*length(vec3(at*TdotV,ab*BdotV,NdotV));float GGXL=NdotV*length(vec3(at*TdotL,ab*BdotL,NdotL));float v=0.5/(GGXV+GGXL);return clamp(v,0.0,1.0);}vec3 BRDF_specularGGXAnisotropy(float alphaRoughness,float anisotropy,vec3 n,vec3 v,vec3 l,vec3 h,vec3 t,vec3 b){float at=mix(alphaRoughness,1.0,anisotropy*anisotropy);float ab=clamp(alphaRoughness,0.001,1.0);float NdotL=clamp(dot(n,l),0.0,1.0);float NdotH=clamp(dot(n,h),0.001,1.0);float NdotV=dot(n,v);float V=V_GGX_anisotropic(NdotL,NdotV,dot(b,v),dot(t,v),dot(t,l),dot(b,l),at,ab);float D=D_GGX_anisotropic(NdotH,dot(t,h),dot(b,h),anisotropy,at,ab);return vec3(V*D);}\n#endif\nvec3 BRDF_specularSheen(vec3 sheenColor,float sheenRoughness,float NdotL,float NdotV,float NdotH){float sheenDistribution=D_Charlie(sheenRoughness,NdotH);float sheenVisibility=V_Sheen(NdotL,NdotV,sheenRoughness);return sheenColor*sheenDistribution*sheenVisibility;}"; // eslint-disable-line

var iridescenceShader = "#define GLSLIFY 1\nconst mat3 XYZ_TO_REC709=mat3(3.2404542,-0.9692660,0.0556434,-1.5371385,1.8760108,-0.2040259,-0.4985314,0.0415560,1.0572252);vec3 Fresnel0ToIor(vec3 fresnel0){vec3 sqrtF0=sqrt(fresnel0);return(vec3(1.0)+sqrtF0)/(vec3(1.0)-sqrtF0);}vec3 IorToFresnel0(vec3 transmittedIor,float incidentIor){return sq((transmittedIor-vec3(incidentIor))/(transmittedIor+vec3(incidentIor)));}float IorToFresnel0(float transmittedIor,float incidentIor){return sq((transmittedIor-incidentIor)/(transmittedIor+incidentIor));}vec3 evalSensitivity(float OPD,vec3 shift){float phase=2.0*M_PI*OPD*1.0e-9;vec3 val=vec3(5.4856e-13,4.4201e-13,5.2481e-13);vec3 pos=vec3(1.6810e+06,1.7953e+06,2.2084e+06);vec3 var=vec3(4.3278e+09,9.3046e+09,6.6121e+09);vec3 xyz=val*sqrt(2.0*M_PI*var)*cos(pos*phase+shift)*exp(-sq(phase)*var);xyz.x+=9.7470e-14*sqrt(2.0*M_PI*4.5282e+09)*cos(2.2399e+06*phase+shift[0])*exp(-4.5282e+09*sq(phase));xyz/=1.0685e-7;vec3 srgb=XYZ_TO_REC709*xyz;return srgb;}vec3 evalIridescence(float outsideIOR,float eta2,float cosTheta1,float thinFilmThickness,vec3 baseF0){vec3 I;float iridescenceIor=mix(outsideIOR,eta2,smoothstep(0.0,0.03,thinFilmThickness));float sinTheta2Sq=sq(outsideIOR/iridescenceIor)*(1.0-sq(cosTheta1));float cosTheta2Sq=1.0-sinTheta2Sq;if(cosTheta2Sq<0.0){return vec3(1.0);}float cosTheta2=sqrt(cosTheta2Sq);float R0=IorToFresnel0(iridescenceIor,outsideIOR);float R12=F_Schlick(R0,cosTheta1);float R21=R12;float T121=1.0-R12;float phi12=0.0;if(iridescenceIor<outsideIOR)phi12=M_PI;float phi21=M_PI-phi12;vec3 baseIOR=Fresnel0ToIor(clamp(baseF0,0.0,0.9999));vec3 R1=IorToFresnel0(baseIOR,iridescenceIor);vec3 R23=F_Schlick(R1,cosTheta2);vec3 phi23=vec3(0.0);if(baseIOR[0]<iridescenceIor)phi23[0]=M_PI;if(baseIOR[1]<iridescenceIor)phi23[1]=M_PI;if(baseIOR[2]<iridescenceIor)phi23[2]=M_PI;float OPD=2.0*iridescenceIor*thinFilmThickness*cosTheta2;vec3 phi=vec3(phi21)+phi23;vec3 R123=clamp(R12*R23,1e-5,0.9999);vec3 r123=sqrt(R123);vec3 Rs=sq(T121)*R23/(vec3(1.0)-R123);vec3 C0=R12+Rs;I=C0;vec3 Cm=Rs-T121;for(int m=1;m<=2;++m){Cm*=r123;vec3 Sm=2.0*evalSensitivity(float(m)*OPD,float(m)*phi);I+=Cm*Sm;}return max(I,vec3(0.0));}"; // eslint-disable-line

var materialInfoShader = "#define GLSLIFY 1\nuniform float u_MetallicFactor;uniform float u_RoughnessFactor;uniform vec4 u_BaseColorFactor;uniform vec3 u_SpecularFactor;uniform vec4 u_DiffuseFactor;uniform float u_GlossinessFactor;uniform float u_SheenRoughnessFactor;uniform vec3 u_SheenColorFactor;uniform float u_ClearcoatFactor;uniform float u_ClearcoatRoughnessFactor;uniform vec3 u_KHR_materials_specular_specularColorFactor;uniform float u_KHR_materials_specular_specularFactor;uniform float u_TransmissionFactor;uniform float u_ThicknessFactor;uniform vec3 u_AttenuationColor;uniform float u_AttenuationDistance;uniform float u_IridescenceFactor;uniform float u_IridescenceIor;uniform float u_IridescenceThicknessMinimum;uniform float u_IridescenceThicknessMaximum;uniform float u_DiffuseTransmissionFactor;uniform vec3 u_DiffuseTransmissionColorFactor;uniform float u_EmissiveStrength;uniform float u_Ior;uniform vec3 u_Anisotropy;uniform float u_Dispersion;uniform float u_AlphaCutoff;uniform vec3 u_Camera;\n#ifdef MATERIAL_TRANSMISSION\nuniform ivec2 u_ScreenSize;\n#endif\nuniform mat4 u_ModelMatrix;uniform mat4 u_ViewMatrix;uniform mat4 u_ProjectionMatrix;struct MaterialInfo{float ior;float perceptualRoughness;vec3 f0_dielectric;float alphaRoughness;float fresnel_w;vec3 f90;vec3 f90_dielectric;float metallic;vec3 baseColor;float sheenRoughnessFactor;vec3 sheenColorFactor;vec3 clearcoatF0;vec3 clearcoatF90;float clearcoatFactor;vec3 clearcoatNormal;float clearcoatRoughness;float specularWeight;float transmissionFactor;float thickness;vec3 attenuationColor;float attenuationDistance;float iridescenceFactor;float iridescenceIor;float iridescenceThickness;float diffuseTransmissionFactor;vec3 diffuseTransmissionColorFactor;vec3 anisotropicT;vec3 anisotropicB;float anisotropyStrength;float dispersion;};NormalInfo getNormalInfo(vec3 v){vec2 UV=getNormalUV();vec2 uv_dx=dFdx(UV);vec2 uv_dy=dFdy(UV);if(length(uv_dx)<=1e-2){uv_dx=vec2(1.0,0.0);}if(length(uv_dy)<=1e-2){uv_dy=vec2(0.0,1.0);}vec3 t_=(uv_dy.t*dFdx(v_Position)-uv_dx.t*dFdy(v_Position))/(uv_dx.s*uv_dy.t-uv_dy.s*uv_dx.t);vec3 n,t,b,ng;\n#ifdef HAS_NORMAL_VEC3\n#ifdef HAS_TANGENT_VEC4\nt=normalize(v_TBN[0]);b=normalize(v_TBN[1]);ng=normalize(v_TBN[2]);\n#else\nng=normalize(v_Normal);t=normalize(t_-ng*dot(ng,t_));b=cross(ng,t);\n#endif\n#else\nng=normalize(cross(dFdx(v_Position),dFdy(v_Position)));t=normalize(t_-ng*dot(ng,t_));b=cross(ng,t);\n#endif\n#ifndef NOT_TRIANGLE\nif(gl_FrontFacing==false){t*=-1.0;b*=-1.0;ng*=-1.0;}\n#endif\nNormalInfo info;info.ng=ng;\n#ifdef HAS_NORMAL_MAP\ninfo.ntex=texture(u_NormalSampler,UV).rgb*2.0-vec3(1.0);info.ntex*=vec3(u_NormalScale,u_NormalScale,1.0);info.ntex=normalize(info.ntex);info.n=normalize(mat3(t,b,ng)*info.ntex);\n#else\ninfo.n=ng;\n#endif\ninfo.t=t;info.b=b;return info;}\n#ifdef MATERIAL_CLEARCOAT\nvec3 getClearcoatNormal(NormalInfo normalInfo){\n#ifdef HAS_CLEARCOAT_NORMAL_MAP\nvec3 n=texture(u_ClearcoatNormalSampler,getClearcoatNormalUV()).rgb*2.0-vec3(1.0);n*=vec3(u_ClearcoatNormalScale,u_ClearcoatNormalScale,1.0);n=mat3(normalInfo.t,normalInfo.b,normalInfo.ng)*normalize(n);return n;\n#else\nreturn normalInfo.ng;\n#endif\n}\n#endif\nvec4 getBaseColor(){vec4 baseColor=vec4(1);\n#if defined(MATERIAL_SPECULARGLOSSINESS)\nbaseColor=u_DiffuseFactor;\n#elif defined(MATERIAL_METALLICROUGHNESS)\nbaseColor=u_BaseColorFactor;\n#endif\n#if defined(MATERIAL_SPECULARGLOSSINESS) && defined(HAS_DIFFUSE_MAP)\nbaseColor*=texture(u_DiffuseSampler,getDiffuseUV());\n#elif defined(MATERIAL_METALLICROUGHNESS) && defined(HAS_BASE_COLOR_MAP)\nbaseColor*=texture(u_BaseColorSampler,getBaseColorUV());\n#endif\nreturn baseColor*getVertexColor();}\n#ifdef MATERIAL_SPECULARGLOSSINESS\nMaterialInfo getSpecularGlossinessInfo(MaterialInfo info){info.f0_dielectric=u_SpecularFactor;info.perceptualRoughness=u_GlossinessFactor;\n#ifdef HAS_SPECULAR_GLOSSINESS_MAP\nvec4 sgSample=texture(u_SpecularGlossinessSampler,getSpecularGlossinessUV());info.perceptualRoughness*=sgSample.a;info.f0_dielectric*=sgSample.rgb;\n#endif\ninfo.perceptualRoughness=1.0-info.perceptualRoughness;return info;}\n#endif\n#ifdef MATERIAL_METALLICROUGHNESS\nMaterialInfo getMetallicRoughnessInfo(MaterialInfo info){info.metallic=u_MetallicFactor;info.perceptualRoughness=u_RoughnessFactor;\n#ifdef HAS_METALLIC_ROUGHNESS_MAP\nvec4 mrSample=texture(u_MetallicRoughnessSampler,getMetallicRoughnessUV());info.perceptualRoughness*=mrSample.g;info.metallic*=mrSample.b;\n#endif\nreturn info;}\n#endif\n#ifdef MATERIAL_SHEEN\nMaterialInfo getSheenInfo(MaterialInfo info){info.sheenColorFactor=u_SheenColorFactor;info.sheenRoughnessFactor=u_SheenRoughnessFactor;\n#ifdef HAS_SHEEN_COLOR_MAP\nvec4 sheenColorSample=texture(u_SheenColorSampler,getSheenColorUV());info.sheenColorFactor*=sheenColorSample.rgb;\n#endif\n#ifdef HAS_SHEEN_ROUGHNESS_MAP\nvec4 sheenRoughnessSample=texture(u_SheenRoughnessSampler,getSheenRoughnessUV());info.sheenRoughnessFactor*=sheenRoughnessSample.a;\n#endif\nreturn info;}\n#endif\n#ifdef MATERIAL_SPECULAR\nMaterialInfo getSpecularInfo(MaterialInfo info){vec4 specularTexture=vec4(1.0);\n#ifdef HAS_SPECULAR_MAP\nspecularTexture.a=texture(u_SpecularSampler,getSpecularUV()).a;\n#endif\n#ifdef HAS_SPECULAR_COLOR_MAP\nspecularTexture.rgb=texture(u_SpecularColorSampler,getSpecularColorUV()).rgb;\n#endif\ninfo.f0_dielectric=min(info.f0_dielectric*u_KHR_materials_specular_specularColorFactor*specularTexture.rgb,vec3(1.0));info.specularWeight=u_KHR_materials_specular_specularFactor*specularTexture.a;info.f90_dielectric=vec3(info.specularWeight);return info;}\n#endif\n#ifdef MATERIAL_TRANSMISSION\nMaterialInfo getTransmissionInfo(MaterialInfo info){info.transmissionFactor=u_TransmissionFactor;\n#ifdef HAS_TRANSMISSION_MAP\nvec4 transmissionSample=texture(u_TransmissionSampler,getTransmissionUV());info.transmissionFactor*=transmissionSample.r;\n#endif\n#ifdef MATERIAL_DISPERSION\ninfo.dispersion=u_Dispersion;\n#else\ninfo.dispersion=0.0;\n#endif\nreturn info;}\n#endif\n#ifdef MATERIAL_VOLUME\nMaterialInfo getVolumeInfo(MaterialInfo info){info.thickness=u_ThicknessFactor;info.attenuationColor=u_AttenuationColor;info.attenuationDistance=u_AttenuationDistance;\n#ifdef HAS_THICKNESS_MAP\nvec4 thicknessSample=texture(u_ThicknessSampler,getThicknessUV());info.thickness*=thicknessSample.g;\n#endif\nreturn info;}\n#endif\n#ifdef MATERIAL_IRIDESCENCE\nMaterialInfo getIridescenceInfo(MaterialInfo info){info.iridescenceFactor=u_IridescenceFactor;info.iridescenceIor=u_IridescenceIor;info.iridescenceThickness=u_IridescenceThicknessMaximum;\n#ifdef HAS_IRIDESCENCE_MAP\ninfo.iridescenceFactor*=texture(u_IridescenceSampler,getIridescenceUV()).r;\n#endif\n#ifdef HAS_IRIDESCENCE_THICKNESS_MAP\nfloat thicknessSampled=texture(u_IridescenceThicknessSampler,getIridescenceThicknessUV()).g;float thickness=mix(u_IridescenceThicknessMinimum,u_IridescenceThicknessMaximum,thicknessSampled);info.iridescenceThickness=thickness;\n#endif\nreturn info;}\n#endif\n#ifdef MATERIAL_DIFFUSE_TRANSMISSION\nMaterialInfo getDiffuseTransmissionInfo(MaterialInfo info){info.diffuseTransmissionFactor=u_DiffuseTransmissionFactor;info.diffuseTransmissionColorFactor=u_DiffuseTransmissionColorFactor;\n#ifdef HAS_DIFFUSE_TRANSMISSION_MAP\ninfo.diffuseTransmissionFactor*=texture(u_DiffuseTransmissionSampler,getDiffuseTransmissionUV()).a;\n#endif\n#ifdef HAS_DIFFUSE_TRANSMISSION_COLOR_MAP\ninfo.diffuseTransmissionColorFactor*=texture(u_DiffuseTransmissionColorSampler,getDiffuseTransmissionColorUV()).rgb;\n#endif\nreturn info;}\n#endif\n#ifdef MATERIAL_CLEARCOAT\nMaterialInfo getClearCoatInfo(MaterialInfo info,NormalInfo normalInfo){info.clearcoatFactor=u_ClearcoatFactor;info.clearcoatRoughness=u_ClearcoatRoughnessFactor;info.clearcoatF0=vec3(pow((info.ior-1.0)/(info.ior+1.0),2.0));info.clearcoatF90=vec3(1.0);\n#ifdef HAS_CLEARCOAT_MAP\nvec4 clearcoatSample=texture(u_ClearcoatSampler,getClearcoatUV());info.clearcoatFactor*=clearcoatSample.r;\n#endif\n#ifdef HAS_CLEARCOAT_ROUGHNESS_MAP\nvec4 clearcoatSampleRoughness=texture(u_ClearcoatRoughnessSampler,getClearcoatRoughnessUV());info.clearcoatRoughness*=clearcoatSampleRoughness.g;\n#endif\ninfo.clearcoatNormal=getClearcoatNormal(normalInfo);info.clearcoatRoughness=clamp(info.clearcoatRoughness,0.0,1.0);return info;}\n#endif\n#ifdef MATERIAL_IOR\nMaterialInfo getIorInfo(MaterialInfo info){info.f0_dielectric=vec3(pow((u_Ior-1.0)/(u_Ior+1.0),2.0));info.ior=u_Ior;return info;}\n#endif\n#ifdef MATERIAL_ANISOTROPY\nMaterialInfo getAnisotropyInfo(MaterialInfo info,NormalInfo normalInfo){vec2 direction=vec2(1.0,0.0);float strengthFactor=1.0;\n#ifdef HAS_ANISOTROPY_MAP\nvec3 anisotropySample=texture(u_AnisotropySampler,getAnisotropyUV()).xyz;direction=anisotropySample.xy*2.0-vec2(1.0);strengthFactor=anisotropySample.z;\n#endif\nvec2 directionRotation=u_Anisotropy.xy;mat2 rotationMatrix=mat2(directionRotation.x,directionRotation.y,-directionRotation.y,directionRotation.x);direction=rotationMatrix*direction.xy;info.anisotropicT=mat3(normalInfo.t,normalInfo.b,normalInfo.n)*normalize(vec3(direction,0.0));info.anisotropicB=cross(normalInfo.ng,info.anisotropicT);info.anisotropyStrength=clamp(u_Anisotropy.z*strengthFactor,0.0,1.0);return info;}\n#endif\nfloat albedoSheenScalingLUT(float NdotV,float sheenRoughnessFactor){return texture(u_SheenELUT,vec2(NdotV,sheenRoughnessFactor)).r;}"; // eslint-disable-line

var iblShader = "#define GLSLIFY 1\nuniform float u_EnvIntensity;vec3 getDiffuseLight(vec3 n){vec4 textureSample=texture(u_LambertianEnvSampler,u_EnvRotation*n);textureSample.rgb*=u_EnvIntensity;return textureSample.rgb;}vec4 getSpecularSample(vec3 reflection,float lod){vec4 textureSample=textureLod(u_GGXEnvSampler,u_EnvRotation*reflection,lod);textureSample.rgb*=u_EnvIntensity;return textureSample;}vec4 getSheenSample(vec3 reflection,float lod){vec4 textureSample=textureLod(u_CharlieEnvSampler,u_EnvRotation*reflection,lod);textureSample.rgb*=u_EnvIntensity;return textureSample;}vec3 getIBLGGXFresnel(vec3 n,vec3 v,float roughness,vec3 F0,float specularWeight){float NdotV=clampedDot(n,v);vec2 brdfSamplePoint=clamp(vec2(NdotV,roughness),vec2(0.0,0.0),vec2(1.0,1.0));vec2 f_ab=texture(u_GGXLUT,brdfSamplePoint).rg;vec3 Fr=max(vec3(1.0-roughness),F0)-F0;vec3 k_S=F0+Fr*pow(1.0-NdotV,5.0);vec3 FssEss=specularWeight*(k_S*f_ab.x+f_ab.y);float Ems=(1.0-(f_ab.x+f_ab.y));vec3 F_avg=specularWeight*(F0+(1.0-F0)/21.0);vec3 FmsEms=Ems*FssEss*F_avg/(1.0-F_avg*Ems);return FssEss+FmsEms;}vec3 getIBLRadianceGGX(vec3 n,vec3 v,float roughness){float NdotV=clampedDot(n,v);float lod=roughness*float(u_MipCount-1);vec3 reflection=normalize(reflect(-v,n));vec4 specularSample=getSpecularSample(reflection,lod);vec3 specularLight=specularSample.rgb;return specularLight;}\n#ifdef MATERIAL_TRANSMISSION\nvec3 getTransmissionSample(vec2 fragCoord,float roughness,float ior){float framebufferLod=log2(float(u_TransmissionFramebufferSize.x))*applyIorToRoughness(roughness,ior);vec3 transmittedLight=textureLod(u_TransmissionFramebufferSampler,fragCoord.xy,framebufferLod).rgb;return transmittedLight;}\n#endif\n#ifdef MATERIAL_TRANSMISSION\nvec3 getIBLVolumeRefraction(vec3 n,vec3 v,float perceptualRoughness,vec3 baseColor,vec3 f0,vec3 f90,vec3 position,mat4 modelMatrix,mat4 viewMatrix,mat4 projMatrix,float ior,float thickness,vec3 attenuationColor,float attenuationDistance,float dispersion){\n#ifdef MATERIAL_DISPERSION\nfloat halfSpread=(ior-1.0)*0.025*dispersion;vec3 iors=vec3(ior-halfSpread,ior,ior+halfSpread);vec3 transmittedLight;float transmissionRayLength;for(int i=0;i<3;i++){vec3 transmissionRay=getVolumeTransmissionRay(n,v,thickness,iors[i],modelMatrix);transmissionRayLength=length(transmissionRay);vec3 refractedRayExit=position+transmissionRay;vec4 ndcPos=projMatrix*viewMatrix*vec4(refractedRayExit,1.0);vec2 refractionCoords=ndcPos.xy/ndcPos.w;refractionCoords+=1.0;refractionCoords/=2.0;transmittedLight[i]=getTransmissionSample(refractionCoords,perceptualRoughness,iors[i])[i];}\n#else\nvec3 transmissionRay=getVolumeTransmissionRay(n,v,thickness,ior,modelMatrix);float transmissionRayLength=length(transmissionRay);vec3 refractedRayExit=position+transmissionRay;vec4 ndcPos=projMatrix*viewMatrix*vec4(refractedRayExit,1.0);vec2 refractionCoords=ndcPos.xy/ndcPos.w;refractionCoords+=1.0;refractionCoords/=2.0;vec3 transmittedLight=getTransmissionSample(refractionCoords,perceptualRoughness,ior);\n#endif\nvec3 attenuatedColor=applyVolumeAttenuation(transmittedLight,transmissionRayLength,attenuationColor,attenuationDistance);float NdotV=clampedDot(n,v);vec2 brdfSamplePoint=clamp(vec2(NdotV,perceptualRoughness),vec2(0.0,0.0),vec2(1.0,1.0));vec2 brdf=texture(u_GGXLUT,brdfSamplePoint).rg;vec3 specularColor=f0*brdf.x+f90*brdf.y;return(1.0-specularColor)*attenuatedColor*baseColor;}\n#endif\n#ifdef MATERIAL_ANISOTROPY\nvec3 getIBLRadianceAnisotropy(vec3 n,vec3 v,float roughness,float anisotropy,vec3 anisotropyDirection){float NdotV=clampedDot(n,v);float tangentRoughness=mix(roughness,1.0,anisotropy*anisotropy);vec3 anisotropicTangent=cross(anisotropyDirection,v);vec3 anisotropicNormal=cross(anisotropicTangent,anisotropyDirection);float bendFactor=1.0-anisotropy*(1.0-roughness);float bendFactorPow4=bendFactor*bendFactor*bendFactor*bendFactor;vec3 bentNormal=normalize(mix(anisotropicNormal,n,bendFactorPow4));float lod=roughness*float(u_MipCount-1);vec3 reflection=normalize(reflect(-v,bentNormal));vec4 specularSample=getSpecularSample(reflection,lod);vec3 specularLight=specularSample.rgb;return specularLight;}\n#endif\nvec3 getIBLRadianceCharlie(vec3 n,vec3 v,float sheenRoughness,vec3 sheenColor){float NdotV=clampedDot(n,v);float lod=sheenRoughness*float(u_MipCount-1);vec3 reflection=normalize(reflect(-v,n));vec2 brdfSamplePoint=clamp(vec2(NdotV,sheenRoughness),vec2(0.0,0.0),vec2(1.0,1.0));float brdf=texture(u_CharlieLUT,brdfSamplePoint).b;vec4 sheenSample=getSheenSample(reflection,lod);vec3 sheenLight=sheenSample.rgb;return sheenLight*sheenColor*brdf;}"; // eslint-disable-line

var punctualShader = "#define GLSLIFY 1\nstruct Light{vec3 direction;float range;vec3 color;float intensity;vec3 position;float innerConeCos;float outerConeCos;int type;};const int LightType_Directional=0;const int LightType_Point=1;const int LightType_Spot=2;\n#ifdef USE_PUNCTUAL\nuniform Light u_Lights[LIGHT_COUNT+1];\n#endif\nfloat getRangeAttenuation(float range,float distance){if(range<=0.0){return 1.0/pow(distance,2.0);}return max(min(1.0-pow(distance/range,4.0),1.0),0.0)/pow(distance,2.0);}float getSpotAttenuation(vec3 pointToLight,vec3 spotDirection,float outerConeCos,float innerConeCos){float actualCos=dot(normalize(spotDirection),normalize(-pointToLight));if(actualCos>outerConeCos){if(actualCos<innerConeCos){float angularAttenuation=(actualCos-outerConeCos)/(innerConeCos-outerConeCos);return angularAttenuation*angularAttenuation;}return 1.0;}return 0.0;}vec3 getLighIntensity(Light light,vec3 pointToLight){float rangeAttenuation=1.0;float spotAttenuation=1.0;if(light.type!=LightType_Directional){rangeAttenuation=getRangeAttenuation(light.range,length(pointToLight));}if(light.type==LightType_Spot){spotAttenuation=getSpotAttenuation(pointToLight,light.direction,light.outerConeCos,light.innerConeCos);}return rangeAttenuation*spotAttenuation*light.intensity*light.color;}vec3 getPunctualRadianceTransmission(vec3 normal,vec3 view,vec3 pointToLight,float alphaRoughness,vec3 f0,vec3 f90,vec3 baseColor,float ior){float transmissionRougness=applyIorToRoughness(alphaRoughness,ior);vec3 n=normalize(normal);vec3 v=normalize(view);vec3 l=normalize(pointToLight);vec3 l_mirror=normalize(l+2.0*n*dot(-l,n));vec3 h=normalize(l_mirror+v);float D=D_GGX(clamp(dot(n,h),0.0,1.0),transmissionRougness);vec3 F=F_Schlick(f0,f90,clamp(dot(v,h),0.0,1.0));float Vis=V_GGX(clamp(dot(n,l_mirror),0.0,1.0),clamp(dot(n,v),0.0,1.0),transmissionRougness);return(1.0-F)*baseColor*D*Vis;}vec3 getPunctualRadianceClearCoat(vec3 clearcoatNormal,vec3 v,vec3 l,vec3 h,float VdotH,vec3 f0,vec3 f90,float clearcoatRoughness){float NdotL=clampedDot(clearcoatNormal,l);float NdotV=clampedDot(clearcoatNormal,v);float NdotH=clampedDot(clearcoatNormal,h);return NdotL*BRDF_specularGGX(clearcoatRoughness*clearcoatRoughness,NdotL,NdotV,NdotH);}vec3 getPunctualRadianceSheen(vec3 sheenColor,float sheenRoughness,float NdotL,float NdotV,float NdotH){return NdotL*BRDF_specularSheen(sheenColor,sheenRoughness,NdotL,NdotV,NdotH);}vec3 applyVolumeAttenuation(vec3 radiance,float transmissionDistance,vec3 attenuationColor,float attenuationDistance){if(attenuationDistance==0.0){return radiance;}else{vec3 transmittance=pow(attenuationColor,vec3(transmissionDistance/attenuationDistance));return transmittance*radiance;}}vec3 getVolumeTransmissionRay(vec3 n,vec3 v,float thickness,float ior,mat4 modelMatrix){vec3 refractionVector=refract(-v,normalize(n),1.0/ior);vec3 modelScale;modelScale.x=length(vec3(modelMatrix[0].xyz));modelScale.y=length(vec3(modelMatrix[1].xyz));modelScale.z=length(vec3(modelMatrix[2].xyz));return normalize(refractionVector)*thickness*modelScale;}"; // eslint-disable-line

var primitiveShader = "#define GLSLIFY 1\n#include <animation.glsl>\nuniform mat4 u_ViewProjectionMatrix;uniform mat4 u_ModelMatrix;uniform mat4 u_NormalMatrix;in vec3 a_position;out vec3 v_Position;\n#ifdef HAS_NORMAL_VEC3\nin vec3 a_normal;\n#endif\n#ifdef HAS_NORMAL_VEC3\n#ifdef HAS_TANGENT_VEC4\nin vec4 a_tangent;out mat3 v_TBN;\n#else\nout vec3 v_Normal;\n#endif\n#endif\n#ifdef HAS_TEXCOORD_0_VEC2\nin vec2 a_texcoord_0;\n#endif\n#ifdef HAS_TEXCOORD_1_VEC2\nin vec2 a_texcoord_1;\n#endif\nout vec2 v_texcoord_0;out vec2 v_texcoord_1;\n#ifdef HAS_COLOR_0_VEC3\nin vec3 a_color_0;out vec3 v_Color;\n#endif\n#ifdef HAS_COLOR_0_VEC4\nin vec4 a_color_0;out vec4 v_Color;\n#endif\n#ifdef USE_INSTANCING\nin mat4 a_instance_model_matrix;\n#endif\n#ifdef HAS_VERT_NORMAL_UV_TRANSFORM\nuniform mat3 u_vertNormalUVTransform;\n#endif\nvec4 getPosition(){vec4 pos=vec4(a_position,1.0);\n#ifdef USE_MORPHING\npos+=getTargetPosition(gl_VertexID);\n#endif\n#ifdef USE_SKINNING\npos=getSkinningMatrix()*pos;\n#endif\nreturn pos;}\n#ifdef HAS_NORMAL_VEC3\nvec3 getNormal(){vec3 normal=a_normal;\n#ifdef USE_MORPHING\nnormal+=getTargetNormal(gl_VertexID);\n#endif\n#ifdef USE_SKINNING\nnormal=mat3(getSkinningNormalMatrix())*normal;\n#endif\nreturn normalize(normal);}\n#endif\n#ifdef HAS_NORMAL_VEC3\n#ifdef HAS_TANGENT_VEC4\nvec3 getTangent(){vec3 tangent=a_tangent.xyz;\n#ifdef USE_MORPHING\ntangent+=getTargetTangent(gl_VertexID);\n#endif\n#ifdef USE_SKINNING\ntangent=mat3(getSkinningMatrix())*tangent;\n#endif\nreturn normalize(tangent);}\n#endif\n#endif\nvoid main(){gl_PointSize=1.0f;\n#ifdef USE_INSTANCING\nmat4 modelMatrix=a_instance_model_matrix;mat4 normalMatrix=transpose(inverse(modelMatrix));\n#else\nmat4 modelMatrix=u_ModelMatrix;mat4 normalMatrix=u_NormalMatrix;\n#endif\nvec4 pos=modelMatrix*getPosition();v_Position=vec3(pos.xyz)/pos.w;\n#ifdef HAS_NORMAL_VEC3\n#ifdef HAS_TANGENT_VEC4\nvec3 tangent=getTangent();vec3 normalW=normalize(vec3(normalMatrix*vec4(getNormal(),0.0)));vec3 tangentW=vec3(modelMatrix*vec4(tangent,0.0));vec3 bitangentW=cross(normalW,tangentW)*a_tangent.w;\n#ifdef HAS_VERT_NORMAL_UV_TRANSFORM\ntangentW=u_vertNormalUVTransform*tangentW;bitangentW=u_vertNormalUVTransform*bitangentW;\n#endif\nbitangentW=normalize(bitangentW);tangentW=normalize(tangentW);v_TBN=mat3(tangentW,bitangentW,normalW);\n#else\nv_Normal=normalize(vec3(normalMatrix*vec4(getNormal(),0.0)));\n#endif\n#endif\nv_texcoord_0=vec2(0.0,0.0);v_texcoord_1=vec2(0.0,0.0);\n#ifdef HAS_TEXCOORD_0_VEC2\nv_texcoord_0=a_texcoord_0;\n#endif\n#ifdef HAS_TEXCOORD_1_VEC2\nv_texcoord_1=a_texcoord_1;\n#endif\n#ifdef USE_MORPHING\nv_texcoord_0+=getTargetTexCoord0(gl_VertexID);v_texcoord_1+=getTargetTexCoord1(gl_VertexID);\n#endif\n#if defined(HAS_COLOR_0_VEC3)\nv_Color=a_color_0;\n#if defined(USE_MORPHING)\nv_Color=clamp(v_Color+getTargetColor0(gl_VertexID).xyz,0.0f,1.0f);\n#endif\n#endif\n#if defined(HAS_COLOR_0_VEC4)\nv_Color=a_color_0;\n#if defined(USE_MORPHING)\nv_Color=clamp(v_Color+getTargetColor0(gl_VertexID),0.0f,1.0f);\n#endif\n#endif\ngl_Position=u_ViewProjectionMatrix*pos;}"; // eslint-disable-line

var texturesShader = "#define GLSLIFY 1\nuniform int u_MipCount;uniform samplerCube u_LambertianEnvSampler;uniform samplerCube u_GGXEnvSampler;uniform sampler2D u_GGXLUT;uniform samplerCube u_CharlieEnvSampler;uniform sampler2D u_CharlieLUT;uniform sampler2D u_SheenELUT;uniform mat3 u_EnvRotation;uniform sampler2D u_NormalSampler;uniform float u_NormalScale;uniform int u_NormalUVSet;uniform mat3 u_NormalUVTransform;uniform vec3 u_EmissiveFactor;uniform sampler2D u_EmissiveSampler;uniform int u_EmissiveUVSet;uniform mat3 u_EmissiveUVTransform;uniform sampler2D u_OcclusionSampler;uniform int u_OcclusionUVSet;uniform float u_OcclusionStrength;uniform mat3 u_OcclusionUVTransform;in vec2 v_texcoord_0;in vec2 v_texcoord_1;vec2 getNormalUV(){vec3 uv=vec3(u_NormalUVSet<1 ? v_texcoord_0 : v_texcoord_1,1.0);\n#ifdef HAS_NORMAL_UV_TRANSFORM\nuv=u_NormalUVTransform*uv;\n#endif\nreturn uv.xy;}vec2 getEmissiveUV(){vec3 uv=vec3(u_EmissiveUVSet<1 ? v_texcoord_0 : v_texcoord_1,1.0);\n#ifdef HAS_EMISSIVE_UV_TRANSFORM\nuv=u_EmissiveUVTransform*uv;\n#endif\nreturn uv.xy;}vec2 getOcclusionUV(){vec3 uv=vec3(u_OcclusionUVSet<1 ? v_texcoord_0 : v_texcoord_1,1.0);\n#ifdef HAS_OCCLUSION_UV_TRANSFORM\nuv=u_OcclusionUVTransform*uv;\n#endif\nreturn uv.xy;}\n#ifdef MATERIAL_METALLICROUGHNESS\nuniform sampler2D u_BaseColorSampler;uniform int u_BaseColorUVSet;uniform mat3 u_BaseColorUVTransform;uniform sampler2D u_MetallicRoughnessSampler;uniform int u_MetallicRoughnessUVSet;uniform mat3 u_MetallicRoughnessUVTransform;vec2 getBaseColorUV(){vec3 uv=vec3(u_BaseColorUVSet<1 ? v_texcoord_0 : v_texcoord_1,1.0);\n#ifdef HAS_BASECOLOR_UV_TRANSFORM\nuv=u_BaseColorUVTransform*uv;\n#endif\nreturn uv.xy;}vec2 getMetallicRoughnessUV(){vec3 uv=vec3(u_MetallicRoughnessUVSet<1 ? v_texcoord_0 : v_texcoord_1,1.0);\n#ifdef HAS_METALLICROUGHNESS_UV_TRANSFORM\nuv=u_MetallicRoughnessUVTransform*uv;\n#endif\nreturn uv.xy;}\n#endif\n#ifdef MATERIAL_SPECULARGLOSSINESS\nuniform sampler2D u_DiffuseSampler;uniform int u_DiffuseUVSet;uniform mat3 u_DiffuseUVTransform;uniform sampler2D u_SpecularGlossinessSampler;uniform int u_SpecularGlossinessUVSet;uniform mat3 u_SpecularGlossinessUVTransform;vec2 getSpecularGlossinessUV(){vec3 uv=vec3(u_SpecularGlossinessUVSet<1 ? v_texcoord_0 : v_texcoord_1,1.0);\n#ifdef HAS_SPECULARGLOSSINESS_UV_TRANSFORM\nuv=u_SpecularGlossinessUVTransform*uv;\n#endif\nreturn uv.xy;}vec2 getDiffuseUV(){vec3 uv=vec3(u_DiffuseUVSet<1 ? v_texcoord_0 : v_texcoord_1,1.0);\n#ifdef HAS_DIFFUSE_UV_TRANSFORM\nuv=u_DiffuseUVTransform*uv;\n#endif\nreturn uv.xy;}\n#endif\n#ifdef MATERIAL_CLEARCOAT\nuniform sampler2D u_ClearcoatSampler;uniform int u_ClearcoatUVSet;uniform mat3 u_ClearcoatUVTransform;uniform sampler2D u_ClearcoatRoughnessSampler;uniform int u_ClearcoatRoughnessUVSet;uniform mat3 u_ClearcoatRoughnessUVTransform;uniform sampler2D u_ClearcoatNormalSampler;uniform int u_ClearcoatNormalUVSet;uniform mat3 u_ClearcoatNormalUVTransform;uniform float u_ClearcoatNormalScale;vec2 getClearcoatUV(){vec3 uv=vec3(u_ClearcoatUVSet<1 ? v_texcoord_0 : v_texcoord_1,1.0);\n#ifdef HAS_CLEARCOAT_UV_TRANSFORM\nuv=u_ClearcoatUVTransform*uv;\n#endif\nreturn uv.xy;}vec2 getClearcoatRoughnessUV(){vec3 uv=vec3(u_ClearcoatRoughnessUVSet<1 ? v_texcoord_0 : v_texcoord_1,1.0);\n#ifdef HAS_CLEARCOATROUGHNESS_UV_TRANSFORM\nuv=u_ClearcoatRoughnessUVTransform*uv;\n#endif\nreturn uv.xy;}vec2 getClearcoatNormalUV(){vec3 uv=vec3(u_ClearcoatNormalUVSet<1 ? v_texcoord_0 : v_texcoord_1,1.0);\n#ifdef HAS_CLEARCOATNORMAL_UV_TRANSFORM\nuv=u_ClearcoatNormalUVTransform*uv;\n#endif\nreturn uv.xy;}\n#endif\n#ifdef MATERIAL_SHEEN\nuniform sampler2D u_SheenColorSampler;uniform int u_SheenColorUVSet;uniform mat3 u_SheenColorUVTransform;uniform sampler2D u_SheenRoughnessSampler;uniform int u_SheenRoughnessUVSet;uniform mat3 u_SheenRoughnessUVTransform;vec2 getSheenColorUV(){vec3 uv=vec3(u_SheenColorUVSet<1 ? v_texcoord_0 : v_texcoord_1,1.0);\n#ifdef HAS_SHEENCOLOR_UV_TRANSFORM\nuv=u_SheenColorUVTransform*uv;\n#endif\nreturn uv.xy;}vec2 getSheenRoughnessUV(){vec3 uv=vec3(u_SheenRoughnessUVSet<1 ? v_texcoord_0 : v_texcoord_1,1.0);\n#ifdef HAS_SHEENROUGHNESS_UV_TRANSFORM\nuv=u_SheenRoughnessUVTransform*uv;\n#endif\nreturn uv.xy;}\n#endif\n#ifdef MATERIAL_SPECULAR\nuniform sampler2D u_SpecularSampler;uniform int u_SpecularUVSet;uniform mat3 u_SpecularUVTransform;uniform sampler2D u_SpecularColorSampler;uniform int u_SpecularColorUVSet;uniform mat3 u_SpecularColorUVTransform;vec2 getSpecularUV(){vec3 uv=vec3(u_SpecularUVSet<1 ? v_texcoord_0 : v_texcoord_1,1.0);\n#ifdef HAS_SPECULAR_UV_TRANSFORM\nuv=u_SpecularUVTransform*uv;\n#endif\nreturn uv.xy;}vec2 getSpecularColorUV(){vec3 uv=vec3(u_SpecularColorUVSet<1 ? v_texcoord_0 : v_texcoord_1,1.0);\n#ifdef HAS_SPECULARCOLOR_UV_TRANSFORM\nuv=u_SpecularColorUVTransform*uv;\n#endif\nreturn uv.xy;}\n#endif\n#ifdef MATERIAL_TRANSMISSION\nuniform sampler2D u_TransmissionSampler;uniform int u_TransmissionUVSet;uniform mat3 u_TransmissionUVTransform;uniform sampler2D u_TransmissionFramebufferSampler;uniform ivec2 u_TransmissionFramebufferSize;vec2 getTransmissionUV(){vec3 uv=vec3(u_TransmissionUVSet<1 ? v_texcoord_0 : v_texcoord_1,1.0);\n#ifdef HAS_TRANSMISSION_UV_TRANSFORM\nuv=u_TransmissionUVTransform*uv;\n#endif\nreturn uv.xy;}\n#endif\n#ifdef MATERIAL_VOLUME\nuniform sampler2D u_ThicknessSampler;uniform int u_ThicknessUVSet;uniform mat3 u_ThicknessUVTransform;vec2 getThicknessUV(){vec3 uv=vec3(u_ThicknessUVSet<1 ? v_texcoord_0 : v_texcoord_1,1.0);\n#ifdef HAS_THICKNESS_UV_TRANSFORM\nuv=u_ThicknessUVTransform*uv;\n#endif\nreturn uv.xy;}\n#endif\n#ifdef MATERIAL_IRIDESCENCE\nuniform sampler2D u_IridescenceSampler;uniform int u_IridescenceUVSet;uniform mat3 u_IridescenceUVTransform;uniform sampler2D u_IridescenceThicknessSampler;uniform int u_IridescenceThicknessUVSet;uniform mat3 u_IridescenceThicknessUVTransform;vec2 getIridescenceUV(){vec3 uv=vec3(u_IridescenceUVSet<1 ? v_texcoord_0 : v_texcoord_1,1.0);\n#ifdef HAS_IRIDESCENCE_UV_TRANSFORM\nuv=u_IridescenceUVTransform*uv;\n#endif\nreturn uv.xy;}vec2 getIridescenceThicknessUV(){vec3 uv=vec3(u_IridescenceThicknessUVSet<1 ? v_texcoord_0 : v_texcoord_1,1.0);\n#ifdef HAS_IRIDESCENCETHICKNESS_UV_TRANSFORM\nuv=u_IridescenceThicknessUVTransform*uv;\n#endif\nreturn uv.xy;}\n#endif\n#ifdef MATERIAL_DIFFUSE_TRANSMISSION\nuniform sampler2D u_DiffuseTransmissionSampler;uniform int u_DiffuseTransmissionUVSet;uniform mat3 u_DiffuseTransmissionUVTransform;uniform sampler2D u_DiffuseTransmissionColorSampler;uniform int u_DiffuseTransmissionColorUVSet;uniform mat3 u_DiffuseTransmissionColorUVTransform;vec2 getDiffuseTransmissionUV(){vec3 uv=vec3(u_DiffuseTransmissionUVSet<1 ? v_texcoord_0 : v_texcoord_1,1.0);\n#ifdef HAS_DIFFUSETRANSMISSION_UV_TRANSFORM\nuv=u_DiffuseTransmissionUVTransform*uv;\n#endif\nreturn uv.xy;}vec2 getDiffuseTransmissionColorUV(){vec3 uv=vec3(u_DiffuseTransmissionColorUVSet<1 ? v_texcoord_0 : v_texcoord_1,1.0);\n#ifdef HAS_DIFFUSETRANSMISSIONCOLOR_UV_TRANSFORM\nuv=u_DiffuseTransmissionColorUVTransform*uv;\n#endif\nreturn uv.xy;}\n#endif\n#ifdef MATERIAL_ANISOTROPY\nuniform sampler2D u_AnisotropySampler;uniform int u_AnisotropyUVSet;uniform mat3 u_AnisotropyUVTransform;vec2 getAnisotropyUV(){vec3 uv=vec3(u_AnisotropyUVSet<1 ? v_texcoord_0 : v_texcoord_1,1.0);\n#ifdef HAS_ANISOTROPY_UV_TRANSFORM\nuv=u_AnisotropyUVTransform*uv;\n#endif\nreturn uv.xy;}\n#endif\n"; // eslint-disable-line

var tonemappingShader = "#define GLSLIFY 1\nuniform float u_Exposure;const float GAMMA=2.2;const float INV_GAMMA=1.0/GAMMA;const mat3 ACESInputMat=mat3(0.59719,0.07600,0.02840,0.35458,0.90834,0.13383,0.04823,0.01566,0.83777);const mat3 ACESOutputMat=mat3(1.60475,-0.10208,-0.00327,-0.53108,1.10813,-0.07276,-0.07367,-0.00605,1.07602);vec3 linearTosRGB(vec3 color){return pow(color,vec3(INV_GAMMA));}vec3 sRGBToLinear(vec3 srgbIn){return vec3(pow(srgbIn.xyz,vec3(GAMMA)));}vec4 sRGBToLinear(vec4 srgbIn){return vec4(sRGBToLinear(srgbIn.xyz),srgbIn.w);}vec3 toneMapACES_Narkowicz(vec3 color){const float A=2.51;const float B=0.03;const float C=2.43;const float D=0.59;const float E=0.14;return clamp((color*(A*color+B))/(color*(C*color+D)+E),0.0,1.0);}vec3 RRTAndODTFit(vec3 color){vec3 a=color*(color+0.0245786)-0.000090537;vec3 b=color*(0.983729*color+0.4329510)+0.238081;return a/b;}vec3 toneMapACES_Hill(vec3 color){color=ACESInputMat*color;color=RRTAndODTFit(color);color=ACESOutputMat*color;color=clamp(color,0.0,1.0);return color;}\n#ifdef TONEMAP_KHR_PBR_NEUTRAL\nvec3 toneMap_KhronosPbrNeutral(vec3 color){const float startCompression=0.8-0.04;const float desaturation=0.15;float x=min(color.r,min(color.g,color.b));float offset=x<0.08 ? x-6.25*x*x : 0.04;color-=offset;float peak=max(color.r,max(color.g,color.b));if(peak<startCompression)return color;const float d=1.-startCompression;float newPeak=1.-d*d/(peak+d-startCompression);color*=newPeak/peak;float g=1.-1./(desaturation*(peak-newPeak)+1.);return mix(color,newPeak*vec3(1,1,1),g);}\n#endif\nvec3 toneMap(vec3 color){color*=u_Exposure;\n#ifdef TONEMAP_ACES_NARKOWICZ\ncolor=toneMapACES_Narkowicz(color);\n#endif\n#ifdef TONEMAP_ACES_HILL\ncolor=toneMapACES_Hill(color);\n#endif\n#ifdef TONEMAP_ACES_HILL_EXPOSURE_BOOST\ncolor/=0.6;color=toneMapACES_Hill(color);\n#endif\n#ifdef TONEMAP_KHR_PBR_NEUTRAL\ncolor=toneMap_KhronosPbrNeutral(color);\n#endif\nreturn linearTosRGB(color);}"; // eslint-disable-line

var shaderFunctions = "#define GLSLIFY 1\nconst float M_PI=3.141592653589793;in vec3 v_Position;\n#ifdef HAS_NORMAL_VEC3\n#ifdef HAS_TANGENT_VEC4\nin mat3 v_TBN;\n#else\nin vec3 v_Normal;\n#endif\n#endif\n#ifdef HAS_COLOR_0_VEC3\nin vec3 v_Color;\n#endif\n#ifdef HAS_COLOR_0_VEC4\nin vec4 v_Color;\n#endif\nvec4 getVertexColor(){vec4 color=vec4(1.0);\n#ifdef HAS_COLOR_0_VEC3\ncolor.rgb=v_Color.rgb;\n#endif\n#ifdef HAS_COLOR_0_VEC4\ncolor=v_Color;\n#endif\nreturn color;}struct NormalInfo{vec3 ng;vec3 t;vec3 b;vec3 n;vec3 ntex;};float clampedDot(vec3 x,vec3 y){return clamp(dot(x,y),0.0,1.0);}float max3(vec3 v){return max(max(v.x,v.y),v.z);}float sq(float t){return t*t;}vec2 sq(vec2 t){return t*t;}vec3 sq(vec3 t){return t*t;}vec4 sq(vec4 t){return t*t;}float applyIorToRoughness(float roughness,float ior){return roughness*clamp(ior*2.0-2.0,0.0,1.0);}vec3 rgb_mix(vec3 base,vec3 layer,vec3 rgb_alpha){float rgb_alpha_max=max(rgb_alpha.r,max(rgb_alpha.g,rgb_alpha.b));return(1.0-rgb_alpha_max)*base+rgb_alpha*layer;}"; // eslint-disable-line

var animationShader = "#define GLSLIFY 1\n#ifdef HAS_MORPH_TARGETS\nuniform highp sampler2DArray u_MorphTargetsSampler;\n#endif\n#ifdef USE_MORPHING\nuniform float u_morphWeights[WEIGHT_COUNT];\n#endif\n#ifdef HAS_JOINTS_0_VEC4\nin vec4 a_joints_0;\n#endif\n#ifdef HAS_JOINTS_1_VEC4\nin vec4 a_joints_1;\n#endif\n#ifdef HAS_WEIGHTS_0_VEC4\nin vec4 a_weights_0;\n#endif\n#ifdef HAS_WEIGHTS_1_VEC4\nin vec4 a_weights_1;\n#endif\n#ifdef USE_SKINNING\nuniform sampler2D u_jointsSampler;\n#endif\n#ifdef USE_SKINNING\nmat4 getMatrixFromTexture(sampler2D s,int index){mat4 result=mat4(1);int texSize=textureSize(s,0)[0];int pixelIndex=index*4;for(int i=0;i<4;++i){int x=(pixelIndex+i)% texSize;int y=(pixelIndex+i-x)/texSize;result[i]=texelFetch(s,ivec2(x,y),0);}return result;}mat4 getSkinningMatrix(){mat4 skin=mat4(0);\n#if defined(HAS_WEIGHTS_0_VEC4) && defined(HAS_JOINTS_0_VEC4)\nskin+=a_weights_0.x*getMatrixFromTexture(u_jointsSampler,int(a_joints_0.x)*2)+a_weights_0.y*getMatrixFromTexture(u_jointsSampler,int(a_joints_0.y)*2)+a_weights_0.z*getMatrixFromTexture(u_jointsSampler,int(a_joints_0.z)*2)+a_weights_0.w*getMatrixFromTexture(u_jointsSampler,int(a_joints_0.w)*2);\n#endif\n#if defined(HAS_WEIGHTS_1_VEC4) && defined(HAS_JOINTS_1_VEC4)\nskin+=a_weights_1.x*getMatrixFromTexture(u_jointsSampler,int(a_joints_1.x)*2)+a_weights_1.y*getMatrixFromTexture(u_jointsSampler,int(a_joints_1.y)*2)+a_weights_1.z*getMatrixFromTexture(u_jointsSampler,int(a_joints_1.z)*2)+a_weights_1.w*getMatrixFromTexture(u_jointsSampler,int(a_joints_1.w)*2);\n#endif\nif(skin==mat4(0)){return mat4(1);}return skin;}mat4 getSkinningNormalMatrix(){mat4 skin=mat4(0);\n#if defined(HAS_WEIGHTS_0_VEC4) && defined(HAS_JOINTS_0_VEC4)\nskin+=a_weights_0.x*getMatrixFromTexture(u_jointsSampler,int(a_joints_0.x)*2+1)+a_weights_0.y*getMatrixFromTexture(u_jointsSampler,int(a_joints_0.y)*2+1)+a_weights_0.z*getMatrixFromTexture(u_jointsSampler,int(a_joints_0.z)*2+1)+a_weights_0.w*getMatrixFromTexture(u_jointsSampler,int(a_joints_0.w)*2+1);\n#endif\n#if defined(HAS_WEIGHTS_1_VEC4) && defined(HAS_JOINTS_1_VEC4)\nskin+=a_weights_1.x*getMatrixFromTexture(u_jointsSampler,int(a_joints_1.x)*2+1)+a_weights_1.y*getMatrixFromTexture(u_jointsSampler,int(a_joints_1.y)*2+1)+a_weights_1.z*getMatrixFromTexture(u_jointsSampler,int(a_joints_1.z)*2+1)+a_weights_1.w*getMatrixFromTexture(u_jointsSampler,int(a_joints_1.w)*2+1);\n#endif\nif(skin==mat4(0)){return mat4(1);}return skin;}\n#endif\n#ifdef USE_MORPHING\n#ifdef HAS_MORPH_TARGETS\nvec4 getDisplacement(int vertexID,int targetIndex,int texSize){int x=vertexID % texSize;int y=(vertexID-x)/texSize;return texelFetch(u_MorphTargetsSampler,ivec3(x,y,targetIndex),0);}\n#endif\nvec4 getTargetPosition(int vertexID){vec4 pos=vec4(0);\n#ifdef HAS_MORPH_TARGET_POSITION\nint texSize=textureSize(u_MorphTargetsSampler,0)[0];for(int i=0;i<WEIGHT_COUNT;i++){vec4 displacement=getDisplacement(vertexID,MORPH_TARGET_POSITION_OFFSET+i,texSize);pos+=u_morphWeights[i]*displacement;}\n#endif\nreturn pos;}vec3 getTargetNormal(int vertexID){vec3 normal=vec3(0);\n#ifdef HAS_MORPH_TARGET_NORMAL\nint texSize=textureSize(u_MorphTargetsSampler,0)[0];for(int i=0;i<WEIGHT_COUNT;i++){vec3 displacement=getDisplacement(vertexID,MORPH_TARGET_NORMAL_OFFSET+i,texSize).xyz;normal+=u_morphWeights[i]*displacement;}\n#endif\nreturn normal;}vec3 getTargetTangent(int vertexID){vec3 tangent=vec3(0);\n#ifdef HAS_MORPH_TARGET_TANGENT\nint texSize=textureSize(u_MorphTargetsSampler,0)[0];for(int i=0;i<WEIGHT_COUNT;i++){vec3 displacement=getDisplacement(vertexID,MORPH_TARGET_TANGENT_OFFSET+i,texSize).xyz;tangent+=u_morphWeights[i]*displacement;}\n#endif\nreturn tangent;}vec2 getTargetTexCoord0(int vertexID){vec2 uv=vec2(0);\n#ifdef HAS_MORPH_TARGET_TEXCOORD_0\nint texSize=textureSize(u_MorphTargetsSampler,0)[0];for(int i=0;i<WEIGHT_COUNT;i++){vec2 displacement=getDisplacement(vertexID,MORPH_TARGET_TEXCOORD_0_OFFSET+i,texSize).xy;uv+=u_morphWeights[i]*displacement;}\n#endif\nreturn uv;}vec2 getTargetTexCoord1(int vertexID){vec2 uv=vec2(0);\n#ifdef HAS_MORPH_TARGET_TEXCOORD_1\nint texSize=textureSize(u_MorphTargetsSampler,0)[0];for(int i=0;i<WEIGHT_COUNT;i++){vec2 displacement=getDisplacement(vertexID,MORPH_TARGET_TEXCOORD_1_OFFSET+i,texSize).xy;uv+=u_morphWeights[i]*displacement;}\n#endif\nreturn uv;}vec4 getTargetColor0(int vertexID){vec4 color=vec4(0);\n#ifdef HAS_MORPH_TARGET_COLOR_0\nint texSize=textureSize(u_MorphTargetsSampler,0)[0];for(int i=0;i<WEIGHT_COUNT;i++){vec4 displacement=getDisplacement(vertexID,MORPH_TARGET_COLOR_0_OFFSET+i,texSize);color+=u_morphWeights[i]*displacement;}\n#endif\nreturn color;}\n#endif\n"; // eslint-disable-line

var cubemapVertShader = "#define GLSLIFY 1\nuniform mat4 u_ViewProjectionMatrix;uniform mat3 u_EnvRotation;in vec3 a_position;out vec3 v_TexCoords;void main(){v_TexCoords=u_EnvRotation*a_position;mat4 mat=u_ViewProjectionMatrix;mat[3]=vec4(0.0,0.0,0.0,0.1);vec4 pos=mat*vec4(a_position,1.0);gl_Position=pos.xyww;}"; // eslint-disable-line

var cubemapFragShader = "precision highp float;\n#define GLSLIFY 1\n#include <tonemapping.glsl>\nuniform float u_EnvIntensity;uniform float u_EnvBlurNormalized;uniform int u_MipCount;uniform samplerCube u_GGXEnvSampler;out vec4 FragColor;in vec3 v_TexCoords;void main(){vec4 color=textureLod(u_GGXEnvSampler,v_TexCoords,u_EnvBlurNormalized*float(u_MipCount-1));color.rgb*=u_EnvIntensity;color.a=1.0;\n#ifdef LINEAR_OUTPUT\nFragColor=color.rgba;\n#else\nFragColor=vec4(toneMap(color.rgb),color.a);\n#endif\n}"; // eslint-disable-line

class gltfLight extends GltfObject
{
    static animatedProperties = ["color", "intensity", "range"];
    constructor()
    {
        super();
        this.name = undefined;
        this.type = "directional";
        this.color = [1, 1, 1];
        this.intensity = 1;
        this.range = -1;
        this.spot = new gltfLightSpot();

        // Used to override direction from node
        this.direction = undefined;
    }

    fromJson(json)
    {
        super.fromJson(json);
        if (json.spot !== undefined)
        {
            this.spot = new gltfLightSpot();
            this.spot.fromJson(json.spot);
        }
    }

    toUniform(node)
    {
        const matrix = node?.worldTransform ?? identity$1;

        // To extract a correct rotation, the scaling component must be eliminated.
        var scale = fromValues$2(1, 1, 1);
        getScaling(scale, matrix);
        const mn = create$3();
        for(const col of [0, 1, 2])
        {
            mn[col] = matrix[col] / scale[0];
            mn[col + 4] = matrix[col + 4] / scale[1];
            mn[col + 8] = matrix[col + 8] / scale[2];
        }
        var rotation = create$5();
        getRotation(rotation, mn);
        normalize(rotation, rotation);

        const uLight = new UniformLight();

        const alongNegativeZ = fromValues$2(0, 0, -1);
        transformQuat(uLight.direction, alongNegativeZ, rotation);

        var translation = fromValues$2(0, 0, 0);
        getTranslation(translation, matrix);
        uLight.position = translation;

        if (this.direction !== undefined)
        {
            uLight.direction = this.direction;
        }

        uLight.range = this.range;
        uLight.color = jsToGl(this.color);
        uLight.intensity = this.intensity;

        uLight.innerConeCos = Math.cos(this.spot.innerConeAngle);
        uLight.outerConeCos = Math.cos(this.spot.outerConeAngle);

        switch(this.type)
        {
        case "spot":
            uLight.type = Type_Spot;
            break;
        case "point":
            uLight.type = Type_Point;
            break;
        case "directional":
        default:
            uLight.type = Type_Directional;
            break;
        }

        return uLight;
    }
}

const Type_Directional = 0;
const Type_Point = 1;
const Type_Spot = 2;

class UniformLight extends UniformStruct
{
    constructor()
    {
        super();

        const defaultDirection = fromValues$2(-0.7399, -0.6428, -0.1983);
        this.direction = defaultDirection;
        this.range = -1;

        this.color = jsToGl([1, 1, 1]);
        this.intensity = 1;

        this.position = jsToGl([0, 0, 0]);
        this.innerConeCos = 0.0;

        this.outerConeCos = Math.PI / 4;
        this.type = Type_Directional;
    }
}

class gltfLightSpot extends GltfObject
{
    static animatedProperties = ["innerConeAngle", "outerConeAngle"];
    constructor()
    {
        super();
        this.innerConeAngle = 0;
        this.outerConeAngle = Math.PI / 4;
    }
}

class gltfRenderer
{
    constructor(context)
    {
        this.shader = undefined; // current shader

        this.currentWidth = 0;
        this.currentHeight = 0;

        this.webGl = new gltfWebGl(context);
        this.initialized = false;
        this.samples = 4;

        // create render target for non transmission materials
        this.opaqueRenderTexture = 0;
        this.opaqueFramebuffer = 0;
        this.opaqueDepthTexture = 0;
        this.opaqueFramebufferWidth = 1024;
        this.opaqueFramebufferHeight = 1024;

        const shaderSources = new Map();
        shaderSources.set("primitive.vert", primitiveShader);
        shaderSources.set("pbr.frag", pbrShader);
        shaderSources.set("material_info.glsl", materialInfoShader);
        shaderSources.set("brdf.glsl", brdfShader);
        shaderSources.set("iridescence.glsl", iridescenceShader);
        shaderSources.set("ibl.glsl", iblShader);
        shaderSources.set("punctual.glsl", punctualShader);
        shaderSources.set("tonemapping.glsl", tonemappingShader);
        shaderSources.set("textures.glsl", texturesShader);
        shaderSources.set("functions.glsl", shaderFunctions);
        shaderSources.set("animation.glsl", animationShader);
        shaderSources.set("cubemap.vert", cubemapVertShader);
        shaderSources.set("cubemap.frag", cubemapFragShader);

        this.shaderCache = new ShaderCache(shaderSources, this.webGl);

        this.webGl.loadWebGlExtensions();

        this.visibleLights = [];

        this.viewMatrix = create$3();
        this.projMatrix = create$3();
        this.viewProjectionMatrix = create$3();

        this.currentCameraPosition = create$2();

        this.lightKey = new gltfLight();
        this.lightFill = new gltfLight();
        this.lightFill.intensity = 0.5;
        const quatKey = fromValues$3(
            -0.3535534,
            -0.353553385,
            -0.146446586,
            0.8535534);
        const quatFill = fromValues$3(
            -0.8535534,
            0.146446645,
            -0.353553325,
            -0.353553444);
        this.lightKey.direction = create$2();
        this.lightFill.direction = create$2();
        transformQuat(this.lightKey.direction, [0, 0, -1], quatKey);
        transformQuat(this.lightFill.direction, [0, 0, -1], quatFill);
        
        this.maxVertAttributes = undefined;
        this.instanceBuffer = undefined;
    }

    /////////////////////////////////////////////////////////////////////
    // Render glTF scene graph
    /////////////////////////////////////////////////////////////////////

    // app state
    init(state)
    {
        const context = this.webGl.context;
        const maxSamples = context.getParameter(context.MAX_SAMPLES);
        const samples = state.internalMSAA < maxSamples ? state.internalMSAA : maxSamples;
        if (!this.initialized){

            context.pixelStorei(GL.UNPACK_COLORSPACE_CONVERSION_WEBGL, GL.NONE);
            context.enable(GL.DEPTH_TEST);
            context.depthFunc(GL.LEQUAL);
            context.colorMask(true, true, true, true);
            context.clearDepth(1.0);

            this.opaqueRenderTexture = context.createTexture();
            context.bindTexture(context.TEXTURE_2D, this.opaqueRenderTexture);
            context.texParameteri(context.TEXTURE_2D, context.TEXTURE_MIN_FILTER, context.LINEAR_MIPMAP_LINEAR);
            context.texParameteri(context.TEXTURE_2D, context.TEXTURE_WRAP_S, context.CLAMP_TO_EDGE);
            context.texParameteri(context.TEXTURE_2D, context.TEXTURE_WRAP_T, context.CLAMP_TO_EDGE);
            context.texParameteri(context.TEXTURE_2D, context.TEXTURE_MAG_FILTER, context.NEAREST);
            context.texImage2D(context.TEXTURE_2D, 0, context.RGBA, this.opaqueFramebufferWidth, this.opaqueFramebufferHeight, 0, context.RGBA, context.UNSIGNED_BYTE, null);
            context.bindTexture(context.TEXTURE_2D, null);

            this.opaqueDepthTexture = context.createTexture();
            context.bindTexture(context.TEXTURE_2D, this.opaqueDepthTexture);
            context.texParameteri(context.TEXTURE_2D, context.TEXTURE_MIN_FILTER, context.NEAREST);
            context.texParameteri(context.TEXTURE_2D, context.TEXTURE_WRAP_S, context.CLAMP_TO_EDGE);
            context.texParameteri(context.TEXTURE_2D, context.TEXTURE_WRAP_T, context.CLAMP_TO_EDGE);
            context.texParameteri(context.TEXTURE_2D, context.TEXTURE_MAG_FILTER, context.NEAREST);
            context.texImage2D( context.TEXTURE_2D, 0, context.DEPTH_COMPONENT16, this.opaqueFramebufferWidth, this.opaqueFramebufferHeight, 0, context.DEPTH_COMPONENT, context.UNSIGNED_SHORT, null);
            context.bindTexture(context.TEXTURE_2D, null);


            this.colorRenderBuffer = context.createRenderbuffer();
            context.bindRenderbuffer(context.RENDERBUFFER, this.colorRenderBuffer);
            context.renderbufferStorageMultisample( context.RENDERBUFFER, samples, context.RGBA8,  this.opaqueFramebufferWidth, this.opaqueFramebufferHeight);

            this.depthRenderBuffer = context.createRenderbuffer();
            context.bindRenderbuffer(context.RENDERBUFFER, this.depthRenderBuffer);
            context.renderbufferStorageMultisample( context.RENDERBUFFER,
                samples,
                context.DEPTH_COMPONENT16, 
                this.opaqueFramebufferWidth,
                this.opaqueFramebufferHeight);

            this.samples = samples;

            this.opaqueFramebufferMSAA = context.createFramebuffer();
            context.bindFramebuffer(context.FRAMEBUFFER, this.opaqueFramebufferMSAA);
            context.framebufferRenderbuffer(context.FRAMEBUFFER, context.COLOR_ATTACHMENT0, context.RENDERBUFFER, this.colorRenderBuffer);
            context.framebufferRenderbuffer(context.FRAMEBUFFER, context.DEPTH_ATTACHMENT, context.RENDERBUFFER, this.depthRenderBuffer);


            this.opaqueFramebuffer = context.createFramebuffer();
            context.bindFramebuffer(context.FRAMEBUFFER, this.opaqueFramebuffer);
            context.framebufferTexture2D(context.FRAMEBUFFER, context.COLOR_ATTACHMENT0, context.TEXTURE_2D, this.opaqueRenderTexture, 0);
            context.framebufferTexture2D(context.FRAMEBUFFER, context.DEPTH_ATTACHMENT, context.TEXTURE_2D, this.opaqueDepthTexture, 0);
            context.viewport(0, 0, this.opaqueFramebufferWidth, this.opaqueFramebufferHeight);
            context.bindFramebuffer(context.FRAMEBUFFER, null);

            this.maxVertAttributes = context.getParameter(context.MAX_VERTEX_ATTRIBS);

            this.initialized = true;

            this.environmentRenderer = new EnvironmentRenderer(this.webGl);
        }
        else {
            if (this.samples != samples)
            {
                this.samples = samples;
                context.bindRenderbuffer(context.RENDERBUFFER, this.colorRenderBuffer);
                context.renderbufferStorageMultisample( context.RENDERBUFFER,
                    samples,
                    context.RGBA8, 
                    this.opaqueFramebufferWidth,
                    this.opaqueFramebufferHeight);
                
                context.bindRenderbuffer(context.RENDERBUFFER, this.depthRenderBuffer);
                context.renderbufferStorageMultisample( context.RENDERBUFFER,
                    samples,
                    context.DEPTH_COMPONENT16, 
                    this.opaqueFramebufferWidth,
                    this.opaqueFramebufferHeight);
            }
        }
    }

    resize(width, height)
    {
        if (this.currentWidth !== width || this.currentHeight !== height)
        {
            this.currentHeight = height;
            this.currentWidth = width;
            this.webGl.context.viewport(0, 0, width, height);
        }
    }

    // frame state
    clearFrame(clearColor)
    {
        this.webGl.context.bindFramebuffer(this.webGl.context.FRAMEBUFFER, null);
        this.webGl.context.clearColor(...clearColor);
        this.webGl.context.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);
        this.webGl.context.bindFramebuffer(this.webGl.context.FRAMEBUFFER, this.opaqueFramebuffer);
        this.webGl.context.clearColor(...clearColor);
        this.webGl.context.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);
        this.webGl.context.bindFramebuffer(this.webGl.context.FRAMEBUFFER, null);
        this.webGl.context.bindFramebuffer(this.webGl.context.FRAMEBUFFER, this.opaqueFramebufferMSAA);
        this.webGl.context.clearColor(...clearColor);
        this.webGl.context.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);
        this.webGl.context.bindFramebuffer(this.webGl.context.FRAMEBUFFER, null);
    }

    prepareScene(state, scene) {
        this.nodes = scene.gatherNodes(state.gltf);

        // collect drawables by essentially zipping primitives (for geometry and material)
        // and nodes for the transform
        const drawables = this.nodes
            .filter(node => node.mesh !== undefined)
            .reduce((acc, node) => acc.concat(state.gltf.meshes[node.mesh].primitives.map( (primitive, index) => {
                return  {node: node, primitive: primitive, primitiveIndex: index};
            })), [])
            .filter(({primitive}) => primitive.material !== undefined);

        // opaque drawables don't need sorting
        this.opaqueDrawables = drawables
            .filter(({primitive}) => state.gltf.materials[primitive.material].alphaMode !== "BLEND"
                && (state.gltf.materials[primitive.material].extensions === undefined
                    || state.gltf.materials[primitive.material].extensions.KHR_materials_transmission === undefined));
        
        let counter = 0;
        this.opaqueDrawables = Object.groupBy(this.opaqueDrawables, (a) => {
            const winding = Math.sign(determinant(a.node.worldTransform));
            const id = `${a.node.mesh}_${winding}_${a.primitiveIndex}`;
            // Disable instancing for skins, morph targets and if the GPU attributes limit is reached.
            // Additionally we define a new id for each instance of the EXT_mesh_gpu_instancing extension.
            if (a.node.skin || a.primitive.targets.length > 0 || a.primitive.glAttributes.length + 4 > this.maxVertAttributes || a.node.instanceMatrices) {
                if (a.node.instanceMatrices && a.primitive.glAttributes.length + 4 > this.maxVertAttributes) {
                    console.warn(`EXT_mesh_gpu_instancing disabled for mesh ${a.node.mesh} because the GPU vertex attribute limit is reached.`);
                }
                counter++;
                return id + "_" + counter;
            }
            return id;
        });

        // transparent drawables need sorting before they can be drawn
        this.transparentDrawables = drawables
            .filter(({primitive}) => state.gltf.materials[primitive.material].alphaMode === "BLEND"
                && (state.gltf.materials[primitive.material].extensions === undefined
                    || state.gltf.materials[primitive.material].extensions.KHR_materials_transmission === undefined));

        this.transmissionDrawables = drawables
            .filter(({primitive}) => state.gltf.materials[primitive.material].extensions !== undefined
                && state.gltf.materials[primitive.material].extensions.KHR_materials_transmission !== undefined);
    }

    // render complete gltf scene with given camera
    drawScene(state, scene)
    {
        if (this.preparedScene !== scene) {
            this.prepareScene(state, scene);
            this.preparedScene = scene;
        }

        let currentCamera = undefined;

        if (state.cameraIndex === undefined)
        {
            currentCamera = state.userCamera;
            currentCamera.perspective.aspectRatio = this.currentWidth / this.currentHeight;
        }
        else
        {
            currentCamera = state.gltf.cameras[state.cameraIndex];
        }

        let aspectHeight = this.currentHeight;
        let aspectWidth = this.currentWidth;
        let aspectOffsetX = 0;
        let aspectOffsetY = 0;
        const currentAspectRatio = aspectWidth / aspectHeight;
        if (currentCamera.type === "perspective") {
            if (currentCamera.perspective.aspectRatio) {
                if (currentCamera.perspective.aspectRatio > currentAspectRatio) {
                    aspectHeight = aspectWidth * 1 / currentCamera.perspective.aspectRatio;
                } else {
                    aspectWidth = aspectHeight * currentCamera.perspective.aspectRatio;
                }
            }
        } else {
            const orthoAspect = currentCamera.orthographic.xmag / currentCamera.orthographic.ymag;
            if (orthoAspect > currentAspectRatio) {
                aspectHeight = aspectWidth * 1 / orthoAspect;
            } else {
                aspectWidth = aspectHeight * orthoAspect;
            }
        }
        if (aspectHeight < this.currentHeight) {
            aspectOffsetY = (this.currentHeight - aspectHeight) / 2;
        }
        if (aspectWidth < this.currentWidth) {
            aspectOffsetX = (this.currentWidth - aspectWidth) / 2;
        }

        this.projMatrix = currentCamera.getProjectionMatrix(currentAspectRatio);
        this.viewMatrix = currentCamera.getViewMatrix(state.gltf);
        this.currentCameraPosition = currentCamera.getPosition(state.gltf);

        this.visibleLights = this.getVisibleLights(state.gltf, scene.nodes);
        if (this.visibleLights.length === 0 && !state.renderingParameters.useIBL &&
            state.renderingParameters.useDirectionalLightsWithDisabledIBL)
        {
            this.visibleLights.push([null, this.lightKey]);
            this.visibleLights.push([null, this.lightFill]);
        }

        multiply(this.viewProjectionMatrix, this.projMatrix, this.viewMatrix);

        // Update skins.
        for (const node of this.nodes)
        {
            if (node.mesh !== undefined && node.skin !== undefined)
            {
                this.updateSkin(state, node);
            }
        }

        const instanceWorldTransforms = [];
        for (const instance of Object.values(this.opaqueDrawables))
        {  
            let instanceOffset = undefined;
            if (instance.length > 1) {
                instanceOffset = [];
                for (const iDrawable of instance) {
                    instanceOffset.push(iDrawable.node.worldTransform);
                }
            } else if (instance[0].node.instanceMatrices !== undefined) {
                // Set instance matrices for EXT_mesh_gpu_instancing extension
                if (instance[0].primitive.glAttributes.length + 4 <= this.maxVertAttributes) {
                    instanceOffset = instance[0].node.instanceWorldTransforms;
                }
            }
            instanceWorldTransforms.push(instanceOffset);
        }

        // If any transmissive drawables are present, render all opaque and transparent drawables into a separate framebuffer.
        if (this.transmissionDrawables.length > 0) {
            // Render transmission sample texture
            this.webGl.context.bindFramebuffer(this.webGl.context.FRAMEBUFFER, this.opaqueFramebufferMSAA);
            this.webGl.context.viewport(0, 0, this.opaqueFramebufferWidth, this.opaqueFramebufferHeight);

            // Render environment for the transmission background
            this.environmentRenderer.drawEnvironmentMap(this.webGl, this.viewProjectionMatrix, state, this.shaderCache, ["LINEAR_OUTPUT 1"]);

            let drawableCounter = 0;
            for (const instance of Object.values(this.opaqueDrawables))
            {
                const drawable = instance[0];
                let renderpassConfiguration = {};
                renderpassConfiguration.linearOutput = true;
                const instanceOffset = instanceWorldTransforms[drawableCounter];
                drawableCounter++;
                this.drawPrimitive(state, renderpassConfiguration, drawable.primitive, drawable.node, this.viewProjectionMatrix, undefined, instanceOffset);
            }

            this.transparentDrawables = currentCamera.sortPrimitivesByDepth(state.gltf, this.transparentDrawables);
            for (const drawable of this.transparentDrawables)
            {
                let renderpassConfiguration = {};
                renderpassConfiguration.linearOutput = true;
                this.drawPrimitive(state, renderpassConfiguration, drawable.primitive, drawable.node, this.viewProjectionMatrix);
            }

            // "blit" the multisampled opaque texture into the color buffer, which adds antialiasing
            this.webGl.context.bindFramebuffer(this.webGl.context.READ_FRAMEBUFFER, this.opaqueFramebufferMSAA);
            this.webGl.context.bindFramebuffer(this.webGl.context.DRAW_FRAMEBUFFER, this.opaqueFramebuffer);
            this.webGl.context.blitFramebuffer(0, 0, this.opaqueFramebufferWidth, this.opaqueFramebufferHeight, 0, 0, this.opaqueFramebufferWidth, this.opaqueFramebufferHeight, this.webGl.context.COLOR_BUFFER_BIT, this.webGl.context.NEAREST);

            // Create Framebuffer Mipmaps
            this.webGl.context.bindTexture(this.webGl.context.TEXTURE_2D, this.opaqueRenderTexture);

            this.webGl.context.generateMipmap(this.webGl.context.TEXTURE_2D);
        }

        // Render to canvas
        this.webGl.context.bindFramebuffer(this.webGl.context.FRAMEBUFFER, null);
        this.webGl.context.viewport(aspectOffsetX, aspectOffsetY,  aspectWidth, aspectHeight);

        // Render environment
        const fragDefines = [];
        this.pushFragParameterDefines(fragDefines, state);
        this.environmentRenderer.drawEnvironmentMap(this.webGl, this.viewProjectionMatrix, state, this.shaderCache, fragDefines);

        let drawableCounter = 0;
        for (const instance of Object.values(this.opaqueDrawables))
        {  
            const drawable = instance[0];
            let renderpassConfiguration = {};
            renderpassConfiguration.linearOutput = false;
            const instanceOffset = instanceWorldTransforms[drawableCounter];
            drawableCounter++;
            this.drawPrimitive(state, renderpassConfiguration, drawable.primitive, drawable.node, this.viewProjectionMatrix, undefined, instanceOffset);
        }

        // filter materials with transmission extension
        this.transmissionDrawables = currentCamera.sortPrimitivesByDepth(state.gltf, this.transmissionDrawables);
        for (const drawable of this.transmissionDrawables.filter((a) => a.depth <= 0))
        {
            let renderpassConfiguration = {};
            renderpassConfiguration.linearOutput = false;
            this.drawPrimitive(state, renderpassConfiguration, drawable.primitive, drawable.node, this.viewProjectionMatrix, this.opaqueRenderTexture);
        }


        this.transparentDrawables = currentCamera.sortPrimitivesByDepth(state.gltf, this.transparentDrawables);
        for (const drawable of this.transparentDrawables.filter((a) => a.depth <= 0))
        {
            let renderpassConfiguration = {};
            renderpassConfiguration.linearOutput = false;
            this.drawPrimitive(state, renderpassConfiguration, drawable.primitive, drawable.node, this.viewProjectionMatrix);
        }
    }

    // vertices with given material
    drawPrimitive(state, renderpassConfiguration, primitive, node, viewProjectionMatrix, transmissionSampleTexture, instanceOffset = undefined)
    {
        if (primitive.skip) return;

        let material;
        if(primitive.mappings !== undefined && state.variant != "default")
        {
            const names = state.gltf.variants.map(obj => obj.name);
            const idx = names.indexOf(state.variant);
            let materialIdx = primitive.material;
            primitive.mappings.forEach(element => {
                if(element.variants.indexOf(idx) >= 0)
                {
                    materialIdx = element.material;
                }
            });
            material = state.gltf.materials[materialIdx];
        }
        else
        {
            material = state.gltf.materials[primitive.material];
        }

        //select shader permutation, compile and link program.

        let vertDefines = [];
        this.pushVertParameterDefines(vertDefines, state.renderingParameters, state.gltf, node, primitive);
        vertDefines = primitive.defines.concat(vertDefines);
        if (instanceOffset !== undefined) {
            vertDefines.push("USE_INSTANCING 1");
        }
        if (material.textureTransforms.length > 0) {
            for (let i = 0; i < material.textureTransforms.length; i++) {
                if (material.textureTransforms[i] !== undefined && material.textureTransforms[i].key === "Normal") {
                    vertDefines.push("HAS_VERT_NORMAL_UV_TRANSFORM 1");
                    break;
                }
            }
        }

        let fragDefines = material.getDefines(state.renderingParameters).concat(vertDefines);
        if (renderpassConfiguration.linearOutput)
        {
            fragDefines.push("LINEAR_OUTPUT 1");
        }

        // POINTS, LINES, LINE_LOOP, LINE_STRIP
        if (primitive.mode < 4) {
            fragDefines.push("NOT_TRIANGLE 1");
            if (primitive.attributes?.NORMAL !== undefined && primitive.attributes?.TANGENT === undefined) {
                //Points or Lines with NORMAL but without TANGENT attributes SHOULD be rendered with standard lighting but ignoring any normal textures on the material.
                fragDefines = fragDefines.filter(e => e !== "HAS_NORMAL_MAP 1" && e !== "HAS_CLEARCOAT_NORMAL_MAP 1");
            }
        }

        this.pushFragParameterDefines(fragDefines, state);
        
        const fragmentHash = this.shaderCache.selectShader("pbr.frag", fragDefines);
        const vertexHash = this.shaderCache.selectShader("primitive.vert", vertDefines);

        if (fragmentHash && vertexHash)
        {
            this.shader = this.shaderCache.getShaderProgram(fragmentHash, vertexHash);
        }

        if (this.shader === undefined)
        {
            return;
        }

        this.webGl.context.useProgram(this.shader.program);

        if (state.renderingParameters.usePunctual)
        {
            this.applyLights();
        }

        // update model dependant matrices once per node
        this.shader.updateUniform("u_ViewProjectionMatrix", viewProjectionMatrix);
        this.shader.updateUniform("u_ModelMatrix", node.worldTransform);
        this.shader.updateUniform("u_NormalMatrix", node.normalMatrix, false);
        this.shader.updateUniform("u_Exposure", state.renderingParameters.exposure, false);
        this.shader.updateUniform("u_Camera", this.currentCameraPosition, false);
        

        this.updateAnimationUniforms(state, node, primitive);

        if (determinant(node.worldTransform) < 0.0)
        {
            this.webGl.context.frontFace(GL.CW);
        }
        else
        {
            this.webGl.context.frontFace(GL.CCW);
        }

        if (material.doubleSided)
        {
            this.webGl.context.disable(GL.CULL_FACE);
        }
        else
        {
            this.webGl.context.enable(GL.CULL_FACE);
        }
    
        if (material.alphaMode === 'BLEND')
        {
            this.webGl.context.enable(GL.BLEND);
            this.webGl.context.blendFuncSeparate(GL.SRC_ALPHA, GL.ONE_MINUS_SRC_ALPHA, GL.ONE, GL.ONE_MINUS_SRC_ALPHA);
            this.webGl.context.blendEquation(GL.FUNC_ADD);
        }
        else
        {
            this.webGl.context.disable(GL.BLEND);
        }
        

        const drawIndexed = primitive.indices !== undefined;
        if (drawIndexed)
        {
            if (!this.webGl.setIndices(state.gltf, primitive.indices))
            {
                return;
            }
        }

        let vertexCount = 0;
        for (const attribute of primitive.glAttributes)
        {
            const gltfAccessor = state.gltf.accessors[attribute.accessor];
            vertexCount = gltfAccessor.count;

            const location = this.shader.getAttributeLocation(attribute.name);
            if (location === null)
            {
                continue; // only skip this attribute
            }
            if (!this.webGl.enableAttribute(state.gltf, location, gltfAccessor))
            {
                return; // skip this primitive
            }
        }

        if (instanceOffset !== undefined) {
            const location = this.shader.getAttributeLocation("a_instance_model_matrix");
            const location2 = location + 1;
            const location3 = location2 + 1;
            const location4 = location3 + 1;
            if (this.instanceBuffer === undefined) {
                this.instanceBuffer = this.webGl.context.createBuffer();
            }
            this.webGl.context.enableVertexAttribArray(location);
            this.webGl.context.enableVertexAttribArray(location2);
            this.webGl.context.enableVertexAttribArray(location3);
            this.webGl.context.enableVertexAttribArray(location4);

            this.webGl.context.bindBuffer(GL.ARRAY_BUFFER, this.instanceBuffer);
            const data = new Float32Array(instanceOffset.length * 16);
            instanceOffset.forEach((element, index) => {
                data.set(element, 16 * index);
            });
            this.webGl.context.bufferData(GL.ARRAY_BUFFER, data, GL.DYNAMIC_DRAW);
            this.webGl.context.vertexAttribPointer(location, 4, GL.FLOAT, GL.FALSE, 4 * 16, 0);
            this.webGl.context.vertexAttribPointer(location2, 4, GL.FLOAT, GL.FALSE, 4 * 16, 4 * 4);
            this.webGl.context.vertexAttribPointer(location3, 4, GL.FLOAT, GL.FALSE, 4 * 16, 4 * 8);
            this.webGl.context.vertexAttribPointer(location4, 4, GL.FLOAT, GL.FALSE, 4 * 16, 4 * 12);
            
            this.webGl.context.vertexAttribDivisor(location, 1);
            this.webGl.context.vertexAttribDivisor(location2, 1);
            this.webGl.context.vertexAttribDivisor(location3, 1);
            this.webGl.context.vertexAttribDivisor(location4, 1);
        }

        // Update material uniforms
        material.updateTextureTransforms(this.shader);

        this.shader.updateUniform("u_EmissiveFactor", jsToGl(material.emissiveFactor));
        this.shader.updateUniform("u_AlphaCutoff", material.alphaCutoff);

        this.shader.updateUniform("u_NormalScale", material.normalTexture?.scale);
        this.shader.updateUniform("u_NormalUVSet", material.normalTexture?.texCoord);

        this.shader.updateUniform("u_OcclusionStrength", material.occlusionTexture?.strength);
        this.shader.updateUniform("u_OcclusionUVSet", material.occlusionTexture?.texCoord);

        this.shader.updateUniform("u_EmissiveUVSet", material.emissiveTexture?.texCoord);

        this.shader.updateUniform("u_BaseColorUVSet", material.pbrMetallicRoughness?.baseColorTexture?.texCoord);
        
        this.shader.updateUniform("u_MetallicRoughnessUVSet", material.pbrMetallicRoughness?.metallicRoughnessTexture?.texCoord);
        this.shader.updateUniform("u_MetallicFactor", material.pbrMetallicRoughness?.metallicFactor);
        this.shader.updateUniform("u_RoughnessFactor", material.pbrMetallicRoughness?.roughnessFactor);
        this.shader.updateUniform("u_BaseColorFactor", jsToGl(material.pbrMetallicRoughness?.baseColorFactor));

        this.shader.updateUniform("u_AnisotropyUVSet", material.extensions?.KHR_materials_anisotropy?.anisotropyTexture?.texCoord);

        const factor = material.extensions?.KHR_materials_anisotropy?.anisotropyStrength;
        const rotation = material.extensions?.KHR_materials_anisotropy?.anisotropyRotation;
        const anisotropy =  fromValues$2(Math.cos(rotation ?? 0), Math.sin(rotation ?? 0), factor ?? 0.0);
        this.shader.updateUniform("u_Anisotropy", anisotropy);

        this.shader.updateUniform("u_ClearcoatFactor", material.extensions?.KHR_materials_clearcoat?.clearcoatFactor);
        this.shader.updateUniform("u_ClearcoatRoughnessFactor", material.extensions?.KHR_materials_clearcoat?.clearcoatRoughnessFactor);
        this.shader.updateUniform("u_ClearcoatUVSet", material.extensions?.KHR_materials_clearcoat?.clearcoatTexture?.texCoord);
        this.shader.updateUniform("u_ClearcoatRoughnessUVSet", material.extensions?.KHR_materials_clearcoat?.clearcoatRoughnessTexture?.texCoord);
        this.shader.updateUniform("u_ClearcoatNormalUVSet", material.extensions?.KHR_materials_clearcoat?.clearcoatNormalTexture?.texCoord);
        this.shader.updateUniform("u_ClearcoatNormalScale", material.extensions?.KHR_materials_clearcoat?.clearcoatNormalTexture?.scale);

        this.shader.updateUniform("u_Dispersion", material.extensions?.KHR_materials_dispersion?.dispersion);

        this.shader.updateUniform("u_EmissiveStrength", material.extensions?.KHR_materials_emissive_strength?.emissiveStrength);

        this.shader.updateUniform("u_Ior", material.extensions?.KHR_materials_ior?.ior);

        this.shader.updateUniform("u_IridescenceFactor", material.extensions?.KHR_materials_iridescence?.iridescenceFactor);
        this.shader.updateUniform("u_IridescenceIor", material.extensions?.KHR_materials_iridescence?.iridescenceIor);
        this.shader.updateUniform("u_IridescenceThicknessMaximum", material.extensions?.KHR_materials_iridescence?.iridescenceThicknessMaximum);
        this.shader.updateUniform("u_IridescenceUVSet", material.extensions?.KHR_materials_iridescence?.iridescenceTexture?.texCoord);
        this.shader.updateUniform("u_IridescenceThicknessUVSet", material.extensions?.KHR_materials_iridescence?.iridescenceThicknessTexture?.texCoord);
        this.shader.updateUniform("u_IridescenceThicknessMinimum", material.extensions?.KHR_materials_iridescence?.iridescenceThicknessMinimum);

        this.shader.updateUniform("u_SheenRoughnessFactor", material.extensions?.KHR_materials_sheen?.sheenRoughnessFactor);
        this.shader.updateUniform("u_SheenColorFactor", jsToGl(material.extensions?.KHR_materials_sheen?.sheenColorFactor));
        this.shader.updateUniform("u_SheenRoughnessUVSet", material.extensions?.KHR_materials_sheen?.sheenRoughnessTexture?.texCoord);
        this.shader.updateUniform("u_SheenColorUVSet", material.extensions?.KHR_materials_sheen?.sheenColorTexture?.texCoord);
        
        this.shader.updateUniform("u_KHR_materials_specular_specularColorFactor", jsToGl(material.extensions?.KHR_materials_specular?.specularColorFactor));
        this.shader.updateUniform("u_KHR_materials_specular_specularFactor", material.extensions?.KHR_materials_specular?.specularFactor);
        this.shader.updateUniform("u_SpecularUVSet", material.extensions?.KHR_materials_specular?.specularTexture?.texCoord);
        this.shader.updateUniform("u_SpecularColorUVSet", material.extensions?.KHR_materials_specular?.specularColorTexture?.texCoord);

        this.shader.updateUniform("u_TransmissionFactor", material.extensions?.KHR_materials_transmission?.transmissionFactor);
        this.shader.updateUniform("u_TransmissionUVSet", material.extensions?.KHR_materials_transmission?.transmissionTexture?.texCoord);

        this.shader.updateUniform("u_AttenuationColor", jsToGl(material.extensions?.KHR_materials_volume?.attenuationColor));
        this.shader.updateUniform("u_AttenuationDistance", material.extensions?.KHR_materials_volume?.attenuationDistance);
        this.shader.updateUniform("u_ThicknessFactor", material.extensions?.KHR_materials_volume?.thicknessFactor);
        this.shader.updateUniform("u_ThicknessUVSet", material.extensions?.KHR_materials_volume?.thicknessTexture?.texCoord);

        this.shader.updateUniform("u_DiffuseTransmissionFactor", material.extensions?.KHR_materials_diffuse_transmission?.diffuseTransmissionFactor);
        this.shader.updateUniform("u_DiffuseTransmissionColorFactor", jsToGl(material.extensions?.KHR_materials_diffuse_transmission?.diffuseTransmissionColorFactor));
        this.shader.updateUniform("u_DiffuseTransmissionUVSet", material.extensions?.KHR_materials_diffuse_transmission?.diffuseTransmissionTexture?.texCoord);
        this.shader.updateUniform("u_DiffuseTransmissionColorUVSet", material.extensions?.KHR_materials_diffuse_transmission?.diffuseTransmissionColorTexture?.texCoord);

        this.shader.updateUniform("u_DiffuseFactor", jsToGl(material.extensions?.KHR_materials_pbrSpecularGlossiness?.diffuseFactor));
        this.shader.updateUniform("u_SpecularFactor", jsToGl(material.extensions?.KHR_materials_pbrSpecularGlossiness?.specularFactor));
        this.shader.updateUniform("u_GlossinessFactor", material.extensions?.KHR_materials_pbrSpecularGlossiness?.glossinessFactor);
        this.shader.updateUniform("u_SpecularGlossinessUVSet", material.extensions?.KHR_materials_pbrSpecularGlossiness?.specularGlossinessTexture?.texCoord);
        this.shader.updateUniform("u_DiffuseUVSet", material.extensions?.KHR_materials_pbrSpecularGlossiness?.diffuseTexture?.texCoord);
    
        let textureIndex = 0;
        for (; textureIndex < material.textures.length; ++textureIndex)
        {
            let info = material.textures[textureIndex];
            const location = this.shader.getUniformLocation(info.samplerName);
            if (!this.webGl.setTexture(location, state.gltf, info, textureIndex))
            {
                continue;
            }
        }


        // set the morph target texture
        if (primitive.morphTargetTextureInfo !== undefined) 
        {
            const location = this.shader.getUniformLocation(primitive.morphTargetTextureInfo.samplerName);
            this.webGl.setTexture(location, state.gltf, primitive.morphTargetTextureInfo, textureIndex); // binds texture and sampler
            textureIndex++;
        }

        // set the joints texture
        if (state.renderingParameters.skinning && node.skin !== undefined && primitive.hasWeights && primitive.hasJoints) 
        {
            const skin = state.gltf.skins[node.skin];
            const location = this.shader.getUniformLocation(skin.jointTextureInfo.samplerName);
            this.webGl.setTexture(location, state.gltf, skin.jointTextureInfo, textureIndex); // binds texture and sampler
            textureIndex++;
        }

        let textureCount = textureIndex;

        textureCount = this.applyEnvironmentMap(state, textureCount);


        if (state.environment !== undefined)
        {
            this.webGl.setTexture(this.shader.getUniformLocation("u_SheenELUT"), state.environment, state.environment.sheenELUT, textureCount++);
        }

        if(transmissionSampleTexture !== undefined &&
            state.environment &&
            state.renderingParameters.enabledExtensions.KHR_materials_transmission)
        {
            this.webGl.context.activeTexture(GL.TEXTURE0 + textureCount);
            this.webGl.context.bindTexture(this.webGl.context.TEXTURE_2D, this.opaqueRenderTexture);
            this.webGl.context.uniform1i(this.shader.getUniformLocation("u_TransmissionFramebufferSampler"), textureCount);
            textureCount++;

            this.webGl.context.uniform2i(this.shader.getUniformLocation("u_TransmissionFramebufferSize"), this.opaqueFramebufferWidth, this.opaqueFramebufferHeight);

            this.webGl.context.uniformMatrix4fv(this.shader.getUniformLocation("u_ModelMatrix"),false, node.worldTransform);
            this.webGl.context.uniformMatrix4fv(this.shader.getUniformLocation("u_ViewMatrix"),false, this.viewMatrix);
            this.webGl.context.uniformMatrix4fv(this.shader.getUniformLocation("u_ProjectionMatrix"),false, this.projMatrix);
        }

        if (drawIndexed)
        {
            const indexAccessor = state.gltf.accessors[primitive.indices];
            if (instanceOffset !== undefined) {
                this.webGl.context.drawElementsInstanced(primitive.mode, indexAccessor.count, indexAccessor.componentType, 0, instanceOffset.length);
            } else {
                this.webGl.context.drawElements(primitive.mode, indexAccessor.count, indexAccessor.componentType, 0);
            }
        }
        else
        {
            if (instanceOffset !== undefined) {
                this.webGl.context.drawArraysInstanced(primitive.mode, 0, vertexCount, instanceOffset.length);
            } else {
                this.webGl.context.drawArrays(primitive.mode, 0, vertexCount);
            }
        }

        for (const attribute of primitive.glAttributes)
        {
            const location = this.shader.getAttributeLocation(attribute.name);
            if (location === null)
            {
                continue; // skip this attribute
            }
            this.webGl.context.disableVertexAttribArray(location);
        }
        if (instanceOffset !== undefined) {
            const location = this.shader.getAttributeLocation("a_instance_model_matrix");
            this.webGl.context.vertexAttribDivisor(location, 0);
            this.webGl.context.vertexAttribDivisor(location + 1, 0);
            this.webGl.context.vertexAttribDivisor(location + 2, 0);
            this.webGl.context.vertexAttribDivisor(location + 3, 0);
            this.webGl.context.disableVertexAttribArray(location);
            this.webGl.context.disableVertexAttribArray(location + 1);
            this.webGl.context.disableVertexAttribArray(location + 2);
            this.webGl.context.disableVertexAttribArray(location + 3);
        }
    }

    /// Compute a list of lights instantiated by one or more nodes as a list of node-light tuples.
    getVisibleLights(gltf, nodes)
    {
        let nodeLights = [];

        for (const nodeIndex of nodes) {
            const node = gltf.nodes[nodeIndex];

            if (node.children !== undefined) {
                nodeLights = nodeLights.concat(this.getVisibleLights(gltf, node.children));
            }

            const lightIndex = node.extensions?.KHR_lights_punctual?.light;
            if (lightIndex === undefined) {
                continue;
            }
            const light = gltf.lights[lightIndex];
            nodeLights.push([node, light]);
        }

        return nodeLights;
    }

    updateSkin(state, node)
    {
        if (state.renderingParameters.skinning && state.gltf.skins !== undefined)
        {
            const skin = state.gltf.skins[node.skin];
            skin.computeJoints(state.gltf, node, this.webGl.context);
        }
    }

    pushVertParameterDefines(vertDefines, parameters, gltf, node, primitive)
    {
        // skinning
        if (parameters.skinning && node.skin !== undefined && primitive.hasWeights && primitive.hasJoints)
        {
            vertDefines.push("USE_SKINNING 1");
        }

        // morphing
        if (parameters.morphing && node.mesh !== undefined && primitive.targets.length > 0)
        {
            const weights = node.getWeights(gltf);
            if (weights !== undefined && weights.length > 0)
            {
                vertDefines.push("USE_MORPHING 1");
                vertDefines.push("WEIGHT_COUNT " + weights.length);
            }
        }
    }

    updateAnimationUniforms(state, node, primitive)
    {
        if (state.renderingParameters.morphing && node.mesh !== undefined && primitive.targets.length > 0)
        {
            const weights = node.getWeights(state.gltf);
            if (weights !== undefined && weights.length > 0)
            {
                this.shader.updateUniformArray("u_morphWeights", weights);
            }
        }
    }

    pushFragParameterDefines(fragDefines, state)
    {
        if (state.renderingParameters.usePunctual)
        {
            fragDefines.push("USE_PUNCTUAL 1");
            fragDefines.push(`LIGHT_COUNT ${this.visibleLights.length}`);
        }

        if (state.renderingParameters.useIBL && state.environment)
        {
            fragDefines.push("USE_IBL 1");
        }

        switch (state.renderingParameters.toneMap)
        {
        case (GltfState.ToneMaps.KHR_PBR_NEUTRAL):
            fragDefines.push("TONEMAP_KHR_PBR_NEUTRAL 1");
            break;
        case (GltfState.ToneMaps.ACES_NARKOWICZ):
            fragDefines.push("TONEMAP_ACES_NARKOWICZ 1");
            break;
        case (GltfState.ToneMaps.ACES_HILL):
            fragDefines.push("TONEMAP_ACES_HILL 1");
            break;
        case (GltfState.ToneMaps.ACES_HILL_EXPOSURE_BOOST):
            fragDefines.push("TONEMAP_ACES_HILL_EXPOSURE_BOOST 1");
            break;
        case (GltfState.ToneMaps.NONE):
        }

        let debugOutputMapping = [
            {debugOutput: GltfState.DebugOutput.NONE, shaderDefine: "DEBUG_NONE"},
            
            {debugOutput: GltfState.DebugOutput.generic.WORLDSPACENORMAL, shaderDefine: "DEBUG_NORMAL_SHADING"},
            {debugOutput: GltfState.DebugOutput.generic.NORMAL, shaderDefine: "DEBUG_NORMAL_TEXTURE"},
            {debugOutput: GltfState.DebugOutput.generic.GEOMETRYNORMAL, shaderDefine: "DEBUG_NORMAL_GEOMETRY"},
            {debugOutput: GltfState.DebugOutput.generic.TANGENT, shaderDefine: "DEBUG_TANGENT"},
            {debugOutput: GltfState.DebugOutput.generic.BITANGENT, shaderDefine: "DEBUG_BITANGENT"},
            {debugOutput: GltfState.DebugOutput.generic.ALPHA, shaderDefine: "DEBUG_ALPHA"},
            {debugOutput: GltfState.DebugOutput.generic.UV_COORDS_0, shaderDefine: "DEBUG_UV_0"},
            {debugOutput: GltfState.DebugOutput.generic.UV_COORDS_1, shaderDefine: "DEBUG_UV_1"},
            {debugOutput: GltfState.DebugOutput.generic.OCCLUSION, shaderDefine: "DEBUG_OCCLUSION"},
            {debugOutput: GltfState.DebugOutput.generic.EMISSIVE, shaderDefine: "DEBUG_EMISSIVE"},

            {debugOutput: GltfState.DebugOutput.mr.METALLIC_ROUGHNESS, shaderDefine: "DEBUG_METALLIC_ROUGHNESS"},
            {debugOutput: GltfState.DebugOutput.mr.BASECOLOR, shaderDefine: "DEBUG_BASE_COLOR"},
            {debugOutput: GltfState.DebugOutput.mr.ROUGHNESS, shaderDefine: "DEBUG_ROUGHNESS"},
            {debugOutput: GltfState.DebugOutput.mr.METALLIC, shaderDefine: "DEBUG_METALLIC"},
            
            {debugOutput: GltfState.DebugOutput.clearcoat.CLEARCOAT, shaderDefine: "DEBUG_CLEARCOAT"},
            {debugOutput: GltfState.DebugOutput.clearcoat.CLEARCOAT_FACTOR, shaderDefine: "DEBUG_CLEARCOAT_FACTOR"},
            {debugOutput: GltfState.DebugOutput.clearcoat.CLEARCOAT_ROUGHNESS, shaderDefine: "DEBUG_CLEARCOAT_ROUGHNESS"},
            {debugOutput: GltfState.DebugOutput.clearcoat.CLEARCOAT_NORMAL, shaderDefine: "DEBUG_CLEARCOAT_NORMAL"},
            
            {debugOutput: GltfState.DebugOutput.sheen.SHEEN, shaderDefine: "DEBUG_SHEEN"},
            {debugOutput: GltfState.DebugOutput.sheen.SHEEN_COLOR, shaderDefine: "DEBUG_SHEEN_COLOR"},
            {debugOutput: GltfState.DebugOutput.sheen.SHEEN_ROUGHNESS, shaderDefine: "DEBUG_SHEEN_ROUGHNESS"},

            {debugOutput: GltfState.DebugOutput.specular.SPECULAR, shaderDefine: "DEBUG_SPECULAR"},
            {debugOutput: GltfState.DebugOutput.specular.SPECULAR_FACTOR, shaderDefine: "DEBUG_SPECULAR_FACTOR"},
            {debugOutput: GltfState.DebugOutput.specular.SPECULAR_COLOR, shaderDefine: "DEBUG_SPECULAR_COLOR"},

            {debugOutput: GltfState.DebugOutput.transmission.TRANSMISSION_VOLUME, shaderDefine: "DEBUG_TRANSMISSION_VOLUME"},
            {debugOutput: GltfState.DebugOutput.transmission.TRANSMISSION_FACTOR, shaderDefine: "DEBUG_TRANSMISSION_FACTOR"},
            {debugOutput: GltfState.DebugOutput.transmission.VOLUME_THICKNESS, shaderDefine: "DEBUG_VOLUME_THICKNESS"},

            {debugOutput: GltfState.DebugOutput.diffuseTransmission.DIFFUSE_TRANSMISSION, shaderDefine: "DEBUG_DIFFUSE_TRANSMISSION"},
            {debugOutput: GltfState.DebugOutput.diffuseTransmission.DIFFUSE_TRANSMISSION_FACTOR, shaderDefine: "DEBUG_DIFFUSE_TRANSMISSION_FACTOR"},
            {debugOutput: GltfState.DebugOutput.diffuseTransmission.DIFFUSE_TRANSMISSION_COLOR_FACTOR, shaderDefine: "DEBUG_DIFFUSE_TRANSMISSION_COLOR_FACTOR"},

            {debugOutput: GltfState.DebugOutput.iridescence.IRIDESCENCE, shaderDefine: "DEBUG_IRIDESCENCE"},
            {debugOutput: GltfState.DebugOutput.iridescence.IRIDESCENCE_FACTOR, shaderDefine: "DEBUG_IRIDESCENCE_FACTOR"},
            {debugOutput: GltfState.DebugOutput.iridescence.IRIDESCENCE_THICKNESS, shaderDefine: "DEBUG_IRIDESCENCE_THICKNESS"},

            {debugOutput: GltfState.DebugOutput.anisotropy.ANISOTROPIC_STRENGTH, shaderDefine: "DEBUG_ANISOTROPIC_STRENGTH"},
            {debugOutput: GltfState.DebugOutput.anisotropy.ANISOTROPIC_DIRECTION, shaderDefine: "DEBUG_ANISOTROPIC_DIRECTION"},
        ];

        let mappingCount = 0;
        let mappingFound = false;
        for (let mapping of debugOutputMapping) {
            fragDefines.push(mapping.shaderDefine+" "+mappingCount++);
            if(state.renderingParameters.debugOutput == mapping.debugOutput){
                fragDefines.push("DEBUG "+mapping.shaderDefine);
                mappingFound = true;
            }
        }

        if(mappingFound == false) { // fallback
            fragDefines.push("DEBUG DEBUG_NONE");
        }

    }

    applyLights()
    {
        const uniforms = [];
        for (const [node, light] of this.visibleLights)
        {
            uniforms.push(light.toUniform(node));
        }
        if (uniforms.length > 0)
        {
            this.shader.updateUniform("u_Lights", uniforms);
        }
    }

    applyEnvironmentMap(state, texSlotOffset)
    {
        const environment = state.environment;
        if (environment === undefined) {
            return texSlotOffset;
        }
        this.webGl.setTexture(this.shader.getUniformLocation("u_LambertianEnvSampler"), environment, environment.diffuseEnvMap, texSlotOffset++);

        this.webGl.setTexture(this.shader.getUniformLocation("u_GGXEnvSampler"), environment, environment.specularEnvMap, texSlotOffset++);
        this.webGl.setTexture(this.shader.getUniformLocation("u_GGXLUT"), environment, environment.lut, texSlotOffset++);

        this.webGl.setTexture(this.shader.getUniformLocation("u_CharlieEnvSampler"), environment, environment.sheenEnvMap, texSlotOffset++);
        this.webGl.setTexture(this.shader.getUniformLocation("u_CharlieLUT"), environment, environment.sheenLUT, texSlotOffset++);

        this.shader.updateUniform("u_MipCount", environment.mipCount);

        let rotMatrix4 = create$3();
        rotateY(rotMatrix4, rotMatrix4,  state.renderingParameters.environmentRotation / 180.0 * Math.PI);
        let rotMatrix3 = create$4();
        fromMat4(rotMatrix3, rotMatrix4);
        this.shader.updateUniform("u_EnvRotation", rotMatrix3);

        let envIntensity = state.renderingParameters.iblIntensity * state.environment.iblIntensityScale;

        if(state.renderingParameters.useIBL === false) {
            envIntensity = 0.0;
        }

        this.shader.updateUniform("u_EnvIntensity", envIntensity);

        return texSlotOffset;
    }

    destroy()
    {
        this.shaderCache.destroy();
    }
}

class gltfBuffer extends GltfObject
{
    static animatedProperties = [];
    constructor()
    {
        super();
        this.uri = undefined;
        this.byteLength = undefined;
        this.name = undefined;

        // non gltf
        this.buffer = undefined; // raw data blob
    }

    load(gltf, additionalFiles = undefined)
    {
        if (this.buffer !== undefined)
        {
            console.error("buffer has already been loaded");
            return;
        }

        const self = this;
        return new Promise(function(resolve)
        {
            if (!self.setBufferFromFiles(additionalFiles, resolve) &&
                !self.setBufferFromUri(gltf, resolve))
            {
                resolve();
            }
        });
    }

    setBufferFromUri(gltf, callback)
    {
        if (this.uri === undefined)
        {
            return false;
        }
        const parentPath = this.uri.startsWith("data:") ? "" : getContainingFolder(gltf.path);
        fetch(parentPath + this.uri)
            .then(response => response.arrayBuffer())
            .then(buffer => {
                this.buffer = buffer;
                callback();
            });

        return true;
    }

    setBufferFromFiles(files, callback)
    {
        if (this.uri === undefined || files === undefined)
        {
            return false;
        }

        const foundFile = files.find(file => file[1].name === this.uri || file[1].fullPath === this.uri);

        if (foundFile === undefined)
        {
            return false;
        }

        const self = this;
        const reader = new FileReader();
        reader.onloadend = function(event)
        {
            self.buffer = event.target.result;
            callback();
        };
        reader.readAsArrayBuffer(foundFile[1]);

        return true;
    }
}

class gltfBufferView extends GltfObject
{
    static animatedProperties = [];
    constructor()
    {
        super();
        this.buffer = undefined;
        this.byteOffset = 0;
        this.byteLength = undefined;
        this.byteStride = 0;
        this.target = undefined;
        this.name = undefined;
    }
}

class AsyncFileReader
{
    static async readAsArrayBuffer(path) {
        return new Promise( (resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsArrayBuffer(path);
        });
    }

    static async readAsText(path) {
        return new Promise( (resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsText(path);
        });
    }

    static async readAsDataURL(path) {
        return new Promise( (resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(path);
        });
    }
}

var encoder$1 = {exports: {}};

/*
  Copyright (c) 2008, Adobe Systems Incorporated
  All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are
  met:

  * Redistributions of source code must retain the above copyright notice, 
    this list of conditions and the following disclaimer.
  
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the 
    documentation and/or other materials provided with the distribution.
  
  * Neither the name of Adobe Systems Incorporated nor the names of its 
    contributors may be used to endorse or promote products derived from 
    this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function (module) {

	function JPEGEncoder(quality) {
		var ffloor = Math.floor;
		var YTable = new Array(64);
		var UVTable = new Array(64);
		var fdtbl_Y = new Array(64);
		var fdtbl_UV = new Array(64);
		var YDC_HT;
		var UVDC_HT;
		var YAC_HT;
		var UVAC_HT;
		
		var bitcode = new Array(65535);
		var category = new Array(65535);
		var outputfDCTQuant = new Array(64);
		var DU = new Array(64);
		var byteout = [];
		var bytenew = 0;
		var bytepos = 7;
		
		var YDU = new Array(64);
		var UDU = new Array(64);
		var VDU = new Array(64);
		var clt = new Array(256);
		var RGB_YUV_TABLE = new Array(2048);
		var currentQuality;
		
		var ZigZag = [
				 0, 1, 5, 6,14,15,27,28,
				 2, 4, 7,13,16,26,29,42,
				 3, 8,12,17,25,30,41,43,
				 9,11,18,24,31,40,44,53,
				10,19,23,32,39,45,52,54,
				20,22,33,38,46,51,55,60,
				21,34,37,47,50,56,59,61,
				35,36,48,49,57,58,62,63
			];
		
		var std_dc_luminance_nrcodes = [0,0,1,5,1,1,1,1,1,1,0,0,0,0,0,0,0];
		var std_dc_luminance_values = [0,1,2,3,4,5,6,7,8,9,10,11];
		var std_ac_luminance_nrcodes = [0,0,2,1,3,3,2,4,3,5,5,4,4,0,0,1,0x7d];
		var std_ac_luminance_values = [
				0x01,0x02,0x03,0x00,0x04,0x11,0x05,0x12,
				0x21,0x31,0x41,0x06,0x13,0x51,0x61,0x07,
				0x22,0x71,0x14,0x32,0x81,0x91,0xa1,0x08,
				0x23,0x42,0xb1,0xc1,0x15,0x52,0xd1,0xf0,
				0x24,0x33,0x62,0x72,0x82,0x09,0x0a,0x16,
				0x17,0x18,0x19,0x1a,0x25,0x26,0x27,0x28,
				0x29,0x2a,0x34,0x35,0x36,0x37,0x38,0x39,
				0x3a,0x43,0x44,0x45,0x46,0x47,0x48,0x49,
				0x4a,0x53,0x54,0x55,0x56,0x57,0x58,0x59,
				0x5a,0x63,0x64,0x65,0x66,0x67,0x68,0x69,
				0x6a,0x73,0x74,0x75,0x76,0x77,0x78,0x79,
				0x7a,0x83,0x84,0x85,0x86,0x87,0x88,0x89,
				0x8a,0x92,0x93,0x94,0x95,0x96,0x97,0x98,
				0x99,0x9a,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,
				0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,0xb5,0xb6,
				0xb7,0xb8,0xb9,0xba,0xc2,0xc3,0xc4,0xc5,
				0xc6,0xc7,0xc8,0xc9,0xca,0xd2,0xd3,0xd4,
				0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xe1,0xe2,
				0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,
				0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,
				0xf9,0xfa
			];
		
		var std_dc_chrominance_nrcodes = [0,0,3,1,1,1,1,1,1,1,1,1,0,0,0,0,0];
		var std_dc_chrominance_values = [0,1,2,3,4,5,6,7,8,9,10,11];
		var std_ac_chrominance_nrcodes = [0,0,2,1,2,4,4,3,4,7,5,4,4,0,1,2,0x77];
		var std_ac_chrominance_values = [
				0x00,0x01,0x02,0x03,0x11,0x04,0x05,0x21,
				0x31,0x06,0x12,0x41,0x51,0x07,0x61,0x71,
				0x13,0x22,0x32,0x81,0x08,0x14,0x42,0x91,
				0xa1,0xb1,0xc1,0x09,0x23,0x33,0x52,0xf0,
				0x15,0x62,0x72,0xd1,0x0a,0x16,0x24,0x34,
				0xe1,0x25,0xf1,0x17,0x18,0x19,0x1a,0x26,
				0x27,0x28,0x29,0x2a,0x35,0x36,0x37,0x38,
				0x39,0x3a,0x43,0x44,0x45,0x46,0x47,0x48,
				0x49,0x4a,0x53,0x54,0x55,0x56,0x57,0x58,
				0x59,0x5a,0x63,0x64,0x65,0x66,0x67,0x68,
				0x69,0x6a,0x73,0x74,0x75,0x76,0x77,0x78,
				0x79,0x7a,0x82,0x83,0x84,0x85,0x86,0x87,
				0x88,0x89,0x8a,0x92,0x93,0x94,0x95,0x96,
				0x97,0x98,0x99,0x9a,0xa2,0xa3,0xa4,0xa5,
				0xa6,0xa7,0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,
				0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xc2,0xc3,
				0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xd2,
				0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,
				0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,
				0xea,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,
				0xf9,0xfa
			];
		
		function initQuantTables(sf){
				var YQT = [
					16, 11, 10, 16, 24, 40, 51, 61,
					12, 12, 14, 19, 26, 58, 60, 55,
					14, 13, 16, 24, 40, 57, 69, 56,
					14, 17, 22, 29, 51, 87, 80, 62,
					18, 22, 37, 56, 68,109,103, 77,
					24, 35, 55, 64, 81,104,113, 92,
					49, 64, 78, 87,103,121,120,101,
					72, 92, 95, 98,112,100,103, 99
				];
				
				for (var i = 0; i < 64; i++) {
					var t = ffloor((YQT[i]*sf+50)/100);
					if (t < 1) {
						t = 1;
					} else if (t > 255) {
						t = 255;
					}
					YTable[ZigZag[i]] = t;
				}
				var UVQT = [
					17, 18, 24, 47, 99, 99, 99, 99,
					18, 21, 26, 66, 99, 99, 99, 99,
					24, 26, 56, 99, 99, 99, 99, 99,
					47, 66, 99, 99, 99, 99, 99, 99,
					99, 99, 99, 99, 99, 99, 99, 99,
					99, 99, 99, 99, 99, 99, 99, 99,
					99, 99, 99, 99, 99, 99, 99, 99,
					99, 99, 99, 99, 99, 99, 99, 99
				];
				for (var j = 0; j < 64; j++) {
					var u = ffloor((UVQT[j]*sf+50)/100);
					if (u < 1) {
						u = 1;
					} else if (u > 255) {
						u = 255;
					}
					UVTable[ZigZag[j]] = u;
				}
				var aasf = [
					1.0, 1.387039845, 1.306562965, 1.175875602,
					1.0, 0.785694958, 0.541196100, 0.275899379
				];
				var k = 0;
				for (var row = 0; row < 8; row++)
				{
					for (var col = 0; col < 8; col++)
					{
						fdtbl_Y[k]  = (1.0 / (YTable [ZigZag[k]] * aasf[row] * aasf[col] * 8.0));
						fdtbl_UV[k] = (1.0 / (UVTable[ZigZag[k]] * aasf[row] * aasf[col] * 8.0));
						k++;
					}
				}
			}
			
			function computeHuffmanTbl(nrcodes, std_table){
				var codevalue = 0;
				var pos_in_table = 0;
				var HT = new Array();
				for (var k = 1; k <= 16; k++) {
					for (var j = 1; j <= nrcodes[k]; j++) {
						HT[std_table[pos_in_table]] = [];
						HT[std_table[pos_in_table]][0] = codevalue;
						HT[std_table[pos_in_table]][1] = k;
						pos_in_table++;
						codevalue++;
					}
					codevalue*=2;
				}
				return HT;
			}
			
			function initHuffmanTbl()
			{
				YDC_HT = computeHuffmanTbl(std_dc_luminance_nrcodes,std_dc_luminance_values);
				UVDC_HT = computeHuffmanTbl(std_dc_chrominance_nrcodes,std_dc_chrominance_values);
				YAC_HT = computeHuffmanTbl(std_ac_luminance_nrcodes,std_ac_luminance_values);
				UVAC_HT = computeHuffmanTbl(std_ac_chrominance_nrcodes,std_ac_chrominance_values);
			}
		
			function initCategoryNumber()
			{
				var nrlower = 1;
				var nrupper = 2;
				for (var cat = 1; cat <= 15; cat++) {
					//Positive numbers
					for (var nr = nrlower; nr<nrupper; nr++) {
						category[32767+nr] = cat;
						bitcode[32767+nr] = [];
						bitcode[32767+nr][1] = cat;
						bitcode[32767+nr][0] = nr;
					}
					//Negative numbers
					for (var nrneg =-(nrupper-1); nrneg<=-nrlower; nrneg++) {
						category[32767+nrneg] = cat;
						bitcode[32767+nrneg] = [];
						bitcode[32767+nrneg][1] = cat;
						bitcode[32767+nrneg][0] = nrupper-1+nrneg;
					}
					nrlower <<= 1;
					nrupper <<= 1;
				}
			}
			
			function initRGBYUVTable() {
				for(var i = 0; i < 256;i++) {
					RGB_YUV_TABLE[i]      		=  19595 * i;
					RGB_YUV_TABLE[(i+ 256)>>0] 	=  38470 * i;
					RGB_YUV_TABLE[(i+ 512)>>0] 	=   7471 * i + 0x8000;
					RGB_YUV_TABLE[(i+ 768)>>0] 	= -11059 * i;
					RGB_YUV_TABLE[(i+1024)>>0] 	= -21709 * i;
					RGB_YUV_TABLE[(i+1280)>>0] 	=  32768 * i + 0x807FFF;
					RGB_YUV_TABLE[(i+1536)>>0] 	= -27439 * i;
					RGB_YUV_TABLE[(i+1792)>>0] 	= - 5329 * i;
				}
			}
			
			// IO functions
			function writeBits(bs)
			{
				var value = bs[0];
				var posval = bs[1]-1;
				while ( posval >= 0 ) {
					if (value & (1 << posval) ) {
						bytenew |= (1 << bytepos);
					}
					posval--;
					bytepos--;
					if (bytepos < 0) {
						if (bytenew == 0xFF) {
							writeByte(0xFF);
							writeByte(0);
						}
						else {
							writeByte(bytenew);
						}
						bytepos=7;
						bytenew=0;
					}
				}
			}
		
			function writeByte(value)
			{
				//byteout.push(clt[value]); // write char directly instead of converting later
	      byteout.push(value);
			}
		
			function writeWord(value)
			{
				writeByte((value>>8)&0xFF);
				writeByte((value   )&0xFF);
			}
			
			// DCT & quantization core
			function fDCTQuant(data, fdtbl)
			{
				var d0, d1, d2, d3, d4, d5, d6, d7;
				/* Pass 1: process rows. */
				var dataOff=0;
				var i;
				var I8 = 8;
				var I64 = 64;
				for (i=0; i<I8; ++i)
				{
					d0 = data[dataOff];
					d1 = data[dataOff+1];
					d2 = data[dataOff+2];
					d3 = data[dataOff+3];
					d4 = data[dataOff+4];
					d5 = data[dataOff+5];
					d6 = data[dataOff+6];
					d7 = data[dataOff+7];
					
					var tmp0 = d0 + d7;
					var tmp7 = d0 - d7;
					var tmp1 = d1 + d6;
					var tmp6 = d1 - d6;
					var tmp2 = d2 + d5;
					var tmp5 = d2 - d5;
					var tmp3 = d3 + d4;
					var tmp4 = d3 - d4;
		
					/* Even part */
					var tmp10 = tmp0 + tmp3;	/* phase 2 */
					var tmp13 = tmp0 - tmp3;
					var tmp11 = tmp1 + tmp2;
					var tmp12 = tmp1 - tmp2;
		
					data[dataOff] = tmp10 + tmp11; /* phase 3 */
					data[dataOff+4] = tmp10 - tmp11;
		
					var z1 = (tmp12 + tmp13) * 0.707106781; /* c4 */
					data[dataOff+2] = tmp13 + z1; /* phase 5 */
					data[dataOff+6] = tmp13 - z1;
		
					/* Odd part */
					tmp10 = tmp4 + tmp5; /* phase 2 */
					tmp11 = tmp5 + tmp6;
					tmp12 = tmp6 + tmp7;
		
					/* The rotator is modified from fig 4-8 to avoid extra negations. */
					var z5 = (tmp10 - tmp12) * 0.382683433; /* c6 */
					var z2 = 0.541196100 * tmp10 + z5; /* c2-c6 */
					var z4 = 1.306562965 * tmp12 + z5; /* c2+c6 */
					var z3 = tmp11 * 0.707106781; /* c4 */
		
					var z11 = tmp7 + z3;	/* phase 5 */
					var z13 = tmp7 - z3;
		
					data[dataOff+5] = z13 + z2;	/* phase 6 */
					data[dataOff+3] = z13 - z2;
					data[dataOff+1] = z11 + z4;
					data[dataOff+7] = z11 - z4;
		
					dataOff += 8; /* advance pointer to next row */
				}
		
				/* Pass 2: process columns. */
				dataOff = 0;
				for (i=0; i<I8; ++i)
				{
					d0 = data[dataOff];
					d1 = data[dataOff + 8];
					d2 = data[dataOff + 16];
					d3 = data[dataOff + 24];
					d4 = data[dataOff + 32];
					d5 = data[dataOff + 40];
					d6 = data[dataOff + 48];
					d7 = data[dataOff + 56];
					
					var tmp0p2 = d0 + d7;
					var tmp7p2 = d0 - d7;
					var tmp1p2 = d1 + d6;
					var tmp6p2 = d1 - d6;
					var tmp2p2 = d2 + d5;
					var tmp5p2 = d2 - d5;
					var tmp3p2 = d3 + d4;
					var tmp4p2 = d3 - d4;
		
					/* Even part */
					var tmp10p2 = tmp0p2 + tmp3p2;	/* phase 2 */
					var tmp13p2 = tmp0p2 - tmp3p2;
					var tmp11p2 = tmp1p2 + tmp2p2;
					var tmp12p2 = tmp1p2 - tmp2p2;
		
					data[dataOff] = tmp10p2 + tmp11p2; /* phase 3 */
					data[dataOff+32] = tmp10p2 - tmp11p2;
		
					var z1p2 = (tmp12p2 + tmp13p2) * 0.707106781; /* c4 */
					data[dataOff+16] = tmp13p2 + z1p2; /* phase 5 */
					data[dataOff+48] = tmp13p2 - z1p2;
		
					/* Odd part */
					tmp10p2 = tmp4p2 + tmp5p2; /* phase 2 */
					tmp11p2 = tmp5p2 + tmp6p2;
					tmp12p2 = tmp6p2 + tmp7p2;
		
					/* The rotator is modified from fig 4-8 to avoid extra negations. */
					var z5p2 = (tmp10p2 - tmp12p2) * 0.382683433; /* c6 */
					var z2p2 = 0.541196100 * tmp10p2 + z5p2; /* c2-c6 */
					var z4p2 = 1.306562965 * tmp12p2 + z5p2; /* c2+c6 */
					var z3p2 = tmp11p2 * 0.707106781; /* c4 */
		
					var z11p2 = tmp7p2 + z3p2;	/* phase 5 */
					var z13p2 = tmp7p2 - z3p2;
		
					data[dataOff+40] = z13p2 + z2p2; /* phase 6 */
					data[dataOff+24] = z13p2 - z2p2;
					data[dataOff+ 8] = z11p2 + z4p2;
					data[dataOff+56] = z11p2 - z4p2;
		
					dataOff++; /* advance pointer to next column */
				}
		
				// Quantize/descale the coefficients
				var fDCTQuant;
				for (i=0; i<I64; ++i)
				{
					// Apply the quantization and scaling factor & Round to nearest integer
					fDCTQuant = data[i]*fdtbl[i];
					outputfDCTQuant[i] = (fDCTQuant > 0.0) ? ((fDCTQuant + 0.5)|0) : ((fDCTQuant - 0.5)|0);
					//outputfDCTQuant[i] = fround(fDCTQuant);

				}
				return outputfDCTQuant;
			}
			
			function writeAPP0()
			{
				writeWord(0xFFE0); // marker
				writeWord(16); // length
				writeByte(0x4A); // J
				writeByte(0x46); // F
				writeByte(0x49); // I
				writeByte(0x46); // F
				writeByte(0); // = "JFIF",'\0'
				writeByte(1); // versionhi
				writeByte(1); // versionlo
				writeByte(0); // xyunits
				writeWord(1); // xdensity
				writeWord(1); // ydensity
				writeByte(0); // thumbnwidth
				writeByte(0); // thumbnheight
			}

			function writeAPP1(exifBuffer) {
				if (!exifBuffer) return;

				writeWord(0xFFE1); // APP1 marker

				if (exifBuffer[0] === 0x45 &&
						exifBuffer[1] === 0x78 &&
						exifBuffer[2] === 0x69 &&
						exifBuffer[3] === 0x66) {
					// Buffer already starts with EXIF, just use it directly
					writeWord(exifBuffer.length + 2); // length is buffer + length itself!
				} else {
					// Buffer doesn't start with EXIF, write it for them
					writeWord(exifBuffer.length + 5 + 2); // length is buffer + EXIF\0 + length itself!
					writeByte(0x45); // E
					writeByte(0x78); // X
					writeByte(0x69); // I
					writeByte(0x66); // F
					writeByte(0); // = "EXIF",'\0'
				}

				for (var i = 0; i < exifBuffer.length; i++) {
					writeByte(exifBuffer[i]);
				}
			}

			function writeSOF0(width, height)
			{
				writeWord(0xFFC0); // marker
				writeWord(17);   // length, truecolor YUV JPG
				writeByte(8);    // precision
				writeWord(height);
				writeWord(width);
				writeByte(3);    // nrofcomponents
				writeByte(1);    // IdY
				writeByte(0x11); // HVY
				writeByte(0);    // QTY
				writeByte(2);    // IdU
				writeByte(0x11); // HVU
				writeByte(1);    // QTU
				writeByte(3);    // IdV
				writeByte(0x11); // HVV
				writeByte(1);    // QTV
			}
		
			function writeDQT()
			{
				writeWord(0xFFDB); // marker
				writeWord(132);	   // length
				writeByte(0);
				for (var i=0; i<64; i++) {
					writeByte(YTable[i]);
				}
				writeByte(1);
				for (var j=0; j<64; j++) {
					writeByte(UVTable[j]);
				}
			}
		
			function writeDHT()
			{
				writeWord(0xFFC4); // marker
				writeWord(0x01A2); // length
		
				writeByte(0); // HTYDCinfo
				for (var i=0; i<16; i++) {
					writeByte(std_dc_luminance_nrcodes[i+1]);
				}
				for (var j=0; j<=11; j++) {
					writeByte(std_dc_luminance_values[j]);
				}
		
				writeByte(0x10); // HTYACinfo
				for (var k=0; k<16; k++) {
					writeByte(std_ac_luminance_nrcodes[k+1]);
				}
				for (var l=0; l<=161; l++) {
					writeByte(std_ac_luminance_values[l]);
				}
		
				writeByte(1); // HTUDCinfo
				for (var m=0; m<16; m++) {
					writeByte(std_dc_chrominance_nrcodes[m+1]);
				}
				for (var n=0; n<=11; n++) {
					writeByte(std_dc_chrominance_values[n]);
				}
		
				writeByte(0x11); // HTUACinfo
				for (var o=0; o<16; o++) {
					writeByte(std_ac_chrominance_nrcodes[o+1]);
				}
				for (var p=0; p<=161; p++) {
					writeByte(std_ac_chrominance_values[p]);
				}
			}
			
			function writeCOM(comments)
			{
				if (typeof comments === "undefined" || comments.constructor !== Array) return;
				comments.forEach(e => {
					if (typeof e !== "string") return;
					writeWord(0xFFFE); // marker
					var l = e.length;
					writeWord(l + 2); // length itself as well
					var i;
					for (i = 0; i < l; i++)
						writeByte(e.charCodeAt(i));
				});
			}
		
			function writeSOS()
			{
				writeWord(0xFFDA); // marker
				writeWord(12); // length
				writeByte(3); // nrofcomponents
				writeByte(1); // IdY
				writeByte(0); // HTY
				writeByte(2); // IdU
				writeByte(0x11); // HTU
				writeByte(3); // IdV
				writeByte(0x11); // HTV
				writeByte(0); // Ss
				writeByte(0x3f); // Se
				writeByte(0); // Bf
			}
			
			function processDU(CDU, fdtbl, DC, HTDC, HTAC){
				var EOB = HTAC[0x00];
				var M16zeroes = HTAC[0xF0];
				var pos;
				var I16 = 16;
				var I63 = 63;
				var I64 = 64;
				var DU_DCT = fDCTQuant(CDU, fdtbl);
				//ZigZag reorder
				for (var j=0;j<I64;++j) {
					DU[ZigZag[j]]=DU_DCT[j];
				}
				var Diff = DU[0] - DC; DC = DU[0];
				//Encode DC
				if (Diff==0) {
					writeBits(HTDC[0]); // Diff might be 0
				} else {
					pos = 32767+Diff;
					writeBits(HTDC[category[pos]]);
					writeBits(bitcode[pos]);
				}
				//Encode ACs
				var end0pos = 63; // was const... which is crazy
				for (; (end0pos>0)&&(DU[end0pos]==0); end0pos--) {}				//end0pos = first element in reverse order !=0
				if ( end0pos == 0) {
					writeBits(EOB);
					return DC;
				}
				var i = 1;
				var lng;
				while ( i <= end0pos ) {
					var startpos = i;
					for (; (DU[i]==0) && (i<=end0pos); ++i) {}
					var nrzeroes = i-startpos;
					if ( nrzeroes >= I16 ) {
						lng = nrzeroes>>4;
						for (var nrmarker=1; nrmarker <= lng; ++nrmarker)
							writeBits(M16zeroes);
						nrzeroes = nrzeroes&0xF;
					}
					pos = 32767+DU[i];
					writeBits(HTAC[(nrzeroes<<4)+category[pos]]);
					writeBits(bitcode[pos]);
					i++;
				}
				if ( end0pos != I63 ) {
					writeBits(EOB);
				}
				return DC;
			}

			function initCharLookupTable(){
				var sfcc = String.fromCharCode;
				for(var i=0; i < 256; i++){ ///// ACHTUNG // 255
					clt[i] = sfcc(i);
				}
			}
			
			this.encode = function(image,quality) // image data object
			{
				new Date().getTime();
				
				if(quality) setQuality(quality);
				
				// Initialize bit writer
				byteout = new Array();
				bytenew=0;
				bytepos=7;
		
				// Add JPEG headers
				writeWord(0xFFD8); // SOI
				writeAPP0();
				writeCOM(image.comments);
				writeAPP1(image.exifBuffer);
				writeDQT();
				writeSOF0(image.width,image.height);
				writeDHT();
				writeSOS();

		
				// Encode 8x8 macroblocks
				var DCY=0;
				var DCU=0;
				var DCV=0;
				
				bytenew=0;
				bytepos=7;
				
				
				this.encode.displayName = "_encode_";

				var imageData = image.data;
				var width = image.width;
				var height = image.height;

				var quadWidth = width*4;
				
				var x, y = 0;
				var r, g, b;
				var start,p, col,row,pos;
				while(y < height){
					x = 0;
					while(x < quadWidth){
					start = quadWidth * y + x;
					p = start;
					col = -1;
					row = 0;
					
					for(pos=0; pos < 64; pos++){
						row = pos >> 3;// /8
						col = ( pos & 7 ) * 4; // %8
						p = start + ( row * quadWidth ) + col;		
						
						if(y+row >= height){ // padding bottom
							p-= (quadWidth*(y+1+row-height));
						}

						if(x+col >= quadWidth){ // padding right	
							p-= ((x+col) - quadWidth +4);
						}
						
						r = imageData[ p++ ];
						g = imageData[ p++ ];
						b = imageData[ p++ ];
						
						
						/* // calculate YUV values dynamically
						YDU[pos]=((( 0.29900)*r+( 0.58700)*g+( 0.11400)*b))-128; //-0x80
						UDU[pos]=(((-0.16874)*r+(-0.33126)*g+( 0.50000)*b));
						VDU[pos]=((( 0.50000)*r+(-0.41869)*g+(-0.08131)*b));
						*/
						
						// use lookup table (slightly faster)
						YDU[pos] = ((RGB_YUV_TABLE[r]             + RGB_YUV_TABLE[(g +  256)>>0] + RGB_YUV_TABLE[(b +  512)>>0]) >> 16)-128;
						UDU[pos] = ((RGB_YUV_TABLE[(r +  768)>>0] + RGB_YUV_TABLE[(g + 1024)>>0] + RGB_YUV_TABLE[(b + 1280)>>0]) >> 16)-128;
						VDU[pos] = ((RGB_YUV_TABLE[(r + 1280)>>0] + RGB_YUV_TABLE[(g + 1536)>>0] + RGB_YUV_TABLE[(b + 1792)>>0]) >> 16)-128;

					}
					
					DCY = processDU(YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT);
					DCU = processDU(UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);
					DCV = processDU(VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);
					x+=32;
					}
					y+=8;
				}
				
				
				////////////////////////////////////////////////////////////////
		
				// Do the bit alignment of the EOI marker
				if ( bytepos >= 0 ) {
					var fillbits = [];
					fillbits[1] = bytepos+1;
					fillbits[0] = (1<<(bytepos+1))-1;
					writeBits(fillbits);
				}
		
				writeWord(0xFFD9); //EOI
	      return Buffer.from(byteout);
		};
		
		function setQuality(quality){
			if (quality <= 0) {
				quality = 1;
			}
			if (quality > 100) {
				quality = 100;
			}
			
			if(currentQuality == quality) return // don't recalc if unchanged
			
			var sf = 0;
			if (quality < 50) {
				sf = Math.floor(5000 / quality);
			} else {
				sf = Math.floor(200 - quality*2);
			}
			
			initQuantTables(sf);
			currentQuality = quality;
			//console.log('Quality set to: '+quality +'%');
		}
		
		function init(){
			var time_start = new Date().getTime();
			if(!quality) quality = 50;
			// Create tables
			initCharLookupTable();
			initHuffmanTbl();
			initCategoryNumber();
			initRGBYUVTable();
			
			setQuality(quality);
			new Date().getTime() - time_start;
	    	//console.log('Initialization '+ duration + 'ms');
		}
		
		init();
		
	}
	{
		module.exports = encode;
	}

	function encode(imgData, qu) {
	  if (typeof qu === 'undefined') qu = 50;
	  var encoder = new JPEGEncoder(qu);
		var data = encoder.encode(imgData, qu);
	  return {
	    data: data,
	    width: imgData.width,
	    height: imgData.height,
	  };
	}
} (encoder$1));

var encoderExports = encoder$1.exports;

var decoder$1 = {exports: {}};

/* -*- tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- /
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */

(function (module) {
	/*
	   Copyright 2011 notmasteryet

	   Licensed under the Apache License, Version 2.0 (the "License");
	   you may not use this file except in compliance with the License.
	   You may obtain a copy of the License at

	       http://www.apache.org/licenses/LICENSE-2.0

	   Unless required by applicable law or agreed to in writing, software
	   distributed under the License is distributed on an "AS IS" BASIS,
	   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	   See the License for the specific language governing permissions and
	   limitations under the License.
	*/

	// - The JPEG specification can be found in the ITU CCITT Recommendation T.81
	//   (www.w3.org/Graphics/JPEG/itu-t81.pdf)
	// - The JFIF specification can be found in the JPEG File Interchange Format
	//   (www.w3.org/Graphics/JPEG/jfif3.pdf)
	// - The Adobe Application-Specific JPEG markers in the Supporting the DCT Filters
	//   in PostScript Level 2, Technical Note #5116
	//   (partners.adobe.com/public/developer/en/ps/sdk/5116.DCT_Filter.pdf)

	var JpegImage = (function jpegImage() {
	  var dctZigZag = new Int32Array([
	     0,
	     1,  8,
	    16,  9,  2,
	     3, 10, 17, 24,
	    32, 25, 18, 11, 4,
	     5, 12, 19, 26, 33, 40,
	    48, 41, 34, 27, 20, 13,  6,
	     7, 14, 21, 28, 35, 42, 49, 56,
	    57, 50, 43, 36, 29, 22, 15,
	    23, 30, 37, 44, 51, 58,
	    59, 52, 45, 38, 31,
	    39, 46, 53, 60,
	    61, 54, 47,
	    55, 62,
	    63
	  ]);

	  var dctCos1  =  4017;   // cos(pi/16)
	  var dctSin1  =   799;   // sin(pi/16)
	  var dctCos3  =  3406;   // cos(3*pi/16)
	  var dctSin3  =  2276;   // sin(3*pi/16)
	  var dctCos6  =  1567;   // cos(6*pi/16)
	  var dctSin6  =  3784;   // sin(6*pi/16)
	  var dctSqrt2 =  5793;   // sqrt(2)
	  var dctSqrt1d2 = 2896;  // sqrt(2) / 2

	  function constructor() {
	  }

	  function buildHuffmanTable(codeLengths, values) {
	    var k = 0, code = [], i, j, length = 16;
	    while (length > 0 && !codeLengths[length - 1])
	      length--;
	    code.push({children: [], index: 0});
	    var p = code[0], q;
	    for (i = 0; i < length; i++) {
	      for (j = 0; j < codeLengths[i]; j++) {
	        p = code.pop();
	        p.children[p.index] = values[k];
	        while (p.index > 0) {
	          if (code.length === 0)
	            throw new Error('Could not recreate Huffman Table');
	          p = code.pop();
	        }
	        p.index++;
	        code.push(p);
	        while (code.length <= i) {
	          code.push(q = {children: [], index: 0});
	          p.children[p.index] = q.children;
	          p = q;
	        }
	        k++;
	      }
	      if (i + 1 < length) {
	        // p here points to last code
	        code.push(q = {children: [], index: 0});
	        p.children[p.index] = q.children;
	        p = q;
	      }
	    }
	    return code[0].children;
	  }

	  function decodeScan(data, offset,
	                      frame, components, resetInterval,
	                      spectralStart, spectralEnd,
	                      successivePrev, successive, opts) {
	    frame.precision;
	    frame.samplesPerLine;
	    frame.scanLines;
	    var mcusPerLine = frame.mcusPerLine;
	    var progressive = frame.progressive;
	    frame.maxH; frame.maxV;

	    var startOffset = offset, bitsData = 0, bitsCount = 0;
	    function readBit() {
	      if (bitsCount > 0) {
	        bitsCount--;
	        return (bitsData >> bitsCount) & 1;
	      }
	      bitsData = data[offset++];
	      if (bitsData == 0xFF) {
	        var nextByte = data[offset++];
	        if (nextByte) {
	          throw new Error("unexpected marker: " + ((bitsData << 8) | nextByte).toString(16));
	        }
	        // unstuff 0
	      }
	      bitsCount = 7;
	      return bitsData >>> 7;
	    }
	    function decodeHuffman(tree) {
	      var node = tree, bit;
	      while ((bit = readBit()) !== null) {
	        node = node[bit];
	        if (typeof node === 'number')
	          return node;
	        if (typeof node !== 'object')
	          throw new Error("invalid huffman sequence");
	      }
	      return null;
	    }
	    function receive(length) {
	      var n = 0;
	      while (length > 0) {
	        var bit = readBit();
	        if (bit === null) return;
	        n = (n << 1) | bit;
	        length--;
	      }
	      return n;
	    }
	    function receiveAndExtend(length) {
	      var n = receive(length);
	      if (n >= 1 << (length - 1))
	        return n;
	      return n + (-1 << length) + 1;
	    }
	    function decodeBaseline(component, zz) {
	      var t = decodeHuffman(component.huffmanTableDC);
	      var diff = t === 0 ? 0 : receiveAndExtend(t);
	      zz[0]= (component.pred += diff);
	      var k = 1;
	      while (k < 64) {
	        var rs = decodeHuffman(component.huffmanTableAC);
	        var s = rs & 15, r = rs >> 4;
	        if (s === 0) {
	          if (r < 15)
	            break;
	          k += 16;
	          continue;
	        }
	        k += r;
	        var z = dctZigZag[k];
	        zz[z] = receiveAndExtend(s);
	        k++;
	      }
	    }
	    function decodeDCFirst(component, zz) {
	      var t = decodeHuffman(component.huffmanTableDC);
	      var diff = t === 0 ? 0 : (receiveAndExtend(t) << successive);
	      zz[0] = (component.pred += diff);
	    }
	    function decodeDCSuccessive(component, zz) {
	      zz[0] |= readBit() << successive;
	    }
	    var eobrun = 0;
	    function decodeACFirst(component, zz) {
	      if (eobrun > 0) {
	        eobrun--;
	        return;
	      }
	      var k = spectralStart, e = spectralEnd;
	      while (k <= e) {
	        var rs = decodeHuffman(component.huffmanTableAC);
	        var s = rs & 15, r = rs >> 4;
	        if (s === 0) {
	          if (r < 15) {
	            eobrun = receive(r) + (1 << r) - 1;
	            break;
	          }
	          k += 16;
	          continue;
	        }
	        k += r;
	        var z = dctZigZag[k];
	        zz[z] = receiveAndExtend(s) * (1 << successive);
	        k++;
	      }
	    }
	    var successiveACState = 0, successiveACNextValue;
	    function decodeACSuccessive(component, zz) {
	      var k = spectralStart, e = spectralEnd, r = 0;
	      while (k <= e) {
	        var z = dctZigZag[k];
	        var direction = zz[z] < 0 ? -1 : 1;
	        switch (successiveACState) {
	        case 0: // initial state
	          var rs = decodeHuffman(component.huffmanTableAC);
	          var s = rs & 15, r = rs >> 4;
	          if (s === 0) {
	            if (r < 15) {
	              eobrun = receive(r) + (1 << r);
	              successiveACState = 4;
	            } else {
	              r = 16;
	              successiveACState = 1;
	            }
	          } else {
	            if (s !== 1)
	              throw new Error("invalid ACn encoding");
	            successiveACNextValue = receiveAndExtend(s);
	            successiveACState = r ? 2 : 3;
	          }
	          continue;
	        case 1: // skipping r zero items
	        case 2:
	          if (zz[z])
	            zz[z] += (readBit() << successive) * direction;
	          else {
	            r--;
	            if (r === 0)
	              successiveACState = successiveACState == 2 ? 3 : 0;
	          }
	          break;
	        case 3: // set value for a zero item
	          if (zz[z])
	            zz[z] += (readBit() << successive) * direction;
	          else {
	            zz[z] = successiveACNextValue << successive;
	            successiveACState = 0;
	          }
	          break;
	        case 4: // eob
	          if (zz[z])
	            zz[z] += (readBit() << successive) * direction;
	          break;
	        }
	        k++;
	      }
	      if (successiveACState === 4) {
	        eobrun--;
	        if (eobrun === 0)
	          successiveACState = 0;
	      }
	    }
	    function decodeMcu(component, decode, mcu, row, col) {
	      var mcuRow = (mcu / mcusPerLine) | 0;
	      var mcuCol = mcu % mcusPerLine;
	      var blockRow = mcuRow * component.v + row;
	      var blockCol = mcuCol * component.h + col;
	      // If the block is missing and we're in tolerant mode, just skip it.
	      if (component.blocks[blockRow] === undefined && opts.tolerantDecoding)
	        return;
	      decode(component, component.blocks[blockRow][blockCol]);
	    }
	    function decodeBlock(component, decode, mcu) {
	      var blockRow = (mcu / component.blocksPerLine) | 0;
	      var blockCol = mcu % component.blocksPerLine;
	      // If the block is missing and we're in tolerant mode, just skip it.
	      if (component.blocks[blockRow] === undefined && opts.tolerantDecoding)
	        return;
	      decode(component, component.blocks[blockRow][blockCol]);
	    }

	    var componentsLength = components.length;
	    var component, i, j, k, n;
	    var decodeFn;
	    if (progressive) {
	      if (spectralStart === 0)
	        decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
	      else
	        decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
	    } else {
	      decodeFn = decodeBaseline;
	    }

	    var mcu = 0, marker;
	    var mcuExpected;
	    if (componentsLength == 1) {
	      mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
	    } else {
	      mcuExpected = mcusPerLine * frame.mcusPerColumn;
	    }
	    if (!resetInterval) resetInterval = mcuExpected;

	    var h, v;
	    while (mcu < mcuExpected) {
	      // reset interval stuff
	      for (i = 0; i < componentsLength; i++)
	        components[i].pred = 0;
	      eobrun = 0;

	      if (componentsLength == 1) {
	        component = components[0];
	        for (n = 0; n < resetInterval; n++) {
	          decodeBlock(component, decodeFn, mcu);
	          mcu++;
	        }
	      } else {
	        for (n = 0; n < resetInterval; n++) {
	          for (i = 0; i < componentsLength; i++) {
	            component = components[i];
	            h = component.h;
	            v = component.v;
	            for (j = 0; j < v; j++) {
	              for (k = 0; k < h; k++) {
	                decodeMcu(component, decodeFn, mcu, j, k);
	              }
	            }
	          }
	          mcu++;

	          // If we've reached our expected MCU's, stop decoding
	          if (mcu === mcuExpected) break;
	        }
	      }

	      if (mcu === mcuExpected) {
	        // Skip trailing bytes at the end of the scan - until we reach the next marker
	        do {
	          if (data[offset] === 0xFF) {
	            if (data[offset + 1] !== 0x00) {
	              break;
	            }
	          }
	          offset += 1;
	        } while (offset < data.length - 2);
	      }

	      // find marker
	      bitsCount = 0;
	      marker = (data[offset] << 8) | data[offset + 1];
	      if (marker < 0xFF00) {
	        throw new Error("marker was not found");
	      }

	      if (marker >= 0xFFD0 && marker <= 0xFFD7) { // RSTx
	        offset += 2;
	      }
	      else
	        break;
	    }

	    return offset - startOffset;
	  }

	  function buildComponentData(frame, component) {
	    var lines = [];
	    var blocksPerLine = component.blocksPerLine;
	    var blocksPerColumn = component.blocksPerColumn;
	    var samplesPerLine = blocksPerLine << 3;
	    // Only 1 used per invocation of this function and garbage collected after invocation, so no need to account for its memory footprint.
	    var R = new Int32Array(64), r = new Uint8Array(64);

	    // A port of poppler's IDCT method which in turn is taken from:
	    //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,
	    //   "Practical Fast 1-D DCT Algorithms with 11 Multiplications",
	    //   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,
	    //   988-991.
	    function quantizeAndInverse(zz, dataOut, dataIn) {
	      var qt = component.quantizationTable;
	      var v0, v1, v2, v3, v4, v5, v6, v7, t;
	      var p = dataIn;
	      var i;

	      // dequant
	      for (i = 0; i < 64; i++)
	        p[i] = zz[i] * qt[i];

	      // inverse DCT on rows
	      for (i = 0; i < 8; ++i) {
	        var row = 8 * i;

	        // check for all-zero AC coefficients
	        if (p[1 + row] == 0 && p[2 + row] == 0 && p[3 + row] == 0 &&
	            p[4 + row] == 0 && p[5 + row] == 0 && p[6 + row] == 0 &&
	            p[7 + row] == 0) {
	          t = (dctSqrt2 * p[0 + row] + 512) >> 10;
	          p[0 + row] = t;
	          p[1 + row] = t;
	          p[2 + row] = t;
	          p[3 + row] = t;
	          p[4 + row] = t;
	          p[5 + row] = t;
	          p[6 + row] = t;
	          p[7 + row] = t;
	          continue;
	        }

	        // stage 4
	        v0 = (dctSqrt2 * p[0 + row] + 128) >> 8;
	        v1 = (dctSqrt2 * p[4 + row] + 128) >> 8;
	        v2 = p[2 + row];
	        v3 = p[6 + row];
	        v4 = (dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128) >> 8;
	        v7 = (dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128) >> 8;
	        v5 = p[3 + row] << 4;
	        v6 = p[5 + row] << 4;

	        // stage 3
	        t = (v0 - v1+ 1) >> 1;
	        v0 = (v0 + v1 + 1) >> 1;
	        v1 = t;
	        t = (v2 * dctSin6 + v3 * dctCos6 + 128) >> 8;
	        v2 = (v2 * dctCos6 - v3 * dctSin6 + 128) >> 8;
	        v3 = t;
	        t = (v4 - v6 + 1) >> 1;
	        v4 = (v4 + v6 + 1) >> 1;
	        v6 = t;
	        t = (v7 + v5 + 1) >> 1;
	        v5 = (v7 - v5 + 1) >> 1;
	        v7 = t;

	        // stage 2
	        t = (v0 - v3 + 1) >> 1;
	        v0 = (v0 + v3 + 1) >> 1;
	        v3 = t;
	        t = (v1 - v2 + 1) >> 1;
	        v1 = (v1 + v2 + 1) >> 1;
	        v2 = t;
	        t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;
	        v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;
	        v7 = t;
	        t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;
	        v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;
	        v6 = t;

	        // stage 1
	        p[0 + row] = v0 + v7;
	        p[7 + row] = v0 - v7;
	        p[1 + row] = v1 + v6;
	        p[6 + row] = v1 - v6;
	        p[2 + row] = v2 + v5;
	        p[5 + row] = v2 - v5;
	        p[3 + row] = v3 + v4;
	        p[4 + row] = v3 - v4;
	      }

	      // inverse DCT on columns
	      for (i = 0; i < 8; ++i) {
	        var col = i;

	        // check for all-zero AC coefficients
	        if (p[1*8 + col] == 0 && p[2*8 + col] == 0 && p[3*8 + col] == 0 &&
	            p[4*8 + col] == 0 && p[5*8 + col] == 0 && p[6*8 + col] == 0 &&
	            p[7*8 + col] == 0) {
	          t = (dctSqrt2 * dataIn[i+0] + 8192) >> 14;
	          p[0*8 + col] = t;
	          p[1*8 + col] = t;
	          p[2*8 + col] = t;
	          p[3*8 + col] = t;
	          p[4*8 + col] = t;
	          p[5*8 + col] = t;
	          p[6*8 + col] = t;
	          p[7*8 + col] = t;
	          continue;
	        }

	        // stage 4
	        v0 = (dctSqrt2 * p[0*8 + col] + 2048) >> 12;
	        v1 = (dctSqrt2 * p[4*8 + col] + 2048) >> 12;
	        v2 = p[2*8 + col];
	        v3 = p[6*8 + col];
	        v4 = (dctSqrt1d2 * (p[1*8 + col] - p[7*8 + col]) + 2048) >> 12;
	        v7 = (dctSqrt1d2 * (p[1*8 + col] + p[7*8 + col]) + 2048) >> 12;
	        v5 = p[3*8 + col];
	        v6 = p[5*8 + col];

	        // stage 3
	        t = (v0 - v1 + 1) >> 1;
	        v0 = (v0 + v1 + 1) >> 1;
	        v1 = t;
	        t = (v2 * dctSin6 + v3 * dctCos6 + 2048) >> 12;
	        v2 = (v2 * dctCos6 - v3 * dctSin6 + 2048) >> 12;
	        v3 = t;
	        t = (v4 - v6 + 1) >> 1;
	        v4 = (v4 + v6 + 1) >> 1;
	        v6 = t;
	        t = (v7 + v5 + 1) >> 1;
	        v5 = (v7 - v5 + 1) >> 1;
	        v7 = t;

	        // stage 2
	        t = (v0 - v3 + 1) >> 1;
	        v0 = (v0 + v3 + 1) >> 1;
	        v3 = t;
	        t = (v1 - v2 + 1) >> 1;
	        v1 = (v1 + v2 + 1) >> 1;
	        v2 = t;
	        t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;
	        v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;
	        v7 = t;
	        t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;
	        v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;
	        v6 = t;

	        // stage 1
	        p[0*8 + col] = v0 + v7;
	        p[7*8 + col] = v0 - v7;
	        p[1*8 + col] = v1 + v6;
	        p[6*8 + col] = v1 - v6;
	        p[2*8 + col] = v2 + v5;
	        p[5*8 + col] = v2 - v5;
	        p[3*8 + col] = v3 + v4;
	        p[4*8 + col] = v3 - v4;
	      }

	      // convert to 8-bit integers
	      for (i = 0; i < 64; ++i) {
	        var sample = 128 + ((p[i] + 8) >> 4);
	        dataOut[i] = sample < 0 ? 0 : sample > 0xFF ? 0xFF : sample;
	      }
	    }

	    requestMemoryAllocation(samplesPerLine * blocksPerColumn * 8);

	    var i, j;
	    for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
	      var scanLine = blockRow << 3;
	      for (i = 0; i < 8; i++)
	        lines.push(new Uint8Array(samplesPerLine));
	      for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
	        quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);

	        var offset = 0, sample = blockCol << 3;
	        for (j = 0; j < 8; j++) {
	          var line = lines[scanLine + j];
	          for (i = 0; i < 8; i++)
	            line[sample + i] = r[offset++];
	        }
	      }
	    }
	    return lines;
	  }

	  function clampTo8bit(a) {
	    return a < 0 ? 0 : a > 255 ? 255 : a;
	  }

	  constructor.prototype = {
	    load: function load(path) {
	      var xhr = new XMLHttpRequest();
	      xhr.open("GET", path, true);
	      xhr.responseType = "arraybuffer";
	      xhr.onload = (function() {
	        // TODO catch parse error
	        var data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);
	        this.parse(data);
	        if (this.onload)
	          this.onload();
	      }).bind(this);
	      xhr.send(null);
	    },
	    parse: function parse(data) {
	      var maxResolutionInPixels = this.opts.maxResolutionInMP * 1000 * 1000;
	      var offset = 0; data.length;
	      function readUint16() {
	        var value = (data[offset] << 8) | data[offset + 1];
	        offset += 2;
	        return value;
	      }
	      function readDataBlock() {
	        var length = readUint16();
	        var array = data.subarray(offset, offset + length - 2);
	        offset += array.length;
	        return array;
	      }
	      function prepareComponents(frame) {
	        // According to the JPEG standard, the sampling factor must be between 1 and 4
	        // See https://github.com/libjpeg-turbo/libjpeg-turbo/blob/9abeff46d87bd201a952e276f3e4339556a403a3/libjpeg.txt#L1138-L1146
	        var maxH = 1, maxV = 1;
	        var component, componentId;
	        for (componentId in frame.components) {
	          if (frame.components.hasOwnProperty(componentId)) {
	            component = frame.components[componentId];
	            if (maxH < component.h) maxH = component.h;
	            if (maxV < component.v) maxV = component.v;
	          }
	        }
	        var mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / maxH);
	        var mcusPerColumn = Math.ceil(frame.scanLines / 8 / maxV);
	        for (componentId in frame.components) {
	          if (frame.components.hasOwnProperty(componentId)) {
	            component = frame.components[componentId];
	            var blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / maxH);
	            var blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines  / 8) * component.v / maxV);
	            var blocksPerLineForMcu = mcusPerLine * component.h;
	            var blocksPerColumnForMcu = mcusPerColumn * component.v;
	            var blocksToAllocate = blocksPerColumnForMcu * blocksPerLineForMcu;
	            var blocks = [];

	            // Each block is a Int32Array of length 64 (4 x 64 = 256 bytes)
	            requestMemoryAllocation(blocksToAllocate * 256);

	            for (var i = 0; i < blocksPerColumnForMcu; i++) {
	              var row = [];
	              for (var j = 0; j < blocksPerLineForMcu; j++)
	                row.push(new Int32Array(64));
	              blocks.push(row);
	            }
	            component.blocksPerLine = blocksPerLine;
	            component.blocksPerColumn = blocksPerColumn;
	            component.blocks = blocks;
	          }
	        }
	        frame.maxH = maxH;
	        frame.maxV = maxV;
	        frame.mcusPerLine = mcusPerLine;
	        frame.mcusPerColumn = mcusPerColumn;
	      }
	      var jfif = null;
	      var adobe = null;
	      var frame, resetInterval;
	      var quantizationTables = [], frames = [];
	      var huffmanTablesAC = [], huffmanTablesDC = [];
	      var fileMarker = readUint16();
	      var malformedDataOffset = -1;
	      this.comments = [];
	      if (fileMarker != 0xFFD8) { // SOI (Start of Image)
	        throw new Error("SOI not found");
	      }

	      fileMarker = readUint16();
	      while (fileMarker != 0xFFD9) { // EOI (End of image)
	        var i, j;
	        switch(fileMarker) {
	          case 0xFF00: break;
	          case 0xFFE0: // APP0 (Application Specific)
	          case 0xFFE1: // APP1
	          case 0xFFE2: // APP2
	          case 0xFFE3: // APP3
	          case 0xFFE4: // APP4
	          case 0xFFE5: // APP5
	          case 0xFFE6: // APP6
	          case 0xFFE7: // APP7
	          case 0xFFE8: // APP8
	          case 0xFFE9: // APP9
	          case 0xFFEA: // APP10
	          case 0xFFEB: // APP11
	          case 0xFFEC: // APP12
	          case 0xFFED: // APP13
	          case 0xFFEE: // APP14
	          case 0xFFEF: // APP15
	          case 0xFFFE: // COM (Comment)
	            var appData = readDataBlock();

	            if (fileMarker === 0xFFFE) {
	              var comment = String.fromCharCode.apply(null, appData);
	              this.comments.push(comment);
	            }

	            if (fileMarker === 0xFFE0) {
	              if (appData[0] === 0x4A && appData[1] === 0x46 && appData[2] === 0x49 &&
	                appData[3] === 0x46 && appData[4] === 0) { // 'JFIF\x00'
	                jfif = {
	                  version: { major: appData[5], minor: appData[6] },
	                  densityUnits: appData[7],
	                  xDensity: (appData[8] << 8) | appData[9],
	                  yDensity: (appData[10] << 8) | appData[11],
	                  thumbWidth: appData[12],
	                  thumbHeight: appData[13],
	                  thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
	                };
	              }
	            }
	            // TODO APP1 - Exif
	            if (fileMarker === 0xFFE1) {
	              if (appData[0] === 0x45 &&
	                appData[1] === 0x78 &&
	                appData[2] === 0x69 &&
	                appData[3] === 0x66 &&
	                appData[4] === 0) { // 'EXIF\x00'
	                this.exifBuffer = appData.subarray(5, appData.length);
	              }
	            }

	            if (fileMarker === 0xFFEE) {
	              if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6F &&
	                appData[3] === 0x62 && appData[4] === 0x65 && appData[5] === 0) { // 'Adobe\x00'
	                adobe = {
	                  version: appData[6],
	                  flags0: (appData[7] << 8) | appData[8],
	                  flags1: (appData[9] << 8) | appData[10],
	                  transformCode: appData[11]
	                };
	              }
	            }
	            break;

	          case 0xFFDB: // DQT (Define Quantization Tables)
	            var quantizationTablesLength = readUint16();
	            var quantizationTablesEnd = quantizationTablesLength + offset - 2;
	            while (offset < quantizationTablesEnd) {
	              var quantizationTableSpec = data[offset++];
	              requestMemoryAllocation(64 * 4);
	              var tableData = new Int32Array(64);
	              if ((quantizationTableSpec >> 4) === 0) { // 8 bit values
	                for (j = 0; j < 64; j++) {
	                  var z = dctZigZag[j];
	                  tableData[z] = data[offset++];
	                }
	              } else if ((quantizationTableSpec >> 4) === 1) { //16 bit
	                for (j = 0; j < 64; j++) {
	                  var z = dctZigZag[j];
	                  tableData[z] = readUint16();
	                }
	              } else
	                throw new Error("DQT: invalid table spec");
	              quantizationTables[quantizationTableSpec & 15] = tableData;
	            }
	            break;

	          case 0xFFC0: // SOF0 (Start of Frame, Baseline DCT)
	          case 0xFFC1: // SOF1 (Start of Frame, Extended DCT)
	          case 0xFFC2: // SOF2 (Start of Frame, Progressive DCT)
	            readUint16(); // skip data length
	            frame = {};
	            frame.extended = (fileMarker === 0xFFC1);
	            frame.progressive = (fileMarker === 0xFFC2);
	            frame.precision = data[offset++];
	            frame.scanLines = readUint16();
	            frame.samplesPerLine = readUint16();
	            frame.components = {};
	            frame.componentsOrder = [];

	            var pixelsInFrame = frame.scanLines * frame.samplesPerLine;
	            if (pixelsInFrame > maxResolutionInPixels) {
	              var exceededAmount = Math.ceil((pixelsInFrame - maxResolutionInPixels) / 1e6);
	              throw new Error(`maxResolutionInMP limit exceeded by ${exceededAmount}MP`);
	            }

	            var componentsCount = data[offset++], componentId;
	            for (i = 0; i < componentsCount; i++) {
	              componentId = data[offset];
	              var h = data[offset + 1] >> 4;
	              var v = data[offset + 1] & 15;
	              var qId = data[offset + 2];

	              if ( h <= 0 || v <= 0 ) {
	                throw new Error('Invalid sampling factor, expected values above 0');
	              }

	              frame.componentsOrder.push(componentId);
	              frame.components[componentId] = {
	                h: h,
	                v: v,
	                quantizationIdx: qId
	              };
	              offset += 3;
	            }
	            prepareComponents(frame);
	            frames.push(frame);
	            break;

	          case 0xFFC4: // DHT (Define Huffman Tables)
	            var huffmanLength = readUint16();
	            for (i = 2; i < huffmanLength;) {
	              var huffmanTableSpec = data[offset++];
	              var codeLengths = new Uint8Array(16);
	              var codeLengthSum = 0;
	              for (j = 0; j < 16; j++, offset++) {
	                codeLengthSum += (codeLengths[j] = data[offset]);
	              }
	              requestMemoryAllocation(16 + codeLengthSum);
	              var huffmanValues = new Uint8Array(codeLengthSum);
	              for (j = 0; j < codeLengthSum; j++, offset++)
	                huffmanValues[j] = data[offset];
	              i += 17 + codeLengthSum;

	              ((huffmanTableSpec >> 4) === 0 ?
	                huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] =
	                buildHuffmanTable(codeLengths, huffmanValues);
	            }
	            break;

	          case 0xFFDD: // DRI (Define Restart Interval)
	            readUint16(); // skip data length
	            resetInterval = readUint16();
	            break;

	          case 0xFFDC: // Number of Lines marker
	            readUint16(); // skip data length
	            readUint16(); // Ignore this data since it represents the image height
	            break;
	            
	          case 0xFFDA: // SOS (Start of Scan)
	            readUint16();
	            var selectorsCount = data[offset++];
	            var components = [], component;
	            for (i = 0; i < selectorsCount; i++) {
	              component = frame.components[data[offset++]];
	              var tableSpec = data[offset++];
	              component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
	              component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
	              components.push(component);
	            }
	            var spectralStart = data[offset++];
	            var spectralEnd = data[offset++];
	            var successiveApproximation = data[offset++];
	            var processed = decodeScan(data, offset,
	              frame, components, resetInterval,
	              spectralStart, spectralEnd,
	              successiveApproximation >> 4, successiveApproximation & 15, this.opts);
	            offset += processed;
	            break;

	          case 0xFFFF: // Fill bytes
	            if (data[offset] !== 0xFF) { // Avoid skipping a valid marker.
	              offset--;
	            }
	            break;
	          default:
	            if (data[offset - 3] == 0xFF &&
	                data[offset - 2] >= 0xC0 && data[offset - 2] <= 0xFE) {
	              // could be incorrect encoding -- last 0xFF byte of the previous
	              // block was eaten by the encoder
	              offset -= 3;
	              break;
	            }
	            else if (fileMarker === 0xE0 || fileMarker == 0xE1) {
	              // Recover from malformed APP1 markers popular in some phone models.
	              // See https://github.com/eugeneware/jpeg-js/issues/82
	              if (malformedDataOffset !== -1) {
	                throw new Error(`first unknown JPEG marker at offset ${malformedDataOffset.toString(16)}, second unknown JPEG marker ${fileMarker.toString(16)} at offset ${(offset - 1).toString(16)}`);
	              }
	              malformedDataOffset = offset - 1;
	              const nextOffset = readUint16();
	              if (data[offset + nextOffset - 2] === 0xFF) {
	                offset += nextOffset - 2;
	                break;
	              }
	            }
	            throw new Error("unknown JPEG marker " + fileMarker.toString(16));
	        }
	        fileMarker = readUint16();
	      }
	      if (frames.length != 1)
	        throw new Error("only single frame JPEGs supported");

	      // set each frame's components quantization table
	      for (var i = 0; i < frames.length; i++) {
	        var cp = frames[i].components;
	        for (var j in cp) {
	          cp[j].quantizationTable = quantizationTables[cp[j].quantizationIdx];
	          delete cp[j].quantizationIdx;
	        }
	      }

	      this.width = frame.samplesPerLine;
	      this.height = frame.scanLines;
	      this.jfif = jfif;
	      this.adobe = adobe;
	      this.components = [];
	      for (var i = 0; i < frame.componentsOrder.length; i++) {
	        var component = frame.components[frame.componentsOrder[i]];
	        this.components.push({
	          lines: buildComponentData(frame, component),
	          scaleX: component.h / frame.maxH,
	          scaleY: component.v / frame.maxV
	        });
	      }
	    },
	    getData: function getData(width, height) {
	      var scaleX = this.width / width, scaleY = this.height / height;

	      var component1, component2, component3, component4;
	      var component1Line, component2Line, component3Line, component4Line;
	      var x, y;
	      var offset = 0;
	      var Y, Cb, Cr, K, C, M, Ye, R, G, B;
	      var colorTransform;
	      var dataLength = width * height * this.components.length;
	      requestMemoryAllocation(dataLength);
	      var data = new Uint8Array(dataLength);
	      switch (this.components.length) {
	        case 1:
	          component1 = this.components[0];
	          for (y = 0; y < height; y++) {
	            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];
	            for (x = 0; x < width; x++) {
	              Y = component1Line[0 | (x * component1.scaleX * scaleX)];

	              data[offset++] = Y;
	            }
	          }
	          break;
	        case 2:
	          // PDF might compress two component data in custom colorspace
	          component1 = this.components[0];
	          component2 = this.components[1];
	          for (y = 0; y < height; y++) {
	            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];
	            component2Line = component2.lines[0 | (y * component2.scaleY * scaleY)];
	            for (x = 0; x < width; x++) {
	              Y = component1Line[0 | (x * component1.scaleX * scaleX)];
	              data[offset++] = Y;
	              Y = component2Line[0 | (x * component2.scaleX * scaleX)];
	              data[offset++] = Y;
	            }
	          }
	          break;
	        case 3:
	          // The default transform for three components is true
	          colorTransform = true;
	          // The adobe transform marker overrides any previous setting
	          if (this.adobe && this.adobe.transformCode)
	            colorTransform = true;
	          else if (typeof this.opts.colorTransform !== 'undefined')
	            colorTransform = !!this.opts.colorTransform;

	          component1 = this.components[0];
	          component2 = this.components[1];
	          component3 = this.components[2];
	          for (y = 0; y < height; y++) {
	            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];
	            component2Line = component2.lines[0 | (y * component2.scaleY * scaleY)];
	            component3Line = component3.lines[0 | (y * component3.scaleY * scaleY)];
	            for (x = 0; x < width; x++) {
	              if (!colorTransform) {
	                R = component1Line[0 | (x * component1.scaleX * scaleX)];
	                G = component2Line[0 | (x * component2.scaleX * scaleX)];
	                B = component3Line[0 | (x * component3.scaleX * scaleX)];
	              } else {
	                Y = component1Line[0 | (x * component1.scaleX * scaleX)];
	                Cb = component2Line[0 | (x * component2.scaleX * scaleX)];
	                Cr = component3Line[0 | (x * component3.scaleX * scaleX)];

	                R = clampTo8bit(Y + 1.402 * (Cr - 128));
	                G = clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
	                B = clampTo8bit(Y + 1.772 * (Cb - 128));
	              }

	              data[offset++] = R;
	              data[offset++] = G;
	              data[offset++] = B;
	            }
	          }
	          break;
	        case 4:
	          if (!this.adobe)
	            throw new Error('Unsupported color mode (4 components)');
	          // The default transform for four components is false
	          colorTransform = false;
	          // The adobe transform marker overrides any previous setting
	          if (this.adobe && this.adobe.transformCode)
	            colorTransform = true;
	          else if (typeof this.opts.colorTransform !== 'undefined')
	            colorTransform = !!this.opts.colorTransform;

	          component1 = this.components[0];
	          component2 = this.components[1];
	          component3 = this.components[2];
	          component4 = this.components[3];
	          for (y = 0; y < height; y++) {
	            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];
	            component2Line = component2.lines[0 | (y * component2.scaleY * scaleY)];
	            component3Line = component3.lines[0 | (y * component3.scaleY * scaleY)];
	            component4Line = component4.lines[0 | (y * component4.scaleY * scaleY)];
	            for (x = 0; x < width; x++) {
	              if (!colorTransform) {
	                C = component1Line[0 | (x * component1.scaleX * scaleX)];
	                M = component2Line[0 | (x * component2.scaleX * scaleX)];
	                Ye = component3Line[0 | (x * component3.scaleX * scaleX)];
	                K = component4Line[0 | (x * component4.scaleX * scaleX)];
	              } else {
	                Y = component1Line[0 | (x * component1.scaleX * scaleX)];
	                Cb = component2Line[0 | (x * component2.scaleX * scaleX)];
	                Cr = component3Line[0 | (x * component3.scaleX * scaleX)];
	                K = component4Line[0 | (x * component4.scaleX * scaleX)];

	                C = 255 - clampTo8bit(Y + 1.402 * (Cr - 128));
	                M = 255 - clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
	                Ye = 255 - clampTo8bit(Y + 1.772 * (Cb - 128));
	              }
	              data[offset++] = 255-C;
	              data[offset++] = 255-M;
	              data[offset++] = 255-Ye;
	              data[offset++] = 255-K;
	            }
	          }
	          break;
	        default:
	          throw new Error('Unsupported color mode');
	      }
	      return data;
	    },
	    copyToImageData: function copyToImageData(imageData, formatAsRGBA) {
	      var width = imageData.width, height = imageData.height;
	      var imageDataArray = imageData.data;
	      var data = this.getData(width, height);
	      var i = 0, j = 0, x, y;
	      var Y, K, C, M, R, G, B;
	      switch (this.components.length) {
	        case 1:
	          for (y = 0; y < height; y++) {
	            for (x = 0; x < width; x++) {
	              Y = data[i++];

	              imageDataArray[j++] = Y;
	              imageDataArray[j++] = Y;
	              imageDataArray[j++] = Y;
	              if (formatAsRGBA) {
	                imageDataArray[j++] = 255;
	              }
	            }
	          }
	          break;
	        case 3:
	          for (y = 0; y < height; y++) {
	            for (x = 0; x < width; x++) {
	              R = data[i++];
	              G = data[i++];
	              B = data[i++];

	              imageDataArray[j++] = R;
	              imageDataArray[j++] = G;
	              imageDataArray[j++] = B;
	              if (formatAsRGBA) {
	                imageDataArray[j++] = 255;
	              }
	            }
	          }
	          break;
	        case 4:
	          for (y = 0; y < height; y++) {
	            for (x = 0; x < width; x++) {
	              C = data[i++];
	              M = data[i++];
	              Y = data[i++];
	              K = data[i++];

	              R = 255 - clampTo8bit(C * (1 - K / 255) + K);
	              G = 255 - clampTo8bit(M * (1 - K / 255) + K);
	              B = 255 - clampTo8bit(Y * (1 - K / 255) + K);

	              imageDataArray[j++] = R;
	              imageDataArray[j++] = G;
	              imageDataArray[j++] = B;
	              if (formatAsRGBA) {
	                imageDataArray[j++] = 255;
	              }
	            }
	          }
	          break;
	        default:
	          throw new Error('Unsupported color mode');
	      }
	    }
	  };


	  // We cap the amount of memory used by jpeg-js to avoid unexpected OOMs from untrusted content.
	  var totalBytesAllocated = 0;
	  var maxMemoryUsageBytes = 0;
	  function requestMemoryAllocation(increaseAmount = 0) {
	    var totalMemoryImpactBytes = totalBytesAllocated + increaseAmount;
	    if (totalMemoryImpactBytes > maxMemoryUsageBytes) {
	      var exceededAmount = Math.ceil((totalMemoryImpactBytes - maxMemoryUsageBytes) / 1024 / 1024);
	      throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${exceededAmount}MB`);
	    }

	    totalBytesAllocated = totalMemoryImpactBytes;
	  }

	  constructor.resetMaxMemoryUsage = function (maxMemoryUsageBytes_) {
	    totalBytesAllocated = 0;
	    maxMemoryUsageBytes = maxMemoryUsageBytes_;
	  };

	  constructor.getBytesAllocated = function () {
	    return totalBytesAllocated;
	  };

	  constructor.requestMemoryAllocation = requestMemoryAllocation;

	  return constructor;
	})();

	{
		module.exports = decode;
	}

	function decode(jpegData, userOpts = {}) {
	  var defaultOpts = {
	    // "undefined" means "Choose whether to transform colors based on the image’s color model."
	    colorTransform: undefined,
	    useTArray: false,
	    formatAsRGBA: true,
	    tolerantDecoding: true,
	    maxResolutionInMP: 100, // Don't decode more than 100 megapixels
	    maxMemoryUsageInMB: 512, // Don't decode if memory footprint is more than 512MB
	  };

	  var opts = {...defaultOpts, ...userOpts};
	  var arr = new Uint8Array(jpegData);
	  var decoder = new JpegImage();
	  decoder.opts = opts;
	  // If this constructor ever supports async decoding this will need to be done differently.
	  // Until then, treating as singleton limit is fine.
	  JpegImage.resetMaxMemoryUsage(opts.maxMemoryUsageInMB * 1024 * 1024);
	  decoder.parse(arr);

	  var channels = (opts.formatAsRGBA) ? 4 : 3;
	  var bytesNeeded = decoder.width * decoder.height * channels;
	  try {
	    JpegImage.requestMemoryAllocation(bytesNeeded);
	    var image = {
	      width: decoder.width,
	      height: decoder.height,
	      exifBuffer: decoder.exifBuffer,
	      data: opts.useTArray ?
	        new Uint8Array(bytesNeeded) :
	        Buffer.alloc(bytesNeeded)
	    };
	    if(decoder.comments.length > 0) {
	      image["comments"] = decoder.comments;
	    }
	  } catch (err) {
	    if (err instanceof RangeError) {
	      throw new Error("Could not allocate enough memory for the image. " +
	                      "Required: " + bytesNeeded);
	    } 
	    
	    if (err instanceof ReferenceError) {
	      if (err.message === "Buffer is not defined") {
	        throw new Error("Buffer is not globally defined in this environment. " +
	                        "Consider setting useTArray to true");
	      }
	    }
	    throw err;
	  }

	  decoder.copyToImageData(image, opts.formatAsRGBA);

	  return image;
	} 
} (decoder$1));

var decoderExports = decoder$1.exports;

var encode$1 = encoderExports,
    decode$1 = decoderExports;

var jpegJs = {
  encode: encode$1,
  decode: decode$1
};

/*
 * Copyright 2017 Sam Thorogood. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
(function (scope) {
    // fail early
    if (scope['TextEncoder'] && scope['TextDecoder']) {
        return false;
    }
    /**
     * @constructor
     * @param {string=} utfLabel
     */
    function FastTextEncoder(utfLabel = 'utf-8') {
        if (utfLabel !== 'utf-8') {
            throw new RangeError(`Failed to construct 'TextEncoder': The encoding label provided ('${utfLabel}') is invalid.`);
        }
    }
    Object.defineProperty(FastTextEncoder.prototype, 'encoding', {
        value: 'utf-8',
    });
    /**
     * @param {string} string
     * @param {{stream: boolean}=} options
     * @return {!Uint8Array}
     */
    FastTextEncoder.prototype.encode = function (string, options = { stream: false }) {
        if (options.stream) {
            throw new Error(`Failed to encode: the 'stream' option is unsupported.`);
        }
        let pos = 0;
        const len = string.length;
        let at = 0; // output position
        let tlen = Math.max(32, len + (len >> 1) + 7); // 1.5x size
        let target = new Uint8Array((tlen >> 3) << 3); // ... but at 8 byte offset
        while (pos < len) {
            let value = string.charCodeAt(pos++);
            if (value >= 0xd800 && value <= 0xdbff) {
                // high surrogate
                if (pos < len) {
                    const extra = string.charCodeAt(pos);
                    if ((extra & 0xfc00) === 0xdc00) {
                        ++pos;
                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;
                    }
                }
                if (value >= 0xd800 && value <= 0xdbff) {
                    continue; // drop lone surrogate
                }
            }
            // expand the buffer if we couldn't write 4 bytes
            if (at + 4 > target.length) {
                tlen += 8; // minimum extra
                tlen *= 1.0 + (pos / string.length) * 2; // take 2x the remaining
                tlen = (tlen >> 3) << 3; // 8 byte offset
                const update = new Uint8Array(tlen);
                update.set(target);
                target = update;
            }
            if ((value & 0xffffff80) === 0) {
                // 1-byte
                target[at++] = value; // ASCII
                continue;
            }
            else if ((value & 0xfffff800) === 0) {
                // 2-byte
                target[at++] = ((value >> 6) & 0x1f) | 0xc0;
            }
            else if ((value & 0xffff0000) === 0) {
                // 3-byte
                target[at++] = ((value >> 12) & 0x0f) | 0xe0;
                target[at++] = ((value >> 6) & 0x3f) | 0x80;
            }
            else if ((value & 0xffe00000) === 0) {
                // 4-byte
                target[at++] = ((value >> 18) & 0x07) | 0xf0;
                target[at++] = ((value >> 12) & 0x3f) | 0x80;
                target[at++] = ((value >> 6) & 0x3f) | 0x80;
            }
            else {
                // FIXME: do we care
                continue;
            }
            target[at++] = (value & 0x3f) | 0x80;
        }
        return target.slice(0, at);
    };
    /**
     * @constructor
     * @param {string=} utfLabel
     * @param {{fatal: boolean}=} options
     */
    function FastTextDecoder(utfLabel = 'utf-8', options = { fatal: false }) {
        if (utfLabel !== 'utf-8') {
            throw new RangeError(`Failed to construct 'TextDecoder': The encoding label provided ('${utfLabel}') is invalid.`);
        }
        if (options.fatal) {
            throw new Error(`Failed to construct 'TextDecoder': the 'fatal' option is unsupported.`);
        }
    }
    Object.defineProperty(FastTextDecoder.prototype, 'encoding', {
        value: 'utf-8',
    });
    Object.defineProperty(FastTextDecoder.prototype, 'fatal', { value: false });
    Object.defineProperty(FastTextDecoder.prototype, 'ignoreBOM', {
        value: false,
    });
    /**
     * @param {(!ArrayBuffer|!ArrayBufferView)} buffer
     * @param {{stream: boolean}=} options
     */
    FastTextDecoder.prototype.decode = function (buffer, options = { stream: false }) {
        if (options['stream']) {
            throw new Error(`Failed to decode: the 'stream' option is unsupported.`);
        }
        const bytes = new Uint8Array(buffer);
        let pos = 0;
        const len = bytes.length;
        const out = [];
        while (pos < len) {
            const byte1 = bytes[pos++];
            if (byte1 === 0) {
                break; // NULL
            }
            if ((byte1 & 0x80) === 0) {
                // 1-byte
                out.push(byte1);
            }
            else if ((byte1 & 0xe0) === 0xc0) {
                // 2-byte
                const byte2 = bytes[pos++] & 0x3f;
                out.push(((byte1 & 0x1f) << 6) | byte2);
            }
            else if ((byte1 & 0xf0) === 0xe0) {
                const byte2 = bytes[pos++] & 0x3f;
                const byte3 = bytes[pos++] & 0x3f;
                out.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);
            }
            else if ((byte1 & 0xf8) === 0xf0) {
                const byte2 = bytes[pos++] & 0x3f;
                const byte3 = bytes[pos++] & 0x3f;
                const byte4 = bytes[pos++] & 0x3f;
                // this can be > 0xffff, so possibly generate surrogates
                let codepoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;
                if (codepoint > 0xffff) {
                    // codepoint &= ~0x10000;
                    codepoint -= 0x10000;
                    out.push(((codepoint >>> 10) & 0x3ff) | 0xd800);
                    codepoint = 0xdc00 | (codepoint & 0x3ff);
                }
                out.push(codepoint);
            }
            else ;
        }
        return String.fromCharCode.apply(null, out);
    };
    scope['TextEncoder'] = FastTextEncoder;
    scope['TextDecoder'] = FastTextDecoder;
})(typeof window !== 'undefined'
    ? window
    : typeof self !== 'undefined'
        ? self
        : undefined);

// eslint-disable-next-line import/no-unassigned-import
function decode(bytes, encoding = 'utf8') {
    const decoder = new TextDecoder(encoding);
    return decoder.decode(bytes);
}
const encoder = new TextEncoder();
function encode(str) {
    return encoder.encode(str);
}

const defaultByteLength = 1024 * 8;
const hostBigEndian = (() => {
    const array = new Uint8Array(4);
    const view = new Uint32Array(array.buffer);
    return !((view[0] = 1) & array[0]);
})();
const typedArrays = {
    int8: globalThis.Int8Array,
    uint8: globalThis.Uint8Array,
    int16: globalThis.Int16Array,
    uint16: globalThis.Uint16Array,
    int32: globalThis.Int32Array,
    uint32: globalThis.Uint32Array,
    uint64: globalThis.BigUint64Array,
    int64: globalThis.BigInt64Array,
    float32: globalThis.Float32Array,
    float64: globalThis.Float64Array,
};
class IOBuffer {
    /**
     * @param data - The data to construct the IOBuffer with.
     * If data is a number, it will be the new buffer's length<br>
     * If data is `undefined`, the buffer will be initialized with a default length of 8Kb<br>
     * If data is an ArrayBuffer, SharedArrayBuffer, an ArrayBufferView (Typed Array), an IOBuffer instance,
     * or a Node.js Buffer, a view will be created over the underlying ArrayBuffer.
     * @param options
     */
    constructor(data = defaultByteLength, options = {}) {
        let dataIsGiven = false;
        if (typeof data === 'number') {
            data = new ArrayBuffer(data);
        }
        else {
            dataIsGiven = true;
            this.lastWrittenByte = data.byteLength;
        }
        const offset = options.offset ? options.offset >>> 0 : 0;
        const byteLength = data.byteLength - offset;
        let dvOffset = offset;
        if (ArrayBuffer.isView(data) || data instanceof IOBuffer) {
            if (data.byteLength !== data.buffer.byteLength) {
                dvOffset = data.byteOffset + offset;
            }
            data = data.buffer;
        }
        if (dataIsGiven) {
            this.lastWrittenByte = byteLength;
        }
        else {
            this.lastWrittenByte = 0;
        }
        this.buffer = data;
        this.length = byteLength;
        this.byteLength = byteLength;
        this.byteOffset = dvOffset;
        this.offset = 0;
        this.littleEndian = true;
        this._data = new DataView(this.buffer, dvOffset, byteLength);
        this._mark = 0;
        this._marks = [];
    }
    /**
     * Checks if the memory allocated to the buffer is sufficient to store more
     * bytes after the offset.
     * @param byteLength - The needed memory in bytes.
     * @returns `true` if there is sufficient space and `false` otherwise.
     */
    available(byteLength = 1) {
        return this.offset + byteLength <= this.length;
    }
    /**
     * Check if little-endian mode is used for reading and writing multi-byte
     * values.
     * @returns `true` if little-endian mode is used, `false` otherwise.
     */
    isLittleEndian() {
        return this.littleEndian;
    }
    /**
     * Set little-endian mode for reading and writing multi-byte values.
     */
    setLittleEndian() {
        this.littleEndian = true;
        return this;
    }
    /**
     * Check if big-endian mode is used for reading and writing multi-byte values.
     * @returns `true` if big-endian mode is used, `false` otherwise.
     */
    isBigEndian() {
        return !this.littleEndian;
    }
    /**
     * Switches to big-endian mode for reading and writing multi-byte values.
     */
    setBigEndian() {
        this.littleEndian = false;
        return this;
    }
    /**
     * Move the pointer n bytes forward.
     * @param n - Number of bytes to skip.
     */
    skip(n = 1) {
        this.offset += n;
        return this;
    }
    /**
     * Move the pointer n bytes backward.
     * @param n - Number of bytes to move back.
     */
    back(n = 1) {
        this.offset -= n;
        return this;
    }
    /**
     * Move the pointer to the given offset.
     * @param offset
     */
    seek(offset) {
        this.offset = offset;
        return this;
    }
    /**
     * Store the current pointer offset.
     * @see {@link IOBuffer#reset}
     */
    mark() {
        this._mark = this.offset;
        return this;
    }
    /**
     * Move the pointer back to the last pointer offset set by mark.
     * @see {@link IOBuffer#mark}
     */
    reset() {
        this.offset = this._mark;
        return this;
    }
    /**
     * Push the current pointer offset to the mark stack.
     * @see {@link IOBuffer#popMark}
     */
    pushMark() {
        this._marks.push(this.offset);
        return this;
    }
    /**
     * Pop the last pointer offset from the mark stack, and set the current
     * pointer offset to the popped value.
     * @see {@link IOBuffer#pushMark}
     */
    popMark() {
        const offset = this._marks.pop();
        if (offset === undefined) {
            throw new Error('Mark stack empty');
        }
        this.seek(offset);
        return this;
    }
    /**
     * Move the pointer offset back to 0.
     */
    rewind() {
        this.offset = 0;
        return this;
    }
    /**
     * Make sure the buffer has sufficient memory to write a given byteLength at
     * the current pointer offset.
     * If the buffer's memory is insufficient, this method will create a new
     * buffer (a copy) with a length that is twice (byteLength + current offset).
     * @param byteLength
     */
    ensureAvailable(byteLength = 1) {
        if (!this.available(byteLength)) {
            const lengthNeeded = this.offset + byteLength;
            const newLength = lengthNeeded * 2;
            const newArray = new Uint8Array(newLength);
            newArray.set(new Uint8Array(this.buffer));
            this.buffer = newArray.buffer;
            this.length = this.byteLength = newLength;
            this._data = new DataView(this.buffer);
        }
        return this;
    }
    /**
     * Read a byte and return false if the byte's value is 0, or true otherwise.
     * Moves pointer forward by one byte.
     */
    readBoolean() {
        return this.readUint8() !== 0;
    }
    /**
     * Read a signed 8-bit integer and move pointer forward by 1 byte.
     */
    readInt8() {
        return this._data.getInt8(this.offset++);
    }
    /**
     * Read an unsigned 8-bit integer and move pointer forward by 1 byte.
     */
    readUint8() {
        return this._data.getUint8(this.offset++);
    }
    /**
     * Alias for {@link IOBuffer#readUint8}.
     */
    readByte() {
        return this.readUint8();
    }
    /**
     * Read `n` bytes and move pointer forward by `n` bytes.
     */
    readBytes(n = 1) {
        return this.readArray(n, 'uint8');
    }
    /**
     * Creates an array of corresponding to the type `type` and size `size`.
     * For example type `uint8` will create a `Uint8Array`.
     * @param size - size of the resulting array
     * @param type - number type of elements to read
     */
    readArray(size, type) {
        const bytes = typedArrays[type].BYTES_PER_ELEMENT * size;
        const offset = this.byteOffset + this.offset;
        const slice = this.buffer.slice(offset, offset + bytes);
        if (this.littleEndian === hostBigEndian &&
            type !== 'uint8' &&
            type !== 'int8') {
            const slice = new Uint8Array(this.buffer.slice(offset, offset + bytes));
            slice.reverse();
            const returnArray = new typedArrays[type](slice.buffer);
            this.offset += bytes;
            returnArray.reverse();
            return returnArray;
        }
        const returnArray = new typedArrays[type](slice);
        this.offset += bytes;
        return returnArray;
    }
    /**
     * Read a 16-bit signed integer and move pointer forward by 2 bytes.
     */
    readInt16() {
        const value = this._data.getInt16(this.offset, this.littleEndian);
        this.offset += 2;
        return value;
    }
    /**
     * Read a 16-bit unsigned integer and move pointer forward by 2 bytes.
     */
    readUint16() {
        const value = this._data.getUint16(this.offset, this.littleEndian);
        this.offset += 2;
        return value;
    }
    /**
     * Read a 32-bit signed integer and move pointer forward by 4 bytes.
     */
    readInt32() {
        const value = this._data.getInt32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
    }
    /**
     * Read a 32-bit unsigned integer and move pointer forward by 4 bytes.
     */
    readUint32() {
        const value = this._data.getUint32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
    }
    /**
     * Read a 32-bit floating number and move pointer forward by 4 bytes.
     */
    readFloat32() {
        const value = this._data.getFloat32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
    }
    /**
     * Read a 64-bit floating number and move pointer forward by 8 bytes.
     */
    readFloat64() {
        const value = this._data.getFloat64(this.offset, this.littleEndian);
        this.offset += 8;
        return value;
    }
    /**
     * Read a 64-bit signed integer number and move pointer forward by 8 bytes.
     */
    readBigInt64() {
        const value = this._data.getBigInt64(this.offset, this.littleEndian);
        this.offset += 8;
        return value;
    }
    /**
     * Read a 64-bit unsigned integer number and move pointer forward by 8 bytes.
     */
    readBigUint64() {
        const value = this._data.getBigUint64(this.offset, this.littleEndian);
        this.offset += 8;
        return value;
    }
    /**
     * Read a 1-byte ASCII character and move pointer forward by 1 byte.
     */
    readChar() {
        return String.fromCharCode(this.readInt8());
    }
    /**
     * Read `n` 1-byte ASCII characters and move pointer forward by `n` bytes.
     */
    readChars(n = 1) {
        let result = '';
        for (let i = 0; i < n; i++) {
            result += this.readChar();
        }
        return result;
    }
    /**
     * Read the next `n` bytes, return a UTF-8 decoded string and move pointer
     * forward by `n` bytes.
     */
    readUtf8(n = 1) {
        return decode(this.readBytes(n));
    }
    /**
     * Read the next `n` bytes, return a string decoded with `encoding` and move pointer
     * forward by `n` bytes.
     * If no encoding is passed, the function is equivalent to @see {@link IOBuffer#readUtf8}
     */
    decodeText(n = 1, encoding = 'utf-8') {
        return decode(this.readBytes(n), encoding);
    }
    /**
     * Write 0xff if the passed value is truthy, 0x00 otherwise and move pointer
     * forward by 1 byte.
     */
    writeBoolean(value) {
        this.writeUint8(value ? 0xff : 0x00);
        return this;
    }
    /**
     * Write `value` as an 8-bit signed integer and move pointer forward by 1 byte.
     */
    writeInt8(value) {
        this.ensureAvailable(1);
        this._data.setInt8(this.offset++, value);
        this._updateLastWrittenByte();
        return this;
    }
    /**
     * Write `value` as an 8-bit unsigned integer and move pointer forward by 1
     * byte.
     */
    writeUint8(value) {
        this.ensureAvailable(1);
        this._data.setUint8(this.offset++, value);
        this._updateLastWrittenByte();
        return this;
    }
    /**
     * An alias for {@link IOBuffer#writeUint8}.
     */
    writeByte(value) {
        return this.writeUint8(value);
    }
    /**
     * Write all elements of `bytes` as uint8 values and move pointer forward by
     * `bytes.length` bytes.
     */
    writeBytes(bytes) {
        this.ensureAvailable(bytes.length);
        for (let i = 0; i < bytes.length; i++) {
            this._data.setUint8(this.offset++, bytes[i]);
        }
        this._updateLastWrittenByte();
        return this;
    }
    /**
     * Write `value` as a 16-bit signed integer and move pointer forward by 2
     * bytes.
     */
    writeInt16(value) {
        this.ensureAvailable(2);
        this._data.setInt16(this.offset, value, this.littleEndian);
        this.offset += 2;
        this._updateLastWrittenByte();
        return this;
    }
    /**
     * Write `value` as a 16-bit unsigned integer and move pointer forward by 2
     * bytes.
     */
    writeUint16(value) {
        this.ensureAvailable(2);
        this._data.setUint16(this.offset, value, this.littleEndian);
        this.offset += 2;
        this._updateLastWrittenByte();
        return this;
    }
    /**
     * Write `value` as a 32-bit signed integer and move pointer forward by 4
     * bytes.
     */
    writeInt32(value) {
        this.ensureAvailable(4);
        this._data.setInt32(this.offset, value, this.littleEndian);
        this.offset += 4;
        this._updateLastWrittenByte();
        return this;
    }
    /**
     * Write `value` as a 32-bit unsigned integer and move pointer forward by 4
     * bytes.
     */
    writeUint32(value) {
        this.ensureAvailable(4);
        this._data.setUint32(this.offset, value, this.littleEndian);
        this.offset += 4;
        this._updateLastWrittenByte();
        return this;
    }
    /**
     * Write `value` as a 32-bit floating number and move pointer forward by 4
     * bytes.
     */
    writeFloat32(value) {
        this.ensureAvailable(4);
        this._data.setFloat32(this.offset, value, this.littleEndian);
        this.offset += 4;
        this._updateLastWrittenByte();
        return this;
    }
    /**
     * Write `value` as a 64-bit floating number and move pointer forward by 8
     * bytes.
     */
    writeFloat64(value) {
        this.ensureAvailable(8);
        this._data.setFloat64(this.offset, value, this.littleEndian);
        this.offset += 8;
        this._updateLastWrittenByte();
        return this;
    }
    /**
     * Write `value` as a 64-bit signed bigint and move pointer forward by 8
     * bytes.
     */
    writeBigInt64(value) {
        this.ensureAvailable(8);
        this._data.setBigInt64(this.offset, value, this.littleEndian);
        this.offset += 8;
        this._updateLastWrittenByte();
        return this;
    }
    /**
     * Write `value` as a 64-bit unsigned bigint and move pointer forward by 8
     * bytes.
     */
    writeBigUint64(value) {
        this.ensureAvailable(8);
        this._data.setBigUint64(this.offset, value, this.littleEndian);
        this.offset += 8;
        this._updateLastWrittenByte();
        return this;
    }
    /**
     * Write the charCode of `str`'s first character as an 8-bit unsigned integer
     * and move pointer forward by 1 byte.
     */
    writeChar(str) {
        return this.writeUint8(str.charCodeAt(0));
    }
    /**
     * Write the charCodes of all `str`'s characters as 8-bit unsigned integers
     * and move pointer forward by `str.length` bytes.
     */
    writeChars(str) {
        for (let i = 0; i < str.length; i++) {
            this.writeUint8(str.charCodeAt(i));
        }
        return this;
    }
    /**
     * UTF-8 encode and write `str` to the current pointer offset and move pointer
     * forward according to the encoded length.
     */
    writeUtf8(str) {
        return this.writeBytes(encode(str));
    }
    /**
     * Export a Uint8Array view of the internal buffer.
     * The view starts at the byte offset and its length
     * is calculated to stop at the last written byte or the original length.
     */
    toArray() {
        return new Uint8Array(this.buffer, this.byteOffset, this.lastWrittenByte);
    }
    /**
     * Update the last written byte offset
     * @private
     */
    _updateLastWrittenByte() {
        if (this.offset > this.lastWrittenByte) {
            this.lastWrittenByte = this.offset;
        }
    }
}

/*============================================================================*/


function zero$1(buf) { let len = buf.length; while (--len >= 0) { buf[len] = 0; } }
/* The three kinds of block type */

const MIN_MATCH$1    = 3;
const MAX_MATCH$1    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

const LENGTH_CODES$1  = 29;
/* number of length codes, not counting the special END_BLOCK code */

const LITERALS$1      = 256;
/* number of literal bytes 0..255 */

const L_CODES$1       = LITERALS$1 + 1 + LENGTH_CODES$1;
/* number of Literal or Length codes, including the END_BLOCK code */

const D_CODES$1       = 30;
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

const DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
const static_ltree  = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

const static_dtree  = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

const _dist_code    = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

const _length_code  = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

const base_length   = new Array(LENGTH_CODES$1);
zero$1(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

const base_dist     = new Array(D_CODES$1);
zero$1(base_dist);

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const adler32 = (adler, buf, len, pos) => {
  let s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
};


var adler32_1 = adler32;

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here
const makeTable = () => {
  let c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
};

// Create table on load. Just 255 signed longs. Not a problem.
const crcTable$1 = new Uint32Array(makeTable());


const crc32 = (crc, buf, len, pos) => {
  const t = crcTable$1;
  const end = pos + len;

  crc ^= -1;

  for (let i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
};


var crc32_1 = crc32;

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var messages = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var constants$2 = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  Z_MEM_ERROR:       -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};

const _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};

var assign = function (obj /*from1, from2, from3, ...*/) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// Join array of chunks to single array.
var flattenChunks = (chunks) => {
  // calculate data length
  let len = 0;

  for (let i = 0, l = chunks.length; i < l; i++) {
    len += chunks[i].length;
  }

  // join chunks
  const result = new Uint8Array(len);

  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
    let chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }

  return result;
};

var common = {
	assign: assign,
	flattenChunks: flattenChunks
};

// String encode/decode helpers


// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safari
//
let STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
const _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
var string2buf = (str) => {
  if (typeof TextEncoder === 'function' && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }

  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new Uint8Array(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper
const buf2binstring = (buf, len) => {
  // On Chrome, the arguments in a function call that are allowed is `65534`.
  // If the length of the buffer is smaller than that, we can use this optimization,
  // otherwise we will take a slower path.
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }

  let result = '';
  for (let i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
};


// convert array to string
var buf2string = (buf, max) => {
  const len = max || buf.length;

  if (typeof TextDecoder === 'function' && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max));
  }

  let i, out;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  const utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    let c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    let c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
var utf8border = (buf, max) => {

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means buffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};

var strings = {
	string2buf: string2buf,
	buf2string: buf2string,
	utf8border: utf8border
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

var zstream = ZStream;

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js
const BAD$1 = 16209;       /* got a data error -- remain here until reset */
const TYPE$1 = 16191;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
var inffast = function inflate_fast(strm, start) {
  let _in;                    /* local strm.input */
  let last;                   /* have enough input while in < last */
  let _out;                   /* local strm.output */
  let beg;                    /* inflate()'s initial strm.output */
  let end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  let dmax;                   /* maximum distance from zlib header */
//#endif
  let wsize;                  /* window size or zero if not using window */
  let whave;                  /* valid bytes in the window */
  let wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  let s_window;               /* allocated sliding window, if wsize != 0 */
  let hold;                   /* local strm.hold */
  let bits;                   /* local strm.bits */
  let lcode;                  /* local strm.lencode */
  let dcode;                  /* local strm.distcode */
  let lmask;                  /* mask for first level of length codes */
  let dmask;                  /* mask for first level of distance codes */
  let here;                   /* retrieved table entry */
  let op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  let len;                    /* match length, unused bytes */
  let dist;                   /* match distance */
  let from;                   /* where to copy match from */
  let from_source;


  let input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  const state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD$1;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD$1;
                  break top;
                }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD$1;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE$1;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD$1;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const MAXBITS = 15;
const ENOUGH_LENS$1 = 852;
const ENOUGH_DISTS$1 = 592;
//const ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

const CODES$1 = 0;
const LENS$1 = 1;
const DISTS$1 = 2;

const lbase = new Uint16Array([ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
]);

const lext = new Uint8Array([ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
]);

const dbase = new Uint16Array([ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
]);

const dext = new Uint8Array([ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
]);

const inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) =>
{
  const bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  let len = 0;               /* a code's length in bits */
  let sym = 0;               /* index of code symbols */
  let min = 0, max = 0;          /* minimum and maximum code lengths */
  let root = 0;              /* number of index bits for root table */
  let curr = 0;              /* number of index bits for current table */
  let drop = 0;              /* code bits to drop for sub-table */
  let left = 0;                   /* number of prefix codes available */
  let used = 0;              /* code entries in table used */
  let huff = 0;              /* Huffman code */
  let incr;              /* for incrementing code, index */
  let fill;              /* index for replicating entries */
  let low;               /* low bits for current root entry */
  let mask;              /* mask for low root bits */
  let next;             /* next available space in table */
  let base = null;     /* base value table to use */
//  let shoextra;    /* extra bits table to use */
  let match;                  /* use base and extra for symbol >= match */
  const count = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  const offs = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  let extra = null;

  let here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES$1 || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES$1) {
    base = extra = work;    /* dummy value--not used */
    match = 20;

  } else if (type === LENS$1) {
    base = lbase;
    extra = lext;
    match = 257;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    match = 0;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS$1 && used > ENOUGH_LENS$1) ||
    (type === DISTS$1 && used > ENOUGH_DISTS$1)) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] + 1 < match) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] >= match) {
      here_op = extra[work[sym] - match];
      here_val = base[work[sym] - match];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS$1 && used > ENOUGH_LENS$1) ||
        (type === DISTS$1 && used > ENOUGH_DISTS$1)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};


var inftrees = inflate_table;

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.






const CODES = 0;
const LENS = 1;
const DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_FINISH: Z_FINISH$1, Z_BLOCK, Z_TREES,
  Z_OK: Z_OK$1, Z_STREAM_END: Z_STREAM_END$1, Z_NEED_DICT: Z_NEED_DICT$1, Z_STREAM_ERROR: Z_STREAM_ERROR$1, Z_DATA_ERROR: Z_DATA_ERROR$1, Z_MEM_ERROR: Z_MEM_ERROR$1, Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2;


/* STATES ====================================================================*/
/* ===========================================================================*/


const    HEAD = 16180;       /* i: waiting for magic header */
const    FLAGS = 16181;      /* i: waiting for method and flags (gzip) */
const    TIME = 16182;       /* i: waiting for modification time (gzip) */
const    OS = 16183;         /* i: waiting for extra flags and operating system (gzip) */
const    EXLEN = 16184;      /* i: waiting for extra length (gzip) */
const    EXTRA = 16185;      /* i: waiting for extra bytes (gzip) */
const    NAME = 16186;       /* i: waiting for end of file name (gzip) */
const    COMMENT = 16187;    /* i: waiting for end of comment (gzip) */
const    HCRC = 16188;       /* i: waiting for header crc (gzip) */
const    DICTID = 16189;    /* i: waiting for dictionary check value */
const    DICT = 16190;      /* waiting for inflateSetDictionary() call */
const        TYPE = 16191;      /* i: waiting for type bits, including last-flag bit */
const        TYPEDO = 16192;    /* i: same, but skip check to exit inflate on new block */
const        STORED = 16193;    /* i: waiting for stored size (length and complement) */
const        COPY_ = 16194;     /* i/o: same as COPY below, but only first time in */
const        COPY = 16195;      /* i/o: waiting for input or output to copy stored block */
const        TABLE = 16196;     /* i: waiting for dynamic block table lengths */
const        LENLENS = 16197;   /* i: waiting for code length code lengths */
const        CODELENS = 16198;  /* i: waiting for length/lit and distance code lengths */
const            LEN_ = 16199;      /* i: same as LEN below, but only first time in */
const            LEN = 16200;       /* i: waiting for length/lit/eob code */
const            LENEXT = 16201;    /* i: waiting for length extra bits */
const            DIST = 16202;      /* i: waiting for distance code */
const            DISTEXT = 16203;   /* i: waiting for distance extra bits */
const            MATCH = 16204;     /* o: waiting for output space to copy string */
const            LIT = 16205;       /* o: waiting for output space to write literal */
const    CHECK = 16206;     /* i: waiting for 32-bit check value */
const    LENGTH = 16207;    /* i: waiting for 32-bit length (gzip) */
const    DONE = 16208;      /* finished check, done -- remain here until reset */
const    BAD = 16209;       /* got a data error -- remain here until reset */
const    MEM = 16210;       /* got an inflate() memory error -- remain here until reset */
const    SYNC = 16211;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
//const ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

const MAX_WBITS = 15;
/* 32K LZ77 window */
const DEF_WBITS = MAX_WBITS;


const zswap32 = (q) => {

  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
};


function InflateState() {
  this.strm = null;           /* pointer back to this zlib stream */
  this.mode = 0;              /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip,
                                 bit 2 true to validate check value */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib), or
                                 -1 if raw or no header yet */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new Uint16Array(320); /* temporary storage for code lengths */
  this.work = new Uint16Array(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new Int32Array(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}


const inflateStateCheck = (strm) => {

  if (!strm) {
    return 1;
  }
  const state = strm.state;
  if (!state || state.strm !== strm ||
    state.mode < HEAD || state.mode > SYNC) {
    return 1;
  }
  return 0;
};


const inflateResetKeep = (strm) => {

  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.flags = -1;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK$1;
};


const inflateReset = (strm) => {

  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

};


const inflateReset2 = (strm, windowBits) => {
  let wrap;

  /* get the state */
  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }
  const state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 5;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};


const inflateInit2 = (strm, windowBits) => {

  if (!strm) { return Z_STREAM_ERROR$1; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  const state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.strm = strm;
  state.window = null/*Z_NULL*/;
  state.mode = HEAD;     /* to pass state test in inflateReset2() */
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
};


const inflateInit = (strm) => {

  return inflateInit2(strm, DEF_WBITS);
};


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
let virgin = true;

let lenfix, distfix; // We have no pointers in JS, so keep tables separate


const fixedtables = (state) => {

  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);

    /* literal/length table */
    let sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inftrees(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inftrees(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
const updatewindow = (strm, src, end, copy) => {

  let dist;
  const state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new Uint8Array(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      state.window.set(src.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
};


const inflate$2 = (strm, flush) => {

  let state;
  let input, output;          // input/output buffers
  let next;                   /* next input INDEX */
  let put;                    /* next output INDEX */
  let have, left;             /* available input and output */
  let hold;                   /* bit buffer */
  let bits;                   /* bits in bit buffer */
  let _in, _out;              /* save starting available input and output */
  let copy;                   /* number of stored or match bytes to copy */
  let from;                   /* where to copy match bytes from */
  let from_source;
  let here = 0;               /* current decoding table entry */
  let here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //let last;                   /* parent table entry */
  let last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  let len;                    /* length to copy for repeats, bits to drop */
  let ret;                    /* return code */
  const hbuf = new Uint8Array(4);    /* buffer for gzip header crc calculation */
  let opts;

  let n; // temporary variable for NEED_BITS

  const order = /* permutation of code lengths */
    new Uint8Array([ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ]);


  if (inflateStateCheck(strm) || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR$1;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK$1;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO;
          break;
        }
        //=== NEEDBITS(16);
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
          if (state.wbits === 0) {
            state.wbits = 15;
          }
          state.check = 0/*crc32(0L, Z_NULL, 0)*/;
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//

          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = FLAGS;
          break;
        }
        if (state.head) {
          state.head.done = false;
        }
        if (!(state.wrap & 1) ||   /* check if zlib header allowed */
          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = BAD;
          break;
        }
        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        len = (hold & 0x0f)/*BITS(4)*/ + 8;
        if (state.wbits === 0) {
          state.wbits = len;
        }
        if (len > 15 || len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = BAD;
          break;
        }

        // !!! pako patch. Force use `options.windowBits` if passed.
        // Required to always use max window size by default.
        state.dmax = 1 << state.wbits;
        //state.dmax = 1 << len;

        state.flags = 0;               /* indicate zlib header */
        //Tracev((stderr, "inflate:   zlib header ok\n"));
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = hold & 0x200 ? DICTID : TYPE;
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        break;
      case FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.flags = hold;
        if ((state.flags & 0xff) !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = BAD;
          break;
        }
        if (state.head) {
          state.head.text = ((hold >> 8) & 1);
        }
        if ((state.flags & 0x0200) && (state.wrap & 4)) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = TIME;
        /* falls through */
      case TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.time = hold;
        }
        if ((state.flags & 0x0200) && (state.wrap & 4)) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          hbuf[2] = (hold >>> 16) & 0xff;
          hbuf[3] = (hold >>> 24) & 0xff;
          state.check = crc32_1(state.check, hbuf, 4, 0);
          //===
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = OS;
        /* falls through */
      case OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.xflags = (hold & 0xff);
          state.head.os = (hold >> 8);
        }
        if ((state.flags & 0x0200) && (state.wrap & 4)) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = EXLEN;
        /* falls through */
      case EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length = hold;
          if (state.head) {
            state.head.extra_len = hold;
          }
          if ((state.flags & 0x0200) && (state.wrap & 4)) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = (hold >>> 8) & 0xff;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        else if (state.head) {
          state.head.extra = null/*Z_NULL*/;
        }
        state.mode = EXTRA;
        /* falls through */
      case EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;
          if (copy > have) { copy = have; }
          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;
              if (!state.head.extra) {
                // Use untyped array for more convenient processing later
                state.head.extra = new Uint8Array(state.head.extra_len);
              }
              state.head.extra.set(
                input.subarray(
                  next,
                  // extra field is limited to 65536 bytes
                  // - no need for additional size check
                  next + copy
                ),
                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                len
              );
              //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }
            if ((state.flags & 0x0200) && (state.wrap & 4)) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            state.length -= copy;
          }
          if (state.length) { break inf_leave; }
        }
        state.length = 0;
        state.mode = NAME;
        /* falls through */
      case NAME:
        if (state.flags & 0x0800) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.name_max*/)) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if ((state.flags & 0x0200) && (state.wrap & 4)) {
            state.check = crc32_1(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.name = null;
        }
        state.length = 0;
        state.mode = COMMENT;
        /* falls through */
      case COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.comm_max*/)) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);
          if ((state.flags & 0x0200) && (state.wrap & 4)) {
            state.check = crc32_1(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.comment = null;
        }
        state.mode = HCRC;
        /* falls through */
      case HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if ((state.wrap & 4) && hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        if (state.head) {
          state.head.hcrc = ((state.flags >> 9) & 1);
          state.head.done = true;
        }
        strm.adler = state.check = 0;
        state.mode = TYPE;
        break;
      case DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        strm.adler = state.check = zswap32(hold);
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = DICT;
        /* falls through */
      case DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          return Z_NEED_DICT$1;
        }
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = TYPE;
        /* falls through */
      case TYPE:
        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7;
          //---//
          state.mode = CHECK;
          break;
        }
        //=== NEEDBITS(3); */
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.last = (hold & 0x01)/*BITS(1)*/;
        //--- DROPBITS(1) ---//
        hold >>>= 1;
        bits -= 1;
        //---//

        switch ((hold & 0x03)/*BITS(2)*/) {
          case 0:                             /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = STORED;
            break;
          case 1:                             /* fixed block */
            fixedtables(state);
            //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = LEN_;             /* decode codes */
            if (flush === Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
              break inf_leave;
            }
            break;
          case 2:                             /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = TABLE;
            break;
          case 3:
            strm.msg = 'invalid block type';
            state.mode = BAD;
        }
        //--- DROPBITS(2) ---//
        hold >>>= 2;
        bits -= 2;
        //---//
        break;
      case STORED:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = BAD;
          break;
        }
        state.length = hold & 0xffff;
        //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = COPY_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case COPY_:
        state.mode = COPY;
        /* falls through */
      case COPY:
        copy = state.length;
        if (copy) {
          if (copy > have) { copy = have; }
          if (copy > left) { copy = left; }
          if (copy === 0) { break inf_leave; }
          //--- zmemcpy(put, next, copy); ---
          output.set(input.subarray(next, next + copy), put);
          //---//
          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        }
        //Tracev((stderr, "inflate:       stored end\n"));
        state.mode = TYPE;
        break;
      case TABLE:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
//#ifndef PKZIP_BUG_WORKAROUND
        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));
        state.have = 0;
        state.mode = LENLENS;
        /* falls through */
      case LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
          //--- DROPBITS(3) ---//
          hold >>>= 3;
          bits -= 3;
          //---//
        }
        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        }
        // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table
        state.lencode = state.lendyn;
        state.lenbits = 7;

        opts = { bits: state.lenbits };
        ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;

        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, "inflate:       code lengths ok\n"));
        state.have = 0;
        state.mode = CODELENS;
        /* falls through */
      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.lens[state.have++] = here_val;
          }
          else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD;
                break;
              }
              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03);//BITS(2);
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
            }
            else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 3 + (hold & 0x07);//BITS(3);
              //--- DROPBITS(3) ---//
              hold >>>= 3;
              bits -= 3;
              //---//
            }
            else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 11 + (hold & 0x7f);//BITS(7);
              //--- DROPBITS(7) ---//
              hold >>>= 7;
              bits -= 7;
              //---//
            }
            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }

        /* handle error breaks in while */
        if (state.mode === BAD) { break; }

        /* check for end-of-block code (better have one) */
        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = BAD;
          break;
        }

        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */
        state.lenbits = 9;

        opts = { bits: state.lenbits };
        ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.lenbits = opts.bits;
        // state.lencode = state.next;

        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = BAD;
          break;
        }

        state.distbits = 6;
        //state.distcode.copy(state.codes);
        // Switch to use dynamic table
        state.distcode = state.distdyn;
        opts = { bits: state.distbits };
        ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.distbits = opts.bits;
        // state.distcode = state.next;

        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, 'inflate:       codes ok\n'));
        state.mode = LEN_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case LEN_:
        state.mode = LEN;
        /* falls through */
      case LEN:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          inffast(strm, _out);
          //--- LOAD() ---
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          //---

          if (state.mode === TYPE) {
            state.back = -1;
          }
          break;
        }
        state.back = 0;
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.lencode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        state.length = here_val;
        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = LIT;
          break;
        }
        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = TYPE;
          break;
        }
        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break;
        }
        state.extra = here_op & 15;
        state.mode = LENEXT;
        /* falls through */
      case LENEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //Tracevv((stderr, "inflate:         length %u\n", state.length));
        state.was = state.length;
        state.mode = DIST;
        /* falls through */
      case DIST:
        for (;;) {
          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.distcode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = BAD;
          break;
        }
        state.offset = here_val;
        state.extra = (here_op) & 15;
        state.mode = DISTEXT;
        /* falls through */
      case DISTEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
//#ifdef INFLATE_STRICT
        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
        state.mode = MATCH;
        /* falls through */
      case MATCH:
        if (left === 0) { break inf_leave; }
        copy = _out - left;
        if (state.offset > copy) {         /* copy from window */
          copy = state.offset - copy;
          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            }
// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
          }
          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          }
          else {
            from = state.wnext - copy;
          }
          if (copy > state.length) { copy = state.length; }
          from_source = state.window;
        }
        else {                              /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }
        if (copy > left) { copy = left; }
        left -= copy;
        state.length -= copy;
        do {
          output[put++] = from_source[from++];
        } while (--copy);
        if (state.length === 0) { state.mode = LEN; }
        break;
      case LIT:
        if (left === 0) { break inf_leave; }
        output[put++] = state.length;
        left--;
        state.mode = LEN;
        break;
      case CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            // Use '|' instead of '+' to make sure that result is signed
            hold |= input[next++] << bits;
            bits += 8;
          }
          //===//
          _out -= left;
          strm.total_out += _out;
          state.total += _out;
          if ((state.wrap & 4) && _out) {
            strm.adler = state.check =
                /*UPDATE_CHECK(state.check, put - _out, _out);*/
                (state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out));

          }
          _out = left;
          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
          if ((state.wrap & 4) && (state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }
        state.mode = LENGTH;
        /* falls through */
      case LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if ((state.wrap & 4) && hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }
        state.mode = DONE;
        /* falls through */
      case DONE:
        ret = Z_STREAM_END$1;
        break inf_leave;
      case BAD:
        ret = Z_DATA_ERROR$1;
        break inf_leave;
      case MEM:
        return Z_MEM_ERROR$1;
      case SYNC:
        /* falls through */
      default:
        return Z_STREAM_ERROR$1;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                      (state.mode < CHECK || flush !== Z_FINISH$1))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if ((state.wrap & 4) && _out) {
    strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};


const inflateEnd = (strm) => {

  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }

  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};


const inflateGetHeader = (strm, head) => {

  /* check state */
  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }
  const state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR$1; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK$1;
};


const inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;

  let state;
  let dictid;
  let ret;

  /* check state */
  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK$1;
};


var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
module.exports.inflateCodesUsed = inflateCodesUsed;
module.exports.inflateCopy = inflateCopy;
module.exports.inflateGetDictionary = inflateGetDictionary;
module.exports.inflateMark = inflateMark;
module.exports.inflatePrime = inflatePrime;
module.exports.inflateSync = inflateSync;
module.exports.inflateSyncPoint = inflateSyncPoint;
module.exports.inflateUndermine = inflateUndermine;
module.exports.inflateValidate = inflateValidate;
*/

var inflate_1$2 = {
	inflateReset: inflateReset_1,
	inflateReset2: inflateReset2_1,
	inflateResetKeep: inflateResetKeep_1,
	inflateInit: inflateInit_1,
	inflateInit2: inflateInit2_1,
	inflate: inflate_2$1,
	inflateEnd: inflateEnd_1,
	inflateGetHeader: inflateGetHeader_1,
	inflateSetDictionary: inflateSetDictionary_1,
	inflateInfo: inflateInfo
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

var gzheader = GZheader;

const toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH, Z_FINISH,
  Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR
} = constants$2;

/* ===========================================================================*/


/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overridden.
 **/

/**
 * Inflate.result -> Uint8Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 * const chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
 * const chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * const inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate$1(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ''
  }, options || {});

  const opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
      !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new zstream();
  this.strm.avail_out = 0;

  let status  = inflate_1$2.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }

  this.header = new gzheader();

  inflate_1$2.inflateGetHeader(this.strm, this.header);

  // Setup dictionary
  if (opt.dictionary) {
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) { //In raw mode we need to set the dictionary early
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}

/**
 * Inflate#push(data[, flush_mode]) -> Boolean
 * - data (Uint8Array|ArrayBuffer): input data
 * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE
 *   flush modes. See constants. Skipped or `false` means Z_NO_FLUSH,
 *   `true` means Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. If end of stream detected,
 * [[Inflate#onEnd]] will be called.
 *
 * `flush_mode` is not needed for normal operation, because end of stream
 * detected automatically. You may try to use it for advanced things, but
 * this functionality was not tested.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate$1.prototype.push = function (data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;

  if (this.ended) return false;

  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;

  // Convert data if needed
  if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  for (;;) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = inflate_1$2.inflate(strm, _flush_mode);

    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);

      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        // Replace code with more verbose
        status = Z_NEED_DICT;
      }
    }

    // Skip snyc markers if more data follows and not raw mode
    while (strm.avail_in > 0 &&
           status === Z_STREAM_END &&
           strm.state.wrap > 0 &&
           data[strm.next_in] !== 0)
    {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }

    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }

    // Remember real `avail_out` value, because we may patch out buffer content
    // to align utf8 strings boundaries.
    last_avail_out = strm.avail_out;

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {

        if (this.options.to === 'string') {

          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail & realign counters
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);

          this.onData(utf8str);

        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }

    // Must repeat iteration if out buffer is full
    if (status === Z_OK && last_avail_out === 0) continue;

    // Finalize if end of stream reached.
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }

    if (strm.avail_in === 0) break;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|String): output data. When string output requested,
 *   each chunk will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate$1.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH). By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate$1.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * inflate(data[, options]) -> Uint8Array|String
 * - data (Uint8Array|ArrayBuffer): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako');
 * const input = pako.deflate(new Uint8Array([1,2,3,4,5,6,7,8,9]));
 * let output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err) {
 *   console.log(err);
 * }
 * ```
 **/
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);

  inflator.push(input);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) throw inflator.msg || messages[inflator.err];

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|String
 * - data (Uint8Array|ArrayBuffer): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}


/**
 * ungzip(data[, options]) -> Uint8Array|String
 * - data (Uint8Array|ArrayBuffer): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var constants = constants$2;

var inflate_1$1 = {
	Inflate: Inflate_1$1,
	inflate: inflate_2,
	inflateRaw: inflateRaw_1$1,
	ungzip: ungzip$1,
	constants: constants
};

const { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;
var Inflate_1 = Inflate;
var inflate_1 = inflate;

const pngSignature = [137, 80, 78, 71, 13, 10, 26, 10];
const crcTable = [];
for (let n = 0; n < 256; n++) {
    let c = n;
    for (let k = 0; k < 8; k++) {
        if (c & 1) {
            c = 0xedb88320 ^ (c >>> 1);
        }
        else {
            c = c >>> 1;
        }
    }
    crcTable[n] = c;
}
const initialCrc = 0xffffffff;
function updateCrc(currentCrc, data, length) {
    let c = currentCrc;
    for (let n = 0; n < length; n++) {
        c = crcTable[(c ^ data[n]) & 0xff] ^ (c >>> 8);
    }
    return c;
}
function crc(data, length) {
    return (updateCrc(initialCrc, data, length) ^ initialCrc) >>> 0;
}

var ColorType;
(function (ColorType) {
    ColorType[ColorType["UNKNOWN"] = -1] = "UNKNOWN";
    ColorType[ColorType["GREYSCALE"] = 0] = "GREYSCALE";
    ColorType[ColorType["TRUECOLOUR"] = 2] = "TRUECOLOUR";
    ColorType[ColorType["INDEXED_COLOUR"] = 3] = "INDEXED_COLOUR";
    ColorType[ColorType["GREYSCALE_ALPHA"] = 4] = "GREYSCALE_ALPHA";
    ColorType[ColorType["TRUECOLOUR_ALPHA"] = 6] = "TRUECOLOUR_ALPHA";
})(ColorType || (ColorType = {}));
var CompressionMethod;
(function (CompressionMethod) {
    CompressionMethod[CompressionMethod["UNKNOWN"] = -1] = "UNKNOWN";
    CompressionMethod[CompressionMethod["DEFLATE"] = 0] = "DEFLATE";
})(CompressionMethod || (CompressionMethod = {}));
var FilterMethod;
(function (FilterMethod) {
    FilterMethod[FilterMethod["UNKNOWN"] = -1] = "UNKNOWN";
    FilterMethod[FilterMethod["ADAPTIVE"] = 0] = "ADAPTIVE";
})(FilterMethod || (FilterMethod = {}));
var InterlaceMethod;
(function (InterlaceMethod) {
    InterlaceMethod[InterlaceMethod["UNKNOWN"] = -1] = "UNKNOWN";
    InterlaceMethod[InterlaceMethod["NO_INTERLACE"] = 0] = "NO_INTERLACE";
    InterlaceMethod[InterlaceMethod["ADAM7"] = 1] = "ADAM7";
})(InterlaceMethod || (InterlaceMethod = {}));

const empty$1 = new Uint8Array(0);
const NULL = '\0';
const uint16 = new Uint16Array([0x00ff]);
const uint8 = new Uint8Array(uint16.buffer);
const osIsLittleEndian = uint8[0] === 0xff;
class PngDecoder extends IOBuffer {
    constructor(data, options = {}) {
        super(data);
        const { checkCrc = false } = options;
        this._checkCrc = checkCrc;
        this._inflator = new Inflate_1();
        this._png = {
            width: -1,
            height: -1,
            channels: -1,
            data: new Uint8Array(0),
            depth: 1,
            text: {},
        };
        this._end = false;
        this._hasPalette = false;
        this._palette = [];
        this._hasTransparency = false;
        this._transparency = new Uint16Array(0);
        this._compressionMethod = CompressionMethod.UNKNOWN;
        this._filterMethod = FilterMethod.UNKNOWN;
        this._interlaceMethod = InterlaceMethod.UNKNOWN;
        this._colorType = ColorType.UNKNOWN;
        // PNG is always big endian
        // https://www.w3.org/TR/PNG/#7Integers-and-byte-order
        this.setBigEndian();
    }
    decode() {
        this.decodeSignature();
        while (!this._end) {
            this.decodeChunk();
        }
        this.decodeImage();
        return this._png;
    }
    // https://www.w3.org/TR/PNG/#5PNG-file-signature
    decodeSignature() {
        for (let i = 0; i < pngSignature.length; i++) {
            if (this.readUint8() !== pngSignature[i]) {
                throw new Error(`wrong PNG signature. Byte at ${i} should be ${pngSignature[i]}.`);
            }
        }
    }
    // https://www.w3.org/TR/PNG/#5Chunk-layout
    decodeChunk() {
        const length = this.readUint32();
        const type = this.readChars(4);
        const offset = this.offset;
        switch (type) {
            // 11.2 Critical chunks
            case 'IHDR': // 11.2.2 IHDR Image header
                this.decodeIHDR();
                break;
            case 'PLTE': // 11.2.3 PLTE Palette
                this.decodePLTE(length);
                break;
            case 'IDAT': // 11.2.4 IDAT Image data
                this.decodeIDAT(length);
                break;
            case 'IEND': // 11.2.5 IEND Image trailer
                this._end = true;
                break;
            // 11.3 Ancillary chunks
            case 'tRNS': // 11.3.2.1 tRNS Transparency
                this.decodetRNS(length);
                break;
            case 'iCCP': // 11.3.3.3 iCCP Embedded ICC profile
                this.decodeiCCP(length);
                break;
            case 'tEXt': // 11.3.4.3 tEXt Textual data
                this.decodetEXt(length);
                break;
            case 'pHYs': // 11.3.5.3 pHYs Physical pixel dimensions
                this.decodepHYs();
                break;
            default:
                this.skip(length);
                break;
        }
        if (this.offset - offset !== length) {
            throw new Error(`Length mismatch while decoding chunk ${type}`);
        }
        if (this._checkCrc) {
            const expectedCrc = this.readUint32();
            const crcLength = length + 4; // includes type
            const actualCrc = crc(new Uint8Array(this.buffer, this.byteOffset + this.offset - crcLength - 4, crcLength), crcLength); // "- 4" because we already advanced by reading the CRC
            if (actualCrc !== expectedCrc) {
                throw new Error(`CRC mismatch for chunk ${type}. Expected ${expectedCrc}, found ${actualCrc}`);
            }
        }
        else {
            this.skip(4);
        }
    }
    // https://www.w3.org/TR/PNG/#11IHDR
    decodeIHDR() {
        const image = this._png;
        image.width = this.readUint32();
        image.height = this.readUint32();
        image.depth = checkBitDepth(this.readUint8());
        const colorType = this.readUint8();
        this._colorType = colorType;
        let channels;
        switch (colorType) {
            case ColorType.GREYSCALE:
                channels = 1;
                break;
            case ColorType.TRUECOLOUR:
                channels = 3;
                break;
            case ColorType.INDEXED_COLOUR:
                channels = 1;
                break;
            case ColorType.GREYSCALE_ALPHA:
                channels = 2;
                break;
            case ColorType.TRUECOLOUR_ALPHA:
                channels = 4;
                break;
            default:
                throw new Error(`Unknown color type: ${colorType}`);
        }
        this._png.channels = channels;
        this._compressionMethod = this.readUint8();
        if (this._compressionMethod !== CompressionMethod.DEFLATE) {
            throw new Error(`Unsupported compression method: ${this._compressionMethod}`);
        }
        this._filterMethod = this.readUint8();
        this._interlaceMethod = this.readUint8();
    }
    // https://www.w3.org/TR/PNG/#11PLTE
    decodePLTE(length) {
        if (length % 3 !== 0) {
            throw new RangeError(`PLTE field length must be a multiple of 3. Got ${length}`);
        }
        const l = length / 3;
        this._hasPalette = true;
        const palette = [];
        this._palette = palette;
        for (let i = 0; i < l; i++) {
            palette.push([this.readUint8(), this.readUint8(), this.readUint8()]);
        }
    }
    // https://www.w3.org/TR/PNG/#11IDAT
    decodeIDAT(length) {
        this._inflator.push(new Uint8Array(this.buffer, this.offset + this.byteOffset, length));
        this.skip(length);
    }
    // https://www.w3.org/TR/PNG/#11tRNS
    decodetRNS(length) {
        switch (this._colorType) {
            case ColorType.GREYSCALE:
            case ColorType.TRUECOLOUR: {
                if (length % 2 !== 0) {
                    throw new RangeError(`tRNS chunk length must be a multiple of 2. Got ${length}`);
                }
                if (length / 2 > this._png.width * this._png.height) {
                    throw new Error(`tRNS chunk contains more alpha values than there are pixels (${length / 2} vs ${this._png.width * this._png.height})`);
                }
                this._hasTransparency = true;
                this._transparency = new Uint16Array(length / 2);
                for (let i = 0; i < length / 2; i++) {
                    this._transparency[i] = this.readUint16();
                }
                break;
            }
            case ColorType.INDEXED_COLOUR: {
                if (length > this._palette.length) {
                    throw new Error(`tRNS chunk contains more alpha values than there are palette colors (${length} vs ${this._palette.length})`);
                }
                let i = 0;
                for (; i < length; i++) {
                    const alpha = this.readByte();
                    this._palette[i].push(alpha);
                }
                for (; i < this._palette.length; i++) {
                    this._palette[i].push(255);
                }
                break;
            }
            default: {
                throw new Error(`tRNS chunk is not supported for color type ${this._colorType}`);
            }
        }
    }
    // https://www.w3.org/TR/PNG/#11iCCP
    decodeiCCP(length) {
        let name = '';
        let char;
        while ((char = this.readChar()) !== NULL) {
            name += char;
        }
        const compressionMethod = this.readUint8();
        if (compressionMethod !== CompressionMethod.DEFLATE) {
            throw new Error(`Unsupported iCCP compression method: ${compressionMethod}`);
        }
        const compressedProfile = this.readBytes(length - name.length - 2);
        this._png.iccEmbeddedProfile = {
            name,
            profile: inflate_1(compressedProfile),
        };
    }
    // https://www.w3.org/TR/PNG/#11tEXt
    decodetEXt(length) {
        let keyword = '';
        let char;
        while ((char = this.readChar()) !== NULL) {
            keyword += char;
        }
        this._png.text[keyword] = this.readChars(length - keyword.length - 1);
    }
    // https://www.w3.org/TR/PNG/#11pHYs
    decodepHYs() {
        const ppuX = this.readUint32();
        const ppuY = this.readUint32();
        const unitSpecifier = this.readByte();
        this._png.resolution = { x: ppuX, y: ppuY, unit: unitSpecifier };
    }
    decodeImage() {
        if (this._inflator.err) {
            throw new Error(`Error while decompressing the data: ${this._inflator.err}`);
        }
        const data = this._inflator.result;
        if (this._filterMethod !== FilterMethod.ADAPTIVE) {
            throw new Error(`Filter method ${this._filterMethod} not supported`);
        }
        if (this._interlaceMethod === InterlaceMethod.NO_INTERLACE) {
            this.decodeInterlaceNull(data);
        }
        else {
            throw new Error(`Interlace method ${this._interlaceMethod} not supported`);
        }
    }
    decodeInterlaceNull(data) {
        const height = this._png.height;
        const bytesPerPixel = (this._png.channels * this._png.depth) / 8;
        const bytesPerLine = this._png.width * bytesPerPixel;
        const newData = new Uint8Array(this._png.height * bytesPerLine);
        let prevLine = empty$1;
        let offset = 0;
        let currentLine;
        let newLine;
        for (let i = 0; i < height; i++) {
            currentLine = data.subarray(offset + 1, offset + 1 + bytesPerLine);
            newLine = newData.subarray(i * bytesPerLine, (i + 1) * bytesPerLine);
            switch (data[offset]) {
                case 0:
                    unfilterNone(currentLine, newLine, bytesPerLine);
                    break;
                case 1:
                    unfilterSub(currentLine, newLine, bytesPerLine, bytesPerPixel);
                    break;
                case 2:
                    unfilterUp(currentLine, newLine, prevLine, bytesPerLine);
                    break;
                case 3:
                    unfilterAverage(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel);
                    break;
                case 4:
                    unfilterPaeth(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel);
                    break;
                default:
                    throw new Error(`Unsupported filter: ${data[offset]}`);
            }
            prevLine = newLine;
            offset += bytesPerLine + 1;
        }
        if (this._hasPalette) {
            this._png.palette = this._palette;
        }
        if (this._hasTransparency) {
            this._png.transparency = this._transparency;
        }
        if (this._png.depth === 16) {
            const uint16Data = new Uint16Array(newData.buffer);
            if (osIsLittleEndian) {
                for (let k = 0; k < uint16Data.length; k++) {
                    // PNG is always big endian. Swap the bytes.
                    uint16Data[k] = swap16(uint16Data[k]);
                }
            }
            this._png.data = uint16Data;
        }
        else {
            this._png.data = newData;
        }
    }
}
function unfilterNone(currentLine, newLine, bytesPerLine) {
    for (let i = 0; i < bytesPerLine; i++) {
        newLine[i] = currentLine[i];
    }
}
function unfilterSub(currentLine, newLine, bytesPerLine, bytesPerPixel) {
    let i = 0;
    for (; i < bytesPerPixel; i++) {
        // just copy first bytes
        newLine[i] = currentLine[i];
    }
    for (; i < bytesPerLine; i++) {
        newLine[i] = (currentLine[i] + newLine[i - bytesPerPixel]) & 0xff;
    }
}
function unfilterUp(currentLine, newLine, prevLine, bytesPerLine) {
    let i = 0;
    if (prevLine.length === 0) {
        // just copy bytes for first line
        for (; i < bytesPerLine; i++) {
            newLine[i] = currentLine[i];
        }
    }
    else {
        for (; i < bytesPerLine; i++) {
            newLine[i] = (currentLine[i] + prevLine[i]) & 0xff;
        }
    }
}
function unfilterAverage(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel) {
    let i = 0;
    if (prevLine.length === 0) {
        for (; i < bytesPerPixel; i++) {
            newLine[i] = currentLine[i];
        }
        for (; i < bytesPerLine; i++) {
            newLine[i] = (currentLine[i] + (newLine[i - bytesPerPixel] >> 1)) & 0xff;
        }
    }
    else {
        for (; i < bytesPerPixel; i++) {
            newLine[i] = (currentLine[i] + (prevLine[i] >> 1)) & 0xff;
        }
        for (; i < bytesPerLine; i++) {
            newLine[i] =
                (currentLine[i] + ((newLine[i - bytesPerPixel] + prevLine[i]) >> 1)) &
                    0xff;
        }
    }
}
function unfilterPaeth(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel) {
    let i = 0;
    if (prevLine.length === 0) {
        for (; i < bytesPerPixel; i++) {
            newLine[i] = currentLine[i];
        }
        for (; i < bytesPerLine; i++) {
            newLine[i] = (currentLine[i] + newLine[i - bytesPerPixel]) & 0xff;
        }
    }
    else {
        for (; i < bytesPerPixel; i++) {
            newLine[i] = (currentLine[i] + prevLine[i]) & 0xff;
        }
        for (; i < bytesPerLine; i++) {
            newLine[i] =
                (currentLine[i] +
                    paethPredictor(newLine[i - bytesPerPixel], prevLine[i], prevLine[i - bytesPerPixel])) &
                    0xff;
        }
    }
}
function paethPredictor(a, b, c) {
    const p = a + b - c;
    const pa = Math.abs(p - a);
    const pb = Math.abs(p - b);
    const pc = Math.abs(p - c);
    if (pa <= pb && pa <= pc)
        return a;
    else if (pb <= pc)
        return b;
    else
        return c;
}
function swap16(val) {
    return ((val & 0xff) << 8) | ((val >> 8) & 0xff);
}
function checkBitDepth(value) {
    if (value !== 1 &&
        value !== 2 &&
        value !== 4 &&
        value !== 8 &&
        value !== 16) {
        throw new Error(`invalid bit depth: ${value}`);
    }
    return value;
}

var ResolutionUnitSpecifier;
(function (ResolutionUnitSpecifier) {
    /**
     * Unit is unknown
     */
    ResolutionUnitSpecifier[ResolutionUnitSpecifier["UNKNOWN"] = 0] = "UNKNOWN";
    /**
     * Unit is the metre
     */
    ResolutionUnitSpecifier[ResolutionUnitSpecifier["METRE"] = 1] = "METRE";
})(ResolutionUnitSpecifier || (ResolutionUnitSpecifier = {}));

function decodePng(data, options) {
    const decoder = new PngDecoder(data, options);
    return decoder.decode();
}

class gltfImage extends GltfObject
{
    static animatedProperties = [];
    constructor(
        uri = undefined,
        type = GL.TEXTURE_2D,
        miplevel = 0,
        bufferView = undefined,
        name = undefined,
        mimeType = undefined,
        image = undefined)
    {
        super();
        this.uri = uri;
        this.bufferView = bufferView;
        this.mimeType = mimeType;
        this.image = image; // javascript image
        this.name = name;
        this.type = type; // nonstandard
        this.miplevel = miplevel; // nonstandard
    }

    resolveRelativePath(basePath)
    {
        if (typeof this.uri === 'string' || this.uri instanceof String) {
            if (this.uri.startsWith('data:')) {
                return;
            }
            if (this.uri.startsWith('./')) {
                this.uri = this.uri.substring(2);
            }
            this.uri = basePath + this.uri;
        }
    }

    async load(gltf, additionalFiles = undefined)
    {
        if (this.image !== undefined)
        {
            if (this.mimeType !== ImageMimeType.GLTEXTURE)
            {
                console.error("image has already been loaded");
            }
            return;
        }

        if (!await this.setImageFromBufferView(gltf) &&
            !await this.setImageFromFiles(gltf, additionalFiles) &&
            !await this.setImageFromUri(gltf) &&
            !await this.setImageFromBase64(gltf))
        {
            return;
        }

        return;
    }

    static loadHTMLImage(url)
    {
        return new Promise( (resolve, reject) => {
            const image = new Image();
            image.addEventListener('load', () => resolve(image) );
            image.addEventListener('error', reject);
            image.src = url;
            image.crossOrigin = "";
        });
    }

    setMimetypeFromFilename(filename)
    {

        let extension = getExtension(filename);
        if(extension == "ktx2" || extension == "ktx")
        {
            this.mimeType = ImageMimeType.KTX2;
        }
        else if(extension == "jpg" || extension == "jpeg")
        {
            this.mimeType = ImageMimeType.JPEG;
        }
        else if(extension == "png" )
        {
            this.mimeType = ImageMimeType.PNG;
        }
        else if(extension == "webp" )
        {
            this.mimeType = ImageMimeType.WEBP;
        }
        else
        {
            console.warn("MimeType not defined");
            // assume jpeg encoding as best guess
            this.mimeType = ImageMimeType.JPEG;
        }

    }

    async setImageFromBytes(gltf, array)
    {
        if (this.mimeType === ImageMimeType.KTX2)
        {
            if (gltf.ktxDecoder !== undefined)
            {
                this.image = await gltf.ktxDecoder.loadKtxFromBuffer(array);
            }
            else
            {
                console.warn('Loading of ktx images failed: KtxDecoder not initalized');
            }
        }
        else if(typeof(Image) !== 'undefined' && (this.mimeType === ImageMimeType.JPEG || this.mimeType === ImageMimeType.PNG || this.mimeType === ImageMimeType.WEBP))
        {
            const blob = new Blob([array], { "type": this.mimeType });
            const objectURL = URL.createObjectURL(blob);
            this.image = await gltfImage.loadHTMLImage(objectURL).catch( () => {
                console.error("Could not load image from buffer view");
            });
        }
        else if(this.mimeType === ImageMimeType.JPEG)
        {
            this.image = jpegJs.decode(array, {useTArray: true});
        }
        else if(this.mimeType === ImageMimeType.PNG)
        {
            this.image = decodePng(array);
        }
        else
        {
            console.error("Unsupported image type " + this.mimeType);
            return false;
        }

        return true;
    }

    async setImageFromBase64(gltf)
    {
        if (this.uri === undefined || !this.uri.startsWith('data:'))
        {
            return false;
        }
        const parts = this.uri.split(",");
        if (this.mimeType === undefined)
        {
            switch (parts[0]) {
            case "data:image/jpeg;base64":
                this.mimeType = ImageMimeType.JPEG;
                break;
            case "data:image/png;base64":
                this.mimeType = ImageMimeType.PNG;
                break;
            case "data:image/webp;base64":
                this.mimeType = ImageMimeType.WEBP;
                break;
            case "data:image/ktx2;base64":
                this.mimeType = ImageMimeType.KTX2;
                break;
            default:
                console.warn(`Data URI ${parts[0]} not supported`);
                return false;
            }
        }
        const res = await fetch(this.uri);
        const buffer = await res.arrayBuffer();
        return await this.setImageFromBytes(gltf, new Uint8Array(buffer));
    }

    async setImageFromUri(gltf)
    {
        if (this.uri === undefined || this.uri.startsWith('data:'))
        {
            return false;
        }
        if (this.mimeType === undefined)
        {
            this.setMimetypeFromFilename(this.uri);
        }

        if(this.mimeType === ImageMimeType.KTX2)
        {
            if (gltf.ktxDecoder !== undefined)
            {
                this.image = await gltf.ktxDecoder.loadKtxFromUri(this.uri);
            }
            else
            {
                console.warn('Loading of ktx images failed: KtxDecoder not initalized');
            }
        }
        else if (typeof(Image) !== 'undefined' && (this.mimeType === ImageMimeType.JPEG || this.mimeType === ImageMimeType.PNG || this.mimeType === ImageMimeType.WEBP))
        {
            this.image = await gltfImage.loadHTMLImage(this.uri).catch( (error) => {
                console.error(error);
            });
        }
        else if(this.mimeType === ImageMimeType.JPEG && this.uri instanceof ArrayBuffer)
        {
            this.image = jpegJs.decode(this.uri, {useTArray: true});
        }
        else if(this.mimeType === ImageMimeType.PNG && this.uri instanceof ArrayBuffer)
        {
            this.image = decodePng(this.uri);
        }
        else
        {
            console.error("Unsupported image type " + this.mimeType);
            return false;
        }

        return true;
    }

    async setImageFromBufferView(gltf)
    {
        const view = gltf.bufferViews[this.bufferView];
        if (view === undefined)
        {
            return false;
        }

        const buffer = gltf.buffers[view.buffer].buffer;
        const array = new Uint8Array(buffer, view.byteOffset, view.byteLength);
        return await this.setImageFromBytes(gltf, array);
    }

    async setImageFromFiles(gltf, files)
    {
        if (this.uri === undefined || files === undefined)
        {
            return false;
        }

        let foundFile = files.find(file => {
            if (file[0] == "/" + this.uri) {
                return true;
            }
        });

        if (foundFile === undefined)
        {
            return false;
        }

        if (this.mimeType === undefined)
        {
            this.setMimetypeFromFilename(foundFile[0]);
        }


        if(this.mimeType === ImageMimeType.KTX2)
        {
            if (gltf.ktxDecoder !== undefined)
            {
                const data = new Uint8Array(await foundFile[1].arrayBuffer());
                this.image = await gltf.ktxDecoder.loadKtxFromBuffer(data);
            }
            else
            {
                console.warn('Loading of ktx images failed: KtxDecoder not initalized');
            }
        }
        else if (typeof(Image) !== 'undefined' && (this.mimeType === ImageMimeType.JPEG || this.mimeType === ImageMimeType.PNG || this.mimeType === ImageMimeType.WEBP))
        {
            const imageData = await AsyncFileReader.readAsDataURL(foundFile[1]).catch( () => {
                console.error("Could not load image with FileReader");
            });
            this.image = await gltfImage.loadHTMLImage(imageData).catch( () => {
                console.error("Could not create image from FileReader image data");
            });
        }
        else
        {
            console.error("Unsupported image type " + this.mimeType);
            return false;
        }


        return true;
    }
}

// https://github.com/KhronosGroup/glTF/blob/khr_ktx2_ibl/extensions/2.0/Khronos/KHR_lights_image_based/schema/imageBasedLight.schema.json

class ImageBasedLight extends GltfObject
{
    static animatedProperties = [];
    constructor()
    {
        super();
        this.rotation = jsToGl([0, 0, 0, 1]);
        this.brightnessFactor = 1;
        this.brightnessOffset = 0;
        this.specularEnvironmentTexture = undefined;
        this.diffuseEnvironmentTexture = undefined;
        this.sheenEnvironmentTexture = undefined;

        // non-gltf
        this.levelCount = 1;
    }

    fromJson(jsonIBL)
    {
        super.fromJson(jsonIBL);

        if(jsonIBL.extensions !== undefined)
        {
            this.fromJsonExtensions(jsonIBL.extensions);
        }
    }

    fromJsonExtensions(extensions)
    {
        if (extensions.KHR_materials_sheen !== undefined)
        {
            this.sheenEnvironmentTexture = extensions.KHR_materials_sheen.sheenEnvironmentTexture;
        }
    }

    initGl(gltf)
    {
        if (this.diffuseEnvironmentTexture !== undefined)
        {
            const textureObject = gltf.textures[this.diffuseEnvironmentTexture];
            textureObject.type = GL.TEXTURE_CUBE_MAP;
        }
        if (this.specularEnvironmentTexture !== undefined)
        {
            const textureObject = gltf.textures[this.specularEnvironmentTexture];
            textureObject.type = GL.TEXTURE_CUBE_MAP;

            const imageObject = gltf.images[textureObject.source];
            this.levelCount = imageObject.image.levelCount;
        }
        if(this.sheenEnvironmentTexture !== undefined)
        {
            const textureObject = gltf.textures[this.sheenEnvironmentTexture];
            textureObject.type = GL.TEXTURE_CUBE_MAP;

            const imageObject = gltf.images[textureObject.source];
            if (this.levelCount !== imageObject.image.levelCount)
            {
                console.error("Specular and sheen do not have same level count");
            }
        }
    }
}

/* globals WebGl */


class gltfTexture extends GltfObject
{
    static animatedProperties = [];
    constructor(sampler = undefined, source = undefined, type = GL.TEXTURE_2D)
    {
        super();
        this.sampler = sampler; // index to gltfSampler, default sampler ?
        this.source = source; // index to gltfImage

        // non gltf
        this.glTexture = undefined;
        this.type = type;
        this.initialized = false;
        this.mipLevelCount = 0;
    }

    initGl(gltf, webGlContext)
    {
        if (this.sampler === undefined)
        {
            this.sampler = gltf.samplers.length - 1;
        }

        initGlForMembers(this, gltf, webGlContext);
    }

    fromJson(jsonTexture)
    {
        super.fromJson(jsonTexture);
        if (jsonTexture.extensions !== undefined &&
            jsonTexture.extensions.EXT_texture_webp !== undefined &&
            jsonTexture.extensions.EXT_texture_webp.source !== undefined)
        {
            this.source = jsonTexture.extensions.EXT_texture_webp.source;
        }
        if (jsonTexture.extensions !== undefined &&
            jsonTexture.extensions.KHR_texture_basisu !== undefined &&
            jsonTexture.extensions.KHR_texture_basisu.source !== undefined)
        {
            this.source = jsonTexture.extensions.KHR_texture_basisu.source;
        }
    }

    destroy()
    {
        if (this.glTexture !== undefined)
        {
            // TODO: this breaks the dependency direction
            WebGl.context.deleteTexture(this.glTexture);
        }

        this.glTexture = undefined;
    }
}

class gltfTextureInfo extends GltfObject
{
    static animatedProperties = ["strength", "scale"];
    constructor(index = undefined, texCoord = 0, linear = true, samplerName = "", generateMips = true) // linear by default
    {
        super();
        this.index = index; // reference to gltfTexture
        this.texCoord = texCoord; // which UV set to use
        this.linear = linear;
        this.samplerName = samplerName;
        this.strength = 1.0; // occlusion
        this.scale = 1.0; // normal
        this.generateMips = generateMips;

        this.extensions = undefined;
    }

    initGl(gltf, webGlContext)
    {
        initGlForMembers(this, gltf, webGlContext);
    }

    fromJson(jsonTextureInfo)
    {
        fromKeys(this, jsonTextureInfo);

        if (jsonTextureInfo?.extensions?.KHR_texture_transform !== undefined)
        {
            this.extensions.KHR_texture_transform = new KHR_texture_transform();
            this.extensions.KHR_texture_transform.fromJson(jsonTextureInfo.extensions.KHR_texture_transform);
        }
    }
}

class KHR_texture_transform extends GltfObject {
    static animatedProperties = ["offset", "scale", "rotation"];
    constructor() {
        super();
        this.offset = [0, 0];
        this.scale = [1, 1];
        this.rotation = 0;
    }
}

class gltfMaterial extends GltfObject
{
    static animatedProperties = ["alphaCutoff", "emissiveFactor"];
    constructor()
    {
        super();
        this.name = undefined;
        this.pbrMetallicRoughness = new PbrMetallicRoughness();
        this.normalTexture = undefined;
        this.occlusionTexture = undefined;
        this.emissiveTexture = undefined;
        this.emissiveFactor = fromValues$2(0, 0, 0);
        this.alphaMode = "OPAQUE";
        this.alphaCutoff = 0.5;
        this.doubleSided = false;

        // pbr next extension toggles
        this.hasClearcoat = false;
        this.hasSheen = false;
        this.hasTransmission = false;
        this.hasDiffuseTransmission = false;
        this.hasIOR = false;
        this.hasEmissiveStrength = false;
        this.hasVolume = false;
        this.hasIridescence = false;
        this.hasAnisotropy = false;
        this.hasDispersion = false;

        // non gltf properties
        this.type = "unlit";
        this.textures = [];
        this.textureTransforms = [];
        this.defines = [];
    }

    static createDefault()
    {
        const defaultMaterial = new gltfMaterial();
        defaultMaterial.type = "MR";
        defaultMaterial.name = "Default Material";
        defaultMaterial.defines.push("MATERIAL_METALLICROUGHNESS 1");

        return defaultMaterial;
    }

    getDefines(renderingParameters)
    {
        const defines = Array.from(this.defines);

        if (this.hasClearcoat && renderingParameters.enabledExtensions.KHR_materials_clearcoat)
        {
            defines.push("MATERIAL_CLEARCOAT 1");
        }
        if (this.hasSheen && renderingParameters.enabledExtensions.KHR_materials_sheen)
        {
            defines.push("MATERIAL_SHEEN 1");
        }
        if (this.hasTransmission && renderingParameters.enabledExtensions.KHR_materials_transmission)
        {
            defines.push("MATERIAL_TRANSMISSION 1");
        }
        if(this.hasDiffuseTransmission && renderingParameters.enabledExtensions.KHR_materials_diffuse_transmission)
        {
            defines.push("MATERIAL_DIFFUSE_TRANSMISSION 1");
        }
        if (this.hasVolume && renderingParameters.enabledExtensions.KHR_materials_volume)
        {
            defines.push("MATERIAL_VOLUME 1");
        }
        if(this.hasIOR && renderingParameters.enabledExtensions.KHR_materials_ior)
        {
            defines.push("MATERIAL_IOR 1");
        }
        if(this.hasSpecular && renderingParameters.enabledExtensions.KHR_materials_specular)
        {
            defines.push("MATERIAL_SPECULAR 1");
        }
        if(this.hasIridescence && renderingParameters.enabledExtensions.KHR_materials_iridescence)
        {
            defines.push("MATERIAL_IRIDESCENCE 1");
        }
        if(this.hasEmissiveStrength && renderingParameters.enabledExtensions.KHR_materials_emissive_strength)
        {
            defines.push("MATERIAL_EMISSIVE_STRENGTH 1");
        }
        if(this.hasAnisotropy && renderingParameters.enabledExtensions.KHR_materials_anisotropy)
        {
            defines.push("MATERIAL_ANISOTROPY 1");
        }
        if(this.hasDispersion && renderingParameters.enabledExtensions.KHR_materials_dispersion)
        {
            defines.push("MATERIAL_DISPERSION 1");
        }

        return defines;
    }

    updateTextureTransforms(shader)
    {
        for (const { key, uv } of this.textureTransforms) {
            let rotation = create$4();
            let scale = create$4();
            let translation = create$4();

            if (uv.rotation !== undefined)
            {
                const s =  Math.sin(uv.rotation);
                const c =  Math.cos(uv.rotation);
                rotation = jsToGl([
                    c, -s, 0.0,
                    s, c, 0.0,
                    0.0, 0.0, 1.0]);
            }

            if (uv.scale !== undefined)
            {
                scale = jsToGl([
                    uv.scale[0], 0, 0, 
                    0, uv.scale[1], 0, 
                    0, 0, 1
                ]);
            }

            if (uv.offset !== undefined)
            {
                translation = jsToGl([
                    1, 0, 0, 
                    0, 1, 0, 
                    uv.offset[0], uv.offset[1], 1
                ]);
            }

            let uvMatrix = create$4();
            multiply$1(uvMatrix, translation, rotation);
            multiply$1(uvMatrix, uvMatrix, scale);
            shader.updateUniform("u_" + key + "UVTransform", jsToGl(uvMatrix));
            
            if(key === "Normal") {
                shader.updateUniform("u_vertNormalUVTransform", jsToGl(uvMatrix));
            }
        }
    }

    parseTextureInfoExtensions(textureInfo, textureKey)
    {
        if (textureInfo.extensions?.KHR_texture_transform === undefined)
        {
            return;
        }

        const uv = textureInfo.extensions.KHR_texture_transform;

        this.textureTransforms.push({
            key: textureKey,
            uv: uv
        });

        if(uv.texCoord !== undefined)
        {
            textureInfo.texCoord = uv.texCoord;
        }

        this.defines.push("HAS_" + textureKey.toUpperCase() + "_UV_TRANSFORM 1");
    }

    initGl(gltf, webGlContext)
    {
        if (this.normalTexture !== undefined)
        {
            this.normalTexture.samplerName = "u_NormalSampler";
            this.parseTextureInfoExtensions(this.normalTexture, "Normal");
            this.textures.push(this.normalTexture);
            this.defines.push("HAS_NORMAL_MAP 1");
        }

        if (this.occlusionTexture !== undefined)
        {
            this.occlusionTexture.samplerName = "u_OcclusionSampler";
            this.parseTextureInfoExtensions(this.occlusionTexture, "Occlusion");
            this.textures.push(this.occlusionTexture);
            this.defines.push("HAS_OCCLUSION_MAP 1");
        }

        if (this.emissiveTexture !== undefined)
        {
            this.emissiveTexture.samplerName = "u_EmissiveSampler";
            this.parseTextureInfoExtensions(this.emissiveTexture, "Emissive");
            this.textures.push(this.emissiveTexture);
            this.defines.push("HAS_EMISSIVE_MAP 1");
        }

        if (this.pbrMetallicRoughness.baseColorTexture !== undefined)
        {
            this.pbrMetallicRoughness.baseColorTexture.samplerName = "u_BaseColorSampler";
            this.parseTextureInfoExtensions(this.pbrMetallicRoughness.baseColorTexture, "BaseColor");
            this.textures.push(this.pbrMetallicRoughness.baseColorTexture);
            this.defines.push("HAS_BASE_COLOR_MAP 1");
        }

        if (this.pbrMetallicRoughness.metallicRoughnessTexture !== undefined)
        {
            this.pbrMetallicRoughness.metallicRoughnessTexture.samplerName = "u_MetallicRoughnessSampler";
            this.parseTextureInfoExtensions(this.pbrMetallicRoughness.metallicRoughnessTexture, "MetallicRoughness");
            this.textures.push(this.pbrMetallicRoughness.metallicRoughnessTexture);
            this.defines.push("HAS_METALLIC_ROUGHNESS_MAP 1");
        }

        if (this.extensions?.KHR_materials_pbrSpecularGlossiness?.diffuseTexture !== undefined)
        {
            const diffuseTexture = this.extensions.KHR_materials_pbrSpecularGlossiness.diffuseTexture;
            diffuseTexture.samplerName = "u_DiffuseSampler";
            this.parseTextureInfoExtensions(diffuseTexture, "Diffuse");
            this.textures.push(diffuseTexture);
            this.defines.push("HAS_DIFFUSE_MAP 1");
        }

        if (this.extensions?.KHR_materials_pbrSpecularGlossiness?.specularGlossinessTexture !== undefined)
        {
            const specularGlossinessTexture = this.extensions.KHR_materials_pbrSpecularGlossiness.specularGlossinessTexture;
            specularGlossinessTexture.samplerName = "u_SpecularGlossinessSampler";
            this.parseTextureInfoExtensions(specularGlossinessTexture, "SpecularGlossiness");
            this.textures.push(specularGlossinessTexture);
            this.defines.push("HAS_SPECULAR_GLOSSINESS_MAP 1");
        }

        this.defines.push("ALPHAMODE_OPAQUE 0");
        this.defines.push("ALPHAMODE_MASK 1");
        this.defines.push("ALPHAMODE_BLEND 2");
        if(this.alphaMode === 'MASK') // only set cutoff value for mask material
        {
            this.defines.push("ALPHAMODE ALPHAMODE_MASK");
        }
        else if (this.alphaMode === 'OPAQUE')
        {
            this.defines.push("ALPHAMODE ALPHAMODE_OPAQUE");
        }
        else
        {
            this.defines.push("ALPHAMODE ALPHAMODE_BLEND");
        }

        // if we have SG, we prefer SG (best practice) but if we have neither objects we use MR default values
        if (this.type !== "SG")
        {
            this.defines.push("MATERIAL_METALLICROUGHNESS 1");
        }

        if (this.extensions !== undefined)
        {
            if (this.extensions.KHR_materials_unlit !== undefined)
            {
                this.defines.push("MATERIAL_UNLIT 1");
            }

            if (this.extensions.KHR_materials_pbrSpecularGlossiness !== undefined)
            {
                this.defines.push("MATERIAL_SPECULARGLOSSINESS 1");
            }

            // Clearcoat is part of the default metallic-roughness shader
            if(this.extensions.KHR_materials_clearcoat !== undefined)
            {
                this.hasClearcoat = true;

                const clearcoatTexture = this.extensions.KHR_materials_clearcoat.clearcoatTexture;
                if (clearcoatTexture !== undefined)
                {
                    clearcoatTexture.samplerName = "u_ClearcoatSampler";
                    this.parseTextureInfoExtensions(clearcoatTexture, "Clearcoat");
                    this.textures.push(clearcoatTexture);
                    this.defines.push("HAS_CLEARCOAT_MAP 1");
                }

                const clearcoatRoughnessTexture = this.extensions.KHR_materials_clearcoat.clearcoatRoughnessTexture;
                if (clearcoatRoughnessTexture !== undefined)
                {
                    clearcoatRoughnessTexture.samplerName = "u_ClearcoatRoughnessSampler";
                    this.parseTextureInfoExtensions(clearcoatRoughnessTexture, "ClearcoatRoughness");
                    this.textures.push(clearcoatRoughnessTexture);
                    this.defines.push("HAS_CLEARCOAT_ROUGHNESS_MAP 1");
                }

                const clearcoatNormalTexture = this.extensions.KHR_materials_clearcoat.clearcoatNormalTexture;
                if (clearcoatNormalTexture !== undefined)
                {
                    clearcoatNormalTexture.samplerName = "u_ClearcoatNormalSampler";
                    this.parseTextureInfoExtensions(clearcoatNormalTexture, "ClearcoatNormal");
                    this.textures.push(clearcoatNormalTexture);
                    this.defines.push("HAS_CLEARCOAT_NORMAL_MAP 1");
                }
            }

            // Sheen material extension
            // https://github.com/sebavan/glTF/tree/KHR_materials_sheen/extensions/2.0/Khronos/KHR_materials_sheen
            if(this.extensions.KHR_materials_sheen !== undefined)
            {
                this.hasSheen = true;
     
                if (this.extensions.KHR_materials_sheen.sheenRoughnessTexture !== undefined)
                {
                    this.extensions.KHR_materials_sheen.sheenRoughnessTexture.samplerName = "u_SheenRoughnessSampler";
                    this.parseTextureInfoExtensions(this.extensions.KHR_materials_sheen.sheenRoughnessTexture, "SheenRoughness");
                    this.textures.push(this.extensions.KHR_materials_sheen.sheenRoughnessTexture);
                    this.defines.push("HAS_SHEEN_ROUGHNESS_MAP 1");
                }
                
                const sheenColorTexture = this.extensions.KHR_materials_sheen.sheenColorTexture;
                if (sheenColorTexture !== undefined)
                {
                    sheenColorTexture.samplerName = "u_SheenColorSampler";
                    this.parseTextureInfoExtensions(sheenColorTexture, "SheenColor");
                    sheenColorTexture.linear = false;
                    this.textures.push(sheenColorTexture);
                    this.defines.push("HAS_SHEEN_COLOR_MAP 1");
                }
            }

            // KHR Extension: Specular
            if (this.extensions.KHR_materials_specular !== undefined)
            {
                this.hasSpecular = true;

                if (this.extensions.KHR_materials_specular?.specularTexture !== undefined)
                {
                    this.extensions.KHR_materials_specular.specularTexture.samplerName = "u_SpecularSampler";
                    this.parseTextureInfoExtensions(this.extensions?.KHR_materials_specular?.specularTexture, "Specular");
                    this.textures.push(this.extensions?.KHR_materials_specular?.specularTexture);
                    this.defines.push("HAS_SPECULAR_MAP 1");
                }

                if (this.extensions.KHR_materials_specular?.specularColorTexture !== undefined)
                {
                    this.extensions.KHR_materials_specular.specularColorTexture.samplerName = "u_SpecularColorSampler";
                    this.parseTextureInfoExtensions(this.extensions?.KHR_materials_specular.specularColorTexture, "SpecularColor");
                    this.extensions.KHR_materials_specular.specularColorTexture.linear = false;
                    this.textures.push(this.extensions.KHR_materials_specular.specularColorTexture);
                    this.defines.push("HAS_SPECULAR_COLOR_MAP 1");
                }
            }

            // KHR Extension: Emissive strength
            if (this.extensions.KHR_materials_emissive_strength !== undefined)
            {
                this.hasEmissiveStrength = true;
            }

            // KHR Extension: Transmission
            if (this.extensions.KHR_materials_transmission !== undefined)
            {
                this.hasTransmission = true;

                if (this.extensions?.KHR_materials_transmission?.transmissionTexture !== undefined)
                {
                    this.extensions.KHR_materials_transmission.transmissionTexture.samplerName = "u_TransmissionSampler";
                    this.parseTextureInfoExtensions(this.extensions?.KHR_materials_transmission?.transmissionTexture, "Transmission");
                    this.textures.push(this.extensions?.KHR_materials_transmission?.transmissionTexture);
                    this.defines.push("HAS_TRANSMISSION_MAP 1");
                }
            }

            // KHR Extension: Diffuse Transmission
            if(this.extensions.KHR_materials_diffuse_transmission !== undefined)
            {
                const extension = this.extensions.KHR_materials_diffuse_transmission;

                this.hasDiffuseTransmission = true;

                if (extension.diffuseTransmissionTexture !== undefined)
                {
                    extension.diffuseTransmissionTexture.samplerName = "u_DiffuseTransmissionSampler";
                    this.parseTextureInfoExtensions(extension.diffuseTransmissionTexture, "DiffuseTransmission");
                    this.textures.push(extension.diffuseTransmissionTexture);
                    this.defines.push("HAS_DIFFUSE_TRANSMISSION_MAP 1");
                }

                if (extension.diffuseTransmissionColorTexture !== undefined)
                {
                    extension.diffuseTransmissionColorTexture.samplerName = "u_DiffuseTransmissionColorSampler";
                    this.parseTextureInfoExtensions(extension.diffuseTransmissionColorTexture, "DiffuseTransmissionColor");
                    this.textures.push(extension.diffuseTransmissionColorTexture);
                    this.defines.push("HAS_DIFFUSE_TRANSMISSION_COLOR_MAP 1");
                }
            }

            // KHR Extension: IOR
            //https://github.com/DassaultSystemes-Technology/glTF/tree/KHR_materials_ior/extensions/2.0/Khronos/KHR_materials_ior
            if (this.extensions.KHR_materials_ior !== undefined)
            {
                this.hasIOR = true;
            }

            // KHR Extension: Volume
            if (this.extensions.KHR_materials_volume !== undefined)
            {
                this.hasVolume = true;

                if (this.extensions?.KHR_materials_volume?.thicknessTexture !== undefined)
                {
                    this.extensions.KHR_materials_volume.thicknessTexture.samplerName = "u_ThicknessSampler";
                    this.parseTextureInfoExtensions(this.extensions.KHR_materials_volume.thicknessTexture, "Thickness");
                    this.textures.push(this.extensions.KHR_materials_volume.thicknessTexture);
                    this.defines.push("HAS_THICKNESS_MAP 1");
                }
            }

            // KHR Extension: Iridescence
            // See https://github.com/ux3d/glTF/tree/extensions/KHR_materials_iridescence/extensions/2.0/Khronos/KHR_materials_iridescence
            if(this.extensions.KHR_materials_iridescence !== undefined)
            {
                this.hasIridescence = true;

                const extension = this.extensions.KHR_materials_iridescence;

                if (extension.iridescenceTexture !== undefined)
                {
                    extension.iridescenceTexture.samplerName = "u_IridescenceSampler";
                    this.parseTextureInfoExtensions(extension.iridescenceTexture, "Iridescence");
                    this.textures.push(extension.iridescenceTexture);
                    this.defines.push("HAS_IRIDESCENCE_MAP 1");
                }

                if (extension.iridescenceThicknessTexture !== undefined)
                {
                    extension.iridescenceThicknessTexture.samplerName = "u_IridescenceThicknessSampler";
                    this.parseTextureInfoExtensions(extension.iridescenceThicknessTexture, "IridescenceThickness");
                    this.textures.push(extension.iridescenceThicknessTexture);
                    this.defines.push("HAS_IRIDESCENCE_THICKNESS_MAP 1");
                }
            }

            // KHR Extension: Anisotropy
            // See https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_anisotropy
            if(this.extensions.KHR_materials_anisotropy !== undefined)
            {
                this.hasAnisotropy = true;

                const anisotropyTexture = this.extensions.KHR_materials_anisotropy.anisotropyTexture;

                if (anisotropyTexture !== undefined)
                {
                    anisotropyTexture.samplerName = "u_AnisotropySampler";
                    this.parseTextureInfoExtensions(anisotropyTexture, "Anisotropy");
                    this.textures.push(anisotropyTexture);
                    this.defines.push("HAS_ANISOTROPY_MAP 1");
                }
            }

            // KHR Extension: Dispersion
            // See https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_dispersion
            if (this.extensions.KHR_materials_dispersion !== undefined)
            {
                this.hasDispersion = true;
            }
        }

        initGlForMembers(this, gltf, webGlContext);
    }

    fromJson(jsonMaterial)
    {
        super.fromJson(jsonMaterial);

        if (jsonMaterial.normalTexture !== undefined)
        {
            const normalTexture = new gltfTextureInfo();
            normalTexture.fromJson(jsonMaterial.normalTexture);
            this.normalTexture = normalTexture;
        }

        if (jsonMaterial.occlusionTexture !== undefined)
        {
            const occlusionTexture = new gltfTextureInfo();
            occlusionTexture.fromJson(jsonMaterial.occlusionTexture);
            this.occlusionTexture = occlusionTexture;
        }

        if (jsonMaterial.emissiveTexture !== undefined)
        {
            const emissiveTexture = new gltfTextureInfo(undefined, 0, false);
            emissiveTexture.fromJson(jsonMaterial.emissiveTexture);
            this.emissiveTexture = emissiveTexture;
        }

        if(jsonMaterial.extensions !== undefined)
        {
            this.fromJsonMaterialExtensions(jsonMaterial.extensions);
        }
        this.pbrMetallicRoughness = new PbrMetallicRoughness();
        if (jsonMaterial.pbrMetallicRoughness !== undefined && this.type !== "SG")
        {
            this.type = "MR";
            this.pbrMetallicRoughness.fromJson(jsonMaterial.pbrMetallicRoughness);
        }
    }

    fromJsonMaterialExtensions(jsonExtensions)
    {
        if (jsonExtensions.KHR_materials_pbrSpecularGlossiness !== undefined)
        {
            this.type = "SG";
            this.extensions.KHR_materials_pbrSpecularGlossiness = new KHR_materials_pbrSpecularGlossiness();
            this.extensions.KHR_materials_pbrSpecularGlossiness.fromJson(jsonExtensions.KHR_materials_pbrSpecularGlossiness);
        }

        if(jsonExtensions.KHR_materials_unlit !== undefined)
        {
            this.type = "unlit";
        }

        if(jsonExtensions.KHR_materials_clearcoat !== undefined)
        {
            this.extensions.KHR_materials_clearcoat = new KHR_materials_clearcoat();
            this.extensions.KHR_materials_clearcoat.fromJson(jsonExtensions.KHR_materials_clearcoat);
        }

        if(jsonExtensions.KHR_materials_sheen !== undefined)
        {
            this.extensions.KHR_materials_sheen = new KHR_materials_sheen();
            this.extensions.KHR_materials_sheen.fromJson(jsonExtensions.KHR_materials_sheen);
        }

        if(jsonExtensions.KHR_materials_transmission !== undefined)
        {
            this.extensions.KHR_materials_transmission = new KHR_materials_transmission();
            this.extensions.KHR_materials_transmission.fromJson(jsonExtensions.KHR_materials_transmission);
        }

        if(jsonExtensions.KHR_materials_diffuse_transmission !== undefined)
        {
            this.extensions.KHR_materials_diffuse_transmission = new KHR_materials_diffuse_transmission();
            this.extensions.KHR_materials_diffuse_transmission.fromJson(jsonExtensions.KHR_materials_diffuse_transmission);
        }

        if(jsonExtensions.KHR_materials_specular !== undefined)
        {
            this.extensions.KHR_materials_specular = new KHR_materials_specular();
            this.extensions.KHR_materials_specular.fromJson(jsonExtensions.KHR_materials_specular);
        }

        if(jsonExtensions.KHR_materials_volume !== undefined)
        {
            this.extensions.KHR_materials_volume = new KHR_materials_volume();
            this.extensions.KHR_materials_volume.fromJson(jsonExtensions.KHR_materials_volume);
        }

        if(jsonExtensions.KHR_materials_iridescence !== undefined)
        {
            this.extensions.KHR_materials_iridescence = new KHR_materials_iridescence();
            this.extensions.KHR_materials_iridescence.fromJson(jsonExtensions.KHR_materials_iridescence);
        }

        if(jsonExtensions.KHR_materials_anisotropy !== undefined)
        {
            this.extensions.KHR_materials_anisotropy = new KHR_materials_anisotropy();
            this.extensions.KHR_materials_anisotropy.fromJson(jsonExtensions.KHR_materials_anisotropy);
        }
        
        if(jsonExtensions.KHR_materials_emissive_strength !== undefined)
        {
            this.extensions.KHR_materials_emissive_strength = new KHR_materials_emissive_strength();
            this.extensions.KHR_materials_emissive_strength.fromJson(jsonExtensions.KHR_materials_emissive_strength);
        }

        if(jsonExtensions.KHR_materials_dispersion !== undefined) {
            this.extensions.KHR_materials_dispersion = new KHR_materials_dispersion();
            this.extensions.KHR_materials_dispersion.fromJson(jsonExtensions.KHR_materials_dispersion);
        }

        if(jsonExtensions.KHR_materials_ior !== undefined) {
            this.extensions.KHR_materials_ior = new KHR_materials_ior();
            this.extensions.KHR_materials_ior.fromJson(jsonExtensions.KHR_materials_ior);
        }
    }
}

class PbrMetallicRoughness extends GltfObject {
    static animatedProperties = ["baseColorFactor", "metallicFactor", "roughnessFactor"];
    constructor()
    {
        super();
        this.baseColorFactor = fromValues$1(1, 1, 1, 1);
        this.baseColorTexture = undefined;
        this.metallicFactor = 1;
        this.roughnessFactor = 1;
        this.metallicRoughnessTexture = undefined;
    }

    fromJson(json) {
        super.fromJson(json);
        if (json.baseColorTexture !== undefined)
        {
            const baseColorTexture = new gltfTextureInfo(undefined, 0, false);
            baseColorTexture.fromJson(json.baseColorTexture);
            this.baseColorTexture = baseColorTexture;
        }

        if (json.metallicRoughnessTexture !== undefined)
        {
            const metallicRoughnessTexture = new gltfTextureInfo();
            metallicRoughnessTexture.fromJson(json.metallicRoughnessTexture);
            this.metallicRoughnessTexture = metallicRoughnessTexture;
        }
    }
}

class KHR_materials_anisotropy extends GltfObject {
    static animatedProperties = ["anisotropyStrength", "anisotropyRotation"];
    constructor()
    {
        super();
        this.anisotropyStrength = 0;
        this.anisotropyRotation = 0;
        this.anisotropyTexture = undefined;
    }

    fromJson(json) {
        super.fromJson(json);
        if (json.anisotropyTexture !== undefined)
        {
            const anisotropyTexture = new gltfTextureInfo();
            anisotropyTexture.fromJson(json.anisotropyTexture);
            this.anisotropyTexture = anisotropyTexture;
        }
    }
}

class KHR_materials_clearcoat extends GltfObject {
    static animatedProperties = ["clearcoatFactor", "clearcoatRoughnessFactor"];
    constructor()
    {
        super();
        this.clearcoatFactor = 0;
        this.clearcoatTexture = undefined;
        this.clearcoatRoughnessFactor = 0;
        this.clearcoatRoughnessTexture = undefined;
        this.clearcoatNormalTexture = undefined;
    }

    fromJson(jsonClearcoat) {
        super.fromJson(jsonClearcoat);
        if(jsonClearcoat.clearcoatTexture !== undefined)
        {
            const clearcoatTexture = new gltfTextureInfo();
            clearcoatTexture.fromJson(jsonClearcoat.clearcoatTexture);
            this.clearcoatTexture = clearcoatTexture;
        }

        if(jsonClearcoat.clearcoatRoughnessTexture !== undefined)
        {
            const clearcoatRoughnessTexture =  new gltfTextureInfo();
            clearcoatRoughnessTexture.fromJson(jsonClearcoat.clearcoatRoughnessTexture);
            this.clearcoatRoughnessTexture = clearcoatRoughnessTexture;
        }

        if(jsonClearcoat.clearcoatNormalTexture !== undefined)
        {
            const clearcoatNormalTexture =  new gltfTextureInfo();
            clearcoatNormalTexture.fromJson(jsonClearcoat.clearcoatNormalTexture);
            this.clearcoatNormalTexture = clearcoatNormalTexture;
        }
    }
}

class KHR_materials_dispersion extends GltfObject {
    static animatedProperties = ["dispersion"];
    constructor()
    {
        super();
        this.dispersion = 0;
    }
}

class KHR_materials_emissive_strength extends GltfObject {
    static animatedProperties = ["emissiveStrength"];
    constructor()
    {
        super();
        this.emissiveStrength = 1.0;
    }
}

class KHR_materials_ior extends GltfObject {
    static animatedProperties = ["ior"];
    constructor()
    {
        super();
        this.ior = 1.5;
    }
}

class KHR_materials_iridescence extends GltfObject {
    static animatedProperties = ["iridescenceFactor", "iridescenceIor", "iridescenceThicknessMinimum", "iridescenceThicknessMaximum"];
    constructor()
    {
        super();
        this.iridescenceFactor = 0;
        this.iridescenceIor = 1.3;
        this.iridescenceThicknessMinimum = 100;
        this.iridescenceThicknessMaximum = 400;
        this.iridescenceTexture = undefined;
        this.iridescenceThicknessTexture = undefined;
    }

    fromJson(jsonIridescence) {
        super.fromJson(jsonIridescence);
        if(jsonIridescence.iridescenceTexture !== undefined)
        {
            const iridescenceTexture = new gltfTextureInfo();
            iridescenceTexture.fromJson(jsonIridescence.iridescenceTexture);
            this.iridescenceTexture = iridescenceTexture;
        }

        if(jsonIridescence.iridescenceThicknessTexture !== undefined)
        {
            const iridescenceThicknessTexture = new gltfTextureInfo();
            iridescenceThicknessTexture.fromJson(jsonIridescence.iridescenceThicknessTexture);
            this.iridescenceThicknessTexture = iridescenceThicknessTexture;
        }
    }
}

class KHR_materials_sheen extends GltfObject {
    static animatedProperties = ["sheenRoughnessFactor", "sheenColorFactor"];
    constructor()
    {
        super();
        this.sheenRoughnessFactor = 0;
        this.sheenColorFactor = fromValues$2(0, 0, 0);
        this.sheenColorTexture = undefined;
        this.sheenRoughnessTexture = undefined;
    }

    fromJson(jsonSheen) {
        super.fromJson(jsonSheen);
        if(jsonSheen.sheenColorTexture !== undefined)
        {
            const sheenColorTexture = new gltfTextureInfo();
            sheenColorTexture.fromJson(jsonSheen.sheenColorTexture);
            this.sheenColorTexture = sheenColorTexture;
        }

        if(jsonSheen.sheenRoughnessTexture !== undefined)
        {
            const sheenRoughnessTexture = new gltfTextureInfo();
            sheenRoughnessTexture.fromJson(jsonSheen.sheenRoughnessTexture);
            this.sheenRoughnessTexture = sheenRoughnessTexture;
        }
    }
}

class KHR_materials_specular extends GltfObject {
    static animatedProperties = ["specularFactor", "specularColorFactor"];
    constructor()
    {
        super();
        this.specularFactor = 1;
        this.specularColorFactor = fromValues$2(1, 1, 1);
        this.specularTexture = undefined;
        this.specularColorTexture = undefined;
    }

    fromJson(jsonSpecular) {
        super.fromJson(jsonSpecular);
        if(jsonSpecular.specularTexture !== undefined)
        {
            const specularTexture = new gltfTextureInfo();
            specularTexture.fromJson(jsonSpecular.specularTexture);
            this.specularTexture = specularTexture;
        }

        if(jsonSpecular.specularColorTexture !== undefined)
        {
            const specularColorTexture = new gltfTextureInfo();
            specularColorTexture.fromJson(jsonSpecular.specularColorTexture);
            this.specularColorTexture = specularColorTexture;
        }
    }
}

class KHR_materials_transmission extends GltfObject {
    static animatedProperties = ["transmissionFactor"];
    constructor()
    {
        super();
        this.transmissionFactor = 0;
        this.transmissionTexture = undefined;
    }

    fromJson(jsonTransmission) {
        super.fromJson(jsonTransmission);
        if(jsonTransmission.transmissionTexture !== undefined)
        {
            const transmissionTexture = new gltfTextureInfo();
            transmissionTexture.fromJson(jsonTransmission.transmissionTexture);
            this.transmissionTexture = transmissionTexture;
        }
    }
}

class KHR_materials_volume extends GltfObject {
    static animatedProperties = ["thicknessFactor", "attenuationDistance", "attenuationColor"];
    constructor()
    {
        super();
        this.thicknessFactor = 0;
        this.thicknessTexture = undefined;
        this.attenuationDistance = 0; // 0 means infinite distance
        this.attenuationColor = fromValues$2(1, 1, 1);
    }

    fromJson(jsonVolume) {
        super.fromJson(jsonVolume);
        if(jsonVolume.thicknessTexture !== undefined)
        {
            const thicknessTexture = new gltfTextureInfo();
            thicknessTexture.fromJson(jsonVolume.thicknessTexture);
            this.thicknessTexture = thicknessTexture;
        }
    }
}

class KHR_materials_diffuse_transmission extends GltfObject {

    //TODO: define animated properties
    static animatedProperties = [];
    constructor()
    {
        super();
        this.diffuseTransmissionFactor = 0;
        this.diffuseTransmissionColorFactor = fromValues$2(1, 1, 1);
        this.diffuseTransmissionTexture = undefined;
        this.diffuseTransmissionColorTexture = undefined;
    }

    fromJson(jsonDiffuseTransmission) {
        super.fromJson(jsonDiffuseTransmission);
        if(jsonDiffuseTransmission.diffuseTransmissionTexture !== undefined)
        {
            const diffuseTransmissionTexture = new gltfTextureInfo();
            diffuseTransmissionTexture.fromJson(jsonDiffuseTransmission.diffuseTransmissionTexture);
            this.diffuseTransmissionTexture = diffuseTransmissionTexture;
        }

        if(jsonDiffuseTransmission.diffuseTransmissionColorTexture !== undefined)
        {
            const diffuseTransmissionColorTexture = new gltfTextureInfo();
            diffuseTransmissionColorTexture.fromJson(jsonDiffuseTransmission.diffuseTransmissionColorTexture);
            this.diffuseTransmissionColorTexture = diffuseTransmissionColorTexture;
        }
    }
}

class KHR_materials_pbrSpecularGlossiness extends GltfObject {
    static animatedProperties = [];
    constructor()
    {
        super();
        this.diffuseFactor = fromValues$1(1, 1, 1, 1);
        this.diffuseTexture = undefined;
        this.specularFactor = fromValues$2(1, 1, 1);
        this.specularGlossinessTexture = undefined;
        this.glossinessFactor = 1;
    }

    fromJson(jsonSpecularGlossiness) {
        super.fromJson(jsonSpecularGlossiness);
        if(jsonSpecularGlossiness.diffuseTexture !== undefined)
        {
            const diffuseTexture = new gltfTextureInfo();
            diffuseTexture.fromJson(jsonSpecularGlossiness.diffuseTexture);
            this.diffuseTexture = diffuseTexture;
        }

        if(jsonSpecularGlossiness.specularGlossinessTexture !== undefined)
        {
            const specularGlossinessTexture = new gltfTextureInfo();
            specularGlossinessTexture.fromJson(jsonSpecularGlossiness.specularGlossinessTexture);
            this.specularGlossinessTexture = specularGlossinessTexture;
        }
    }
}

class gltfSampler extends GltfObject
{
    static animatedProperties = [];
    constructor(
        magFilter = GL.LINEAR,
        minFilter = GL.LINEAR_MIPMAP_LINEAR,
        wrapS = GL.REPEAT,
        wrapT = GL.REPEAT)
    {
        super();
        this.magFilter = magFilter;
        this.minFilter = minFilter;
        this.wrapS = wrapS;
        this.wrapT = wrapT;
        this.name = undefined;
    }

    static createDefault()
    {
        return new gltfSampler();
    }
}

/* globals DracoDecoderModule */

class DracoDecoder {

    constructor(dracoLib) {
        if (!DracoDecoder.instance && dracoLib === undefined)
        {
            if (DracoDecoderModule === undefined)
            {
                console.error('Failed to initalize DracoDecoder: draco library undefined');
                return undefined;
            }
            else
            {
                dracoLib = DracoDecoderModule;
            }
        }
        if (!DracoDecoder.instance)
        {
            DracoDecoder.instance = this;
            this.module = null;

            this.initializingPromise = new Promise(resolve => {
                let dracoDecoderType = {};
                dracoDecoderType['onModuleLoaded'] = dracoDecoderModule => {
                    this.module = dracoDecoderModule;
                    resolve();
                };
                dracoLib(dracoDecoderType);
            });
        }
        return DracoDecoder.instance;
    }

    async ready() {
        await this.initializingPromise;
        Object.freeze(DracoDecoder.instance);
    }

}

let wasm;

let cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });

cachedTextDecoder.decode();

let cachegetUint8Memory0 = null;
function getUint8Memory0() {
    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {
        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);
    }
    return cachegetUint8Memory0;
}

function getStringFromWasm0(ptr, len) {
    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}

const heap = new Array(32).fill(undefined);

heap.push(undefined, null, true, false);

let heap_next = heap.length;

function addHeapObject(obj) {
    if (heap_next === heap.length) heap.push(heap.length + 1);
    const idx = heap_next;
    heap_next = heap[idx];

    heap[idx] = obj;
    return idx;
}

function getObject(idx) { return heap[idx]; }

function dropObject(idx) {
    if (idx < 36) return;
    heap[idx] = heap_next;
    heap_next = idx;
}

function takeObject(idx) {
    const ret = getObject(idx);
    dropObject(idx);
    return ret;
}

let cachegetFloat32Memory0 = null;
function getFloat32Memory0() {
    if (cachegetFloat32Memory0 === null || cachegetFloat32Memory0.buffer !== wasm.memory.buffer) {
        cachegetFloat32Memory0 = new Float32Array(wasm.memory.buffer);
    }
    return cachegetFloat32Memory0;
}

let WASM_VECTOR_LEN = 0;

function passArrayF32ToWasm0(arg, malloc) {
    const ptr = malloc(arg.length * 4);
    getFloat32Memory0().set(arg, ptr / 4);
    WASM_VECTOR_LEN = arg.length;
    return ptr;
}

let cachegetInt32Memory0 = null;
function getInt32Memory0() {
    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {
        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);
    }
    return cachegetInt32Memory0;
}

function getArrayF32FromWasm0(ptr, len) {
    return getFloat32Memory0().subarray(ptr / 4, ptr / 4 + len);
}
/**
* Generates vertex tangents for the given position/normal/texcoord attributes.
* @param {Float32Array} position
* @param {Float32Array} normal
* @param {Float32Array} texcoord
* @returns {Float32Array}
*/
function generateTangents(position, normal, texcoord) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        var ptr0 = passArrayF32ToWasm0(position, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        var ptr1 = passArrayF32ToWasm0(normal, wasm.__wbindgen_malloc);
        var len1 = WASM_VECTOR_LEN;
        var ptr2 = passArrayF32ToWasm0(texcoord, wasm.__wbindgen_malloc);
        var len2 = WASM_VECTOR_LEN;
        wasm.generateTangents(retptr, ptr0, len0, ptr1, len1, ptr2, len2);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var v3 = getArrayF32FromWasm0(r0, r1).slice();
        wasm.__wbindgen_free(r0, r1 * 4);
        return v3;
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

async function load$1(module, imports) {
    if (typeof Response === 'function' && module instanceof Response) {
        if (typeof WebAssembly.instantiateStreaming === 'function') {
            try {
                return await WebAssembly.instantiateStreaming(module, imports);

            } catch (e) {
                if (module.headers.get('Content-Type') != 'application/wasm') {
                    console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);

                } else {
                    throw e;
                }
            }
        }

        const bytes = await module.arrayBuffer();
        return await WebAssembly.instantiate(bytes, imports);

    } else {
        const instance = await WebAssembly.instantiate(module, imports);

        if (instance instanceof WebAssembly.Instance) {
            return { instance, module };

        } else {
            return instance;
        }
    }
}

async function init(input) {
    if (typeof input === 'undefined') {
        input = new URL('mikktspace_bg.wasm', import.meta.url);
    }
    const imports = {};
    imports.wbg = {};
    imports.wbg.__wbindgen_string_new = function(arg0, arg1) {
        var ret = getStringFromWasm0(arg0, arg1);
        return addHeapObject(ret);
    };
    imports.wbg.__wbindgen_rethrow = function(arg0) {
        throw takeObject(arg0);
    };

    if (typeof input === 'string' || (typeof Request === 'function' && input instanceof Request) || (typeof URL === 'function' && input instanceof URL)) {
        input = fetch(input);
    }



    const { instance, module } = await load$1(await input, imports);

    wasm = instance.exports;
    init.__wbindgen_wasm_module = module;

    return wasm;
}

class gltfPrimitive extends GltfObject
{
    static animatedProperties = [];
    constructor()
    {
        super();
        this.attributes = {};
        this.targets = [];
        this.indices = undefined;
        this.material = undefined;
        this.mode = GL.TRIANGLES;

        // non gltf
        this.glAttributes = [];
        this.morphTargetTextureInfo = undefined;
        this.defines = [];
        this.skip = true;
        this.hasWeights = false;
        this.hasJoints = false;
        this.hasNormals = false;
        this.hasTangents = false;
        this.hasTexcoord = false;
        this.hasColor = false;

        // The primitive centroid is used for depth sorting.
        this.centroid = undefined;
    }

    initGl(gltf, webGlContext)
    {
        // Use the default glTF material.
        if (this.material === undefined)
        {
            this.material = gltf.materials.length - 1;
        }

        initGlForMembers(this, gltf, webGlContext);

        const maxAttributes = webGlContext.getParameter(GL.MAX_VERTEX_ATTRIBS);

        // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes

        if (this.extensions !== undefined)
        {
            // Decode Draco compressed mesh:
            if (this.extensions.KHR_draco_mesh_compression !== undefined)
            {
                const dracoDecoder = new DracoDecoder();
                if (dracoDecoder !== undefined && Object.isFrozen(dracoDecoder))
                {
                    let dracoGeometry = this.decodeDracoBufferToIntermediate(
                        this.extensions.KHR_draco_mesh_compression, gltf);
                    this.copyDataFromDecodedGeometry(gltf, dracoGeometry, this.attributes);
                }
                else
                {
                    console.warn('Failed to load draco compressed mesh: DracoDecoder not initialized');
                }
            }
        }

        // Generate tangents with Mikktspace which needs normals and texcoords as inputs for triangles
        if (this.attributes.TANGENT === undefined && this.attributes.NORMAL && this.attributes.TEXCOORD_0 && this.mode > 3)
        {
            console.info("Generating tangents using the MikkTSpace algorithm.");
            console.time("Tangent generation");
            this.unweld(gltf);
            this.generateTangents(gltf);
            console.timeEnd("Tangent generation");
        }

        // VERTEX ATTRIBUTES
        for (const attribute of Object.keys(this.attributes))
        {
            if(this.glAttributes.length >= maxAttributes)
            {
                console.error("To many vertex attributes for this primitive, skipping " + attribute);
                break;
            }
            let knownAttribute = true;
            switch (attribute)
            {
            case "POSITION":
                this.skip = false;
                break;
            case "NORMAL":
                this.hasNormals = true;
                break;
            case "TANGENT":
                this.hasTangents = true;
                break;
            case "TEXCOORD_0":
                this.hasTexcoord = true;
                break;
            case "TEXCOORD_1":
                this.hasTexcoord = true;
                break;
            case "COLOR_0":
                this.hasColor = true;
                break;
            case "JOINTS_0":
                this.hasJoints = true;
                break;
            case "WEIGHTS_0":
                this.hasWeights = true;
                break;
            case "JOINTS_1":
                this.hasJoints = true;
                break;
            case "WEIGHTS_1":
                this.hasWeights = true;
                break;
            default:
                knownAttribute = false;
                console.log("Unknown attribute: " + attribute);
            }
            if (knownAttribute) {
                const idx = this.attributes[attribute];
                this.glAttributes.push({ attribute: attribute, name: "a_" + attribute.toLowerCase(), accessor: idx });
                this.defines.push(`HAS_${attribute}_${gltf.accessors[idx].type} 1`);
            }
        }

        // MORPH TARGETS
        if (this.targets !== undefined && this.targets.length > 0)
        {
            const max2DTextureSize = Math.pow(webGlContext.getParameter(GL.MAX_TEXTURE_SIZE), 2);
            const maxTextureArraySize = webGlContext.getParameter(GL.MAX_ARRAY_TEXTURE_LAYERS);
            // Check which attributes are affected by morph targets and
            // define offsets for the attributes in the morph target texture.
            const attributeOffsets = {};
            let attributeOffset = 0;

            // Gather used attributes from all targets (some targets might
            // use more attributes than others)
            const attributes = Array.from(this.targets.reduce((acc, target) => {
                Object.keys(target).map(val => acc.add(val));
                return acc;
            }, new Set()));

            const vertexCount = gltf.accessors[this.attributes[attributes[0]]].count;
            this.defines.push(`NUM_VERTICIES ${vertexCount}`);
            let targetCount = this.targets.length;
            if (targetCount * attributes.length > maxTextureArraySize)
            {
                targetCount = Math.floor(maxTextureArraySize / attributes.length);
                console.warn(`Morph targets exceed texture size limit. Only ${targetCount} of ${this.targets.length} are used.`);
            }

            for (const attribute of attributes)
            {
                // Add morph target defines
                this.defines.push(`HAS_MORPH_TARGET_${attribute} 1`);
                this.defines.push(`MORPH_TARGET_${attribute}_OFFSET ${attributeOffset}`);
                // Store the attribute offset so that later the
                // morph target texture can be assembled.
                attributeOffsets[attribute] = attributeOffset;
                attributeOffset += targetCount;
            }
            this.defines.push("HAS_MORPH_TARGETS 1");

            if (vertexCount <= max2DTextureSize) {
                // Allocate the texture buffer. Note that all target attributes must be vec3 types and
                // all must have the same vertex count as the primitives other attributes.
                const width = Math.ceil(Math.sqrt(vertexCount));
                const singleTextureSize = Math.pow(width, 2) * 4;
                const morphTargetTextureArray = new Float32Array(singleTextureSize * targetCount * attributes.length);

                // Now assemble the texture from the accessors.
                for (let i = 0; i < targetCount; ++i)
                {
                    let target = this.targets[i];
                    for (let [attributeName, offsetRef] of Object.entries(attributeOffsets)){
                        if (target[attributeName] != undefined) {
                            const accessor = gltf.accessors[target[attributeName]];
                            const offset = offsetRef * singleTextureSize;
                            if (accessor.componentType != GL.FLOAT && accessor.normalized == false){
                                console.warn("Unsupported component type for morph targets");
                                attributeOffsets[attributeName] = offsetRef + 1;
                                continue;
                            }
                            const data = accessor.getNormalizedDeinterlacedView(gltf);
                            switch(accessor.type)
                            {
                            case "VEC2":
                            case "VEC3":
                            {
                                // Add padding to fit vec2/vec3 into rgba
                                let paddingOffset = 0;
                                let accessorOffset = 0;
                                const componentCount = accessor.getComponentCount(accessor.type);
                                for (let j = 0; j < accessor.count; ++j) {
                                    morphTargetTextureArray.set(data.subarray(accessorOffset, accessorOffset + componentCount), offset + paddingOffset);
                                    paddingOffset += 4;
                                    accessorOffset += componentCount;
                                }
                                break;
                            }
                            case "VEC4":
                                morphTargetTextureArray.set(data, offset);
                                break;
                            default:
                                console.warn("Unsupported attribute type for morph targets");
                                break;
                            }
                        }
                        attributeOffsets[attributeName] = offsetRef + 1;
                    }
                }


                // Add the morph target texture.
                // We have to create a WebGL2 texture as the format of the
                // morph target texture has to be explicitly specified
                // (gltf image would assume uint8).
                let texture = webGlContext.createTexture();
                webGlContext.bindTexture( webGlContext.TEXTURE_2D_ARRAY, texture);
                // Set texture format and upload data.
                let internalFormat = webGlContext.RGBA32F;
                let format = webGlContext.RGBA;
                let type = webGlContext.FLOAT;
                let data = morphTargetTextureArray;
                webGlContext.texImage3D(
                    webGlContext.TEXTURE_2D_ARRAY,
                    0, //level
                    internalFormat,
                    width,
                    width,
                    targetCount * attributes.length, //Layer count
                    0, //border
                    format,
                    type,
                    data);
                // Ensure mipmapping is disabled and the sampler is configured correctly.
                webGlContext.texParameteri( GL.TEXTURE_2D_ARRAY,  GL.TEXTURE_WRAP_S,  GL.CLAMP_TO_EDGE);
                webGlContext.texParameteri( GL.TEXTURE_2D_ARRAY,  GL.TEXTURE_WRAP_T,  GL.CLAMP_TO_EDGE);
                webGlContext.texParameteri( GL.TEXTURE_2D_ARRAY,  GL.TEXTURE_MIN_FILTER,  GL.NEAREST);
                webGlContext.texParameteri( GL.TEXTURE_2D_ARRAY,  GL.TEXTURE_MAG_FILTER,  GL.NEAREST);

                // Now we add the morph target texture as a gltf texture info resource, so that
                // we can just call webGl.setTexture(..., gltfTextureInfo, ...) in the renderer.
                const morphTargetImage = new gltfImage(
                    undefined, // uri
                    GL.TEXTURE_2D_ARRAY, // type
                    0, // mip level
                    undefined, // buffer view
                    undefined, // name
                    ImageMimeType.GLTEXTURE, // mimeType
                    texture // image
                );
                gltf.images.push(morphTargetImage);

                gltf.samplers.push(new gltfSampler(GL.NEAREST, GL.NEAREST, GL.CLAMP_TO_EDGE, GL.CLAMP_TO_EDGE, undefined));

                const morphTargetTexture = new gltfTexture(
                    gltf.samplers.length - 1,
                    gltf.images.length - 1,
                    GL.TEXTURE_2D_ARRAY);
                // The webgl texture is already initialized -> this flag informs
                // webgl.setTexture about this.
                morphTargetTexture.initialized = true;

                gltf.textures.push(morphTargetTexture);

                this.morphTargetTextureInfo = new gltfTextureInfo(gltf.textures.length - 1, 0, true);
                this.morphTargetTextureInfo.samplerName = "u_MorphTargetsSampler";
                this.morphTargetTextureInfo.generateMips = false;
            } else {
                console.warn("Mesh of Morph targets too big. Cannot apply morphing.");
            }
        }

        this.computeCentroid(gltf);
    }

    computeCentroid(gltf)
    {
        const positionsAccessor = gltf.accessors[this.attributes.POSITION];
        const positions = positionsAccessor.getNormalizedTypedView(gltf);

        if(this.indices !== undefined)
        {
            // Primitive has indices.

            const indicesAccessor = gltf.accessors[this.indices];

            const indices = indicesAccessor.getTypedView(gltf);

            const acc = new Float32Array(3);

            for(let i = 0; i < indices.length; i++) {
                const offset = 3 * indices[i];
                acc[0] += positions[offset];
                acc[1] += positions[offset + 1];
                acc[2] += positions[offset + 2];
            }

            const centroid = new Float32Array([
                acc[0] / indices.length,
                acc[1] / indices.length,
                acc[2] / indices.length,
            ]);

            this.centroid = centroid;
        }
        else
        {
            // Primitive does not have indices.

            const acc = new Float32Array(3);

            for(let i = 0; i < positions.length; i += 3) {
                acc[0] += positions[i];
                acc[1] += positions[i + 1];
                acc[2] += positions[i + 2];
            }

            const positionVectors = positions.length / 3;

            const centroid = new Float32Array([
                acc[0] / positionVectors,
                acc[1] / positionVectors,
                acc[2] / positionVectors,
            ]);

            this.centroid = centroid;
        }
    }

    fromJson(jsonPrimitive)
    {
        super.fromJson(jsonPrimitive);

        if(jsonPrimitive.extensions !== undefined)
        {
            this.fromJsonPrimitiveExtensions(jsonPrimitive.extensions);
        }
    }

    fromJsonPrimitiveExtensions(jsonExtensions)
    {
        if(jsonExtensions.KHR_materials_variants !== undefined)
        {
            this.fromJsonVariants(jsonExtensions.KHR_materials_variants);
        }
    }

    fromJsonVariants(jsonVariants)
    {
        if(jsonVariants.mappings !== undefined)
        {
            this.mappings = jsonVariants.mappings;
        }
    }

    copyDataFromDecodedGeometry(gltf, dracoGeometry, primitiveAttributes)
    {
        // indices
        let indexBuffer = dracoGeometry.index.array;
        if (this.indices !== undefined){
            this.loadBufferIntoGltf(indexBuffer, gltf, this.indices, 34963,
                "index buffer view");
        }

        // Position
        if(dracoGeometry.attributes.POSITION !== undefined)
        {
            let positionBuffer = this.loadArrayIntoArrayBuffer(dracoGeometry.attributes.POSITION.array,
                dracoGeometry.attributes.POSITION.componentType);
            this.loadBufferIntoGltf(positionBuffer, gltf, primitiveAttributes["POSITION"], 34962,
                "position buffer view");
        }

        // Normal
        if(dracoGeometry.attributes.NORMAL !== undefined)
        {
            let normalBuffer = this.loadArrayIntoArrayBuffer(dracoGeometry.attributes.NORMAL.array,
                dracoGeometry.attributes.NORMAL.componentType);
            this.loadBufferIntoGltf(normalBuffer, gltf, primitiveAttributes["NORMAL"], 34962,
                "normal buffer view");
        }

        // TEXCOORD_0
        if(dracoGeometry.attributes.TEXCOORD_0 !== undefined)
        {
            let uvBuffer = this.loadArrayIntoArrayBuffer(dracoGeometry.attributes.TEXCOORD_0.array,
                dracoGeometry.attributes.TEXCOORD_0.componentType);
            this.loadBufferIntoGltf(uvBuffer, gltf, primitiveAttributes["TEXCOORD_0"], 34962,
                "TEXCOORD_0 buffer view");
        }

        // TEXCOORD_1
        if(dracoGeometry.attributes.TEXCOORD_1 !== undefined)
        {
            let uvBuffer = this.loadArrayIntoArrayBuffer(dracoGeometry.attributes.TEXCOORD_1.array,
                dracoGeometry.attributes.TEXCOORD_1.componentType);
            this.loadBufferIntoGltf(uvBuffer, gltf, primitiveAttributes["TEXCOORD_1"], 34962,
                "TEXCOORD_1 buffer view");
        }

        // Tangent
        if(dracoGeometry.attributes.TANGENT !== undefined)
        {
            let tangentBuffer = this.loadArrayIntoArrayBuffer(dracoGeometry.attributes.TANGENT.array,
                dracoGeometry.attributes.TANGENT.componentType);
            this.loadBufferIntoGltf(tangentBuffer, gltf, primitiveAttributes["TANGENT"], 34962,
                "Tangent buffer view");
        }

        // Color
        if(dracoGeometry.attributes.COLOR_0 !== undefined)
        {
            let colorBuffer = this.loadArrayIntoArrayBuffer(dracoGeometry.attributes.COLOR_0.array,
                dracoGeometry.attributes.COLOR_0.componentType);
            this.loadBufferIntoGltf(colorBuffer, gltf, primitiveAttributes["COLOR_0"], 34962,
                "color buffer view");
        }

        // JOINTS_0
        if(dracoGeometry.attributes.JOINTS_0 !== undefined)
        {
            let jointsBuffer = this.loadArrayIntoArrayBuffer(dracoGeometry.attributes.JOINTS_0.array,
                dracoGeometry.attributes.JOINTS_0.componentType);
            this.loadBufferIntoGltf(jointsBuffer, gltf, primitiveAttributes["JOINTS_0"], 34963,
                "JOINTS_0 buffer view");
        }

        // WEIGHTS_0
        if(dracoGeometry.attributes.WEIGHTS_0 !== undefined)
        {
            let weightsBuffer = this.loadArrayIntoArrayBuffer(dracoGeometry.attributes.WEIGHTS_0.array,
                dracoGeometry.attributes.WEIGHTS_0.componentType);
            this.loadBufferIntoGltf(weightsBuffer, gltf, primitiveAttributes["WEIGHTS_0"], 34963,
                "WEIGHTS_0 buffer view");
        }

        // JOINTS_1
        if(dracoGeometry.attributes.JOINTS_1 !== undefined)
        {
            let jointsBuffer = this.loadArrayIntoArrayBuffer(dracoGeometry.attributes.JOINTS_1.array,
                dracoGeometry.attributes.JOINTS_1.componentType);
            this.loadBufferIntoGltf(jointsBuffer, gltf, primitiveAttributes["JOINTS_1"], 34963,
                "JOINTS_1 buffer view");
        }

        // WEIGHTS_1
        if(dracoGeometry.attributes.WEIGHTS_1 !== undefined)
        {
            let weightsBuffer = this.loadArrayIntoArrayBuffer(dracoGeometry.attributes.WEIGHTS_1.array,
                dracoGeometry.attributes.WEIGHTS_1.componentType);
            this.loadBufferIntoGltf(weightsBuffer, gltf, primitiveAttributes["WEIGHTS_1"], 34963,
                "WEIGHTS_1 buffer view");
        }
    }

    loadBufferIntoGltf(buffer, gltf, gltfAccessorIndex, gltfBufferViewTarget, gltfBufferViewName)
    {
        const gltfBufferObj = new gltfBuffer();
        gltfBufferObj.byteLength = buffer.byteLength;
        gltfBufferObj.buffer = buffer;
        gltf.buffers.push(gltfBufferObj);

        const gltfBufferViewObj = new gltfBufferView();
        gltfBufferViewObj.buffer = gltf.buffers.length - 1;
        gltfBufferViewObj.byteLength = buffer.byteLength;
        if(gltfBufferViewName !== undefined)
        {
            gltfBufferViewObj.name = gltfBufferViewName;
        }
        gltfBufferViewObj.target = gltfBufferViewTarget;
        gltf.bufferViews.push(gltfBufferViewObj);

        gltf.accessors[gltfAccessorIndex].byteOffset = 0;
        gltf.accessors[gltfAccessorIndex].bufferView = gltf.bufferViews.length - 1;
    }

    loadArrayIntoArrayBuffer(arrayData, componentType)
    {
        let arrayBuffer;
        switch (componentType)
        {
        case "Int8Array":
            arrayBuffer = new ArrayBuffer(arrayData.length);
            new Int8Array(arrayBuffer).set(arrayData);
            break;
        case "Uint8Array":
            arrayBuffer = new ArrayBuffer(arrayData.length);
            new Uint8Array(arrayBuffer).set(arrayData);
            break;
        case "Int16Array":
            arrayBuffer = new ArrayBuffer(arrayData.length * 2);
            new Int16Array(arrayBuffer).set(arrayData);
            break;
        case "Uint16Array":
            arrayBuffer = new ArrayBuffer(arrayData.length * 2);
            new Uint16Array(arrayBuffer).set(arrayData);
            break;
        case "Int32Array":
            arrayBuffer = new ArrayBuffer(arrayData.length * 4);
            new Int32Array(arrayBuffer).set(arrayData);
            break;
        case "Uint32Array":
            arrayBuffer = new ArrayBuffer(arrayData.length * 4);
            new Uint32Array(arrayBuffer).set(arrayData);
            break;
        default:
        case "Float32Array":
            arrayBuffer = new ArrayBuffer(arrayData.length * 4);
            new Float32Array(arrayBuffer).set(arrayData);
            break;
        }

        return arrayBuffer;
    }

    decodeDracoBufferToIntermediate(dracoExtension, gltf)
    {
        let dracoBufferViewIDX = dracoExtension.bufferView;

        const origGltfDrBufViewObj = gltf.bufferViews[dracoBufferViewIDX];
        const origGltfDracoBuffer = gltf.buffers[origGltfDrBufViewObj.buffer];

        const totalBuffer = new Int8Array( origGltfDracoBuffer.buffer );
        const actualBuffer = totalBuffer.slice(origGltfDrBufViewObj.byteOffset,
            origGltfDrBufViewObj.byteOffset + origGltfDrBufViewObj.byteLength);

        // decode draco buffer to geometry intermediate
        let dracoDecoder = new DracoDecoder();
        let draco = dracoDecoder.module;
        let decoder = new draco.Decoder();
        let decoderBuffer = new draco.DecoderBuffer();
        decoderBuffer.Init(actualBuffer, origGltfDrBufViewObj.byteLength);
        let geometry = this.decodeGeometry( draco, decoder, decoderBuffer, dracoExtension.attributes, gltf );

        draco.destroy(decoderBuffer);

        return geometry;
    }

    getDracoArrayTypeFromComponentType(componentType)
    {
        switch (componentType)
        {
        case GL.BYTE:
            return "Int8Array";
        case GL.UNSIGNED_BYTE:
            return "Uint8Array";
        case GL.SHORT:
            return "Int16Array";
        case GL.UNSIGNED_SHORT:
            return "Uint16Array";
        case GL.INT:
            return "Int32Array";
        case GL.UNSIGNED_INT:
            return "Uint32Array";
        case GL.FLOAT:
            return "Float32Array";
        default:
            return "Float32Array";
        }
    }

    decodeGeometry(draco, decoder, decoderBuffer, gltfDracoAttributes, gltf) {
        let dracoGeometry;
        let decodingStatus;

        // decode mesh in draco decoder
        let geometryType = decoder.GetEncodedGeometryType( decoderBuffer );
        if ( geometryType === draco.TRIANGULAR_MESH ) {
            dracoGeometry = new draco.Mesh();
            decodingStatus = decoder.DecodeBufferToMesh( decoderBuffer, dracoGeometry );
        }
        else
        {
            throw new Error( 'DRACOLoader: Unexpected geometry type.' );
        }

        if ( ! decodingStatus.ok() || dracoGeometry.ptr === 0 ) {
            throw new Error( 'DRACOLoader: Decoding failed: ' + decodingStatus.error_msg() );
        }

        let geometry = { index: null, attributes: {} };
        let vertexCount = dracoGeometry.num_points();

        // Gather all vertex attributes.
        for(let dracoAttr in gltfDracoAttributes)
        {
            let componentType = GL.BYTE;
            let accessotVertexCount;
            // find gltf accessor for this draco attribute
            for (const [key, value] of Object.entries(this.attributes))
            {
                if(key === dracoAttr)
                {
                    componentType = gltf.accessors[value].componentType;
                    accessotVertexCount = gltf.accessors[value].count;
                    break;
                }
            }

            // check if vertex count matches
            if(vertexCount !== accessotVertexCount)
            {
                throw new Error(`DRACOLoader: Accessor vertex count ${accessotVertexCount} does not match draco decoder vertex count  ${vertexCount}`);
            }
            componentType = this.getDracoArrayTypeFromComponentType(componentType);

            let dracoAttribute = decoder.GetAttributeByUniqueId( dracoGeometry, gltfDracoAttributes[dracoAttr]);
            var tmpObj = this.decodeAttribute( draco, decoder,
                dracoGeometry, dracoAttr, dracoAttribute, componentType);
            geometry.attributes[tmpObj.name] = tmpObj;
        }

        // Add index buffer
        if ( geometryType === draco.TRIANGULAR_MESH ) {

            // Generate mesh faces.
            let numFaces = dracoGeometry.num_faces();
            let numIndices = numFaces * 3;
            let dataSize = numIndices * 4;
            let ptr = draco._malloc( dataSize );
            decoder.GetTrianglesUInt32Array( dracoGeometry, dataSize, ptr );
            let index = new Uint32Array( draco.HEAPU32.buffer, ptr, numIndices ).slice();
            draco._free( ptr );

            geometry.index = { array: index, itemSize: 1 };

        }

        draco.destroy( dracoGeometry );
        return geometry;
    }

    decodeAttribute( draco, decoder, dracoGeometry, attributeName, attribute, attributeType) {
        let numComponents = attribute.num_components();
        let numPoints = dracoGeometry.num_points();
        let numValues = numPoints * numComponents;

        let ptr;
        let array;

        let dataSize;
        switch ( attributeType ) {
        case "Float32Array":
            dataSize = numValues * 4;
            ptr = draco._malloc( dataSize );
            decoder.GetAttributeDataArrayForAllPoints( dracoGeometry, attribute, draco.DT_FLOAT32, dataSize, ptr );
            array = new Float32Array( draco.HEAPF32.buffer, ptr, numValues ).slice();
            draco._free( ptr );
            break;

        case "Int8Array":
            ptr = draco._malloc( numValues );
            decoder.GetAttributeDataArrayForAllPoints( dracoGeometry, attribute, draco.DT_INT8, numValues, ptr );
            array = new Int8Array( draco.HEAP8.buffer, ptr, numValues ).slice();
            draco._free( ptr );
            break;

        case "Int16Array":
            dataSize = numValues * 2;
            ptr = draco._malloc( dataSize );
            decoder.GetAttributeDataArrayForAllPoints( dracoGeometry, attribute, draco.DT_INT16, dataSize, ptr );
            array = new Int16Array( draco.HEAP16.buffer, ptr, numValues ).slice();
            draco._free( ptr );
            break;

        case "Int32Array":
            dataSize = numValues * 4;
            ptr = draco._malloc( dataSize );
            decoder.GetAttributeDataArrayForAllPoints( dracoGeometry, attribute, draco.DT_INT32, dataSize, ptr );
            array = new Int32Array( draco.HEAP32.buffer, ptr, numValues ).slice();
            draco._free( ptr );
            break;

        case "Uint8Array":
            ptr = draco._malloc( numValues );
            decoder.GetAttributeDataArrayForAllPoints( dracoGeometry, attribute, draco.DT_UINT8, numValues, ptr );
            array = new Uint8Array( draco.HEAPU8.buffer, ptr, numValues ).slice();
            draco._free( ptr );
            break;

        case "Uint16Array":
            dataSize = numValues * 2;
            ptr = draco._malloc( dataSize );
            decoder.GetAttributeDataArrayForAllPoints( dracoGeometry, attribute, draco.DT_UINT16, dataSize, ptr );
            array = new Uint16Array( draco.HEAPU16.buffer, ptr, numValues ).slice();
            draco._free( ptr );
            break;

        case "Uint32Array":
            dataSize = numValues * 4;
            ptr = draco._malloc( dataSize );
            decoder.GetAttributeDataArrayForAllPoints( dracoGeometry, attribute, draco.DT_UINT32, dataSize, ptr );
            array = new Uint32Array( draco.HEAPU32.buffer, ptr, numValues ).slice();
            draco._free( ptr );
            break;

        default:
            throw new Error( 'DRACOLoader: Unexpected attribute type.' );
        }

        return {
            name: attributeName,
            array: array,
            itemSize: numComponents,
            componentType: attributeType
        };

    }

    /**
     * Unwelds this primitive, i.e. applies the index mapping.
     * This is required for generating tangents using the MikkTSpace algorithm,
     * because the same vertex might be mapped to different tangents.
     * @param {*} gltf The glTF document.
     */
    unweld(gltf) {
        // Unwelding is an idempotent operation.
        if (this.indices === undefined) {
            return;
        }

        const indices = gltf.accessors[this.indices].getTypedView(gltf);

        // Unweld attributes:
        for (const [attribute, accessorIndex] of Object.entries(this.attributes)) {
            this.attributes[attribute] = this.unweldAccessor(gltf, gltf.accessors[accessorIndex], indices);
        }

        // Unweld morph targets:
        for (const target of this.targets) {
            for (const [attribute, accessorIndex] of Object.entries(target)) {
                target[attribute] = this.unweldAccessor(gltf, gltf.accessors[accessorIndex], indices);
            }
        }

        // Dipose the indices:
        this.indices = undefined;
    }

    /**
     * Unwelds a single accessor. Used by {@link unweld}.
     * @param {*} gltf The glTF document.
     * @param {*} accessor The accessor to unweld.
     * @param {*} typedIndexView A typed view of the indices.
     * @returns A new accessor index containing the unwelded attribute.
     */
    unweldAccessor(gltf, accessor, typedIndexView) {
        const componentCount = accessor.getComponentCount(accessor.type);

        const weldedAttribute = accessor.getDeinterlacedView(gltf);
        // Create new array with same type as weldedAttribute
        const unweldedAttribute = new weldedAttribute.constructor(gltf.accessors[this.indices].count * componentCount);

        // Apply the index mapping.
        for (let i = 0; i < typedIndexView.length; i++) {
            for (let j = 0; j < componentCount; j++) {
                unweldedAttribute[i * componentCount + j] = weldedAttribute[typedIndexView[i] * componentCount + j];
            }
        }

        // Create a new buffer and buffer view for the unwelded attribute:
        const unweldedBuffer = new gltfBuffer();
        unweldedBuffer.byteLength = unweldedAttribute.byteLength;
        unweldedBuffer.buffer = unweldedAttribute.buffer;
        gltf.buffers.push(unweldedBuffer);

        const unweldedBufferView = new gltfBufferView();
        unweldedBufferView.buffer = gltf.buffers.length - 1;
        unweldedBufferView.byteLength = unweldedAttribute.byteLength;
        unweldedBufferView.target = GL.ARRAY_BUFFER;
        gltf.bufferViews.push(unweldedBufferView);

        // Create a new accessor for the unwelded attribute:
        const unweldedAccessor = new gltfAccessor();
        unweldedAccessor.bufferView = gltf.bufferViews.length - 1;
        unweldedAccessor.byteOffset = 0;
        unweldedAccessor.count = typedIndexView.length;
        unweldedAccessor.type = accessor.type;
        unweldedAccessor.componentType = accessor.componentType;
        unweldedAccessor.min = accessor.min;
        unweldedAccessor.max = accessor.max;
        unweldedAccessor.normalized = accessor.normalized;
        gltf.accessors.push(unweldedAccessor);

        // Update the primitive to use the unwelded attribute:
        return gltf.accessors.length - 1;
    }

    generateTangents(gltf) {
        if(this.attributes.NORMAL === undefined || this.attributes.TEXCOORD_0 === undefined)
        {
            return;
        }

        const positions = gltf.accessors[this.attributes.POSITION].getTypedView(gltf);
        const normals = gltf.accessors[this.attributes.NORMAL].getTypedView(gltf);
        const texcoords = gltf.accessors[this.attributes.TEXCOORD_0].getTypedView(gltf);

        const tangents = generateTangents(positions, normals, texcoords);

        // convert coordinate system handedness to respect output format of MikkTSpace
        for (let idx = 0; idx < tangents.length; idx += 4) {
            tangents[idx+3] = -tangents[idx+3]; // Flip w-channel
        }

        // Create a new buffer and buffer view for the tangents:
        const tangentBuffer = new gltfBuffer();
        tangentBuffer.byteLength = tangents.byteLength;
        tangentBuffer.buffer = tangents.buffer;
        gltf.buffers.push(tangentBuffer);

        const tangentBufferView = new gltfBufferView();
        tangentBufferView.buffer = gltf.buffers.length - 1;
        tangentBufferView.byteLength = tangents.byteLength;
        tangentBufferView.target = GL.ARRAY_BUFFER;
        gltf.bufferViews.push(tangentBufferView);

        // Create a new accessor for the tangents:
        const tangentAccessor = new gltfAccessor();
        tangentAccessor.bufferView = gltf.bufferViews.length - 1;
        tangentAccessor.byteOffset = 0;
        tangentAccessor.count = tangents.length / 4;
        tangentAccessor.type = "VEC4";
        tangentAccessor.componentType = GL.FLOAT;

        // Update the primitive to use the tangents:
        this.attributes.TANGENT = gltf.accessors.length;
        gltf.accessors.push(tangentAccessor);

    }
}

class gltfMesh extends GltfObject
{
    static animatedProperties = ["weights"];
    constructor()
    {
        super();
        this.primitives = [];
        this.name = undefined;
        this.weights = undefined;
    }

    fromJson(jsonMesh)
    {
        super.fromJson(jsonMesh);

        if (jsonMesh.name !== undefined)
        {
            this.name = jsonMesh.name;
        }

        this.primitives = objectsFromJsons(jsonMesh.primitives, gltfPrimitive);
    }
}

// contain:
// transform
// child indices (reference to scene array of nodes)

class gltfNode extends GltfObject
{
    static animatedProperties = [
        "rotation",
        "scale",
        "translation",
        "weights"
    ];
    constructor()
    {
        super();
        this.camera = undefined;
        this.children = [];
        this.matrix = undefined;
        this.rotation = jsToGl([0, 0, 0, 1]);
        this.scale = jsToGl([1, 1, 1]);
        this.translation = jsToGl([0, 0, 0]);
        this.name = undefined;
        this.mesh = undefined;
        this.skin = undefined;
        this.weights = undefined;

        // non gltf
        this.worldTransform = create$3();
        this.inverseWorldTransform = create$3();
        this.normalMatrix = create$3();
        this.light = undefined;
        this.instanceMatrices = undefined;
        this.instanceWorldTransforms = undefined;
    }

    initGl(gltf, webGlContext)
    {
        if (this.extensions?.EXT_mesh_gpu_instancing?.attributes !== undefined) {
            const firstAccessor = Object.values(this.extensions?.EXT_mesh_gpu_instancing?.attributes)[0];
            const count = gltf.accessors[firstAccessor].count;
            const translationAccessor = this.extensions?.EXT_mesh_gpu_instancing?.attributes?.TRANSLATION;
            let translationData = undefined;
            if (translationAccessor !== undefined) {
                translationData = gltf.accessors[translationAccessor].getDeinterlacedView(gltf);
            }
            const rotationAccessor = this.extensions?.EXT_mesh_gpu_instancing?.attributes?.ROTATION;
            let rotationData = undefined;
            if (rotationAccessor !== undefined) {
                rotationData = gltf.accessors[rotationAccessor].getDeinterlacedView(gltf);
            }
            const scaleAccessor = this.extensions?.EXT_mesh_gpu_instancing?.attributes?.SCALE;
            let scaleData = undefined;
            if (scaleAccessor !== undefined) {
                scaleData = gltf.accessors[scaleAccessor].getDeinterlacedView(gltf);
            }
            this.instanceMatrices = [];
            for (let i = 0; i < count; i++) {
                const translation = translationData ? jsToGlSlice(translationData, i * 3, 3) : create$2();
                const rotation = rotationData ? jsToGlSlice(rotationData, i * 4, 4) : create$5();
                const scale = scaleData ? jsToGlSlice(scaleData, i * 3, 3) : fromValues$2(1, 1, 1);
                this.instanceMatrices.push(fromRotationTranslationScale(
                    create$3(),
                    rotation,
                    translation,
                    scale
                ));
            }
        }
    }

    fromJson(jsonNode) {
        super.fromJson(jsonNode);
        if (jsonNode.matrix !== undefined) {
            this.applyMatrix(jsonNode.matrix);
        }
    }

    getWeights(gltf)
    {
        if (this.weights !== undefined && this.weights.length > 0) {
            return this.weights;
        }
        else {
            return gltf.meshes[this.mesh].weights;
        }
    }

    applyMatrix(matrixData)
    {
        this.matrix = jsToGl(matrixData);

        getScaling(this.scale, this.matrix);

        // To extract a correct rotation, the scaling component must be eliminated.
        const mn = create$3();
        for(const col of [0, 1, 2])
        {
            mn[col] = this.matrix[col] / this.scale[0];
            mn[col + 4] = this.matrix[col + 4] / this.scale[1];
            mn[col + 8] = this.matrix[col + 8] / this.scale[2];
        }
        getRotation(this.rotation, mn);
        normalize(this.rotation, this.rotation);

        getTranslation(this.translation, this.matrix);
    }

    getLocalTransform()
    {
        return fromRotationTranslationScale(
            create$3(),
            this.rotation,
            this.translation,
            this.scale
        );
    }
}

class gltfScene extends GltfObject
{
    static animatedProperties = [];
    constructor(nodes = [], name = undefined)
    {
        super();
        this.nodes = nodes;
        this.name = name;

        // non gltf
        this.imageBasedLight = undefined;
    }

    initGl(gltf, webGlContext)
    {
        super.initGl(gltf, webGlContext);

        if (this.extensions !== undefined &&
            this.extensions.KHR_lights_image_based !== undefined)
        {
            const index = this.extensions.KHR_lights_image_based.imageBasedLight;
            this.imageBasedLight = gltf.imageBasedLights[index];
        }
    }

    applyTransformHierarchy(gltf, rootTransform = create$3())
    {
        function applyTransform(gltf, node, parentTransform)
        {
            multiply(node.worldTransform, parentTransform, node.getLocalTransform());
            invert(node.inverseWorldTransform, node.worldTransform);
            transpose(node.normalMatrix, node.inverseWorldTransform);

            if (node.instanceMatrices) {
                node.instanceWorldTransforms = [];
                for (let i = 0; i < node.instanceMatrices.length; i++) {
                    const instanceTransform = node.instanceMatrices[i];
                    const instanceWorldTransform = create$3();
                    multiply(instanceWorldTransform, node.worldTransform, instanceTransform);
                    node.instanceWorldTransforms.push(instanceWorldTransform);
                }
            }

            for (const child of node.children)
            {
                applyTransform(gltf, gltf.nodes[child], node.worldTransform);
            }
        }

        for (const node of this.nodes)
        {
            applyTransform(gltf, gltf.nodes[node], rootTransform);
        }
    }

    gatherNodes(gltf)
    {
        const nodes = [];

        function gatherNode(nodeIndex)
        {
            const node = gltf.nodes[nodeIndex];
            nodes.push(node);

            // recurse into children
            for(const child of node.children)
            {
                gatherNode(child);
            }
        }

        for (const node of this.nodes)
        {
            gatherNode(node);
        }

        return nodes;
    }

    includesNode(gltf, nodeIndex)
    {
        let children = [...this.nodes];
        while(children.length > 0)
        {
            const childIndex = children.pop();

            if (childIndex === nodeIndex)
            {
                return true;
            }

            children = children.concat(gltf.nodes[childIndex].children);
        }

        return false;
    }
}

class gltfAsset extends GltfObject
{
    static animatedProperties = [];
    constructor()
    {
        super();
        this.copyright = undefined;
        this.generator = undefined;
        this.version = undefined;
        this.minVersion = undefined;
    }
}

class gltfAnimationChannel extends GltfObject
{
    static animatedProperties = [];
    constructor()
    {
        super();
        this.target = undefined;
        this.sampler = undefined;
    }

    fromJson(jsonChannel)
    {
        super.fromJson(jsonChannel);
        this.target = objectFromJson(jsonChannel.target, gltfAnimationTarget);
    }
}

class gltfAnimationTarget extends GltfObject
{
    static animatedProperties = [];
    constructor()
    {
        super();
        this.node = undefined;
        this.path = undefined;
    }
}

const InterpolationPath =
{
    TRANSLATION: "translation",
    ROTATION: "rotation",
    SCALE: "scale",
    WEIGHTS: "weights",
    POINTER: "pointer",
};

class gltfAnimationSampler extends GltfObject
{
    static animatedProperties = [];
    constructor()
    {
        super();
        this.input = undefined;
        this.interpolation = InterpolationModes.LINEAR;
        this.output = undefined;
    }
}

const InterpolationModes =
{
    LINEAR: "LINEAR",
    STEP: "STEP",
    CUBICSPLINE: "CUBICSPLINE"
};

class gltfInterpolator
{
    constructor()
    {
        this.prevKey = 0;
        this.prevT = 0.0;
    }

    slerpQuat(q1, q2, t)
    {
        const qn1 = create$5();
        const qn2 = create$5();

        normalize(qn1, q1);
        normalize(qn2, q2);

        const quatResult = create$5();

        slerp(quatResult, qn1, qn2, t);
        normalize(quatResult, quatResult);

        return quatResult;
    }

    step(prevKey, output, stride)
    {
        const result = new ARRAY_TYPE$1(stride);

        for(let i = 0; i < stride; ++i)
        {
            result[i] = output[prevKey * stride + i];
        }

        return result;
    }

    linear(prevKey, nextKey, output, t, stride)
    {
        const result = new ARRAY_TYPE$1(stride);

        for(let i = 0; i < stride; ++i)
        {
            result[i] = output[prevKey * stride + i] * (1-t) + output[nextKey * stride + i] * t;
        }

        return result;
    }

    cubicSpline(prevKey, nextKey, output, keyDelta, t, stride)
    {
        // stride: Count of components (4 in a quaternion).
        // Scale by 3, because each output entry consist of two tangents and one data-point.
        const prevIndex = prevKey * stride * 3;
        const nextIndex = nextKey * stride * 3;
        const A = 0;
        const V = 1 * stride;
        const B = 2 * stride;

        const result = new ARRAY_TYPE$1(stride);
        const tSq = t ** 2;
        const tCub = t ** 3;

        // We assume that the components in output are laid out like this: in-tangent, point, out-tangent.
        // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#appendix-c-spline-interpolation
        for(let i = 0; i < stride; ++i)
        {
            const v0 = output[prevIndex + i + V];
            const a = keyDelta * output[nextIndex + i + A];
            const b = keyDelta * output[prevIndex + i + B];
            const v1 = output[nextIndex + i + V];

            result[i] = ((2*tCub - 3*tSq + 1) * v0) + ((tCub - 2*tSq + t) * b) + ((-2*tCub + 3*tSq) * v1) + ((tCub - tSq) * a);
        }

        return result;
    }

    resetKey()
    {
        this.prevKey = 0;
    }

    interpolate(gltf, channel, sampler, t, stride, maxTime)
    {
        if(t === undefined)
        {
            return undefined;
        }

        const input = gltf.accessors[sampler.input].getNormalizedDeinterlacedView(gltf);
        const output = gltf.accessors[sampler.output].getNormalizedDeinterlacedView(gltf);

        if(output.length === stride) // no interpolation for single keyFrame animations
        {
            return jsToGlSlice(output, 0, stride);
        }

        // Wrap t around, so the animation loops.
        // Make sure that t is never earlier than the first keyframe and never later then the last keyframe.
        t = t % maxTime;
        t = clamp(t, input[0], input[input.length - 1]);

        if (this.prevT > t)
        {
            this.prevKey = 0;
        }

        this.prevT = t;

        // Find next keyframe: min{ t of input | t > prevKey }
        let nextKey = null;
        for (let i = this.prevKey; i < input.length; ++i)
        {
            if (t <= input[i])
            {
                nextKey = clamp(i, 1, input.length - 1);
                break;
            }
        }
        this.prevKey = clamp(nextKey - 1, 0, nextKey);

        const keyDelta = input[nextKey] - input[this.prevKey];

        // Normalize t: [t0, t1] -> [0, 1]
        const tn = (t - input[this.prevKey]) / keyDelta;

        if(channel.target.path === InterpolationPath.ROTATION)
        {

            if(InterpolationModes.CUBICSPLINE === sampler.interpolation)
            {
                // GLTF requires cubic spline interpolation for quaternions.
                // https://github.com/KhronosGroup/glTF/issues/1386
                const result = this.cubicSpline(this.prevKey, nextKey, output, keyDelta, tn, 4);
                normalize(result, result);
                return result;
            }
            else if(sampler.interpolation === InterpolationModes.LINEAR)
            {
                const q0 = this.getQuat(output, this.prevKey);
                const q1 = this.getQuat(output, nextKey);
                return this.slerpQuat(q0, q1, tn);
            }
            else if(sampler.interpolation === InterpolationModes.STEP)
            {
                return this.getQuat(output, this.prevKey);
            }

        }

        switch(sampler.interpolation)
        {
        case InterpolationModes.STEP:
            return this.step(this.prevKey, output, stride);
        case InterpolationModes.CUBICSPLINE:
            return this.cubicSpline(this.prevKey, nextKey, output, keyDelta, tn, stride);
        default:
            return this.linear(this.prevKey, nextKey, output, tn, stride);
        }
    }

    getQuat(output, index)
    {
        const x = output[4 * index];
        const y = output[4 * index + 1];
        const z = output[4 * index + 2];
        const w = output[4 * index + 3];
        return fromValues$3(x, y, z, w);
    }
}

function replace(source, find, repl) {
    let res = '';
    let rem = source;
    let beg = 0;
    let end = -1;
    while ((end = rem.indexOf(find)) > -1) {
        res += source.substring(beg, beg + end) + repl;
        rem = rem.substring(end + find.length, rem.length);
        beg += end + find.length;
    }
    if (rem.length > 0) {
        res += source.substring(source.length - rem.length, source.length);
    }
    return res;
}
function decodeFragmentSegments(segments) {
    let i = -1;
    const len = segments.length;
    const res = new Array(len);
    while (++i < len) {
        if (typeof segments[i] === 'string') {
            res[i] = replace(replace(decodeURIComponent(segments[i]), '~1', '/'), '~0', '~');
        }
        else {
            res[i] = segments[i];
        }
    }
    return res;
}
function encodeFragmentSegments(segments) {
    let i = -1;
    const len = segments.length;
    const res = new Array(len);
    while (++i < len) {
        if (typeof segments[i] === 'string') {
            res[i] = encodeURIComponent(replace(replace(segments[i], '~', '~0'), '/', '~1'));
        }
        else {
            res[i] = segments[i];
        }
    }
    return res;
}
function decodePointerSegments(segments) {
    let i = -1;
    const len = segments.length;
    const res = new Array(len);
    while (++i < len) {
        if (typeof segments[i] === 'string') {
            res[i] = replace(replace(segments[i], '~1', '/'), '~0', '~');
        }
        else {
            res[i] = segments[i];
        }
    }
    return res;
}
function encodePointerSegments(segments) {
    let i = -1;
    const len = segments.length;
    const res = new Array(len);
    while (++i < len) {
        if (typeof segments[i] === 'string') {
            res[i] = replace(replace(segments[i], '~', '~0'), '/', '~1');
        }
        else {
            res[i] = segments[i];
        }
    }
    return res;
}
function decodePointer(ptr) {
    if (typeof ptr !== 'string') {
        throw new TypeError('Invalid type: JSON Pointers are represented as strings.');
    }
    if (ptr.length === 0) {
        return [];
    }
    if (ptr[0] !== '/') {
        throw new ReferenceError('Invalid JSON Pointer syntax. Non-empty pointer must begin with a solidus `/`.');
    }
    return decodePointerSegments(ptr.substring(1).split('/'));
}
function encodePointer(path) {
    if (!path || (path && !Array.isArray(path))) {
        throw new TypeError('Invalid type: path must be an array of segments.');
    }
    if (path.length === 0) {
        return '';
    }
    return '/'.concat(encodePointerSegments(path).join('/'));
}
function decodeUriFragmentIdentifier(ptr) {
    if (typeof ptr !== 'string') {
        throw new TypeError('Invalid type: JSON Pointers are represented as strings.');
    }
    if (ptr.length === 0 || ptr[0] !== '#') {
        throw new ReferenceError('Invalid JSON Pointer syntax; URI fragment identifiers must begin with a hash.');
    }
    if (ptr.length === 1) {
        return [];
    }
    if (ptr[1] !== '/') {
        throw new ReferenceError('Invalid JSON Pointer syntax.');
    }
    return decodeFragmentSegments(ptr.substring(2).split('/'));
}
function encodeUriFragmentIdentifier(path) {
    if (!path || (path && !Array.isArray(path))) {
        throw new TypeError('Invalid type: path must be an array of segments.');
    }
    if (path.length === 0) {
        return '#';
    }
    return '#/'.concat(encodeFragmentSegments(path).join('/'));
}
const InvalidRelativePointerError = 'Invalid Relative JSON Pointer syntax. Relative pointer must begin with a non-negative integer, followed by either the number sign (#), or a JSON Pointer.';
function decodeRelativePointer(ptr) {
    if (typeof ptr !== 'string') {
        throw new TypeError('Invalid type: Relative JSON Pointers are represented as strings.');
    }
    if (ptr.length === 0) {
        // https://tools.ietf.org/id/draft-handrews-relative-json-pointer-00.html#rfc.section.3
        throw new ReferenceError(InvalidRelativePointerError);
    }
    const segments = ptr.split('/');
    let first = segments[0];
    // It is a name reference; strip the hash.
    if (first[first.length - 1] == '#') {
        if (segments.length > 1) {
            throw new ReferenceError(InvalidRelativePointerError);
        }
        first = first.substr(0, first.length - 1);
    }
    let i = -1;
    const len = first.length;
    while (++i < len) {
        if (first[i] < '0' || first[i] > '9') {
            throw new ReferenceError(InvalidRelativePointerError);
        }
    }
    const path = decodePointerSegments(segments.slice(1));
    path.unshift(segments[0]);
    return path;
}
function toArrayIndexReference(arr, idx) {
    if (typeof idx === 'number')
        return idx;
    const len = idx.length;
    if (!len)
        return -1;
    let cursor = 0;
    if (len === 1 && idx[0] === '-') {
        if (!Array.isArray(arr)) {
            return 0;
        }
        return arr.length;
    }
    while (++cursor < len) {
        if (idx[cursor] < '0' || idx[cursor] > '9') {
            return -1;
        }
    }
    return parseInt(idx, 10);
}
function compilePointerDereference(path) {
    let body = "if (typeof(it) !== 'undefined'";
    if (path.length === 0) {
        return (it) => it;
    }
    body = path.reduce((body, _, i) => {
        return (body +
            "\n\t&& it !== null && typeof((it = it['" +
            replace(replace(path[i] + '', '\\', '\\\\'), "'", "\\'") +
            "'])) !== 'undefined'");
    }, "if (typeof(it) !== 'undefined'");
    body = body + ') {\n\treturn it;\n }';
    // eslint-disable-next-line no-new-func
    return new Function('it', body);
}
function setValueAtPath(target, val, path, force = false) {
    if (path.length === 0) {
        throw new Error('Cannot set the root object; assign it directly.');
    }
    if (typeof target === 'undefined') {
        throw new TypeError('Cannot set values on undefined');
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let it = target;
    const len = path.length;
    const end = path.length - 1;
    let step;
    let cursor = -1;
    let rem;
    let p;
    while (++cursor < len) {
        step = path[cursor];
        if (typeof step !== 'string' && typeof step !== 'number') {
            throw new TypeError('PathSegments must be a string or a number.');
        }
        if (
        // Reconsider this strategy. It disallows legitimate structures on
        // non - objects, or more precisely, on objects not derived from a class
        // or constructor function.
        step === '__proto__' ||
            step === 'constructor' ||
            step === 'prototype') {
            throw new Error('Attempted prototype pollution disallowed.');
        }
        if (Array.isArray(it)) {
            if (step === '-' && cursor === end) {
                it.push(val);
                return undefined;
            }
            p = toArrayIndexReference(it, step);
            if (it.length > p) {
                if (cursor === end) {
                    rem = it[p];
                    it[p] = val;
                    break;
                }
                it = it[p];
            }
            else if (cursor === end && p === it.length) {
                if (force) {
                    it.push(val);
                    return undefined;
                }
            }
            else if (force) {
                it = it[p] = cursor === end ? val : {};
            }
        }
        else {
            if (typeof it[step] === 'undefined') {
                if (force) {
                    if (cursor === end) {
                        it[step] = val;
                        return undefined;
                    }
                    // if the next step is an array index, this step should be an array.
                    const n = Number(path[cursor + 1]);
                    if (Number.isInteger(n) &&
                        toArrayIndexReference(it[step], n) !== -1) {
                        it = it[step] = [];
                        continue;
                    }
                    it = it[step] = {};
                    continue;
                }
                return undefined;
            }
            if (cursor === end) {
                rem = it[step];
                it[step] = val;
                break;
            }
            it = it[step];
        }
    }
    return rem;
}
function unsetValueAtPath(target, path) {
    if (path.length === 0) {
        throw new Error('Cannot unset the root object; assign it directly.');
    }
    if (typeof target === 'undefined') {
        throw new TypeError('Cannot unset values on undefined');
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let it = target;
    const len = path.length;
    const end = path.length - 1;
    let step;
    let cursor = -1;
    let rem;
    let p;
    while (++cursor < len) {
        step = path[cursor];
        if (typeof step !== 'string' && typeof step !== 'number') {
            throw new TypeError('PathSegments must be a string or a number.');
        }
        if (step === '__proto__' ||
            step === 'constructor' ||
            step === 'prototype') {
            throw new Error('Attempted prototype pollution disallowed.');
        }
        if (Array.isArray(it)) {
            p = toArrayIndexReference(it, step);
            if (p >= it.length)
                return undefined;
            if (cursor === end) {
                rem = it[p];
                delete it[p];
                break;
            }
            it = it[p];
        }
        else {
            if (typeof it[step] === 'undefined') {
                return undefined;
            }
            if (cursor === end) {
                rem = it[step];
                delete it[step];
                break;
            }
            it = it[step];
        }
    }
    return rem;
}
function looksLikeFragment(ptr) {
    return typeof ptr === 'string' && ptr.length > 0 && ptr[0] === '#';
}
function pickDecoder(ptr) {
    return looksLikeFragment(ptr) ? decodeUriFragmentIdentifier : decodePointer;
}
function decodePtrInit(ptr) {
    return Array.isArray(ptr)
        ? ptr.slice(0)
        : pickDecoder(ptr)(ptr);
}

/**
 * Determines if the value is an object (not null)
 * @param value the value
 * @returns true if the value is a non-null object; otherwise false.
 *
 * @hidden
 */
function isObject$3(value) {
    return typeof value === 'object' && value !== null;
}
/** @hidden */
function shouldDescend(obj) {
    return isObject$3(obj) && !JsonReference.isReference(obj);
}
/** @hidden */
function descendingVisit(target, visitor, encoder) {
    const distinctObjects = new Map();
    const q = [{ obj: target, path: [] }];
    while (q.length) {
        const { obj, path } = q.shift();
        visitor(encoder(path), obj);
        if (shouldDescend(obj)) {
            distinctObjects.set(obj, new JsonPointer(encodeUriFragmentIdentifier(path)));
            if (!Array.isArray(obj)) {
                const keys = Object.keys(obj);
                const len = keys.length;
                let i = -1;
                while (++i < len) {
                    const it = obj[keys[i]];
                    if (isObject$3(it) && distinctObjects.has(it)) {
                        q.push({
                            obj: new JsonReference(distinctObjects.get(it)),
                            path: path.concat(keys[i]),
                        });
                    }
                    else {
                        q.push({
                            obj: it,
                            path: path.concat(keys[i]),
                        });
                    }
                }
            }
            else {
                // handleArray
                let j = -1;
                const len = obj.length;
                while (++j < len) {
                    const it = obj[j];
                    if (isObject$3(it) && distinctObjects.has(it)) {
                        q.push({
                            obj: new JsonReference(distinctObjects.get(it)),
                            path: path.concat([j + '']),
                        });
                    }
                    else {
                        q.push({
                            obj: it,
                            path: path.concat([j + '']),
                        });
                    }
                }
            }
        }
    }
}
/** @hidden */
const $ptr = Symbol('pointer');
/** @hidden */
const $frg = Symbol('fragmentId');
/** @hidden */
const $get = Symbol('getter');
/**
 * Represents a JSON Pointer, capable of getting and setting the value on target
 * objects at the pointer's location.
 *
 * While there are static variants for most operations, our recommendation is
 * to use the instance level methods, which enables you avoid repeated
 * compiling/emitting transient accessors. Take a look at the speed comparisons
 * for our justification.
 *
 * In most cases, you should create and reuse instances of JsonPointer within
 * scope that makes sense for your app. We often create constants for frequently
 * used pointers, but your use case may vary.
 *
 * The following is a contrived example showing a function that uses pointers to
 * deal with changes in the structure of data (a version independent function):
 *
 * ```ts
 * import { JsonPointer } from 'json-ptr';
 *
 * export type SupportedVersion = '1.0' | '1.1';
 *
 * interface PrimaryGuestNamePointers {
 *   name: JsonPointer;
 *   surname: JsonPointer;
 *   honorific: JsonPointer;
 * }
 * const versions: Record<SupportedVersion, PrimaryGuestNamePointers> = {
 *   '1.0': {
 *     name: JsonPointer.create('/guests/0/name'),
 *     surname: JsonPointer.create('/guests/0/surname'),
 *     honorific: JsonPointer.create('/guests/0/honorific'),
 *   },
 *   '1.1': {
 *     name: JsonPointer.create('/primary/primaryGuest/name'),
 *     surname: JsonPointer.create('/primary/primaryGuest/surname'),
 *     honorific: JsonPointer.create('/primary/primaryGuest/honorific'),
 *   }
 * };
 *
 * interface Reservation extends Record<string, unknown> {
 *   version?: SupportedVersion;
 * }
 *
 * function primaryGuestName(reservation: Reservation): string {
 *   const pointers = versions[reservation.version || '1.0'];
 *   const name = pointers.name.get(reservation) as string;
 *   const surname = pointers.surname.get(reservation) as string;
 *   const honorific = pointers.honorific.get(reservation) as string;
 *   const names: string[] = [];
 *   if (honorific) names.push(honorific);
 *   if (name) names.push(name);
 *   if (surname) names.push(surname);
 *   return names.join(' ');
 * }
 *
 * // The original layout of a reservation (only the parts relevant to our example)
 * const reservationV1: Reservation = {
 *   guests: [{
 *     name: 'Wilbur',
 *     surname: 'Finkle',
 *     honorific: 'Mr.'
 *   }, {
 *     name: 'Wanda',
 *     surname: 'Finkle',
 *     honorific: 'Mrs.'
 *   }, {
 *     name: 'Wilma',
 *     surname: 'Finkle',
 *     honorific: 'Miss',
 *     child: true,
 *     age: 12
 *   }]
 *   // ...
 * };
 *
 * // The new layout of a reservation (only the parts relevant to our example)
 * const reservationV1_1: Reservation = {
 *   version: '1.1',
 *   primary: {
 *     primaryGuest: {
 *       name: 'Wilbur',
 *       surname: 'Finkle',
 *       honorific: 'Mr.'
 *     },
 *     additionalGuests: [{
 *       name: 'Wanda',
 *       surname: 'Finkle',
 *       honorific: 'Mrs.'
 *     }, {
 *       name: 'Wilma',
 *       surname: 'Finkle',
 *       honorific: 'Miss',
 *       child: true,
 *       age: 12
 *     }]
 *     // ...
 *   }
 *   // ...
 * };
 *
 * console.log(primaryGuestName(reservationV1));
 * console.log(primaryGuestName(reservationV1_1));
 *
 * ```
 *
 * There are many uses for pointers.
 */
class JsonPointer {
    /**
     * Creates a new instance.
     * @param ptr a string representation of a JSON Pointer, or a decoded array of path segments.
     */
    constructor(ptr) {
        this.path = decodePtrInit(ptr);
    }
    /**
     * Factory function that creates a JsonPointer instance.
     *
     * ```ts
     * const ptr = JsonPointer.create('/deeply/nested/data/0/here');
     * ```
     * _or_
     * ```ts
     * const ptr = JsonPointer.create(['deeply', 'nested', 'data', 0, 'here']);
     * ```
     * @param pointer the pointer or path.
     */
    static create(pointer) {
        return new JsonPointer(pointer);
    }
    /**
     * Determines if the specified `target`'s object graph has a value at the `pointer`'s location.
     *
     * ```ts
     * const target = {
     *   first: 'second',
     *   third: ['fourth', 'fifth', { sixth: 'seventh' }],
     *   eighth: 'ninth'
     * };
     *
     * console.log(JsonPointer.has(target, '/third/0'));
     * // true
     * console.log(JsonPointer.has(target, '/tenth'));
     * // false
     * ```
     *
     * @param target the target of the operation
     * @param pointer the pointer or path
     */
    static has(target, pointer) {
        if (typeof pointer === 'string' || Array.isArray(pointer)) {
            pointer = new JsonPointer(pointer);
        }
        return pointer.has(target);
    }
    /**
     * Gets the `target` object's value at the `pointer`'s location.
     *
     * ```ts
     * const target = {
     *   first: 'second',
     *   third: ['fourth', 'fifth', { sixth: 'seventh' }],
     *   eighth: 'ninth'
     * };
     *
     * console.log(JsonPointer.get(target, '/third/2/sixth'));
     * // seventh
     * console.log(JsonPointer.get(target, '/tenth'));
     * // undefined
     * ```
     *
     * @param target the target of the operation
     * @param pointer the pointer or path.
     */
    static get(target, pointer) {
        if (typeof pointer === 'string' || Array.isArray(pointer)) {
            pointer = new JsonPointer(pointer);
        }
        return pointer.get(target);
    }
    /**
     * Sets the `target` object's value, as specified, at the `pointer`'s location.
     *
     * ```ts
     * const target = {
     *   first: 'second',
     *   third: ['fourth', 'fifth', { sixth: 'seventh' }],
     *   eighth: 'ninth'
     * };
     *
     * console.log(JsonPointer.set(target, '/third/2/sixth', 'tenth'));
     * // seventh
     * console.log(JsonPointer.set(target, '/tenth', 'eleventh', true));
     * // undefined
     * console.log(JSON.stringify(target, null, ' '));
     * // {
     * // "first": "second",
     * // "third": [
     * //  "fourth",
     * //  "fifth",
     * //  {
     * //   "sixth": "tenth"
     * //  }
     * // ],
     * // "eighth": "ninth",
     * // "tenth": "eleventh"
     * // }
     * ```
     *
     * @param target the target of the operation
     * @param pointer the pointer or path
     * @param val a value to write into the object graph at the specified pointer location
     * @param force indications whether the operation should force the pointer's location into existence in the object graph.
     *
     * @returns the prior value at the pointer's location in the object graph.
     */
    static set(target, pointer, val, force = false) {
        if (typeof pointer === 'string' || Array.isArray(pointer)) {
            pointer = new JsonPointer(pointer);
        }
        return pointer.set(target, val, force);
    }
    /**
     * Removes the `target` object's value at the `pointer`'s location.
     *
     * ```ts
     * const target = {
     *   first: 'second',
     *   third: ['fourth', 'fifth', { sixth: 'seventh' }],
     *   eighth: 'ninth'
     * };
     *
     * console.log(JsonPointer.unset(target, '/third/2/sixth'));
     * // seventh
     * console.log(JsonPointer.unset(target, '/tenth'));
     * // undefined
     * console.log(JSON.stringify(target, null, ' '));
     * // {
     * // "first": "second",
     * // "third": [
     * //  "fourth",
     * //  "fifth",
     * //  {}
     * // ],
     * // "eighth": "ninth",
     * // }
     * ```
     * @param target the target of the operation
     * @param pointer the pointer or path
     *
     * @returns the value that was removed from the object graph.
     */
    static unset(target, pointer) {
        if (typeof pointer === 'string' || Array.isArray(pointer)) {
            pointer = new JsonPointer(pointer);
        }
        return pointer.unset(target);
    }
    /**
     * Decodes the specified pointer into path segments.
     * @param pointer a string representation of a JSON Pointer
     */
    static decode(pointer) {
        return pickDecoder(pointer)(pointer);
    }
    /**
     * Evaluates the target's object graph, calling the specified visitor for every unique pointer location discovered while walking the graph.
     * @param target the target of the operation
     * @param visitor a callback function invoked for each unique pointer location in the object graph
     * @param fragmentId indicates whether the visitor should receive fragment identifiers or regular pointers
     */
    static visit(target, visitor, fragmentId = false) {
        descendingVisit(target, visitor, fragmentId ? encodeUriFragmentIdentifier : encodePointer);
    }
    /**
     * Evaluates the target's object graph, returning a [[JsonStringPointerListItem]] for each location in the graph.
     * @param target the target of the operation
     */
    static listPointers(target) {
        const res = [];
        descendingVisit(target, (pointer, value) => {
            res.push({ pointer, value });
        }, encodePointer);
        return res;
    }
    /**
     * Evaluates the target's object graph, returning a [[UriFragmentIdentifierPointerListItem]] for each location in the graph.
     * @param target the target of the operation
     */
    static listFragmentIds(target) {
        const res = [];
        descendingVisit(target, (fragmentId, value) => {
            res.push({ fragmentId, value });
        }, encodeUriFragmentIdentifier);
        return res;
    }
    /**
     * Evaluates the target's object graph, returning a Record&lt;Pointer, unknown> populated with pointers and the corresponding values from the graph.
     * @param target the target of the operation
     * @param fragmentId indicates whether the results are populated with fragment identifiers rather than regular pointers
     */
    static flatten(target, fragmentId = false) {
        const res = {};
        descendingVisit(target, (p, v) => {
            res[p] = v;
        }, fragmentId ? encodeUriFragmentIdentifier : encodePointer);
        return res;
    }
    /**
     * Evaluates the target's object graph, returning a Map&lt;Pointer,unknown>  populated with pointers and the corresponding values form the graph.
     * @param target the target of the operation
     * @param fragmentId indicates whether the results are populated with fragment identifiers rather than regular pointers
     */
    static map(target, fragmentId = false) {
        const res = new Map();
        descendingVisit(target, res.set.bind(res), fragmentId ? encodeUriFragmentIdentifier : encodePointer);
        return res;
    }
    /**
     * Gets the target object's value at the pointer's location.
     * @param target the target of the operation
     */
    get(target) {
        if (!this[$get]) {
            this[$get] = compilePointerDereference(this.path);
        }
        return this[$get](target);
    }
    /**
     * Sets the target object's value, as specified, at the pointer's location.
     *
     * If any part of the pointer's path does not exist, the operation aborts
     * without modification, unless the caller indicates that pointer's location
     * should be created.
     *
     * @param target the target of the operation
     * @param value the value to set
     * @param force indicates whether the pointer's location should be created if it doesn't already exist.
     */
    set(target, value, force = false) {
        return setValueAtPath(target, value, this.path, force);
    }
    /**
     * Removes the target object's value at the pointer's location.
     * @param target the target of the operation
     *
     * @returns the value that was removed from the object graph.
     */
    unset(target) {
        return unsetValueAtPath(target, this.path);
    }
    /**
     * Determines if the specified target's object graph has a value at the pointer's location.
     * @param target the target of the operation
     */
    has(target) {
        return typeof this.get(target) !== 'undefined';
    }
    /**
     * Gets the value in the object graph that is the parent of the pointer location.
     * @param target the target of the operation
     */
    parent(target) {
        const p = this.path;
        if (p.length == 1)
            return undefined;
        const parent = new JsonPointer(p.slice(0, p.length - 1));
        return parent.get(target);
    }
    /**
     * Creates a new JsonPointer instance, pointing to the specified relative location in the object graph.
     * @param ptr the relative pointer (relative to this)
     * @returns A new instance that points to the relative location.
     */
    relative(ptr) {
        const p = this.path;
        const decoded = decodeRelativePointer(ptr);
        const n = parseInt(decoded[0]);
        if (n > p.length)
            throw new Error('Relative location does not exist.');
        const r = p.slice(0, p.length - n).concat(decoded.slice(1));
        if (decoded[0][decoded[0].length - 1] == '#') {
            // It references the path segment/name, not the value
            const name = r[r.length - 1];
            throw new Error(`We won't compile a pointer that will always return '${name}'. Use JsonPointer.rel(target, ptr) instead.`);
        }
        return new JsonPointer(r);
    }
    /**
     * Resolves the specified relative pointer path against the specified target object, and gets the target object's value at the relative pointer's location.
     * @param target the target of the operation
     * @param ptr the relative pointer (relative to this)
     * @returns the value at the relative pointer's resolved path; otherwise undefined.
     */
    rel(target, ptr) {
        const p = this.path;
        const decoded = decodeRelativePointer(ptr);
        const n = parseInt(decoded[0]);
        if (n > p.length) {
            // out of bounds
            return undefined;
        }
        const r = p.slice(0, p.length - n).concat(decoded.slice(1));
        const other = new JsonPointer(r);
        if (decoded[0][decoded[0].length - 1] == '#') {
            // It references the path segment/name, not the value
            const name = r[r.length - 1];
            const parent = other.parent(target);
            return Array.isArray(parent) ? parseInt(name, 10) : name;
        }
        return other.get(target);
    }
    /**
     * Creates a new instance by concatenating the specified pointer's path onto this pointer's path.
     * @param ptr the string representation of a pointer, it's decoded path, or an instance of JsonPointer indicating the additional path to concatenate onto the pointer.
     */
    concat(ptr) {
        return new JsonPointer(this.path.concat(ptr instanceof JsonPointer ? ptr.path : decodePtrInit(ptr)));
    }
    /**
     * This pointer's JSON Pointer encoded string representation.
     */
    get pointer() {
        if (this[$ptr] === undefined) {
            this[$ptr] = encodePointer(this.path);
        }
        return this[$ptr];
    }
    /**
     * This pointer's URI fragment identifier encoded string representation.
     */
    get uriFragmentIdentifier() {
        if (!this[$frg]) {
            this[$frg] = encodeUriFragmentIdentifier(this.path);
        }
        return this[$frg];
    }
    /**
     * Emits the JSON Pointer encoded string representation.
     */
    toString() {
        return this.pointer;
    }
}
/** @hidden */
const $pointer = Symbol('pointer');
/**
 * A reference to a location in an object graph.
 *
 * This type is used by this module to break cycles in an object graph and to
 * reference locations that have already been visited when enumerating pointers.
 */
class JsonReference {
    /**
     * Creates a new instance.
     * @param pointer a JSON Pointer for the reference.
     */
    constructor(pointer) {
        this[$pointer] =
            pointer instanceof JsonPointer ? pointer : new JsonPointer(pointer);
        this.$ref = this[$pointer].uriFragmentIdentifier;
    }
    /**
     * Determines if the specified `candidate` is a JsonReference.
     * @param candidate the candidate
     */
    static isReference(candidate) {
        if (!candidate)
            return false;
        const ref = candidate;
        return typeof ref.$ref === 'string' && typeof ref.resolve === 'function';
    }
    /**
     * Resolves the reference against the `target` object, returning the value at
     * the referenced pointer's location.
     * @param target the target object
     */
    resolve(target) {
        return this[$pointer].get(target);
    }
    /**
     * Gets the reference's pointer.
     */
    pointer() {
        return this[$pointer];
    }
    /**
     * Gets the reference pointer's string representation (a URI fragment identifier).
     */
    toString() {
        return this.$ref;
    }
}

class gltfAnimation extends GltfObject
{
    static animatedProperties = [];
    constructor()
    {
        super();
        this.channels = [];
        this.samplers = [];
        this.name = '';

        // not gltf
        this.interpolators = [];
        this.maxTime = 0;
        this.disjointAnimations = [];

        this.errors = [];
    }

    fromJson(jsonAnimation)
    {
        super.fromJson(jsonAnimation);

        this.channels = objectsFromJsons(jsonAnimation.channels, gltfAnimationChannel);
        this.samplers = objectsFromJsons(jsonAnimation.samplers, gltfAnimationSampler);
        this.name = jsonAnimation.name;

        if(this.channels === undefined)
        {
            console.error("No channel data found for skin");
            return;
        }

        for(let i = 0; i < this.channels.length; ++i)
        {
            this.interpolators.push(new gltfInterpolator());
        }
    }

    // advance the animation, if totalTime is undefined, the animation is deactivated
    advance(gltf, totalTime)
    {
        if(this.channels === undefined)
        {
            return;
        }

        if(this.maxTime == 0)
        {
            for(let i = 0; i < this.channels.length; ++i)
            {
                const channel = this.channels[i];
                const sampler = this.samplers[channel.sampler];
                const input = gltf.accessors[sampler.input].getDeinterlacedView(gltf);
                const max = input[input.length - 1];
                if(max > this.maxTime)
                {
                    this.maxTime = max;
                }
            }
        }

        for(let i = 0; i < this.interpolators.length; ++i)
        {
            const channel = this.channels[i];
            const sampler = this.samplers[channel.sampler];
            const interpolator = this.interpolators[i];

            let property = null;
            switch(channel.target.path)
            {
            case InterpolationPath.TRANSLATION:
                property = `/nodes/${channel.target.node}/translation`;
                break;
            case InterpolationPath.ROTATION:
                property = `/nodes/${channel.target.node}/rotation`;
                break;
            case InterpolationPath.SCALE:
                property = `/nodes/${channel.target.node}/scale`;
                break;
            case InterpolationPath.WEIGHTS:
                if (gltf.nodes[channel.target.node].weights !== undefined) {
                    property = `/nodes/${channel.target.node}/weights`;
                } else {
                    property = `/meshes/${gltf.nodes[channel.target.node].mesh}/weights`;
                }
                break;
            case InterpolationPath.POINTER:
                property = channel.target.extensions.KHR_animation_pointer.pointer;
                break;
            }

            if (property != null) {
                if (property.startsWith("/extensions/KHR_lights_punctual/")) {
                    const suffix = property.substring("/extensions/KHR_lights_punctual/".length);
                    property = "/" + suffix;
                }
                let jsonPointer = JsonPointer.create(property);
                let parentObject = jsonPointer.parent(gltf);
                let back = jsonPointer.path.at(-1);
                let animatedArrayElement = undefined;
                if (Array.isArray(parentObject)) {
                    animatedArrayElement = Number(back);
                    jsonPointer = JsonPointer.create(jsonPointer.path.slice(0, -1));
                    parentObject = jsonPointer.parent(gltf);
                    back = jsonPointer.path.at(-1);
                }
                let animatedProperty = undefined;
                if (parentObject.animatedPropertyObjects && back in parentObject.animatedPropertyObjects) {
                    animatedProperty = parentObject.animatedPropertyObjects[back];
                }
                if (animatedProperty === undefined || !(animatedProperty instanceof AnimatableProperty)) {
                    if (!this.errors.includes(property)) {
                        console.warn(`Cannot animate ${property}`);
                        this.errors.push(property);
                    }
                    continue;
                }
                if (animatedProperty.restValue === undefined) {
                    continue;
                }

                let stride = animatedProperty.restValue?.length ?? 1;
                if (animatedArrayElement !== undefined) {
                    stride = animatedProperty.restValue[animatedArrayElement]?.length ?? 1;
                }
                
                const interpolant = interpolator.interpolate(gltf, channel, sampler, totalTime, stride, this.maxTime);
                if (interpolant === undefined) {
                    animatedProperty.rest();
                    continue;
                }
                // The interpolator will always return a `Float32Array`, even if the animated value is a scalar.
                // For the renderer it's not a problem because uploading a single-element array is the same as uploading a scalar to a uniform.
                // However, it becomes a problem if we use the animated value for further computation and assume is stays a scalar.
                // Thus we explicitly convert the animated value back to a scalar if the interpolant is a single-element array and the rest value is not an array itself.
                if (animatedArrayElement !== undefined) {
                    const array = animatedProperty.value();
                    if (interpolant.length == 1) {
                        array[animatedArrayElement] = interpolant[0];
                    }
                    else {
                        array[animatedArrayElement] = interpolant;
                    }
                    animatedProperty.animate(array);
                } else {
                    if (interpolant.length == 1 && !Array.isArray(animatedProperty.restValue)) {
                        animatedProperty.animate(interpolant[0]);
                    }
                    else {
                        animatedProperty.animate(interpolant);
                    }
                }
            }
        }
    }
}

class gltfSkin extends GltfObject
{
    static animatedProperties = [];
    constructor()
    {
        super();

        this.name = "";
        this.inverseBindMatrices = undefined;
        this.joints = [];
        this.skeleton = undefined;

        // not gltf
        this.jointTextureInfo = undefined;
        this.jointWebGlTexture = undefined;
    }

    initGl(gltf, webGlContext)
    {
        this.jointWebGlTexture = webGlContext.createTexture();
        webGlContext.bindTexture( webGlContext.TEXTURE_2D, this.jointWebGlTexture);

        // Ensure mipmapping is disabled and the sampler is configured correctly.
        webGlContext.texParameteri( GL.TEXTURE_2D,  GL.TEXTURE_WRAP_S,  GL.CLAMP_TO_EDGE);
        webGlContext.texParameteri( GL.TEXTURE_2D,  GL.TEXTURE_WRAP_T,  GL.CLAMP_TO_EDGE);
        webGlContext.texParameteri( GL.TEXTURE_2D,  GL.TEXTURE_WRAP_R,  GL.CLAMP_TO_EDGE);
        webGlContext.texParameteri( GL.TEXTURE_2D,  GL.TEXTURE_MIN_FILTER,  GL.NEAREST);
        webGlContext.texParameteri( GL.TEXTURE_2D,  GL.TEXTURE_MAG_FILTER,  GL.NEAREST);
        
        // Now we add the joints texture as a gltf texture info resource, so that 
        // we can just call webGl.setTexture(..., gltfTextureInfo, ...) in the renderer.
        const jointsImage = new gltfImage(
            undefined, // uri
            GL.TEXTURE_2D, // type
            0, // mip level
            undefined, // buffer view
            undefined, // name
            ImageMimeType.GLTEXTURE, // mimeType
            this.jointWebGlTexture // image
        );
        gltf.images.push(jointsImage);

        gltf.samplers.push(new gltfSampler(GL.NEAREST, GL.NEAREST, GL.CLAMP_TO_EDGE, GL.CLAMP_TO_EDGE, undefined));

        const jointsTexture = new gltfTexture(
            gltf.samplers.length - 1,
            gltf.images.length - 1,
            GL.TEXTURE_2D);
        // The webgl texture is already initialized -> this flag informs
        // webgl.setTexture about this.
        jointsTexture.initialized = true;

        gltf.textures.push(jointsTexture);

        this.jointTextureInfo = new gltfTextureInfo(gltf.textures.length - 1, 0, true);
        this.jointTextureInfo.samplerName = "u_jointsSampler";
        this.jointTextureInfo.generateMips = false;
    }

    computeJoints(gltf, parentNode, webGlContext)
    {
        let ibmAccessor = null;
        if (this.inverseBindMatrices !== undefined) {
            ibmAccessor = gltf.accessors[this.inverseBindMatrices].getDeinterlacedView(gltf);
        }

        this.jointMatrices = [];
        this.jointNormalMatrices = [];

        const width = Math.ceil(Math.sqrt(this.joints.length * 8));
        let textureData = new Float32Array(Math.pow(width, 2) * 4);

        let i = 0;
        for(const joint of this.joints)
        {
            const node = gltf.nodes[joint];

            let jointMatrix = clone$1(node.worldTransform);

            if (ibmAccessor !== null) {
                let ibm = jsToGlSlice(ibmAccessor, i * 16, 16);
                mul(jointMatrix, jointMatrix, ibm);
                mul(jointMatrix, parentNode.inverseWorldTransform, jointMatrix);
            }

            let normalMatrix = create$3();
            invert(normalMatrix, jointMatrix);
            transpose(normalMatrix, normalMatrix);
            
            textureData.set(jointMatrix, i * 32);
            textureData.set(normalMatrix, i * 32 + 16);
            ++i;
        }

        webGlContext.bindTexture( webGlContext.TEXTURE_2D, this.jointWebGlTexture);
        // Set texture format and upload data.
        let internalFormat = webGlContext.RGBA32F;
        let format = webGlContext.RGBA;
        let type = webGlContext.FLOAT;
        let data = textureData;
        webGlContext.texImage2D(
            webGlContext.TEXTURE_2D,
            0, //level
            internalFormat,
            width,
            width,
            0, //border
            format,
            type,
            data);
    }
}

class gltfVariant extends GltfObject
{
    static animatedProperties = [];
    constructor()
    {
        super();
        this.name = undefined;
    }

    fromJson(jsonVariant)
    {
        if(jsonVariant.name !== undefined)
        {
            this.name = jsonVariant.name;
        }
    }
}

const allowedExtensions = [
    "KHR_animation_pointer",
    "KHR_draco_mesh_compression",
    "KHR_lights_image_based",
    "KHR_lights_punctual",
    "KHR_materials_anisotropy",
    "KHR_materials_clearcoat",
    "KHR_materials_dispersion",
    "KHR_materials_emissive_strength",
    "KHR_materials_ior",
    "KHR_materials_iridescence",
    "KHR_materials_pbrSpecularGlossiness",
    "KHR_materials_sheen",
    "KHR_materials_specular",
    "KHR_materials_transmission",
    "KHR_materials_unlit",
    "KHR_materials_variants",
    "KHR_materials_volume",
    "KHR_mesh_quantization",
    "KHR_texture_basisu",
    "KHR_texture_transform",
    "KHR_xmp_json_ld",
    "EXT_texture_webp",
];

class glTF extends GltfObject
{
    static animatedProperties = [];
    constructor(file)
    {
        super();
        this.asset = undefined;
        this.accessors = [];
        this.nodes = [];
        this.scene = undefined; // the default scene to show.
        this.scenes = [];
        this.cameras = [];
        this.lights = [];
        this.imageBasedLights = [];
        this.textures = [];
        this.images = [];
        this.samplers = [];
        this.meshes = [];
        this.buffers = [];
        this.bufferViews = [];
        this.materials = [];
        this.animations = [];
        this.skins = [];
        this.path = file;
    }

    initGl(webGlContext)
    {
        initGlForMembers(this, this, webGlContext);
    }

    fromJson(json)
    {
        super.fromJson(json);

        for (const extensionName of json.extensionsRequired ?? []) {
            if (!allowedExtensions.includes(extensionName)) {
                throw new Error("Unsupported extension: " + extensionName);
            }
        }

        this.asset = objectFromJson(json.asset, gltfAsset);
        this.cameras = objectsFromJsons(json.cameras, gltfCamera);
        this.accessors = objectsFromJsons(json.accessors, gltfAccessor);
        this.meshes = objectsFromJsons(json.meshes, gltfMesh);
        this.samplers = objectsFromJsons(json.samplers, gltfSampler);
        this.materials = objectsFromJsons(json.materials, gltfMaterial);
        this.buffers = objectsFromJsons(json.buffers, gltfBuffer);
        this.bufferViews = objectsFromJsons(json.bufferViews, gltfBufferView);
        this.scenes = objectsFromJsons(json.scenes, gltfScene);
        this.textures = objectsFromJsons(json.textures, gltfTexture);
        this.nodes = objectsFromJsons(json.nodes, gltfNode);
        this.lights = objectsFromJsons(getJsonLightsFromExtensions(json.extensions), gltfLight);
        this.imageBasedLights = objectsFromJsons(getJsonIBLsFromExtensions(json.extensions), ImageBasedLight);
        this.images = objectsFromJsons(json.images, gltfImage);
        this.animations = objectsFromJsons(json.animations, gltfAnimation);
        this.skins = objectsFromJsons(json.skins, gltfSkin);
        this.variants = objectsFromJsons(getJsonVariantsFromExtension(json.extensions), gltfVariant);
        this.variants = enforceVariantsUniqueness(this.variants);

        this.materials.push(gltfMaterial.createDefault());
        this.samplers.push(gltfSampler.createDefault());

        if (json.scenes !== undefined)
        {
            if (json.scene === undefined && json.scenes.length > 0)
            {
                this.scene = 0;
            }
            else
            {
                this.scene = json.scene;
            }
        }

        this.computeDisjointAnimations();
    }

    // Computes indices of animations which are disjoint and can be played simultaneously.
    computeDisjointAnimations()
    {
        for (let i = 0; i < this.animations.length; i++)
        {
            this.animations[i].disjointAnimations = [];

            for (let k = 0; k < this.animations.length; k++)
            {
                if (i == k)
                {
                    continue;
                }

                let isDisjoint = true;
                for (const iChannel of this.animations[i].channels)
                {
                    const getAnimationProperty = function (channel, nodes){ 
                     
                        let property = null;
                        switch(channel.target.path)
                        {
                        case "translation":
                            property = `/nodes/${channel.target.node}/translation`;
                            break;
                        case "rotation":
                            property = `/nodes/${channel.target.node}/rotation`;
                            break;
                        case "scale":
                            property = `/nodes/${channel.target.node}/scale`;
                            break;
                        case "weights":
                            if (nodes[channel.target.node].weights !== undefined) {
                                property = `/nodes/${channel.target.node}/weights`;
                            } else {
                                property = `/meshes/${nodes[channel.target.node].mesh}/weights`;
                            }
                            break;
                        case "pointer":
                            property = channel.target.extensions.KHR_animation_pointer.pointer;
                            break;
                        }
                        return property;
                    };
                    const iProperty = getAnimationProperty(iChannel, this.nodes);
                    for (const kChannel of this.animations[k].channels)
                    {
                        const kProperty = getAnimationProperty(kChannel, this.nodes);
                        if (iProperty === kProperty)
                        {
                            isDisjoint = false;
                            break;
                        }
                    }
                }

                if (isDisjoint)
                {
                    this.animations[i].disjointAnimations.push(k);
                }
            }
        }
    }

    nonDisjointAnimations(animationIndices)
    {
        const animations = this.animations;
        const nonDisjointAnimations = [];

        for (let i = 0; i < animations.length; i++)
        {
            let isDisjoint = true;
            for (const k of animationIndices)
            {
                if (i == k)
                {
                    continue;
                }

                if (!animations[k].disjointAnimations.includes(i))
                {
                    isDisjoint = false;
                }
            }

            if (!isDisjoint)
            {
                nonDisjointAnimations.push(i);
            }
        }

        return nonDisjointAnimations;
    }
}

function getJsonLightsFromExtensions(extensions)
{
    if (extensions === undefined)
    {
        return [];
    }
    if (extensions.KHR_lights_punctual === undefined)
    {
        return [];
    }
    return extensions.KHR_lights_punctual.lights;
}

function getJsonIBLsFromExtensions(extensions)
{
    if (extensions === undefined)
    {
        return [];
    }
    if (extensions.KHR_lights_image_based === undefined)
    {
        return [];
    }
    return extensions.KHR_lights_image_based.imageBasedLights;
}

function getJsonVariantsFromExtension(extensions)
{
    if (extensions === undefined)
    {
        return [];
    }
    if (extensions.KHR_materials_variants === undefined)
    {
        return [];
    }
    return extensions.KHR_materials_variants.variants;
}

function enforceVariantsUniqueness(variants)
{
    for(let i=0;i<variants.length;i++)
    {
        const name = variants[i].name;
        for(let j=i+1;j<variants.length;j++)
        {
            if(variants[j].name == name)
            {
                variants[j].name += "0";  // Add random character to duplicates
            }
        }
    }


    return variants;
}

class GlbParser
{
    constructor(data)
    {
        this.data = data;
        this.glbHeaderInts = 3;
        this.glbChunkHeaderInts = 2;
        this.glbMagic = 0x46546C67;
        this.glbVersion = 2;
        this.jsonChunkType = 0x4E4F534A;
        this.binaryChunkType = 0x004E4942;
    }

    extractGlbData()
    {
        const glbInfo = this.getCheckedGlbInfo();
        if (glbInfo === undefined)
        {
            return undefined;
        }

        let json = undefined;
        let buffers = [];
        const chunkInfos = this.getAllChunkInfos();
        for (let chunkInfo of chunkInfos)
        {
            if (chunkInfo.type == this.jsonChunkType && !json)
            {
                json = this.getJsonFromChunk(chunkInfo);
            }
            else if (chunkInfo.type == this.binaryChunkType)
            {
                buffers.push(this.getBufferFromChunk(chunkInfo));
            }
        }

        return { json: json, buffers: buffers };
    }

    getCheckedGlbInfo()
    {
        const header = new Uint32Array(this.data, 0, this.glbHeaderInts);
        const magic = header[0];
        const version = header[1];
        const length = header[2];

        if (!this.checkEquality(magic, this.glbMagic, "glb magic") ||
            !this.checkEquality(version, this.glbVersion, "glb header version") ||
            !this.checkEquality(length, this.data.byteLength, "glb byte length"))
        {
            return undefined;
        }

        return { "magic": magic, "version": version, "length": length };
    }

    getAllChunkInfos()
    {
        let infos = [];
        let chunkStart = this.glbHeaderInts * 4;
        while (chunkStart < this.data.byteLength)
        {
            const chunkInfo = this.getChunkInfo(chunkStart);
            infos.push(chunkInfo);
            chunkStart += chunkInfo.length + this.glbChunkHeaderInts * 4;
        }
        return infos;
    }

    getChunkInfo(headerStart)
    {
        const header = new Uint32Array(this.data, headerStart, this.glbChunkHeaderInts);
        const chunkStart = headerStart + this.glbChunkHeaderInts * 4;
        const chunkLength = header[0];
        const chunkType = header[1];
        return { "start": chunkStart, "length": chunkLength, "type": chunkType };
    }

    getJsonFromChunk(chunkInfo)
    {
        const chunkLength = chunkInfo.length;
        const jsonStart = (this.glbHeaderInts + this.glbChunkHeaderInts) * 4;
        const jsonSlice = new Uint8Array(this.data, jsonStart, chunkLength);
        const stringBuffer = new TextDecoder("utf-8").decode(jsonSlice);
        return JSON.parse(stringBuffer);
    }

    getBufferFromChunk(chunkInfo)
    {
        return this.data.slice(chunkInfo.start, chunkInfo.start + chunkInfo.length);
    }

    checkEquality(actual, expected, name)
    {
        if (actual == expected)
        {
            return true;
        }

        console.error("Found invalid/unsupported " + name + ", expected: " + expected + ", but was: " + actual);
        return false;
    }
}

class gltfLoader
{
    static async load(gltf, webGlContext, appendix = undefined)
    {
        const buffers = gltfLoader.getBuffers(appendix);
        const additionalFiles = gltfLoader.getAdditionalFiles(appendix);

        const buffersPromise = gltfLoader.loadBuffers(gltf, buffers, additionalFiles);

        await buffersPromise; // images might be stored in the buffers
        const imagesPromise = gltfLoader.loadImages(gltf, additionalFiles);

        return await Promise.all([buffersPromise, imagesPromise])
            .then(() => gltf.initGl(webGlContext));
    }

    static unload(gltf)
    {
        for (let image of gltf.images)
        {
            image.image = undefined;
        }
        gltf.images = [];

        for (let texture of gltf.textures)
        {
            texture.destroy();
        }
        gltf.textures = [];

        for (let accessor of gltf.accessors)
        {
            accessor.destroy();
        }
        gltf.accessors = [];
    }

    static getBuffers(appendix)
    {
        return gltfLoader.getTypedAppendix(appendix, ArrayBuffer);
    }

    static getAdditionalFiles(appendix)
    {
        if(typeof(File) !== 'undefined')
        {
            return gltfLoader.getTypedAppendix(appendix, File);
        }
        else
        {
            return;
        }
    }

    static getTypedAppendix(appendix, Type)
    {
        if (appendix && appendix.length > 0)
        {
            if (appendix[0] instanceof Type || appendix[0][1] instanceof Type)
            {
                return appendix;
            }
        }
    }

    static loadBuffers(gltf, buffers, additionalFiles)
    {
        const promises = [];

        if (buffers !== undefined && buffers[0] !== undefined) //GLB
        {
            //There is only one buffer for the glb binary data 
            //see https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#glb-file-format-specification
            if (buffers.length > 1)
            {
                console.warn("Too many buffer chunks in GLB file. Only one or zero allowed");
            }

            gltf.buffers[0].buffer = buffers[0];
            for (let i = 1; i < gltf.buffers.length; ++i)
            {
                promises.push(gltf.buffers[i].load(gltf, additionalFiles));
            }
        }
        else
        {
            for (const buffer of gltf.buffers)
            {
                promises.push(buffer.load(gltf, additionalFiles));
            }
        }
        return Promise.all(promises);
    }

    static loadImages(gltf, additionalFiles)
    {
        const imagePromises = [];
        for (let image of gltf.images)
        {
            imagePromises.push(image.load(gltf, additionalFiles));
        }
        return Promise.all(imagePromises);
    }
}

var iblFiltering = "precision highp float;\n#define GLSLIFY 1\n#define MATH_PI 3.1415926535897932384626433832795\nuniform samplerCube u_cubemapTexture;const int cLambertian=0;const int cGGX=1;const int cCharlie=2;uniform float u_roughness;uniform int u_sampleCount;uniform int u_width;uniform float u_lodBias;uniform int u_distribution;uniform int u_currentFace;uniform int u_isGeneratingLUT;uniform int u_floatTexture;uniform float u_intensityScale;in vec2 texCoord;out vec4 fragmentColor;vec3 uvToXYZ(int face,vec2 uv){if(face==0)return vec3(1.f,uv.y,-uv.x);else if(face==1)return vec3(-1.f,uv.y,uv.x);else if(face==2)return vec3(+uv.x,-1.f,+uv.y);else if(face==3)return vec3(+uv.x,1.f,-uv.y);else if(face==4)return vec3(+uv.x,uv.y,1.f);else{return vec3(-uv.x,+uv.y,-1.f);}}vec2 dirToUV(vec3 dir){return vec2(0.5f+0.5f*atan(dir.z,dir.x)/MATH_PI,1.f-acos(dir.y)/MATH_PI);}float saturate(float v){return clamp(v,0.0f,1.0f);}float radicalInverse_VdC(uint bits){bits=(bits<<16u)|(bits>>16u);bits=((bits&0x55555555u)<<1u)|((bits&0xAAAAAAAAu)>>1u);bits=((bits&0x33333333u)<<2u)|((bits&0xCCCCCCCCu)>>2u);bits=((bits&0x0F0F0F0Fu)<<4u)|((bits&0xF0F0F0F0u)>>4u);bits=((bits&0x00FF00FFu)<<8u)|((bits&0xFF00FF00u)>>8u);return float(bits)*2.3283064365386963e-10;}vec2 hammersley2d(int i,int N){return vec2(float(i)/float(N),radicalInverse_VdC(uint(i)));}mat3 generateTBN(vec3 normal){vec3 bitangent=vec3(0.0,1.0,0.0);float NdotUp=dot(normal,vec3(0.0,1.0,0.0));float epsilon=0.0000001;if(1.0-abs(NdotUp)<=epsilon){if(NdotUp>0.0){bitangent=vec3(0.0,0.0,1.0);}else{bitangent=vec3(0.0,0.0,-1.0);}}vec3 tangent=normalize(cross(bitangent,normal));bitangent=cross(normal,tangent);return mat3(tangent,bitangent,normal);}struct MicrofacetDistributionSample{float pdf;float cosTheta;float sinTheta;float phi;};float D_GGX(float NdotH,float roughness){float a=NdotH*roughness;float k=roughness/(1.0-NdotH*NdotH+a*a);return k*k*(1.0/MATH_PI);}MicrofacetDistributionSample GGX(vec2 xi,float roughness){MicrofacetDistributionSample ggx;float alpha=roughness*roughness;ggx.cosTheta=saturate(sqrt((1.0-xi.y)/(1.0+(alpha*alpha-1.0)*xi.y)));ggx.sinTheta=sqrt(1.0-ggx.cosTheta*ggx.cosTheta);ggx.phi=2.0*MATH_PI*xi.x;ggx.pdf=D_GGX(ggx.cosTheta,alpha);ggx.pdf/=4.0;return ggx;}float D_Ashikhmin(float NdotH,float roughness){float alpha=roughness*roughness;float a2=alpha*alpha;float cos2h=NdotH*NdotH;float sin2h=1.0-cos2h;float sin4h=sin2h*sin2h;float cot2=-cos2h/(a2*sin2h);return 1.0/(MATH_PI*(4.0*a2+1.0)*sin4h)*(4.0*exp(cot2)+sin4h);}float D_Charlie(float sheenRoughness,float NdotH){sheenRoughness=max(sheenRoughness,0.000001);float invR=1.0/sheenRoughness;float cos2h=NdotH*NdotH;float sin2h=1.0-cos2h;return(2.0+invR)*pow(sin2h,invR*0.5)/(2.0*MATH_PI);}MicrofacetDistributionSample Charlie(vec2 xi,float roughness){MicrofacetDistributionSample charlie;float alpha=roughness*roughness;charlie.sinTheta=pow(xi.y,alpha/(2.0*alpha+1.0));charlie.cosTheta=sqrt(1.0-charlie.sinTheta*charlie.sinTheta);charlie.phi=2.0*MATH_PI*xi.x;charlie.pdf=D_Charlie(alpha,charlie.cosTheta);charlie.pdf/=4.0;return charlie;}MicrofacetDistributionSample Lambertian(vec2 xi,float roughness){MicrofacetDistributionSample lambertian;lambertian.cosTheta=sqrt(1.0-xi.y);lambertian.sinTheta=sqrt(xi.y);lambertian.phi=2.0*MATH_PI*xi.x;lambertian.pdf=lambertian.cosTheta/MATH_PI;return lambertian;}vec4 getImportanceSample(int sampleIndex,vec3 N,float roughness){vec2 xi=hammersley2d(sampleIndex,u_sampleCount);MicrofacetDistributionSample importanceSample;if(u_distribution==cLambertian){importanceSample=Lambertian(xi,roughness);}else if(u_distribution==cGGX){importanceSample=GGX(xi,roughness);}else if(u_distribution==cCharlie){importanceSample=Charlie(xi,roughness);}vec3 localSpaceDirection=normalize(vec3(importanceSample.sinTheta*cos(importanceSample.phi),importanceSample.sinTheta*sin(importanceSample.phi),importanceSample.cosTheta));mat3 TBN=generateTBN(N);vec3 direction=TBN*localSpaceDirection;return vec4(direction,importanceSample.pdf);}float computeLod(float pdf){float lod=0.5*log2(6.0*float(u_width)*float(u_width)/(float(u_sampleCount)*pdf));return lod;}vec3 filterColor(vec3 N){vec3 color=vec3(0.f);float weight=0.0f;for(int i=0;i<u_sampleCount;++i){vec4 importanceSample=getImportanceSample(i,N,u_roughness);vec3 H=vec3(importanceSample.xyz);float pdf=importanceSample.w;float lod=computeLod(pdf);lod+=u_lodBias;if(u_distribution==cLambertian){vec3 lambertian=textureLod(u_cubemapTexture,H,lod).rgb*u_intensityScale;color+=lambertian;}else if(u_distribution==cGGX||u_distribution==cCharlie){vec3 V=N;vec3 L=normalize(reflect(-V,H));float NdotL=dot(N,L);if(NdotL>0.0){if(u_roughness==0.0){lod=u_lodBias;}vec3 sampleColor=textureLod(u_cubemapTexture,L,lod).rgb*u_intensityScale;color+=sampleColor*NdotL;weight+=NdotL;}}}if(weight!=0.0f){color/=weight;}else{color/=float(u_sampleCount);}return color.rgb;}float V_SmithGGXCorrelated(float NoV,float NoL,float roughness){float a2=pow(roughness,4.0);float GGXV=NoL*sqrt(NoV*NoV*(1.0-a2)+a2);float GGXL=NoV*sqrt(NoL*NoL*(1.0-a2)+a2);return 0.5/(GGXV+GGXL);}float V_Ashikhmin(float NdotL,float NdotV){return clamp(1.0/(4.0*(NdotL+NdotV-NdotL*NdotV)),0.0,1.0);}vec3 LUT(float NdotV,float roughness){vec3 V=vec3(sqrt(1.0-NdotV*NdotV),0.0,NdotV);vec3 N=vec3(0.0,0.0,1.0);float A=0.0;float B=0.0;float C=0.0;for(int i=0;i<u_sampleCount;++i){vec4 importanceSample=getImportanceSample(i,N,roughness);vec3 H=importanceSample.xyz;vec3 L=normalize(reflect(-V,H));float NdotL=saturate(L.z);float NdotH=saturate(H.z);float VdotH=saturate(dot(V,H));if(NdotL>0.0){if(u_distribution==cGGX){float V_pdf=V_SmithGGXCorrelated(NdotV,NdotL,roughness)*VdotH*NdotL/NdotH;float Fc=pow(1.0-VdotH,5.0);A+=(1.0-Fc)*V_pdf;B+=Fc*V_pdf;C+=0.0;}if(u_distribution==cCharlie){float sheenDistribution=D_Charlie(roughness,NdotH);float sheenVisibility=V_Ashikhmin(NdotL,NdotV);A+=0.0;B+=0.0;C+=sheenVisibility*sheenDistribution*NdotL*VdotH;}}}return vec3(4.0*A,4.0*B,4.0*2.0*MATH_PI*C)/float(u_sampleCount);}void main(){vec3 color=vec3(0);if(u_isGeneratingLUT==0){vec2 newUV=texCoord;newUV=newUV*2.0-1.0;vec3 scan=uvToXYZ(u_currentFace,newUV);vec3 direction=normalize(scan);direction.y=-direction.y;color=filterColor(direction);}else{color=LUT(texCoord.x,texCoord.y);fragmentColor.rgb=color;fragmentColor.a=1.0;return;}fragmentColor.a=1.0;if(u_floatTexture==0){float maxV=max(max(color.r,color.g),color.b);color/=u_intensityScale;color=clamp(color,0.0f,1.0f);}fragmentColor.rgb=color;}"; // eslint-disable-line

var panoramaToCubeMap = "#define MATH_PI 3.1415926535897932384626433832795\n#define MATH_INV_PI (1.0 / MATH_PI)\nprecision highp float;\n#define GLSLIFY 1\nin vec2 texCoord;out vec4 fragmentColor;uniform int u_currentFace;uniform sampler2D u_panorama;vec3 uvToXYZ(int face,vec2 uv){if(face==0)return vec3(1.f,uv.y,-uv.x);else if(face==1)return vec3(-1.f,uv.y,uv.x);else if(face==2)return vec3(+uv.x,-1.f,+uv.y);else if(face==3)return vec3(+uv.x,1.f,-uv.y);else if(face==4)return vec3(+uv.x,uv.y,1.f);else{return vec3(-uv.x,+uv.y,-1.f);}}vec2 dirToUV(vec3 dir){return vec2(0.5f+0.5f*atan(dir.z,dir.x)/MATH_PI,1.f-acos(dir.y)/MATH_PI);}vec3 panoramaToCubeMap(int face,vec2 texCoord){vec2 texCoordNew=texCoord*2.0-1.0;vec3 scan=uvToXYZ(face,texCoordNew);vec3 direction=normalize(scan);vec2 src=dirToUV(direction);return texture(u_panorama,src).rgb;}void main(void){fragmentColor=vec4(0.0,0.0,0.0,1.0);fragmentColor.rgb=panoramaToCubeMap(u_currentFace,texCoord);}"; // eslint-disable-line

var debugOutput = "precision highp float;\n#define GLSLIFY 1\nin vec2 texCoord;out vec4 fragmentColor;uniform int u_currentFace;uniform samplerCube u_inputTexture;vec3 uvToXYZ(int face,vec2 uv){if(face==0)return vec3(1.f,uv.y,-uv.x);else if(face==1)return vec3(-1.f,uv.y,uv.x);else if(face==2)return vec3(+uv.x,-1.f,+uv.y);else if(face==3)return vec3(+uv.x,1.f,-uv.y);else if(face==4)return vec3(+uv.x,uv.y,1.f);else{return vec3(-uv.x,+uv.y,-1.f);}}void main(void){fragmentColor=vec4(texCoord.x*10.0,0.0,texCoord.y*10.0,1.0);vec2 newUV=texCoord;newUV=newUV*2.0-1.0;vec4 textureColor=vec4(0.0,0.0,0.0,1.0);vec3 direction=normalize(uvToXYZ(u_currentFace,newUV.xy));textureColor=textureLod(u_inputTexture,direction,1.0);if(texCoord.x>0.1){fragmentColor=textureColor;}if(texCoord.y>0.1){fragmentColor=textureColor;}}"; // eslint-disable-line

var fullscreenShader = "precision highp float;\n#define GLSLIFY 1\nout vec2 texCoord;void main(void){float x=float((gl_VertexID&1)<<2);float y=float((gl_VertexID&2)<<1);texCoord.x=x*0.5;texCoord.y=y*0.5;gl_Position=vec4(x-1.0,y-1.0,0,1);}"; // eslint-disable-line

class iblSampler
{
    constructor(view)
    {
        this.gl = view.context;

        this.textureSize = 256;
        this.ggxSampleCount = 1024;
        this.lambertianSampleCount = 2048;
        this.sheenSamplCount = 64;
        this.lodBias = 0.0;
        this.lowestMipLevel = 4;
        this.lutResolution = 1024;

        this.scaleValue = 1.0;

        this.mipmapCount = undefined;

        this.lambertianTextureID = undefined;
        this.ggxTextureID = undefined;
        this.sheenTextureID = undefined;

        this.ggxLutTextureID = undefined;
        this.charlieLutTextureID = undefined;

        this.inputTextureID = undefined;
        this.cubemapTextureID = undefined;
        this.framebuffer = undefined;

        this.supportedFormats = ["BYTE"];
        this.preferredFormat = "HALF_FLOAT";

        const shaderSources = new Map();

        shaderSources.set("fullscreen.vert", fullscreenShader);
        shaderSources.set("panorama_to_cubemap.frag", panoramaToCubeMap);
        shaderSources.set("ibl_filtering.frag", iblFiltering);
        shaderSources.set("debug.frag", debugOutput);

        this.shaderCache = new ShaderCache(shaderSources, view.renderer.webGl);
    }

    prepareTextureData(image)
    {
        let texture =  {
            internalFormat: this.gl.RGB32F,
            format:this.gl.RGB,
            type: this.gl.FLOAT,
            data:undefined 
        };

        // Reset scaling of hdrs 
        this.scaleValue = 1.0;

        if(this.supportedFormats.includes("FLOAT") == false && this.supportedFormats.includes("HALF_FLOAT") == false)
        {
            texture.internalFormat = this.internalFormat();
            texture.format = this.gl.RGBA;
            texture.type = this.gl.UNSIGNED_BYTE;

            const numPixels = image.dataFloat.length / 3;

            let max_value = 0.0;
            let clamped_sum = 0.0;
            let diff_sum = 0.0;

            for(let i = 0, src = 0, dst = 0; i < numPixels; ++i, src += 3, dst += 4)
            {
                let max_component = Math.max(image.dataFloat[src+0], image.dataFloat[src+1], image.dataFloat[src+2]);
                if(max_component > 1.0) {
                    diff_sum += max_component-1.0;
                }
                clamped_sum += Math.min(max_component, 1.0);

                max_value =  Math.max(max_component, max_value);
            }

            let scaleFactor = 1.0;  
            if(clamped_sum > 1.0) {
                // Apply global scale factor to compensate for intensity lost when clamping
                scaleFactor = (clamped_sum+diff_sum)/clamped_sum;
            }

            if(max_value > 1.0){
                console.warn("Environment light intensity cannot be displayed correctly on this device");
            }
           
            texture.data = new Uint8Array(numPixels * 4);
            for(let i = 0, src = 0, dst = 0; i < numPixels; ++i, src += 3, dst += 4)
            {
                // copy the pixels and pad the alpha channel
                texture.data[dst+0] = Math.min((image.dataFloat[src+0])*255, 255);
                texture.data[dst+1] = Math.min((image.dataFloat[src+1])*255, 255);
                texture.data[dst+2] = Math.min((image.dataFloat[src+2])*255, 255);
                texture.data[dst+3] = 255;  // unused
            }

            this.scaleValue =  scaleFactor;
            return texture;
        }



        const numPixels = image.dataFloat.length / 3;
        texture.data = new Float32Array(numPixels * 4);
        
        let max_value = 0.0;
        for(let i = 0, src = 0, dst = 0; i < numPixels; ++i, src += 3, dst += 4)
        {
            // pad the alpha channel
            // workaround for node-gles not supporting RGB32F -> convert to RGBA32F
            texture.data[dst] =  image.dataFloat[src];
            texture.data[dst+1] = image.dataFloat[src+1];
            texture.data[dst+2] = image.dataFloat[src+2];
            texture.data[dst+3] = 1.0; // unused
            
            let max_component = Math.max(image.dataFloat[src+0], image.dataFloat[src+1], image.dataFloat[src+2]);
            max_value =  Math.max(max_component, max_value);
        }

        if(max_value > 65504.0) {
            // We need float (32 bit) to support value range
            if(this.supportedFormats.includes("FLOAT"))
            {
                // Remove HALF_FLOAT from supported list as we require a higher value range 
                this.supportedFormats.splice(this.supportedFormats.indexOf("HALF_FLOAT"), 1);
            }
            else
            {
                console.warn("Supported texture formats do not support HDR value range ");
                console.warn("Environment light intensity cannot be displayed correctly on this device");

                // Recalcualte texture data to fit in half_float range
                let clamped_sum = 0.0;
                let diff_sum = 0.0;
                const max_range = 65504.0;
                for(let i = 0, src = 0, dst = 0; i < numPixels; ++i, src += 3, dst += 4)
                {
                    texture.data[dst] =  Math.min(image.dataFloat[src], max_range);
                    texture.data[dst+1] = Math.min(image.dataFloat[src+1], max_range);
                    texture.data[dst+2] = Math.min(image.dataFloat[src+2], max_range);
                    texture.data[dst+3] = 1.0; // unused

                    let max_component = Math.max(image.dataFloat[src+0], image.dataFloat[src+1], image.dataFloat[src+2]);
                    if(max_component > max_range) {
                        diff_sum += max_component-max_range;
                    }
                    clamped_sum += Math.min(max_component, max_range);
     
                } 
                if(clamped_sum > 1.0) {
                    // Apply global scale factor to compensate for intensity lost when clamping
                    this.scaleValue =   (clamped_sum+diff_sum)/clamped_sum;
                }
    

            }
        }


        if(image.dataFloat instanceof Float32Array && this.supportedFormats.includes("HALF_FLOAT"))
        {
            texture.internalFormat = this.internalFormat();
            texture.format = this.gl.RGBA;
            texture.type = this.gl.FLOAT;

            return texture;
        }
 
        if (image.dataFloat instanceof Float32Array &&  this.supportedFormats.includes("FLOAT"))
        {
            
            texture.internalFormat = this.gl.RGBA32F;
            texture.format = this.gl.RGBA;
            texture.type = this.gl.FLOAT;

            return texture;
        }

        if (typeof(Image) !== 'undefined' && image instanceof Image)
        {
            texture.internalFormat = this.gl.RGBA8;
            texture.format = this.gl.RGBA;
            texture.type = this.gl.UNSIGNED_BYTE;
            texture.data = image;
            return texture;
        }

        console.error("loadTextureHDR failed, unsupported HDR image");

    }

    loadTextureHDR(image)
    {
        let texture = this.prepareTextureData(image);
       
        const textureID = this.gl.createTexture();
        this.gl.bindTexture(this.gl.TEXTURE_2D, textureID);      

        this.gl.texImage2D(
            this.gl.TEXTURE_2D, // target
            0, // level
            texture.internalFormat, 
            image.width,
            image.height,
            0, // border
            texture.format, // format of the pixel data
            texture.type, // type of the pixel data
            texture.data
        );

        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.MIRRORED_REPEAT);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.MIRRORED_REPEAT);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);

        return textureID;
    }

    internalFormat()
    {
        
        if(this.supportedFormats.includes(this.preferredFormat))
        { 
            // Try to use preferred format
            if(this.preferredFormat == "FLOAT") return  this.gl.RGBA32F;
            if(this.preferredFormat == "HALF_FLOAT") return  this.gl.RGBA16F;
            if(this.preferredFormat == "BYTE") return  this.gl.RGBA8;
        }
        if(this.supportedFormats.includes("FLOAT")) return  this.gl.RGBA32F;
        if(this.supportedFormats.includes("HALF_FLOAT")) return  this.gl.RGBA16F;
        if(this.supportedFormats.includes("BYTE")) return  this.gl.RGBA8;

        return this.gl.RGBA8; // Fallback
    }

    textureTargetType()
    {
        
        if(this.supportedFormats.includes(this.preferredFormat))
        { 
            // Try to use preferred format
            if(this.preferredFormat == "FLOAT") return   this.gl.FLOAT;
            if(this.preferredFormat == "HALF_FLOAT") return  this.gl.HALF_FLOAT;
            if(this.preferredFormat == "BYTE") return  this.gl.UNSIGNED_BYTE;
        }
        if(this.supportedFormats.includes("FLOAT")) return   this.gl.FLOAT;
        if(this.supportedFormats.includes("HALF_FLOAT")) return   this.gl.HALF_FLOAT;
        if(this.supportedFormats.includes("BYTE")) return  this.gl.UNSIGNED_BYTE;

        return this.gl.UNSIGNED_BYTE; // Fallback
    }

    createCubemapTexture(withMipmaps)
    {
        const targetTexture =  this.gl.createTexture();
        this.gl.bindTexture(this.gl.TEXTURE_CUBE_MAP, targetTexture);

        for(let i = 0; i < 6; ++i)
        {
            this.gl.texImage2D(
                this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + i,
                0,
                this.internalFormat(),
                this.textureSize,
                this.textureSize,
                0,
                this.gl.RGBA,
                this.textureTargetType(),
                null
            );
        }

        if(withMipmaps)
        {
            this.gl.texParameteri(this.gl.TEXTURE_CUBE_MAP, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR_MIPMAP_LINEAR);
        }
        else
        {
            this.gl.texParameteri(this.gl.TEXTURE_CUBE_MAP, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
        }

        this.gl.texParameteri(this.gl.TEXTURE_CUBE_MAP, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_CUBE_MAP, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_CUBE_MAP, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);

        return targetTexture;
    }

    createLutTexture()
    {
        const targetTexture = this.gl.createTexture();
        this.gl.bindTexture(this.gl.TEXTURE_2D, targetTexture);

        this.gl.texImage2D(
            this.gl.TEXTURE_2D,
            0,
            this.internalFormat(),
            this.lutResolution,
            this.lutResolution,
            0,
            this.gl.RGBA,
            this.textureTargetType(),
            null
        );

        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);

        return targetTexture;
    }

    init(panoramaImage)
    {
        if (this.gl.getExtension("EXT_color_buffer_float") && this.gl.getExtension("OES_texture_float_linear"))
        {
            this.supportedFormats.push("FLOAT");
        }
        if (this.gl.getExtension("EXT_color_buffer_float") || this.gl.getExtension("EXT_color_buffer_half_float"))
        {
            this.supportedFormats.push("HALF_FLOAT");
        }
       

        this.inputTextureID = this.loadTextureHDR(panoramaImage);

        this.cubemapTextureID = this.createCubemapTexture(true);

        this.framebuffer = this.gl.createFramebuffer();

        this.lambertianTextureID = this.createCubemapTexture(false);
        this.ggxTextureID = this.createCubemapTexture(true);
        this.sheenTextureID = this.createCubemapTexture(true);


        this.gl.bindTexture(this.gl.TEXTURE_CUBE_MAP, this.ggxTextureID);
        this.gl.generateMipmap(this.gl.TEXTURE_CUBE_MAP);

        this.gl.bindTexture(this.gl.TEXTURE_CUBE_MAP, this.sheenTextureID);
        this.gl.generateMipmap(this.gl.TEXTURE_CUBE_MAP);

        this.mipmapLevels = Math.floor(Math.log2(this.textureSize))+1 - this.lowestMipLevel;
    }

    filterAll()
    {
        this.panoramaToCubeMap();
        this.cubeMapToLambertian();
        this.cubeMapToGGX();
        this.cubeMapToSheen();

        this.sampleGGXLut();
        this.sampleCharlieLut();

        this.gl.bindFramebuffer( this.gl.FRAMEBUFFER, null);
    }

    panoramaToCubeMap()
    {
        for(let i = 0; i < 6; ++i)
        {
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.framebuffer);
            this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, this.cubemapTextureID, 0);

            this.gl.bindTexture(this.gl.TEXTURE_CUBE_MAP, this.cubemapTextureID);

            this.gl.viewport(0, 0, this.textureSize, this.textureSize);

            this.gl.clearColor(1.0, 0.0, 0.0, 0.0);
            this.gl.clear(this.gl.COLOR_BUFFER_BIT| this.gl.DEPTH_BUFFER_BIT);

            const vertexHash = this.shaderCache.selectShader("fullscreen.vert", []);
            const fragmentHash = this.shaderCache.selectShader("panorama_to_cubemap.frag", []);

            const shader = this.shaderCache.getShaderProgram(fragmentHash, vertexHash);
            this.gl.useProgram(shader.program);

            //  TEXTURE0 = active.
            this.gl.activeTexture(this.gl.TEXTURE0+0);

            // Bind texture ID to active texture
            this.gl.bindTexture(this.gl.TEXTURE_2D, this.inputTextureID);

            // map shader uniform to texture unit (TEXTURE0)
            const location = this.gl.getUniformLocation(shader.program,"u_panorama");
            this.gl.uniform1i(location, 0); // texture unit 0 (TEXTURE0)

            shader.updateUniform("u_currentFace", i);

            //fullscreen triangle
            this.gl.drawArrays(this.gl.TRIANGLES, 0, 3);
        }

        this.gl.bindTexture(this.gl.TEXTURE_CUBE_MAP, this.cubemapTextureID);
        this.gl.generateMipmap(this.gl.TEXTURE_CUBE_MAP);

    }


    applyFilter(
        distribution,
        roughness,
        targetMipLevel,
        targetTexture,
        sampleCount,
        lodBias = 0.0)
    {
        const currentTextureSize = this.textureSize >> targetMipLevel;

        for(let i = 0; i < 6; ++i)
        {
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.framebuffer);
            this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, targetTexture, targetMipLevel);

            this.gl.bindTexture(this.gl.TEXTURE_CUBE_MAP, targetTexture);

            this.gl.viewport(0, 0, currentTextureSize, currentTextureSize);

            this.gl.clearColor(1.0, 0.0, 0.0, 0.0);
            this.gl.clear(this.gl.COLOR_BUFFER_BIT| this.gl.DEPTH_BUFFER_BIT);

            const vertexHash = this.shaderCache.selectShader("fullscreen.vert", []);
            const fragmentHash = this.shaderCache.selectShader("ibl_filtering.frag", []);

            const shader = this.shaderCache.getShaderProgram(fragmentHash, vertexHash);
            this.gl.useProgram(shader.program);

            //  TEXTURE0 = active.
            this.gl.activeTexture(this.gl.TEXTURE0);

            // Bind texture ID to active texture
            this.gl.bindTexture(this.gl.TEXTURE_CUBE_MAP, this.cubemapTextureID);

            // map shader uniform to texture unit (TEXTURE0)
            const location = this.gl.getUniformLocation(shader.program,"u_cubemapTexture");
            this.gl.uniform1i(location, 0); // texture unit 0

            shader.updateUniform("u_roughness", roughness);
            shader.updateUniform("u_sampleCount", sampleCount);
            shader.updateUniform("u_width", this.textureSize);
            shader.updateUniform("u_lodBias", lodBias);
            shader.updateUniform("u_distribution", distribution);
            shader.updateUniform("u_currentFace", i);
            shader.updateUniform("u_isGeneratingLUT", 0);
            if(this.supportedFormat === "BYTE") {
                shader.updateUniform("u_floatTexture", 0);
            } else {
                shader.updateUniform("u_floatTexture", 1);
            }
            shader.updateUniform("u_intensityScale", this.scaleValue);

            //fullscreen triangle
            this.gl.drawArrays(this.gl.TRIANGLES, 0, 3);
        }

    }

    cubeMapToLambertian()
    {
        this.applyFilter(
            0,
            0.0,
            0,
            this.lambertianTextureID,
            this.lambertianSampleCount);
    }


    cubeMapToGGX()
    {
        for(let currentMipLevel = 0; currentMipLevel <= this.mipmapLevels; ++currentMipLevel)
        {
            const roughness = (currentMipLevel) / (this.mipmapLevels - 1);
            this.applyFilter(
                1,
                roughness,
                currentMipLevel,
                this.ggxTextureID,
                this.ggxSampleCount);
        }
    }

    cubeMapToSheen()
    {
        for(let currentMipLevel = 0; currentMipLevel <= this.mipmapLevels; ++currentMipLevel)
        {
            const roughness = (currentMipLevel) / (this.mipmapLevels - 1);
            this.applyFilter(
                2,
                roughness,
                currentMipLevel,
                this.sheenTextureID,
                this.sheenSamplCount);
        }
    }

    sampleLut(distribution, targetTexture, currentTextureSize)
    {
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.framebuffer);
        this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, targetTexture, 0);

        this.gl.bindTexture(this.gl.TEXTURE_2D, targetTexture);

        this.gl.viewport(0, 0, currentTextureSize, currentTextureSize);

        this.gl.clearColor(1.0, 0.0, 0.0, 0.0);
        this.gl.clear(this.gl.COLOR_BUFFER_BIT| this.gl.DEPTH_BUFFER_BIT);

        const vertexHash = this.shaderCache.selectShader("fullscreen.vert", []);
        const fragmentHash = this.shaderCache.selectShader("ibl_filtering.frag", []);

        const shader = this.shaderCache.getShaderProgram(fragmentHash, vertexHash);
        this.gl.useProgram(shader.program);


        //  TEXTURE0 = active.
        this.gl.activeTexture(this.gl.TEXTURE0+0);

        // Bind texture ID to active texture
        this.gl.bindTexture(this.gl.TEXTURE_CUBE_MAP, this.cubemapTextureID);

        // map shader uniform to texture unit (TEXTURE0)
        const location = this.gl.getUniformLocation(shader.program,"u_cubemapTexture");
        this.gl.uniform1i(location, 0); // texture unit 0


        shader.updateUniform("u_roughness", 0.0);
        shader.updateUniform("u_sampleCount", 512);
        shader.updateUniform("u_width", 0.0);
        shader.updateUniform("u_lodBias", 0.0);
        shader.updateUniform("u_distribution", distribution);
        shader.updateUniform("u_currentFace", 0);
        shader.updateUniform("u_isGeneratingLUT", 1);

        //fullscreen triangle
        this.gl.drawArrays(this.gl.TRIANGLES, 0, 3);
    }

    sampleGGXLut()
    {
        this.ggxLutTextureID = this.createLutTexture();
        this.sampleLut(1, this.ggxLutTextureID, this.lutResolution);
    }

    sampleCharlieLut()
    {
        this.charlieLutTextureID = this.createLutTexture();
        this.sampleLut(2, this.charlieLutTextureID, this.lutResolution);
    }

    destroy()
    {
        this.shaderCache.destroy();
    }
}

/* globals LIBKTX */

class KtxDecoder {

    constructor (context, externalKtxlib) {
        this.gl = context;
        this.libktx = null;
        if (context !== undefined)
        {
            if (externalKtxlib === undefined && LIBKTX !== undefined)
            {
                externalKtxlib = LIBKTX;
            }
            if (externalKtxlib !== undefined)
            {
                this.initializied = this.init(context, externalKtxlib);
            }
            else
            {
                console.error('Failed to initalize KTXDecoder: ktx library undefined');
                return undefined;
            }
        }
        else
        {
            console.error('Failed to initalize KTXDecoder: WebGL context undefined');
            return undefined;
        }
    }

    async init(context, externalKtxlib) {
        this.libktx = await externalKtxlib({preinitializedWebGLContext: context});
        this.libktx.GL.makeContextCurrent(this.libktx.GL.createContext(null, { majorVersion: 2.0 }));
    }

    transcode(ktexture) {
        if (ktexture.needsTranscoding) {
            let format;

            let astcSupported = false;
            let etcSupported = false;
            let dxtSupported = false;
            let bptcSupported = false;
            let pvrtcSupported = false;

            astcSupported = !!this.gl.getExtension('WEBGL_compressed_texture_astc');
            etcSupported = !!this.gl.getExtension('WEBGL_compressed_texture_etc1');
            dxtSupported = !!this.gl.getExtension('WEBGL_compressed_texture_s3tc');
            bptcSupported = !!this.gl.getExtension('EXT_texture_compression_bptc');

            pvrtcSupported = !!(this.gl.getExtension('WEBGL_compressed_texture_pvrtc')) || !!(this.gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc'));

            if (astcSupported) {
                format = this.libktx.TranscodeTarget.ASTC_4x4_RGBA;
            } else if (bptcSupported) {
                format = this.libktx.TranscodeTarget.BC7_RGBA;
            } else if (dxtSupported) {
                format = this.libktx.TranscodeTarget.BC1_OR_3;
            } else if (pvrtcSupported) {
                format = this.libktx.TranscodeTarget.PVRTC1_4_RGBA;
            } else if (etcSupported) {
                format = this.libktx.TranscodeTarget.ETC;
            } else {
                format = this.libktx.TranscodeTarget.RGBA8888;
            }
            if (ktexture.transcodeBasis(format, 0) != this.libktx.ErrorCode.SUCCESS) {
                console.warn('Texture transcode failed. See console for details.');
            }
        }
    }

    async loadKtxFromUri(uri) {
        await this.initializied;
        const response = await fetch(uri);
        const data = new Uint8Array(await response.arrayBuffer());
        const texture = new this.libktx.ktxTexture(data);
        this.transcode(texture);
        let uploadResult = texture.glUpload();
        if (uploadResult.texture == null)
        {
            console.error("Could not load KTX data");
            return undefined;
        }
        uploadResult.texture.levels = Math.log2(texture.baseWidth);
        return uploadResult.texture;
    }

    async loadKtxFromBuffer(data) {
        await this.initializied;
        const texture = new this.libktx.ktxTexture(data);
        this.transcode(texture);
        const uploadResult = texture.glUpload();
        if (uploadResult.texture == null)
        {
            console.error("Could not load KTX data");
            return undefined;
        }
        return uploadResult.texture;
    }
}

/**
 * hdrpng.js - Original code from Enki https://enkimute.github.io/hdrpng.js/
 *
 * Refactored and simplified.
 */


function _rgbeToFloat(buffer)
{
    const length = buffer.byteLength >> 2;
    const result = new Float32Array(length * 3);

    for (let i = 0; i < length; i++)
    {
        const s = Math.pow(2, buffer[i * 4 + 3] - (128 + 8));

        result[i * 3] = buffer[i * 4] * s;
        result[i * 3 + 1] = buffer[i * 4 + 1] * s;
        result[i * 3 + 2] = buffer[i * 4 + 2] * s;
    }
    return result;
}

async function loadHDR(buffer)
{
    let header = '';
    let pos = 0;
    const d8 = buffer;
    let format = undefined;
    // read header.
    while (!header.match(/\n\n[^\n]+\n/g) && pos < d8.length) header += String.fromCharCode(d8[pos++]);
    // check format.
    format = header.match(/FORMAT=(.*)$/m);
    if (format.length < 2)
    {
        return undefined;
    }
    format = format[1];
    if (format != '32-bit_rle_rgbe') return console.warn('unknown format : ' + format), this.onerror();
    // parse resolution
    let rez = header.split(/\n/).reverse();
    if (rez.length < 2)
    {
        return undefined;
    }
    rez = rez[1].split(' ');
    if (rez.length < 4)
    {
        return undefined;
    }
    const width = rez[3] * 1, height = rez[1] * 1;
    // Create image.
    const img = new Uint8Array(width * height * 4);
    let ipos = 0;
    // Read all scanlines
    for (let j = 0; j < height; j++)
    {
        const scanline = [];

        let rgbe = d8.slice(pos, pos += 4);
        const isNewRLE = (rgbe[0] == 2 && rgbe[1] == 2 && rgbe[2] == ((width >> 8) & 0xFF) && rgbe[3] == (width & 0xFF));

        if (isNewRLE && (width >= 8) && (width < 32768))
        {
            for (let i = 0; i < 4; i++)
            {
                let ptr = i * width;
                const ptr_end = (i + 1) * width;
                let buf = undefined;
                let count = undefined;
                while (ptr < ptr_end)
                {
                    buf = d8.slice(pos, pos += 2);
                    if (buf[0] > 128)
                    {
                        count = buf[0] - 128;
                        while (count-- > 0) scanline[ptr++] = buf[1];
                    }
                    else
                    {
                        count = buf[0] - 1;
                        scanline[ptr++] = buf[1];
                        while (count-- > 0) scanline[ptr++] = d8[pos++];
                    }
                }
            }

            for (let i = 0; i < width; i++)
            {
                img[ipos++] = scanline[i + 0 * width];
                img[ipos++] = scanline[i + 1 * width];
                img[ipos++] = scanline[i + 2 * width];
                img[ipos++] = scanline[i + 3 * width];
            }
        }
        else
        {
            pos -= 4;

            for (let i = 0; i < width; i++)
            {
                rgbe = d8.slice(pos, pos += 4);

                img[ipos++] = rgbe[0];
                img[ipos++] = rgbe[1];
                img[ipos++] = rgbe[2];
                img[ipos++] = rgbe[3];
            }
        }
    }

    const imageFloatBuffer = _rgbeToFloat(img);

    return {
        dataFloat: imageFloatBuffer,
        width: width,
        height: height
    };
}

/**
 * ResourceLoader can be used to load resources for the GltfState
 * that are then used to display the loaded data with GltfView
 */
class ResourceLoader
{
    /**
     * ResourceLoader class that provides an interface to load resources into
     * the view. Typically this is created with GltfView.createResourceLoader()
     * You cannot share resource loaders between GltfViews as some of the resources
     * are allocated directly on the WebGl2 Context
     * @param {Object} view the GltfView for which the resources are loaded
     * @param {String} libPath path to the lib folder. This can be used to find the WASM files if sample viewer is repackaged
     */
    constructor(view, libPath = "./libs/")
    {
        this.view = view;
        this.libPath = libPath;
    }

    /**
     * loadGltf asynchroneously and create resources for rendering
     * @param {(String | ArrayBuffer | File)} gltfFile the .gltf or .glb file either as path or as preloaded resource. In node.js environments, only ArrayBuffer types are accepted.
     * @param {File[]} [externalFiles] additional files containing resources that are referenced in the gltf
     * @returns {Promise} a promise that fulfills when the gltf file was loaded
     */
    async loadGltf(gltfFile, externalFiles)
    {
        let isGlb = undefined;
        let buffers = undefined;
        let json = undefined;
        let data = undefined;
        let filename = "";
        if (typeof gltfFile === "string")
        {
            const response = await fetch(gltfFile);
            const responseData = await response.arrayBuffer();
            const uintData = new Uint8Array(responseData);
            const fileMagicNumbers = new TextDecoder().decode(uintData.subarray(0, 5));

            isGlb = fileMagicNumbers.startsWith("glTF");
            if(isGlb) {
                json = data = responseData;
            } else {
                json = data = JSON.parse(new TextDecoder().decode(uintData));
            }

            filename = gltfFile;
        }
        else if (gltfFile instanceof ArrayBuffer)
        {
            isGlb = externalFiles === undefined;
            if (isGlb)
            {
                data = gltfFile;
            }
            else
            {
                console.error("Only .glb files can be loaded from an array buffer");
            }
        }
        else if (Array.isArray(gltfFile) && typeof(File) !== 'undefined' && gltfFile[1] instanceof File)
        {
            let fileContent = gltfFile[1];
            filename = gltfFile[1].name;
            isGlb = getIsGlb(filename);
            if (isGlb)
            {
                data = await AsyncFileReader.readAsArrayBuffer(fileContent);
            }
            else
            {
                data = await AsyncFileReader.readAsText(fileContent);
                json = JSON.parse(data);
                buffers = externalFiles;
            }
        }
        else
        {   
            // Load empty glTF
            data = "{\"asset\":{\"version\": \"2.0\"}}";
            filename = "empty";
            isGlb = false;
            json = JSON.parse(data);
        }

        if (isGlb)
        {
            const glbParser = new GlbParser(data);
            const glb = glbParser.extractGlbData();
            json = glb.json;
            buffers = glb.buffers;
        }

        const gltf = new glTF(filename);
        gltf.ktxDecoder = this.view.ktxDecoder;
        //Make sure draco decoder instance is ready
        gltf.fromJson(json);

        // because the gltf image paths are not relative
        // to the gltf, we have to resolve all image paths before that
        for (const image of gltf.images)
        {
            image.resolveRelativePath(getContainingFolder(gltf.path));
        }
        await init(`${this.libPath}mikktspace_bg.wasm`);
        await gltfLoader.load(gltf, this.view.context, buffers);

        return gltf;
    }

    /**
     * loadEnvironment asynchroneously, run IBL sampling and create resources for rendering
     * @param {(String | ArrayBuffer | File)} environmentFile the .hdr file either as path or resource
     * @param {Object} [lutFiles] object containing paths or resources for the environment look up textures. Keys are lut_ggx_file, lut_charlie_file and lut_sheen_E_file
     * @returns {Promise} a promise that fulfills when the environment file was loaded
     */
    async loadEnvironment(environmentFile, lutFiles)
    {
        let image = undefined;
        if (typeof environmentFile === "string")
        {
            let response = await fetch(environmentFile);
            image = await loadHDR(new Uint8Array(await response.arrayBuffer()));
        }
        else if (environmentFile instanceof ArrayBuffer)
        {
            image = await loadHDR(new Uint8Array(environmentFile));
        }
        else if (typeof (File) !== 'undefined' && environmentFile instanceof File)
        {
            const imageData = await AsyncFileReader.readAsArrayBuffer(environmentFile).catch(() =>
            {
                console.error("Could not load image with FileReader");
            });
            image = await loadHDR(new Uint8Array(imageData));
        }
        else
        {
            console.error("Passed invalid type to loadEnvironment " + typeof (gltfFile));
        }
        if (image === undefined)
        {
            return undefined;
        }
        return _loadEnvironmentFromPanorama(image, this.view, lutFiles);
    }

    /**
     * initKtxLib must be called before loading gltf files with ktx2 assets
     * @param {Object} [externalKtxLib] external ktx library (for example from a CDN)
     */
    initKtxLib(externalKtxLib)
    {
        this.view.ktxDecoder = new KtxDecoder(this.view.context, externalKtxLib);
    }

    /**
     * initDracoLib must be called before loading gltf files with draco meshes
     * @param {*} [externalDracoLib] external draco library (for example from a CDN)
     */
    async initDracoLib(externalDracoLib)
    {
        const dracoDecoder = new DracoDecoder(externalDracoLib);
        if (dracoDecoder !== undefined)
        {
            await dracoDecoder.ready();
        }
    }
}

async function _loadEnvironmentFromPanorama(imageHDR, view, luts)
{
    // The environment uses the same type of samplers, textures and images as used in the glTF class
    // so we just use it as a template
    const environment = new glTF();

    //
    // Prepare samplers.
    //

    let samplerIdx = environment.samplers.length;

    environment.samplers.push(new gltfSampler(GL.LINEAR, GL.LINEAR, GL.CLAMP_TO_EDGE, GL.CLAMP_TO_EDGE, "DiffuseCubeMapSampler"));
    const diffuseCubeSamplerIdx = samplerIdx++;

    environment.samplers.push(new gltfSampler(GL.LINEAR, GL.LINEAR_MIPMAP_LINEAR, GL.CLAMP_TO_EDGE, GL.CLAMP_TO_EDGE, "SpecularCubeMapSampler"));
    const specularCubeSamplerIdx = samplerIdx++;

    environment.samplers.push(new gltfSampler(GL.LINEAR, GL.LINEAR_MIPMAP_LINEAR, GL.CLAMP_TO_EDGE, GL.CLAMP_TO_EDGE, "SheenCubeMapSampler"));
    const sheenCubeSamplerIdx = samplerIdx++;

    environment.samplers.push(new gltfSampler(GL.LINEAR, GL.LINEAR, GL.CLAMP_TO_EDGE, GL.CLAMP_TO_EDGE, "LUTSampler"));
    const lutSamplerIdx = samplerIdx++;

    //
    // Prepare images and textures.
    //

    let imageIdx = environment.images.length;

    let environmentFiltering = new iblSampler(view);

    environmentFiltering.init(imageHDR);
    environmentFiltering.filterAll();

    // Diffuse

    const diffuseGltfImage = new gltfImage(
        undefined,
        GL.TEXTURE_CUBE_MAP,
        0,
        undefined,
        "Diffuse",
        ImageMimeType.GLTEXTURE,
        environmentFiltering.lambertianTextureID
    );

    environment.images.push(diffuseGltfImage);

    const diffuseTexture = new gltfTexture(
        diffuseCubeSamplerIdx,
        [imageIdx++],
        GL.TEXTURE_CUBE_MAP);
    diffuseTexture.initialized = true; // iblsampler has already initialized the texture

    environment.textures.push(diffuseTexture);

    environment.diffuseEnvMap = new gltfTextureInfo(environment.textures.length - 1, 0, true);
    environment.diffuseEnvMap.generateMips = false;



    // Specular
    const specularGltfImage = new gltfImage(
        undefined,
        GL.TEXTURE_CUBE_MAP,
        0,
        undefined,
        "Specular",
        ImageMimeType.GLTEXTURE,
        environmentFiltering.ggxTextureID
    );

    environment.images.push(specularGltfImage);

    const specularTexture = new gltfTexture(
        specularCubeSamplerIdx,
        [imageIdx++],
        GL.TEXTURE_CUBE_MAP);
    specularTexture.initialized = true; // iblsampler has already initialized the texture

    environment.textures.push(specularTexture);

    environment.specularEnvMap = new gltfTextureInfo(environment.textures.length - 1, 0, true);
    environment.specularEnvMap.generateMips = false;


    // Sheen
    const sheenGltfImage = new gltfImage(
        undefined,
        GL.TEXTURE_CUBE_MAP,
        0,
        undefined,
        "Sheen",
        ImageMimeType.GLTEXTURE,
        environmentFiltering.sheenTextureID
    );

    environment.images.push(sheenGltfImage);

    const sheenTexture = new gltfTexture(
        sheenCubeSamplerIdx,
        [imageIdx++],
        GL.TEXTURE_CUBE_MAP);
    sheenTexture.initialized = true; // iblsampler has already initialized the texture

    environment.textures.push(sheenTexture);

    environment.sheenEnvMap = new gltfTextureInfo(environment.textures.length - 1, 0, true);
    environment.sheenEnvMap.generateMips = false;

    /*
        // Diffuse

        const lambertian = new gltfImage(filteredEnvironmentsDirectoryPath + "/lambertian/diffuse.ktx2", GL.TEXTURE_CUBE_MAP);
        lambertian.mimeType = ImageMimeType.KTX2;
        environment.images.push(lambertian);
        environment.textures.push(new gltfTexture(diffuseCubeSamplerIdx, [imageIdx++], GL.TEXTURE_CUBE_MAP));
        environment.diffuseEnvMap = new gltfTextureInfo(environment.textures.length - 1, 0, true);
        environment.diffuseEnvMap.generateMips = false;

        // Specular

        const specular = new gltfImage(filteredEnvironmentsDirectoryPath + "/ggx/specular.ktx2", GL.TEXTURE_CUBE_MAP);
        specular.mimeType = ImageMimeType.KTX2;
        environment.images.push(specular);
        environment.textures.push(new gltfTexture(specularCubeSamplerIdx, [imageIdx++], GL.TEXTURE_CUBE_MAP));
        environment.specularEnvMap = new gltfTextureInfo(environment.textures.length - 1, 0, true);
        environment.specularEnvMap.generateMips = false;

        const specularImage = environment.images[environment.textures[environment.textures.length - 1].source];

        // Sheen

        const sheen = new gltfImage(filteredEnvironmentsDirectoryPath + "/charlie/sheen.ktx2", GL.TEXTURE_CUBE_MAP);
        sheen.mimeType = ImageMimeType.KTX2;
        environment.images.push(sheen);
        environment.textures.push(new gltfTexture(sheenCubeSamplerIdx, [imageIdx++], GL.TEXTURE_CUBE_MAP));
        environment.sheenEnvMap = new gltfTextureInfo(environment.textures.length - 1, 0, true);
        environment.sheenEnvMap.generateMips = false;*/

    //
    // Look Up Tables.
    //

    // GGX

    if (luts === undefined)
    {
        luts = {
            lut_sheen_E_file: "assets/images/lut_sheen_E.png",
        };
    }

    environment.images.push(new gltfImage(
        undefined,
        GL.TEXTURE_2D,
        0,
        undefined,
        undefined,
        ImageMimeType.GLTEXTURE,
        environmentFiltering.ggxLutTextureID));
    const lutTexture = new gltfTexture(lutSamplerIdx, [imageIdx++], GL.TEXTURE_2D);
    lutTexture.initialized = true; // iblsampler has already initialized the texture
    environment.textures.push(lutTexture);

    environment.lut = new gltfTextureInfo(environment.textures.length - 1, 0 , true);
    environment.lut.generateMips = false;

    // Sheen
    // Charlie
    environment.images.push(new gltfImage(
        undefined,
        GL.TEXTURE_2D,
        0,
        undefined,
        undefined,
        ImageMimeType.GLTEXTURE,
        environmentFiltering.charlieLutTextureID));
    const charlieLut = new gltfTexture(lutSamplerIdx, [imageIdx++], GL.TEXTURE_2D);
    charlieLut.initialized = true; // iblsampler has already initialized the texture
    environment.textures.push(charlieLut);

    environment.sheenLUT = new gltfTextureInfo(environment.textures.length - 1, 0, true);
    environment.sheenLUT.generateMips = false;

    // Sheen E LUT

    environment.images.push(new gltfImage(luts.lut_sheen_E_file, GL.TEXTURE_2D, 0, undefined, undefined, ImageMimeType.PNG));
    const sheenELut = new gltfTexture(lutSamplerIdx, [imageIdx++], GL.TEXTURE_2D);
    sheenELut.initialized = true; // iblsampler has already initialized the texture
    environment.textures.push(sheenELut);

    environment.sheenELUT = new gltfTextureInfo(environment.textures.length - 1);
    environment.sheenELUT.generateMips = false;

    await gltfLoader.loadImages(environment);

    environment.initGl(view.context);

    environment.mipCount = environmentFiltering.mipmapLevels;
    environment.iblIntensityScale = environmentFiltering.scaleValue;

    return environment;
}

/**
 * GltfView represents a view on a gltf, e.g. in a canvas
 */
class GltfView
{
    /**
     * GltfView representing one WebGl 2.0 context or in other words one
     * 3D rendering of the Gltf.
     * You can create multiple views for example when multiple canvases should
     * be shown on the same webpage.
     * @param {*} context WebGl 2.0 context. Get it from a canvas with `canvas.getContext("webgl2")`
     */
    constructor(context)
    {
        this.context = context;
        this.renderer = new gltfRenderer(this.context);
    }

    /**
     * createState constructs a new GltfState for the GltfView. The resources
     * referenced in a gltf state can directly be stored as resources on the WebGL
     * context of GltfView, therefore GltfStates cannot not be shared between
     * GltfViews.
     * @returns {GltfState} GltfState
     */
    createState()
    {
        return new GltfState(this);
    }

    /**
     * createResourceLoader creates a resource loader with which glTFs and
     * environments can be loaded for the view
     * @param {Object} [externalDracoLib] optional object of an external Draco library, e.g. from a CDN
     * @param {Object} [externalKtxLib] optional object of an external KTX library, e.g. from a CDN
     * @param {string} [libPath] optional path to the libraries. Used to define the path to the WASM files on repackaging
     * @returns {ResourceLoader} ResourceLoader
     */
    createResourceLoader(externalDracoLib = undefined, externalKtxLib = undefined, libPath = undefined)
    {
        let resourceLoader = new ResourceLoader(this, libPath);
        resourceLoader.initKtxLib(externalKtxLib);
        resourceLoader.initDracoLib(externalDracoLib);
        return resourceLoader;
    }

    /**
     * renderFrame to the context's default frame buffer
     * Call this function in the javascript animation update loop for continuous rendering to a canvas
     * @param {*} state GltfState that is be used for rendering
     * @param {*} width of the viewport
     * @param {*} height of the viewport
     */
    renderFrame(state, width, height)
    {
        this.renderer.init(state);
        this._animate(state);

        this.renderer.resize(width, height);

        this.renderer.clearFrame(state.renderingParameters.clearColor);

        if(state.gltf === undefined)
        {
            return;
        }

        const scene = state.gltf.scenes[state.sceneIndex];

        if(scene === undefined)
        {
            return;
        }

        scene.applyTransformHierarchy(state.gltf);

        this.renderer.drawScene(state, scene);
    }

    /**
     * gatherStatistics collects information about the GltfState such as the number of
     * rendered meshes or triangles
     * @param {*} state GltfState about which the statistics should be collected
     * @returns {Object} an object containing statistics information
     */
    gatherStatistics(state)
    {
        if(state.gltf === undefined)
        {
            return;
        }

        // gather information from the active scene
        const scene = state.gltf.scenes[state.sceneIndex];
        if (scene === undefined)
        {
            return {
                meshCount: 0,
                faceCount: 0,
                opaqueMaterialsCount: 0,
                transparentMaterialsCount: 0};
        }
        const nodes = scene.gatherNodes(state.gltf);
        const activeMeshes = nodes.filter(node => node.mesh !== undefined).map(node => state.gltf.meshes[node.mesh]);
        const activePrimitives = activeMeshes
            .reduce((acc, mesh) => acc.concat(mesh.primitives), [])
            .filter(primitive => primitive.material !== undefined);
        const activeMaterials = [... new Set(activePrimitives.map(primitive => state.gltf.materials[primitive.material]))];
        const opaqueMaterials = activeMaterials.filter(material => material.alphaMode !== "BLEND");
        const transparentMaterials = activeMaterials.filter(material => material.alphaMode === "BLEND");
        const faceCount = activePrimitives
            .map(primitive => {
                let vertexCount = 0;
                if (primitive.indices !== undefined) {
                    vertexCount = state.gltf.accessors[primitive.indices].count;
                }
                else {
                    vertexCount = state.gltf.accessors[primitive.attributes["POSITION"]].count;
                }
                if (vertexCount === 0) {
                    return 0;
                }

                // convert vertex count to point, line or triangle count
                switch (primitive.mode) {
                case GL.POINTS:
                    return vertexCount;
                case GL.LINES:
                    return vertexCount / 2;
                case GL.LINE_LOOP:
                    return vertexCount;
                case GL.LINE_STRIP:
                    return vertexCount - 1;
                case GL.TRIANGLES:
                    return vertexCount / 3;
                case GL.TRIANGLE_STRIP:
                case GL.TRIANGLE_FAN:
                    return vertexCount - 2;
                }
            })
            .reduce((acc, faceCount) => acc + faceCount);

        // assemble statistics object
        return {
            meshCount: activeMeshes.length,
            faceCount: faceCount,
            opaqueMaterialsCount: opaqueMaterials.length,
            transparentMaterialsCount: transparentMaterials.length
        };
    }

    _animate(state)
    {
        if(state.gltf === undefined)
        {
            return;
        }

        if(state.gltf.animations !== undefined && state.animationIndices !== undefined)
        {
            const disabledAnimations = state.gltf.animations.filter( (anim, index) => {
                return false === state.animationIndices.includes(index);
            });

            for(const disabledAnimation of disabledAnimations)
            {
                disabledAnimation.advance(state.gltf, undefined);
            }

            const t = state.animationTimer.elapsedSec();

            const animations = state.animationIndices.map(index => {
                return state.gltf.animations[index];
            }).filter(animation => animation !== undefined);

            for(const animation of animations)
            {
                animation.advance(state.gltf, t);
            }
        }
    }
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isFunction$1(x) {
    return typeof x === 'function';
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var _enable_super_gross_mode_that_will_cause_bad_things = false;
var config$1 = {
    Promise: undefined,
    set useDeprecatedSynchronousErrorHandling(value) {
        if (value) {
            var error = /*@__PURE__*/ new Error();
            /*@__PURE__*/ console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack);
        }
        _enable_super_gross_mode_that_will_cause_bad_things = value;
    },
    get useDeprecatedSynchronousErrorHandling() {
        return _enable_super_gross_mode_that_will_cause_bad_things;
    },
};

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function hostReportError(err) {
    setTimeout(function () { throw err; }, 0);
}

/** PURE_IMPORTS_START _config,_util_hostReportError PURE_IMPORTS_END */
var empty = {
    closed: true,
    next: function (value) { },
    error: function (err) {
        if (config$1.useDeprecatedSynchronousErrorHandling) {
            throw err;
        }
        else {
            hostReportError(err);
        }
    },
    complete: function () { }
};

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var isArray$1 = /*@__PURE__*/ (function () { return Array.isArray || (function (x) { return x && typeof x.length === 'number'; }); })();

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isObject$2(x) {
    return x !== null && typeof x === 'object';
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var UnsubscriptionErrorImpl = /*@__PURE__*/ (function () {
    function UnsubscriptionErrorImpl(errors) {
        Error.call(this);
        this.message = errors ?
            errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ') : '';
        this.name = 'UnsubscriptionError';
        this.errors = errors;
        return this;
    }
    UnsubscriptionErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
    return UnsubscriptionErrorImpl;
})();
var UnsubscriptionError = UnsubscriptionErrorImpl;

/** PURE_IMPORTS_START _util_isArray,_util_isObject,_util_isFunction,_util_UnsubscriptionError PURE_IMPORTS_END */
var Subscription = /*@__PURE__*/ (function () {
    function Subscription(unsubscribe) {
        this.closed = false;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (unsubscribe) {
            this._ctorUnsubscribe = true;
            this._unsubscribe = unsubscribe;
        }
    }
    Subscription.prototype.unsubscribe = function () {
        var errors;
        if (this.closed) {
            return;
        }
        var _a = this, _parentOrParents = _a._parentOrParents, _ctorUnsubscribe = _a._ctorUnsubscribe, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (_parentOrParents instanceof Subscription) {
            _parentOrParents.remove(this);
        }
        else if (_parentOrParents !== null) {
            for (var index = 0; index < _parentOrParents.length; ++index) {
                var parent_1 = _parentOrParents[index];
                parent_1.remove(this);
            }
        }
        if (isFunction$1(_unsubscribe)) {
            if (_ctorUnsubscribe) {
                this._unsubscribe = undefined;
            }
            try {
                _unsubscribe.call(this);
            }
            catch (e) {
                errors = e instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];
            }
        }
        if (isArray$1(_subscriptions)) {
            var index = -1;
            var len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject$2(sub)) {
                    try {
                        sub.unsubscribe();
                    }
                    catch (e) {
                        errors = errors || [];
                        if (e instanceof UnsubscriptionError) {
                            errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
                        }
                        else {
                            errors.push(e);
                        }
                    }
                }
            }
        }
        if (errors) {
            throw new UnsubscriptionError(errors);
        }
    };
    Subscription.prototype.add = function (teardown) {
        var subscription = teardown;
        if (!teardown) {
            return Subscription.EMPTY;
        }
        switch (typeof teardown) {
            case 'function':
                subscription = new Subscription(teardown);
            case 'object':
                if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== 'function') {
                    return subscription;
                }
                else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                }
                else if (!(subscription instanceof Subscription)) {
                    var tmp = subscription;
                    subscription = new Subscription();
                    subscription._subscriptions = [tmp];
                }
                break;
            default: {
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
            }
        }
        var _parentOrParents = subscription._parentOrParents;
        if (_parentOrParents === null) {
            subscription._parentOrParents = this;
        }
        else if (_parentOrParents instanceof Subscription) {
            if (_parentOrParents === this) {
                return subscription;
            }
            subscription._parentOrParents = [_parentOrParents, this];
        }
        else if (_parentOrParents.indexOf(this) === -1) {
            _parentOrParents.push(this);
        }
        else {
            return subscription;
        }
        var subscriptions = this._subscriptions;
        if (subscriptions === null) {
            this._subscriptions = [subscription];
        }
        else {
            subscriptions.push(subscription);
        }
        return subscription;
    };
    Subscription.prototype.remove = function (subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.EMPTY = (function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription()));
    return Subscription;
}());
function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError) ? err.errors : err); }, []);
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var rxSubscriber = /*@__PURE__*/ (function () {
    return typeof Symbol === 'function'
        ? /*@__PURE__*/ Symbol('rxSubscriber')
        : '@@rxSubscriber_' + /*@__PURE__*/ Math.random();
})();

/** PURE_IMPORTS_START tslib,_util_isFunction,_Observer,_Subscription,_internal_symbol_rxSubscriber,_config,_util_hostReportError PURE_IMPORTS_END */
var Subscriber = /*@__PURE__*/ (function (_super) {
    __extends(Subscriber, _super);
    function Subscriber(destinationOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this.syncErrorValue = null;
        _this.syncErrorThrown = false;
        _this.syncErrorThrowable = false;
        _this.isStopped = false;
        switch (arguments.length) {
            case 0:
                _this.destination = empty;
                break;
            case 1:
                if (!destinationOrNext) {
                    _this.destination = empty;
                    break;
                }
                if (typeof destinationOrNext === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                        _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
                        _this.destination = destinationOrNext;
                        destinationOrNext.add(_this);
                    }
                    else {
                        _this.syncErrorThrowable = true;
                        _this.destination = new SafeSubscriber(_this, destinationOrNext);
                    }
                    break;
                }
            default:
                _this.syncErrorThrowable = true;
                _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
                break;
        }
        return _this;
    }
    Subscriber.prototype[rxSubscriber] = function () { return this; };
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    Subscriber.prototype._unsubscribeAndRecycle = function () {
        var _parentOrParents = this._parentOrParents;
        this._parentOrParents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parentOrParents = _parentOrParents;
        return this;
    };
    return Subscriber;
}(Subscription));
var SafeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SafeSubscriber, _super);
    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this._parentSubscriber = _parentSubscriber;
        var next;
        var context = _this;
        if (isFunction$1(observerOrNext)) {
            next = observerOrNext;
        }
        else if (observerOrNext) {
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (observerOrNext !== empty) {
                context = Object.create(observerOrNext);
                if (isFunction$1(context.unsubscribe)) {
                    _this.add(context.unsubscribe.bind(context));
                }
                context.unsubscribe = _this.unsubscribe.bind(_this);
            }
        }
        _this._context = context;
        _this._next = next;
        _this._error = error;
        _this._complete = complete;
        return _this;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parentSubscriber = this._parentSubscriber;
            if (!config$1.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            }
            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            var useDeprecatedSynchronousErrorHandling = config$1.useDeprecatedSynchronousErrorHandling;
            if (this._error) {
                if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);
                    this.unsubscribe();
                }
            }
            else if (!_parentSubscriber.syncErrorThrowable) {
                this.unsubscribe();
                if (useDeprecatedSynchronousErrorHandling) {
                    throw err;
                }
                hostReportError(err);
            }
            else {
                if (useDeprecatedSynchronousErrorHandling) {
                    _parentSubscriber.syncErrorValue = err;
                    _parentSubscriber.syncErrorThrown = true;
                }
                else {
                    hostReportError(err);
                }
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        var _this = this;
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._complete) {
                var wrappedComplete = function () { return _this._complete.call(_this._context); };
                if (!config$1.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(wrappedComplete);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                    this.unsubscribe();
                }
            }
            else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            this.unsubscribe();
            if (config$1.useDeprecatedSynchronousErrorHandling) {
                throw err;
            }
            else {
                hostReportError(err);
            }
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        if (!config$1.useDeprecatedSynchronousErrorHandling) {
            throw new Error('bad call');
        }
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            if (config$1.useDeprecatedSynchronousErrorHandling) {
                parent.syncErrorValue = err;
                parent.syncErrorThrown = true;
                return true;
            }
            else {
                hostReportError(err);
                return true;
            }
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _Subscriber PURE_IMPORTS_END */
function canReportError(observer) {
    while (observer) {
        var _a = observer, closed_1 = _a.closed, destination = _a.destination, isStopped = _a.isStopped;
        if (closed_1 || isStopped) {
            return false;
        }
        else if (destination && destination instanceof Subscriber) {
            observer = destination;
        }
        else {
            observer = null;
        }
    }
    return true;
}

/** PURE_IMPORTS_START _Subscriber,_symbol_rxSubscriber,_Observer PURE_IMPORTS_END */
function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber) {
            return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber]) {
            return nextOrObserver[rxSubscriber]();
        }
    }
    if (!nextOrObserver && !error && !complete) {
        return new Subscriber(empty);
    }
    return new Subscriber(nextOrObserver, error, complete);
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var observable = /*@__PURE__*/ (function () { return typeof Symbol === 'function' && Symbol.observable || '@@observable'; })();

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function identity(x) {
    return x;
}

/** PURE_IMPORTS_START _identity PURE_IMPORTS_END */
function pipeFromArray(fns) {
    if (fns.length === 0) {
        return identity;
    }
    if (fns.length === 1) {
        return fns[0];
    }
    return function piped(input) {
        return fns.reduce(function (prev, fn) { return fn(prev); }, input);
    };
}

/** PURE_IMPORTS_START _util_canReportError,_util_toSubscriber,_symbol_observable,_util_pipe,_config PURE_IMPORTS_END */
var Observable = /*@__PURE__*/ (function () {
    function Observable(subscribe) {
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    Observable.prototype.lift = function (operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber(observerOrNext, error, complete);
        if (operator) {
            sink.add(operator.call(sink, this.source));
        }
        else {
            sink.add(this.source || (config$1.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable) ?
                this._subscribe(sink) :
                this._trySubscribe(sink));
        }
        if (config$1.useDeprecatedSynchronousErrorHandling) {
            if (sink.syncErrorThrowable) {
                sink.syncErrorThrowable = false;
                if (sink.syncErrorThrown) {
                    throw sink.syncErrorValue;
                }
            }
        }
        return sink;
    };
    Observable.prototype._trySubscribe = function (sink) {
        try {
            return this._subscribe(sink);
        }
        catch (err) {
            if (config$1.useDeprecatedSynchronousErrorHandling) {
                sink.syncErrorThrown = true;
                sink.syncErrorValue = err;
            }
            if (canReportError(sink)) {
                sink.error(err);
            }
            else {
                console.warn(err);
            }
        }
    };
    Observable.prototype.forEach = function (next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var subscription;
            subscription = _this.subscribe(function (value) {
                try {
                    next(value);
                }
                catch (err) {
                    reject(err);
                    if (subscription) {
                        subscription.unsubscribe();
                    }
                }
            }, reject, resolve);
        });
    };
    Observable.prototype._subscribe = function (subscriber) {
        var source = this.source;
        return source && source.subscribe(subscriber);
    };
    Observable.prototype[observable] = function () {
        return this;
    };
    Observable.prototype.pipe = function () {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            operations[_i] = arguments[_i];
        }
        if (operations.length === 0) {
            return this;
        }
        return pipeFromArray(operations)(this);
    };
    Observable.prototype.toPromise = function (promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var value;
            _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
        });
    };
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}());
function getPromiseCtor(promiseCtor) {
    if (!promiseCtor) {
        promiseCtor = Promise;
    }
    if (!promiseCtor) {
        throw new Error('no Promise impl found');
    }
    return promiseCtor;
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var ObjectUnsubscribedErrorImpl = /*@__PURE__*/ (function () {
    function ObjectUnsubscribedErrorImpl() {
        Error.call(this);
        this.message = 'object unsubscribed';
        this.name = 'ObjectUnsubscribedError';
        return this;
    }
    ObjectUnsubscribedErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
    return ObjectUnsubscribedErrorImpl;
})();
var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;

/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */
var SubjectSubscription = /*@__PURE__*/ (function (_super) {
    __extends(SubjectSubscription, _super);
    function SubjectSubscription(subject, subscriber) {
        var _this = _super.call(this) || this;
        _this.subject = subject;
        _this.subscriber = subscriber;
        _this.closed = false;
        return _this;
    }
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    return SubjectSubscription;
}(Subscription));

/** PURE_IMPORTS_START tslib,_Observable,_Subscriber,_Subscription,_util_ObjectUnsubscribedError,_SubjectSubscription,_internal_symbol_rxSubscriber PURE_IMPORTS_END */
var SubjectSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SubjectSubscriber, _super);
    function SubjectSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        return _this;
    }
    return SubjectSubscriber;
}(Subscriber));
var Subject = /*@__PURE__*/ (function (_super) {
    __extends(Subject, _super);
    function Subject() {
        var _this = _super.call(this) || this;
        _this.observers = [];
        _this.closed = false;
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
    }
    Subject.prototype[rxSubscriber] = function () {
        return new SubjectSubscriber(this);
    };
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype.next = function (value) {
        if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].next(value);
            }
        }
    };
    Subject.prototype.error = function (err) {
        if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].error(err);
        }
        this.observers.length = 0;
    };
    Subject.prototype.complete = function () {
        if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].complete();
        }
        this.observers.length = 0;
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
    };
    Subject.prototype._trySubscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        else {
            return _super.prototype._trySubscribe.call(this, subscriber);
        }
    };
    Subject.prototype._subscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        else if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription.EMPTY;
        }
        else if (this.isStopped) {
            subscriber.complete();
            return Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            return new SubjectSubscription(this, subscriber);
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new Observable();
        observable.source = this;
        return observable;
    };
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(Observable));
var AnonymousSubject = /*@__PURE__*/ (function (_super) {
    __extends(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
    }
    AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;
        if (destination && destination.next) {
            destination.next(value);
        }
    };
    AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;
        if (destination && destination.error) {
            this.destination.error(err);
        }
    };
    AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;
        if (destination && destination.complete) {
            this.destination.complete();
        }
    };
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;
        if (source) {
            return this.source.subscribe(subscriber);
        }
        else {
            return Subscription.EMPTY;
        }
    };
    return AnonymousSubject;
}(Subject));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function refCount() {
    return function refCountOperatorFunction(source) {
        return source.lift(new RefCountOperator(source));
    };
}
var RefCountOperator = /*@__PURE__*/ (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var RefCountSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subject,_Observable,_Subscriber,_Subscription,_operators_refCount PURE_IMPORTS_END */
var ConnectableObservable = /*@__PURE__*/ (function (_super) {
    __extends(ConnectableObservable, _super);
    function ConnectableObservable(source, subjectFactory) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subjectFactory = subjectFactory;
        _this._refCount = 0;
        _this._isComplete = false;
        return _this;
    }
    ConnectableObservable.prototype._subscribe = function (subscriber) {
        return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable.prototype.getSubject = function () {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
            this._subject = this.subjectFactory();
        }
        return this._subject;
    };
    ConnectableObservable.prototype.connect = function () {
        var connection = this._connection;
        if (!connection) {
            this._isComplete = false;
            connection = this._connection = new Subscription();
            connection.add(this.source
                .subscribe(new ConnectableSubscriber(this.getSubject(), this)));
            if (connection.closed) {
                this._connection = null;
                connection = Subscription.EMPTY;
            }
        }
        return connection;
    };
    ConnectableObservable.prototype.refCount = function () {
        return refCount()(this);
    };
    return ConnectableObservable;
}(Observable));
var connectableObservableDescriptor = /*@__PURE__*/ (function () {
    var connectableProto = ConnectableObservable.prototype;
    return {
        operator: { value: null },
        _refCount: { value: 0, writable: true },
        _subject: { value: null, writable: true },
        _connection: { value: null, writable: true },
        _subscribe: { value: connectableProto._subscribe },
        _isComplete: { value: connectableProto._isComplete, writable: true },
        getSubject: { value: connectableProto.getSubject },
        connect: { value: connectableProto.connect },
        refCount: { value: connectableProto.refCount }
    };
})();
var ConnectableSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ConnectableSubscriber, _super);
    function ConnectableSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    ConnectableSubscriber.prototype._error = function (err) {
        this._unsubscribe();
        _super.prototype._error.call(this, err);
    };
    ConnectableSubscriber.prototype._complete = function () {
        this.connectable._isComplete = true;
        this._unsubscribe();
        _super.prototype._complete.call(this);
    };
    ConnectableSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (connectable) {
            this.connectable = null;
            var connection = connectable._connection;
            connectable._refCount = 0;
            connectable._subject = null;
            connectable._connection = null;
            if (connection) {
                connection.unsubscribe();
            }
        }
    };
    return ConnectableSubscriber;
}(SubjectSubscriber));

/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
var EMPTY = /*@__PURE__*/ new Observable(function (subscriber) { return subscriber.complete(); });

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isScheduler(value) {
    return value && typeof value.schedule === 'function';
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var subscribeToArray = function (array) {
    return function (subscriber) {
        for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {
            subscriber.next(array[i]);
        }
        subscriber.complete();
    };
};

/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */
function scheduleArray(input, scheduler) {
    return new Observable(function (subscriber) {
        var sub = new Subscription();
        var i = 0;
        sub.add(scheduler.schedule(function () {
            if (i === input.length) {
                subscriber.complete();
                return;
            }
            subscriber.next(input[i++]);
            if (!subscriber.closed) {
                sub.add(this.schedule());
            }
        }));
        return sub;
    });
}

/** PURE_IMPORTS_START _Observable,_util_subscribeToArray,_scheduled_scheduleArray PURE_IMPORTS_END */
function fromArray(input, scheduler) {
    if (!scheduler) {
        return new Observable(subscribeToArray(input));
    }
    else {
        return scheduleArray(input, scheduler);
    }
}

/** PURE_IMPORTS_START _util_isScheduler,_fromArray,_scheduled_scheduleArray PURE_IMPORTS_END */
function of() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var scheduler = args[args.length - 1];
    if (isScheduler(scheduler)) {
        args.pop();
        return scheduleArray(args, scheduler);
    }
    else {
        return fromArray(args);
    }
}

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function map(project, thisArg) {
    return function mapOperation(source) {
        if (typeof project !== 'function') {
            throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
        }
        return source.lift(new MapOperator(project, thisArg));
    };
}
var MapOperator = /*@__PURE__*/ (function () {
    function MapOperator(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
    }
    MapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator;
}());
var MapSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(MapSubscriber, _super);
    function MapSubscriber(destination, project, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.count = 0;
        _this.thisArg = thisArg || _this;
        return _this;
    }
    MapSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.project.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return MapSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _hostReportError PURE_IMPORTS_END */
var subscribeToPromise = function (promise) {
    return function (subscriber) {
        promise.then(function (value) {
            if (!subscriber.closed) {
                subscriber.next(value);
                subscriber.complete();
            }
        }, function (err) { return subscriber.error(err); })
            .then(null, hostReportError);
        return subscriber;
    };
};

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function getSymbolIterator() {
    if (typeof Symbol !== 'function' || !Symbol.iterator) {
        return '@@iterator';
    }
    return Symbol.iterator;
}
var iterator$1 = /*@__PURE__*/ getSymbolIterator();

/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */
var subscribeToIterable = function (iterable) {
    return function (subscriber) {
        var iterator = iterable[iterator$1]();
        do {
            var item = void 0;
            try {
                item = iterator.next();
            }
            catch (err) {
                subscriber.error(err);
                return subscriber;
            }
            if (item.done) {
                subscriber.complete();
                break;
            }
            subscriber.next(item.value);
            if (subscriber.closed) {
                break;
            }
        } while (true);
        if (typeof iterator.return === 'function') {
            subscriber.add(function () {
                if (iterator.return) {
                    iterator.return();
                }
            });
        }
        return subscriber;
    };
};

/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */
var subscribeToObservable = function (obj) {
    return function (subscriber) {
        var obs = obj[observable]();
        if (typeof obs.subscribe !== 'function') {
            throw new TypeError('Provided object does not correctly implement Symbol.observable');
        }
        else {
            return obs.subscribe(subscriber);
        }
    };
};

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isPromise$1(value) {
    return !!value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
}

/** PURE_IMPORTS_START _subscribeToArray,_subscribeToPromise,_subscribeToIterable,_subscribeToObservable,_isArrayLike,_isPromise,_isObject,_symbol_iterator,_symbol_observable PURE_IMPORTS_END */
var subscribeTo = function (result) {
    if (!!result && typeof result[observable] === 'function') {
        return subscribeToObservable(result);
    }
    else if (isArrayLike(result)) {
        return subscribeToArray(result);
    }
    else if (isPromise$1(result)) {
        return subscribeToPromise(result);
    }
    else if (!!result && typeof result[iterator$1] === 'function') {
        return subscribeToIterable(result);
    }
    else {
        var value = isObject$2(result) ? 'an invalid object' : "'" + result + "'";
        var msg = "You provided " + value + " where a stream was expected."
            + ' You can provide an Observable, Promise, Array, or Iterable.';
        throw new TypeError(msg);
    }
};

/** PURE_IMPORTS_START _Observable,_util_subscribeTo,_scheduled_scheduled PURE_IMPORTS_END */
function from(input, scheduler) {
    {
        if (input instanceof Observable) {
            return input;
        }
        return new Observable(subscribeTo(input));
    }
}

/** PURE_IMPORTS_START tslib,_Subscriber,_Observable,_util_subscribeTo PURE_IMPORTS_END */
var SimpleInnerSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SimpleInnerSubscriber, _super);
    function SimpleInnerSubscriber(parent) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        return _this;
    }
    SimpleInnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(value);
    };
    SimpleInnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error);
        this.unsubscribe();
    };
    SimpleInnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete();
        this.unsubscribe();
    };
    return SimpleInnerSubscriber;
}(Subscriber));
var SimpleOuterSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SimpleOuterSubscriber, _super);
    function SimpleOuterSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SimpleOuterSubscriber.prototype.notifyNext = function (innerValue) {
        this.destination.next(innerValue);
    };
    SimpleOuterSubscriber.prototype.notifyError = function (err) {
        this.destination.error(err);
    };
    SimpleOuterSubscriber.prototype.notifyComplete = function () {
        this.destination.complete();
    };
    return SimpleOuterSubscriber;
}(Subscriber));
function innerSubscribe(result, innerSubscriber) {
    if (innerSubscriber.closed) {
        return undefined;
    }
    if (result instanceof Observable) {
        return result.subscribe(innerSubscriber);
    }
    var subscription;
    try {
        subscription = subscribeTo(result)(innerSubscriber);
    }
    catch (error) {
        innerSubscriber.error(error);
    }
    return subscription;
}

/** PURE_IMPORTS_START tslib,_map,_observable_from,_innerSubscribe PURE_IMPORTS_END */
function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    if (typeof resultSelector === 'function') {
        return function (source) { return source.pipe(mergeMap(function (a, i) { return from(project(a, i)).pipe(map(function (b, ii) { return resultSelector(a, b, i, ii); })); }, concurrent)); };
    }
    else if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
    }
    return function (source) { return source.lift(new MergeMapOperator(project, concurrent)); };
}
var MergeMapOperator = /*@__PURE__*/ (function () {
    function MergeMapOperator(project, concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        this.project = project;
        this.concurrent = concurrent;
    }
    MergeMapOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
    };
    return MergeMapOperator;
}());
var MergeMapSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(MergeMapSubscriber, _super);
    function MergeMapSubscriber(destination, project, concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.concurrent = concurrent;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
    }
    MergeMapSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            this._tryNext(value);
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeMapSubscriber.prototype._tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.active++;
        this._innerSub(result);
    };
    MergeMapSubscriber.prototype._innerSub = function (ish) {
        var innerSubscriber = new SimpleInnerSubscriber(this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        var innerSubscription = innerSubscribe(ish, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
            destination.add(innerSubscription);
        }
    };
    MergeMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
        this.unsubscribe();
    };
    MergeMapSubscriber.prototype.notifyNext = function (innerValue) {
        this.destination.next(innerValue);
    };
    MergeMapSubscriber.prototype.notifyComplete = function () {
        var buffer = this.buffer;
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeMapSubscriber;
}(SimpleOuterSubscriber));

/** PURE_IMPORTS_START _mergeMap,_util_identity PURE_IMPORTS_END */
function mergeAll(concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    return mergeMap(identity, concurrent);
}

/** PURE_IMPORTS_START _mergeAll PURE_IMPORTS_END */
function concatAll() {
    return mergeAll(1);
}

/** PURE_IMPORTS_START _of,_operators_concatAll PURE_IMPORTS_END */
function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return concatAll()(of.apply(void 0, observables));
}

/** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */
function fromEvent(target, eventName, options, resultSelector) {
    if (isFunction$1(options)) {
        resultSelector = options;
        options = undefined;
    }
    if (resultSelector) {
        return fromEvent(target, eventName, options).pipe(map(function (args) { return isArray$1(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
    }
    return new Observable(function (subscriber) {
        function handler(e) {
            if (arguments.length > 1) {
                subscriber.next(Array.prototype.slice.call(arguments));
            }
            else {
                subscriber.next(e);
            }
        }
        setupSubscription(target, eventName, handler, subscriber, options);
    });
}
function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
    var unsubscribe;
    if (isEventTarget(sourceObj)) {
        var source_1 = sourceObj;
        sourceObj.addEventListener(eventName, handler, options);
        unsubscribe = function () { return source_1.removeEventListener(eventName, handler, options); };
    }
    else if (isJQueryStyleEventEmitter(sourceObj)) {
        var source_2 = sourceObj;
        sourceObj.on(eventName, handler);
        unsubscribe = function () { return source_2.off(eventName, handler); };
    }
    else if (isNodeStyleEventEmitter(sourceObj)) {
        var source_3 = sourceObj;
        sourceObj.addListener(eventName, handler);
        unsubscribe = function () { return source_3.removeListener(eventName, handler); };
    }
    else if (sourceObj && sourceObj.length) {
        for (var i = 0, len = sourceObj.length; i < len; i++) {
            setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
        }
    }
    else {
        throw new TypeError('Invalid event target');
    }
    subscriber.add(unsubscribe);
}
function isNodeStyleEventEmitter(sourceObj) {
    return sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
}
function isJQueryStyleEventEmitter(sourceObj) {
    return sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
}
function isEventTarget(sourceObj) {
    return sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
}

/** PURE_IMPORTS_START _Observable,_util_isScheduler,_operators_mergeAll,_fromArray PURE_IMPORTS_END */
function merge$1() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var concurrent = Number.POSITIVE_INFINITY;
    var scheduler = null;
    var last = observables[observables.length - 1];
    if (isScheduler(last)) {
        scheduler = observables.pop();
        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
            concurrent = observables.pop();
        }
    }
    else if (typeof last === 'number') {
        concurrent = observables.pop();
    }
    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable) {
        return observables[0];
    }
    return mergeAll(concurrent)(fromArray(observables, scheduler));
}

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function filter(predicate, thisArg) {
    return function filterOperatorFunction(source) {
        return source.lift(new FilterOperator(predicate, thisArg));
    };
}
var FilterOperator = /*@__PURE__*/ (function () {
    function FilterOperator(predicate, thisArg) {
        this.predicate = predicate;
        this.thisArg = thisArg;
    }
    FilterOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
    };
    return FilterOperator;
}());
var FilterSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(FilterSubscriber, _super);
    function FilterSubscriber(destination, predicate, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.thisArg = thisArg;
        _this.count = 0;
        return _this;
    }
    FilterSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.predicate.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.destination.next(value);
        }
    };
    return FilterSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */
function catchError(selector) {
    return function catchErrorOperatorFunction(source) {
        var operator = new CatchOperator(selector);
        var caught = source.lift(operator);
        return (operator.caught = caught);
    };
}
var CatchOperator = /*@__PURE__*/ (function () {
    function CatchOperator(selector) {
        this.selector = selector;
    }
    CatchOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
    };
    return CatchOperator;
}());
var CatchSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(CatchSubscriber, _super);
    function CatchSubscriber(destination, selector, caught) {
        var _this = _super.call(this, destination) || this;
        _this.selector = selector;
        _this.caught = caught;
        return _this;
    }
    CatchSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var result = void 0;
            try {
                result = this.selector(err, this.caught);
            }
            catch (err2) {
                _super.prototype.error.call(this, err2);
                return;
            }
            this._unsubscribeAndRecycle();
            var innerSubscriber = new SimpleInnerSubscriber(this);
            this.add(innerSubscriber);
            var innerSubscription = innerSubscribe(result, innerSubscriber);
            if (innerSubscription !== innerSubscriber) {
                this.add(innerSubscription);
            }
        }
    };
    return CatchSubscriber;
}(SimpleOuterSubscriber));

/** PURE_IMPORTS_START _observable_ConnectableObservable PURE_IMPORTS_END */
function multicast(subjectOrSubjectFactory, selector) {
    return function multicastOperatorFunction(source) {
        var subjectFactory;
        if (typeof subjectOrSubjectFactory === 'function') {
            subjectFactory = subjectOrSubjectFactory;
        }
        else {
            subjectFactory = function subjectFactory() {
                return subjectOrSubjectFactory;
            };
        }
        var connectable = Object.create(source, connectableObservableDescriptor);
        connectable.source = source;
        connectable.subjectFactory = subjectFactory;
        return connectable;
    };
}

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function pairwise() {
    return function (source) { return source.lift(new PairwiseOperator()); };
}
var PairwiseOperator = /*@__PURE__*/ (function () {
    function PairwiseOperator() {
    }
    PairwiseOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new PairwiseSubscriber(subscriber));
    };
    return PairwiseOperator;
}());
var PairwiseSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(PairwiseSubscriber, _super);
    function PairwiseSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasPrev = false;
        return _this;
    }
    PairwiseSubscriber.prototype._next = function (value) {
        var pair;
        if (this.hasPrev) {
            pair = [this.prev, value];
        }
        else {
            this.hasPrev = true;
        }
        this.prev = value;
        if (pair) {
            this.destination.next(pair);
        }
    };
    return PairwiseSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _map PURE_IMPORTS_END */
function pluck() {
    var properties = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        properties[_i] = arguments[_i];
    }
    var length = properties.length;
    if (length === 0) {
        throw new Error('list of properties cannot be empty.');
    }
    return function (source) { return map(plucker(properties, length))(source); };
}
function plucker(props, length) {
    var mapper = function (x) {
        var currentProp = x;
        for (var i = 0; i < length; i++) {
            var p = currentProp != null ? currentProp[props[i]] : undefined;
            if (p !== void 0) {
                currentProp = p;
            }
            else {
                return undefined;
            }
        }
        return currentProp;
    };
    return mapper;
}

/** PURE_IMPORTS_START _multicast,_refCount,_Subject PURE_IMPORTS_END */
function shareSubjectFactory() {
    return new Subject();
}
function share() {
    return function (source) { return refCount()(multicast(shareSubjectFactory)(source)); };
}

/** PURE_IMPORTS_START _observable_concat,_util_isScheduler PURE_IMPORTS_END */
function startWith() {
    var array = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        array[_i] = arguments[_i];
    }
    var scheduler = array[array.length - 1];
    if (isScheduler(scheduler)) {
        array.pop();
        return function (source) { return concat(array, source, scheduler); };
    }
    else {
        return function (source) { return concat(array, source); };
    }
}

/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */
function takeUntil(notifier) {
    return function (source) { return source.lift(new TakeUntilOperator(notifier)); };
}
var TakeUntilOperator = /*@__PURE__*/ (function () {
    function TakeUntilOperator(notifier) {
        this.notifier = notifier;
    }
    TakeUntilOperator.prototype.call = function (subscriber, source) {
        var takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
        var notifierSubscription = innerSubscribe(this.notifier, new SimpleInnerSubscriber(takeUntilSubscriber));
        if (notifierSubscription && !takeUntilSubscriber.seenValue) {
            takeUntilSubscriber.add(notifierSubscription);
            return source.subscribe(takeUntilSubscriber);
        }
        return takeUntilSubscriber;
    };
    return TakeUntilOperator;
}());
var TakeUntilSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(TakeUntilSubscriber, _super);
    function TakeUntilSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.seenValue = false;
        return _this;
    }
    TakeUntilSubscriber.prototype.notifyNext = function () {
        this.seenValue = true;
        this.complete();
    };
    TakeUntilSubscriber.prototype.notifyComplete = function () {
    };
    return TakeUntilSubscriber;
}(SimpleOuterSubscriber));

var e=[0,1,2,3,4,4,5,5,6,6,6,6,7,7,7,7,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,9,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,0,0,16,17,18,18,19,19,20,20,20,20,21,21,21,21,22,22,22,22,22,22,22,22,23,23,23,23,23,23,23,23,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29];function t(){var e=this;function t(e,t){var n=0;do{n|=1&e,e>>>=1,n<<=1;}while(--t>0);return n>>>1}e.build_tree=function(n){var i,r,a,o=e.dyn_tree,s=e.stat_desc.static_tree,l=e.stat_desc.elems,f=-1;for(n.heap_len=0,n.heap_max=573,i=0;i<l;i++)0!==o[2*i]?(n.heap[++n.heap_len]=f=i,n.depth[i]=0):o[2*i+1]=0;for(;n.heap_len<2;)o[2*(a=n.heap[++n.heap_len]=f<2?++f:0)]=1,n.depth[a]=0,n.opt_len--,s&&(n.static_len-=s[2*a+1]);for(e.max_code=f,i=Math.floor(n.heap_len/2);i>=1;i--)n.pqdownheap(o,i);a=l;do{i=n.heap[1],n.heap[1]=n.heap[n.heap_len--],n.pqdownheap(o,1),r=n.heap[1],n.heap[--n.heap_max]=i,n.heap[--n.heap_max]=r,o[2*a]=o[2*i]+o[2*r],n.depth[a]=Math.max(n.depth[i],n.depth[r])+1,o[2*i+1]=o[2*r+1]=a,n.heap[1]=a++,n.pqdownheap(o,1);}while(n.heap_len>=2);n.heap[--n.heap_max]=n.heap[1],function(t){var n,i,r,a,o,s,l=e.dyn_tree,f=e.stat_desc.static_tree,u=e.stat_desc.extra_bits,d=e.stat_desc.extra_base,c=e.stat_desc.max_length,_=0;for(a=0;a<=15;a++)t.bl_count[a]=0;for(l[2*t.heap[t.heap_max]+1]=0,n=t.heap_max+1;n<573;n++)(a=l[2*l[2*(i=t.heap[n])+1]+1]+1)>c&&(a=c,_++),l[2*i+1]=a,i>e.max_code||(t.bl_count[a]++,o=0,i>=d&&(o=u[i-d]),t.opt_len+=(s=l[2*i])*(a+o),f&&(t.static_len+=s*(f[2*i+1]+o)));if(0!==_){do{for(a=c-1;0===t.bl_count[a];)a--;t.bl_count[a]--,t.bl_count[a+1]+=2,t.bl_count[c]--,_-=2;}while(_>0);for(a=c;0!==a;a--)for(i=t.bl_count[a];0!==i;)(r=t.heap[--n])>e.max_code||(l[2*r+1]!=a&&(t.opt_len+=(a-l[2*r+1])*l[2*r],l[2*r+1]=a),i--);}}(n),function(e,n,i){var r,a,o,s=[],l=0;for(r=1;r<=15;r++)s[r]=l=l+i[r-1]<<1;for(a=0;a<=n;a++)0!==(o=e[2*a+1])&&(e[2*a]=t(s[o]++,o));}(o,e.max_code,n.bl_count);};}function n(e,t,n,i,r){var a=this;a.static_tree=e,a.extra_bits=t,a.extra_base=n,a.elems=i,a.max_length=r;}function i(e,t,n,i,r){var a=this;a.good_length=e,a.max_lazy=t,a.nice_length=n,a.max_chain=i,a.func=r;}t._length_code=[0,1,2,3,4,5,6,7,8,8,9,9,10,10,11,11,12,12,12,12,13,13,13,13,14,14,14,14,15,15,15,15,16,16,16,16,16,16,16,16,17,17,17,17,17,17,17,17,18,18,18,18,18,18,18,18,19,19,19,19,19,19,19,19,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,28],t.base_length=[0,1,2,3,4,5,6,7,8,10,12,14,16,20,24,28,32,40,48,56,64,80,96,112,128,160,192,224,0],t.base_dist=[0,1,2,3,4,6,8,12,16,24,32,48,64,96,128,192,256,384,512,768,1024,1536,2048,3072,4096,6144,8192,12288,16384,24576],t.d_code=function(t){return t<256?e[t]:e[256+(t>>>7)]},t.extra_lbits=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],t.extra_dbits=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],t.extra_blbits=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],t.bl_order=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],n.static_ltree=[12,8,140,8,76,8,204,8,44,8,172,8,108,8,236,8,28,8,156,8,92,8,220,8,60,8,188,8,124,8,252,8,2,8,130,8,66,8,194,8,34,8,162,8,98,8,226,8,18,8,146,8,82,8,210,8,50,8,178,8,114,8,242,8,10,8,138,8,74,8,202,8,42,8,170,8,106,8,234,8,26,8,154,8,90,8,218,8,58,8,186,8,122,8,250,8,6,8,134,8,70,8,198,8,38,8,166,8,102,8,230,8,22,8,150,8,86,8,214,8,54,8,182,8,118,8,246,8,14,8,142,8,78,8,206,8,46,8,174,8,110,8,238,8,30,8,158,8,94,8,222,8,62,8,190,8,126,8,254,8,1,8,129,8,65,8,193,8,33,8,161,8,97,8,225,8,17,8,145,8,81,8,209,8,49,8,177,8,113,8,241,8,9,8,137,8,73,8,201,8,41,8,169,8,105,8,233,8,25,8,153,8,89,8,217,8,57,8,185,8,121,8,249,8,5,8,133,8,69,8,197,8,37,8,165,8,101,8,229,8,21,8,149,8,85,8,213,8,53,8,181,8,117,8,245,8,13,8,141,8,77,8,205,8,45,8,173,8,109,8,237,8,29,8,157,8,93,8,221,8,61,8,189,8,125,8,253,8,19,9,275,9,147,9,403,9,83,9,339,9,211,9,467,9,51,9,307,9,179,9,435,9,115,9,371,9,243,9,499,9,11,9,267,9,139,9,395,9,75,9,331,9,203,9,459,9,43,9,299,9,171,9,427,9,107,9,363,9,235,9,491,9,27,9,283,9,155,9,411,9,91,9,347,9,219,9,475,9,59,9,315,9,187,9,443,9,123,9,379,9,251,9,507,9,7,9,263,9,135,9,391,9,71,9,327,9,199,9,455,9,39,9,295,9,167,9,423,9,103,9,359,9,231,9,487,9,23,9,279,9,151,9,407,9,87,9,343,9,215,9,471,9,55,9,311,9,183,9,439,9,119,9,375,9,247,9,503,9,15,9,271,9,143,9,399,9,79,9,335,9,207,9,463,9,47,9,303,9,175,9,431,9,111,9,367,9,239,9,495,9,31,9,287,9,159,9,415,9,95,9,351,9,223,9,479,9,63,9,319,9,191,9,447,9,127,9,383,9,255,9,511,9,0,7,64,7,32,7,96,7,16,7,80,7,48,7,112,7,8,7,72,7,40,7,104,7,24,7,88,7,56,7,120,7,4,7,68,7,36,7,100,7,20,7,84,7,52,7,116,7,3,8,131,8,67,8,195,8,35,8,163,8,99,8,227,8],n.static_dtree=[0,5,16,5,8,5,24,5,4,5,20,5,12,5,28,5,2,5,18,5,10,5,26,5,6,5,22,5,14,5,30,5,1,5,17,5,9,5,25,5,5,5,21,5,13,5,29,5,3,5,19,5,11,5,27,5,7,5,23,5],n.static_l_desc=new n(n.static_ltree,t.extra_lbits,257,286,15),n.static_d_desc=new n(n.static_dtree,t.extra_dbits,0,30,15),n.static_bl_desc=new n(null,t.extra_blbits,0,19,7);var r=[new i(0,0,0,0,0),new i(4,4,8,4,1),new i(4,5,16,8,1),new i(4,6,32,32,1),new i(4,4,16,16,2),new i(8,16,32,32,2),new i(8,16,128,128,2),new i(8,32,128,256,2),new i(32,128,258,1024,2),new i(32,258,258,4096,2)],a=["need dictionary","stream end","","","stream error","data error","","buffer error","",""];function o(e,t,n,i){var r=e[2*t],a=e[2*n];return r<a||r==a&&i[t]<=i[n]}function s(){var e,i,s,l,f,u,d,c,_,h,p,w,v,b,x,m,g,y,k,U,z,E,D,A,S,R,F,T,W,M,B,I,C,L,P,Z,N,j,O,V,q,$=this,G=new t,H=new t,Y=new t;function J(){var e;for(e=0;e<286;e++)B[2*e]=0;for(e=0;e<30;e++)I[2*e]=0;for(e=0;e<19;e++)C[2*e]=0;B[512]=1,$.opt_len=$.static_len=0,Z=j=0;}function K(e,t){var n,i,r=-1,a=e[1],o=0,s=7,l=4;for(0===a&&(s=138,l=3),e[2*(t+1)+1]=65535,n=0;n<=t;n++)i=a,a=e[2*(n+1)+1],++o<s&&i==a||(o<l?C[2*i]+=o:0!==i?(i!=r&&C[2*i]++,C[32]++):o<=10?C[34]++:C[36]++,o=0,r=i,0===a?(s=138,l=3):i==a?(s=6,l=3):(s=7,l=4));}function Q(e){$.pending_buf[$.pending++]=e;}function X(e){Q(255&e),Q(e>>>8&255);}function ee(e,t){var n,i=t;q>16-i?(X(V|=(n=e)<<q&65535),V=n>>>16-q,q+=i-16):(V|=e<<q&65535,q+=i);}function te(e,t){var n=2*e;ee(65535&t[n],65535&t[n+1]);}function ne(e,t){var n,i,r=-1,a=e[1],o=0,s=7,l=4;for(0===a&&(s=138,l=3),n=0;n<=t;n++)if(i=a,a=e[2*(n+1)+1],!(++o<s&&i==a)){if(o<l)do{te(i,C);}while(0!=--o);else 0!==i?(i!=r&&(te(i,C),o--),te(16,C),ee(o-3,2)):o<=10?(te(17,C),ee(o-3,3)):(te(18,C),ee(o-11,7));o=0,r=i,0===a?(s=138,l=3):i==a?(s=6,l=3):(s=7,l=4);}}function ie(){16==q?(X(V),V=0,q=0):q>=8&&(Q(255&V),V>>>=8,q-=8);}function re(e,n){var i,r,a;if($.pending_buf[N+2*Z]=e>>>8&255,$.pending_buf[N+2*Z+1]=255&e,$.pending_buf[L+Z]=255&n,Z++,0===e?B[2*n]++:(j++,e--,B[2*(t._length_code[n]+256+1)]++,I[2*t.d_code(e)]++),0==(8191&Z)&&F>2){for(i=8*Z,r=z-g,a=0;a<30;a++)i+=I[2*a]*(5+t.extra_dbits[a]);if(i>>>=3,j<Math.floor(Z/2)&&i<Math.floor(r/2))return !0}return Z==P-1}function ae(e,n){var i,r,a,o,s=0;if(0!==Z)do{i=$.pending_buf[N+2*s]<<8&65280|255&$.pending_buf[N+2*s+1],r=255&$.pending_buf[L+s],s++,0===i?te(r,e):(te((a=t._length_code[r])+256+1,e),0!==(o=t.extra_lbits[a])&&ee(r-=t.base_length[a],o),i--,te(a=t.d_code(i),n),0!==(o=t.extra_dbits[a])&&ee(i-=t.base_dist[a],o));}while(s<Z);te(256,e),O=e[513];}function oe(){q>8?X(V):q>0&&Q(255&V),V=0,q=0;}function se(e,t,n){ee(0+(n?1:0),3),function(e,t,n){oe(),O=8,X(t),X(~t),$.pending_buf.set(c.subarray(e,e+t),$.pending),$.pending+=t;}(e,t);}function le(i){((function(e,i,r){var a,o,s=0;F>0?(G.build_tree($),H.build_tree($),s=function(){var e;for(K(B,G.max_code),K(I,H.max_code),Y.build_tree($),e=18;e>=3&&0===C[2*t.bl_order[e]+1];e--);return $.opt_len+=3*(e+1)+5+5+4,e}(),(o=$.static_len+3+7>>>3)<=(a=$.opt_len+3+7>>>3)&&(a=o)):a=o=i+5,i+4<=a&&-1!=e?se(e,i,r):o==a?(ee(2+(r?1:0),3),ae(n.static_ltree,n.static_dtree)):(ee(4+(r?1:0),3),function(e,n,i){var r;for(ee(e-257,5),ee(n-1,5),ee(i-4,4),r=0;r<i;r++)ee(C[2*t.bl_order[r]+1],3);ne(B,e-1),ne(I,n-1);}(G.max_code+1,H.max_code+1,s+1),ae(B,I)),J(),r&&oe();}))(g>=0?g:-1,z-g,i),g=z,e.flush_pending();}function fe(){var t,n,i,r;do{if(0==(r=_-D-z)&&0===z&&0===D)r=f;else if(-1==r)r--;else if(z>=f+f-262){c.set(c.subarray(f,f+f),0),E-=f,z-=f,g-=f,i=t=v;do{n=65535&p[--i],p[i]=n>=f?n-f:0;}while(0!=--t);i=t=f;do{n=65535&h[--i],h[i]=n>=f?n-f:0;}while(0!=--t);r+=f;}if(0===e.avail_in)return;t=e.read_buf(c,z+D,r),(D+=t)>=3&&(w=((w=255&c[z])<<m^255&c[z+1])&x);}while(D<262&&0!==e.avail_in)}function ue(e){var t,n,i=S,r=z,a=A,o=z>f-262?z-(f-262):0,s=M,l=d,u=z+258,_=c[r+a-1],p=c[r+a];A>=W&&(i>>=2),s>D&&(s=D);do{if(c[(t=e)+a]==p&&c[t+a-1]==_&&c[t]==c[r]&&c[++t]==c[r+1]){r+=2,t++;do{}while(c[++r]==c[++t]&&c[++r]==c[++t]&&c[++r]==c[++t]&&c[++r]==c[++t]&&c[++r]==c[++t]&&c[++r]==c[++t]&&c[++r]==c[++t]&&c[++r]==c[++t]&&r<u);if(n=258-(u-r),r=u-258,n>a){if(E=e,a=n,n>=s)break;_=c[r+a-1],p=c[r+a];}}}while((e=65535&h[e&l])>o&&0!=--i);return a<=D?a:D}$.depth=[],$.bl_count=[],$.heap=[],B=[],I=[],C=[],$.pqdownheap=function(e,t){for(var n=$.heap,i=n[t],r=t<<1;r<=$.heap_len&&(r<$.heap_len&&o(e,n[r+1],n[r],$.depth)&&r++,!o(e,i,n[r],$.depth));)n[t]=n[r],t=r,r<<=1;n[t]=i;},$.deflateInit=function(e,t,a,o,k,E){return o||(o=8),k||(k=8),E||(E=0),e.msg=null,-1==t&&(t=6),k<1||k>9||8!=o||a<9||a>15||t<0||t>9||E<0||E>2?-2:(e.dstate=$,d=(f=1<<(u=a))-1,x=(v=1<<(b=k+7))-1,m=Math.floor((b+3-1)/3),c=new Uint8Array(2*f),h=[],p=[],P=1<<k+6,$.pending_buf=new Uint8Array(4*P),s=4*P,N=Math.floor(P/2),L=3*P,F=t,T=E,function(e){return e.total_in=e.total_out=0,e.msg=null,$.pending=0,$.pending_out=0,i=113,l=0,G.dyn_tree=B,G.stat_desc=n.static_l_desc,H.dyn_tree=I,H.stat_desc=n.static_d_desc,Y.dyn_tree=C,Y.stat_desc=n.static_bl_desc,V=0,q=0,O=8,J(),function(){var e;for(_=2*f,p[v-1]=0,e=0;e<v-1;e++)p[e]=0;R=r[F].max_lazy,W=r[F].good_length,M=r[F].nice_length,S=r[F].max_chain,z=0,g=0,D=0,y=A=2,U=0,w=0;}(),0}(e))},$.deflateEnd=function(){return 42!=i&&113!=i&&666!=i?-2:($.pending_buf=null,p=null,h=null,c=null,$.dstate=null,113==i?-3:0)},$.deflateParams=function(e,t,n){var i=0;return -1==t&&(t=6),t<0||t>9||n<0||n>2?-2:(r[F].func!=r[t].func&&0!==e.total_in&&(i=e.deflate(1)),F!=t&&(R=r[F=t].max_lazy,W=r[F].good_length,M=r[F].nice_length,S=r[F].max_chain),T=n,i)},$.deflateSetDictionary=function(e,t,n){var r,a=n,o=0;if(!t||42!=i)return -2;if(a<3)return 0;for(a>f-262&&(o=n-(a=f-262)),c.set(t.subarray(o,o+a),0),z=a,g=a,w=((w=255&c[0])<<m^255&c[1])&x,r=0;r<=a-3;r++)h[r&d]=p[w=(w<<m^255&c[r+2])&x],p[w]=r;return 0},$.deflate=function(t,o){var _,b,S,W,M,B;if(o>4||o<0)return -2;if(!t.next_out||!t.next_in&&0!==t.avail_in||666==i&&4!=o)return t.msg=a[4],-2;if(0===t.avail_out)return t.msg=a[7],-5;if(e=t,W=l,l=o,42==i&&(b=8+(u-8<<4)<<8,(S=(F-1&255)>>1)>3&&(S=3),b|=S<<6,0!==z&&(b|=32),i=113,Q((B=b+=31-b%31)>>8&255),Q(255&B)),0!==$.pending){if(e.flush_pending(),0===e.avail_out)return l=-1,0}else if(0===e.avail_in&&o<=W&&4!=o)return e.msg=a[7],-5;if(666==i&&0!==e.avail_in)return t.msg=a[7],-5;if(0!==e.avail_in||0!==D||0!=o&&666!=i){switch(M=-1,r[F].func){case 0:M=function(t){var n,i=65535;for(i>s-5&&(i=s-5);;){if(D<=1){if(fe(),0===D&&0==t)return 0;if(0===D)break}if(z+=D,D=0,n=g+i,(0===z||z>=n)&&(D=z-n,z=n,le(!1),0===e.avail_out))return 0;if(z-g>=f-262&&(le(!1),0===e.avail_out))return 0}return le(4==t),0===e.avail_out?4==t?2:0:4==t?3:1}(o);break;case 1:M=function(t){for(var n,i=0;;){if(D<262){if(fe(),D<262&&0==t)return 0;if(0===D)break}if(D>=3&&(i=65535&p[w=(w<<m^255&c[z+2])&x],h[z&d]=p[w],p[w]=z),0!==i&&(z-i&65535)<=f-262&&2!=T&&(y=ue(i)),y>=3)if(n=re(z-E,y-3),D-=y,y<=R&&D>=3){y--;do{z++,i=65535&p[w=(w<<m^255&c[z+2])&x],h[z&d]=p[w],p[w]=z;}while(0!=--y);z++;}else z+=y,y=0,w=((w=255&c[z])<<m^255&c[z+1])&x;else n=re(0,255&c[z]),D--,z++;if(n&&(le(!1),0===e.avail_out))return 0}return le(4==t),0===e.avail_out?4==t?2:0:4==t?3:1}(o);break;case 2:M=function(t){for(var n,i,r=0;;){if(D<262){if(fe(),D<262&&0==t)return 0;if(0===D)break}if(D>=3&&(r=65535&p[w=(w<<m^255&c[z+2])&x],h[z&d]=p[w],p[w]=z),A=y,k=E,y=2,0!==r&&A<R&&(z-r&65535)<=f-262&&(2!=T&&(y=ue(r)),y<=5&&(1==T||3==y&&z-E>4096)&&(y=2)),A>=3&&y<=A){i=z+D-3,n=re(z-1-k,A-3),D-=A-1,A-=2;do{++z<=i&&(r=65535&p[w=(w<<m^255&c[z+2])&x],h[z&d]=p[w],p[w]=z);}while(0!=--A);if(U=0,y=2,z++,n&&(le(!1),0===e.avail_out))return 0}else if(0!==U){if((n=re(0,255&c[z-1]))&&le(!1),z++,D--,0===e.avail_out)return 0}else U=1,z++,D--;}return 0!==U&&(n=re(0,255&c[z-1]),U=0),le(4==t),0===e.avail_out?4==t?2:0:4==t?3:1}(o);}if(2!=M&&3!=M||(i=666),0==M||2==M)return 0===e.avail_out&&(l=-1),0;if(1==M){if(1==o)ee(2,3),te(256,n.static_ltree),ie(),1+O+10-q<9&&(ee(2,3),te(256,n.static_ltree),ie()),O=7;else if(se(0,0,!1),3==o)for(_=0;_<v;_++)p[_]=0;if(e.flush_pending(),0===e.avail_out)return l=-1,0}}return 4!=o?0:1};}function l(){var e=this;e.next_in_index=0,e.next_out_index=0,e.avail_in=0,e.total_in=0,e.avail_out=0,e.total_out=0;}function f(e){var t=new l,n=512,i=new Uint8Array(n),r=e?e.level:-1;void 0===r&&(r=-1),t.deflateInit(r),t.next_out=i,this.append=function(e,r){var a,o=[],s=0,l=0,f=0;if(e.length){t.next_in_index=0,t.next_in=e,t.avail_in=e.length;do{if(t.next_out_index=0,t.avail_out=n,0!=t.deflate(0))throw new Error("deflating: "+t.msg);t.next_out_index&&o.push(t.next_out_index==n?new Uint8Array(i):new Uint8Array(i.subarray(0,t.next_out_index))),f+=t.next_out_index,r&&t.next_in_index>0&&t.next_in_index!=s&&(r(t.next_in_index),s=t.next_in_index);}while(t.avail_in>0||0===t.avail_out);return a=new Uint8Array(f),o.forEach(function(e){a.set(e,l),l+=e.length;}),a}},this.flush=function(){var e,r,a=[],o=0,s=0;do{if(t.next_out_index=0,t.avail_out=n,1!=(e=t.deflate(4))&&0!=e)throw new Error("deflating: "+t.msg);n-t.avail_out>0&&a.push(new Uint8Array(i.subarray(0,t.next_out_index))),s+=t.next_out_index;}while(t.avail_in>0||0===t.avail_out);return t.deflateEnd(),r=new Uint8Array(s),a.forEach(function(e){r.set(e,o),o+=e.length;}),r};}l.prototype={deflateInit:function(e,t){var n=this;return n.dstate=new s,t||(t=15),n.dstate.deflateInit(n,e,t)},deflate:function(e){var t=this;return t.dstate?t.dstate.deflate(t,e):-2},deflateEnd:function(){var e=this;if(!e.dstate)return -2;var t=e.dstate.deflateEnd();return e.dstate=null,t},deflateParams:function(e,t){var n=this;return n.dstate?n.dstate.deflateParams(n,e,t):-2},deflateSetDictionary:function(e,t){var n=this;return n.dstate?n.dstate.deflateSetDictionary(n,e,t):-2},read_buf:function(e,t,n){var i=this,r=i.avail_in;return r>n&&(r=n),0===r?0:(i.avail_in-=r,e.set(i.next_in.subarray(i.next_in_index,i.next_in_index+r),t),i.next_in_index+=r,i.total_in+=r,r)},flush_pending:function(){var e=this,t=e.dstate.pending;t>e.avail_out&&(t=e.avail_out),0!==t&&(e.next_out.set(e.dstate.pending_buf.subarray(e.dstate.pending_out,e.dstate.pending_out+t),e.next_out_index),e.next_out_index+=t,e.dstate.pending_out+=t,e.total_out+=t,e.avail_out-=t,e.dstate.pending-=t,0===e.dstate.pending&&(e.dstate.pending_out=0));}},self._zipjs_Deflater=f;var u=[0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535],d=[96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,192,80,7,10,0,8,96,0,8,32,0,9,160,0,8,0,0,8,128,0,8,64,0,9,224,80,7,6,0,8,88,0,8,24,0,9,144,83,7,59,0,8,120,0,8,56,0,9,208,81,7,17,0,8,104,0,8,40,0,9,176,0,8,8,0,8,136,0,8,72,0,9,240,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,200,81,7,13,0,8,100,0,8,36,0,9,168,0,8,4,0,8,132,0,8,68,0,9,232,80,7,8,0,8,92,0,8,28,0,9,152,84,7,83,0,8,124,0,8,60,0,9,216,82,7,23,0,8,108,0,8,44,0,9,184,0,8,12,0,8,140,0,8,76,0,9,248,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,196,81,7,11,0,8,98,0,8,34,0,9,164,0,8,2,0,8,130,0,8,66,0,9,228,80,7,7,0,8,90,0,8,26,0,9,148,84,7,67,0,8,122,0,8,58,0,9,212,82,7,19,0,8,106,0,8,42,0,9,180,0,8,10,0,8,138,0,8,74,0,9,244,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,204,81,7,15,0,8,102,0,8,38,0,9,172,0,8,6,0,8,134,0,8,70,0,9,236,80,7,9,0,8,94,0,8,30,0,9,156,84,7,99,0,8,126,0,8,62,0,9,220,82,7,27,0,8,110,0,8,46,0,9,188,0,8,14,0,8,142,0,8,78,0,9,252,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,194,80,7,10,0,8,97,0,8,33,0,9,162,0,8,1,0,8,129,0,8,65,0,9,226,80,7,6,0,8,89,0,8,25,0,9,146,83,7,59,0,8,121,0,8,57,0,9,210,81,7,17,0,8,105,0,8,41,0,9,178,0,8,9,0,8,137,0,8,73,0,9,242,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,202,81,7,13,0,8,101,0,8,37,0,9,170,0,8,5,0,8,133,0,8,69,0,9,234,80,7,8,0,8,93,0,8,29,0,9,154,84,7,83,0,8,125,0,8,61,0,9,218,82,7,23,0,8,109,0,8,45,0,9,186,0,8,13,0,8,141,0,8,77,0,9,250,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,198,81,7,11,0,8,99,0,8,35,0,9,166,0,8,3,0,8,131,0,8,67,0,9,230,80,7,7,0,8,91,0,8,27,0,9,150,84,7,67,0,8,123,0,8,59,0,9,214,82,7,19,0,8,107,0,8,43,0,9,182,0,8,11,0,8,139,0,8,75,0,9,246,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,206,81,7,15,0,8,103,0,8,39,0,9,174,0,8,7,0,8,135,0,8,71,0,9,238,80,7,9,0,8,95,0,8,31,0,9,158,84,7,99,0,8,127,0,8,63,0,9,222,82,7,27,0,8,111,0,8,47,0,9,190,0,8,15,0,8,143,0,8,79,0,9,254,96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,193,80,7,10,0,8,96,0,8,32,0,9,161,0,8,0,0,8,128,0,8,64,0,9,225,80,7,6,0,8,88,0,8,24,0,9,145,83,7,59,0,8,120,0,8,56,0,9,209,81,7,17,0,8,104,0,8,40,0,9,177,0,8,8,0,8,136,0,8,72,0,9,241,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,201,81,7,13,0,8,100,0,8,36,0,9,169,0,8,4,0,8,132,0,8,68,0,9,233,80,7,8,0,8,92,0,8,28,0,9,153,84,7,83,0,8,124,0,8,60,0,9,217,82,7,23,0,8,108,0,8,44,0,9,185,0,8,12,0,8,140,0,8,76,0,9,249,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,197,81,7,11,0,8,98,0,8,34,0,9,165,0,8,2,0,8,130,0,8,66,0,9,229,80,7,7,0,8,90,0,8,26,0,9,149,84,7,67,0,8,122,0,8,58,0,9,213,82,7,19,0,8,106,0,8,42,0,9,181,0,8,10,0,8,138,0,8,74,0,9,245,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,205,81,7,15,0,8,102,0,8,38,0,9,173,0,8,6,0,8,134,0,8,70,0,9,237,80,7,9,0,8,94,0,8,30,0,9,157,84,7,99,0,8,126,0,8,62,0,9,221,82,7,27,0,8,110,0,8,46,0,9,189,0,8,14,0,8,142,0,8,78,0,9,253,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,195,80,7,10,0,8,97,0,8,33,0,9,163,0,8,1,0,8,129,0,8,65,0,9,227,80,7,6,0,8,89,0,8,25,0,9,147,83,7,59,0,8,121,0,8,57,0,9,211,81,7,17,0,8,105,0,8,41,0,9,179,0,8,9,0,8,137,0,8,73,0,9,243,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,203,81,7,13,0,8,101,0,8,37,0,9,171,0,8,5,0,8,133,0,8,69,0,9,235,80,7,8,0,8,93,0,8,29,0,9,155,84,7,83,0,8,125,0,8,61,0,9,219,82,7,23,0,8,109,0,8,45,0,9,187,0,8,13,0,8,141,0,8,77,0,9,251,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,199,81,7,11,0,8,99,0,8,35,0,9,167,0,8,3,0,8,131,0,8,67,0,9,231,80,7,7,0,8,91,0,8,27,0,9,151,84,7,67,0,8,123,0,8,59,0,9,215,82,7,19,0,8,107,0,8,43,0,9,183,0,8,11,0,8,139,0,8,75,0,9,247,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,207,81,7,15,0,8,103,0,8,39,0,9,175,0,8,7,0,8,135,0,8,71,0,9,239,80,7,9,0,8,95,0,8,31,0,9,159,84,7,99,0,8,127,0,8,63,0,9,223,82,7,27,0,8,111,0,8,47,0,9,191,0,8,15,0,8,143,0,8,79,0,9,255],c=[80,5,1,87,5,257,83,5,17,91,5,4097,81,5,5,89,5,1025,85,5,65,93,5,16385,80,5,3,88,5,513,84,5,33,92,5,8193,82,5,9,90,5,2049,86,5,129,192,5,24577,80,5,2,87,5,385,83,5,25,91,5,6145,81,5,7,89,5,1537,85,5,97,93,5,24577,80,5,4,88,5,769,84,5,49,92,5,12289,82,5,13,90,5,3073,86,5,193,192,5,24577],_=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],h$1=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,112,112],p$1=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],w=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];function v(){var e,t,n,i,r,a;function o(e,t,o,s,l,f,u,d,c,_,h){var p,w,v,b,x,m,g,y,k,U,z,E,D,A,S;U=0,x=o;do{n[e[t+U]]++,U++,x--;}while(0!==x);if(n[0]==o)return u[0]=-1,d[0]=0,0;for(y=d[0],m=1;m<=15&&0===n[m];m++);for(g=m,y<m&&(y=m),x=15;0!==x&&0===n[x];x--);for(v=x,y>x&&(y=x),d[0]=y,A=1<<m;m<x;m++,A<<=1)if((A-=n[m])<0)return -3;if((A-=n[x])<0)return -3;for(n[x]+=A,a[1]=m=0,U=1,D=2;0!=--x;)a[D]=m+=n[U],D++,U++;x=0,U=0;do{0!==(m=e[t+U])&&(h[a[m]++]=x),U++;}while(++x<o);for(o=a[v],a[0]=x=0,U=0,b=-1,E=-y,r[0]=0,z=0,S=0;g<=v;g++)for(p=n[g];0!=p--;){for(;g>E+y;){if(b++,S=(S=v-(E+=y))>y?y:S,(w=1<<(m=g-E))>p+1&&(w-=p+1,D=g,m<S))for(;++m<S&&!((w<<=1)<=n[++D]);)w-=n[D];if(_[0]+(S=1<<m)>1440)return -3;r[b]=z=_[0],_[0]+=S,0!==b?(a[b]=x,i[0]=m,i[1]=y,i[2]=z-r[b-1]-(m=x>>>E-y),c.set(i,3*(r[b-1]+m))):u[0]=z;}for(i[1]=g-E,U>=o?i[0]=192:h[U]<s?(i[0]=h[U]<256?0:96,i[2]=h[U++]):(i[0]=f[h[U]-s]+16+64,i[2]=l[h[U++]-s]),w=1<<g-E,m=x>>>E;m<S;m+=w)c.set(i,3*(z+m));for(m=1<<g-1;0!=(x&m);m>>>=1)x^=m;for(x^=m,k=(1<<E)-1;(x&k)!=a[b];)b--,k=(1<<(E-=y))-1;}return 0!==A&&1!=v?-5:0}function s(o){var s;for(e||(e=[],t=[],n=new Int32Array(16),i=[],r=new Int32Array(15),a=new Int32Array(16)),t.length<o&&(t=[]),s=0;s<o;s++)t[s]=0;for(s=0;s<16;s++)n[s]=0;for(s=0;s<3;s++)i[s]=0;r.set(n.subarray(0,15),0),a.set(n.subarray(0,16),0);}this.inflate_trees_bits=function(n,i,r,a,l){var f;return s(19),e[0]=0,-3==(f=o(n,0,19,19,null,null,r,i,a,e,t))?l.msg="oversubscribed dynamic bit lengths tree":-5!=f&&0!==i[0]||(l.msg="incomplete dynamic bit lengths tree",f=-3),f},this.inflate_trees_dynamic=function(n,i,r,a,l,f,u,d,c){var v;return s(288),e[0]=0,0!=(v=o(r,0,n,257,_,h$1,f,a,d,e,t))||0===a[0]?(-3==v?c.msg="oversubscribed literal/length tree":-4!=v&&(c.msg="incomplete literal/length tree",v=-3),v):(s(288),0!=(v=o(r,n,i,0,p$1,w,u,l,d,e,t))||0===l[0]&&n>257?(-3==v?c.msg="oversubscribed distance tree":-5==v?(c.msg="incomplete distance tree",v=-3):-4!=v&&(c.msg="empty distance tree with lengths",v=-3),v):0)};}function b(){var e,t,n,i,r=this,a=0,o=0,s=0,l=0,f=0,d=0,c=0,_=0,h=0,p=0;function w(e,t,n,i,r,a,o,s){var l,f,d,c,_,h,p,w,v,b,x,m,g,y,k,U;p=s.next_in_index,w=s.avail_in,_=o.bitb,h=o.bitk,b=(v=o.write)<o.read?o.read-v-1:o.end-v,x=u[e],m=u[t];do{for(;h<20;)w--,_|=(255&s.read_byte(p++))<<h,h+=8;if(0!==(c=(f=n)[U=3*((d=i)+(l=_&x))]))for(;;){if(_>>=f[U+1],h-=f[U+1],0!=(16&c)){for(g=f[U+2]+(_&u[c&=15]),_>>=c,h-=c;h<15;)w--,_|=(255&s.read_byte(p++))<<h,h+=8;for(c=(f=r)[U=3*((d=a)+(l=_&m))];;){if(_>>=f[U+1],h-=f[U+1],0!=(16&c)){for(c&=15;h<c;)w--,_|=(255&s.read_byte(p++))<<h,h+=8;if(y=f[U+2]+(_&u[c]),_>>=c,h-=c,b-=g,v>=y)v-(k=v-y)>0&&2>v-k?(o.window[v++]=o.window[k++],o.window[v++]=o.window[k++],g-=2):(o.window.set(o.window.subarray(k,k+2),v),v+=2,k+=2,g-=2);else {k=v-y;do{k+=o.end;}while(k<0);if(g>(c=o.end-k)){if(g-=c,v-k>0&&c>v-k)do{o.window[v++]=o.window[k++];}while(0!=--c);else o.window.set(o.window.subarray(k,k+c),v),v+=c,k+=c,c=0;k=0;}}if(v-k>0&&g>v-k)do{o.window[v++]=o.window[k++];}while(0!=--g);else o.window.set(o.window.subarray(k,k+g),v),v+=g,k+=g,g=0;break}if(0!=(64&c))return s.msg="invalid distance code",w+=g=h>>3<(g=s.avail_in-w)?h>>3:g,p-=g,h-=g<<3,o.bitb=_,o.bitk=h,s.avail_in=w,s.total_in+=p-s.next_in_index,s.next_in_index=p,o.write=v,-3;l+=f[U+2],c=f[U=3*(d+(l+=_&u[c]))];}break}if(0!=(64&c))return 0!=(32&c)?(w+=g=h>>3<(g=s.avail_in-w)?h>>3:g,p-=g,h-=g<<3,o.bitb=_,o.bitk=h,s.avail_in=w,s.total_in+=p-s.next_in_index,s.next_in_index=p,o.write=v,1):(s.msg="invalid literal/length code",w+=g=h>>3<(g=s.avail_in-w)?h>>3:g,p-=g,h-=g<<3,o.bitb=_,o.bitk=h,s.avail_in=w,s.total_in+=p-s.next_in_index,s.next_in_index=p,o.write=v,-3);if(l+=f[U+2],0===(c=f[U=3*(d+(l+=_&u[c]))])){_>>=f[U+1],h-=f[U+1],o.window[v++]=f[U+2],b--;break}}else _>>=f[U+1],h-=f[U+1],o.window[v++]=f[U+2],b--;}while(b>=258&&w>=10);return w+=g=h>>3<(g=s.avail_in-w)?h>>3:g,p-=g,h-=g<<3,o.bitb=_,o.bitk=h,s.avail_in=w,s.total_in+=p-s.next_in_index,s.next_in_index=p,o.write=v,0}r.init=function(r,a,o,s,l,f){e=0,c=r,_=a,n=o,h=s,i=l,p=f,t=null;},r.proc=function(r,v,b){var x,m,g,y,k,U,z,E=0,D=0,A=0;for(A=v.next_in_index,y=v.avail_in,E=r.bitb,D=r.bitk,U=(k=r.write)<r.read?r.read-k-1:r.end-k;;)switch(e){case 0:if(U>=258&&y>=10&&(r.bitb=E,r.bitk=D,v.avail_in=y,v.total_in+=A-v.next_in_index,v.next_in_index=A,r.write=k,b=w(c,_,n,h,i,p,r,v),A=v.next_in_index,y=v.avail_in,E=r.bitb,D=r.bitk,U=(k=r.write)<r.read?r.read-k-1:r.end-k,0!=b)){e=1==b?7:9;break}s=c,t=n,o=h,e=1;case 1:for(x=s;D<x;){if(0===y)return r.bitb=E,r.bitk=D,v.avail_in=y,v.total_in+=A-v.next_in_index,v.next_in_index=A,r.write=k,r.inflate_flush(v,b);b=0,y--,E|=(255&v.read_byte(A++))<<D,D+=8;}if(E>>>=t[1+(m=3*(o+(E&u[x])))],D-=t[m+1],0===(g=t[m])){l=t[m+2],e=6;break}if(0!=(16&g)){f=15&g,a=t[m+2],e=2;break}if(0==(64&g)){s=g,o=m/3+t[m+2];break}if(0!=(32&g)){e=7;break}return e=9,v.msg="invalid literal/length code",b=-3,r.bitb=E,r.bitk=D,v.avail_in=y,v.total_in+=A-v.next_in_index,v.next_in_index=A,r.write=k,r.inflate_flush(v,b);case 2:for(x=f;D<x;){if(0===y)return r.bitb=E,r.bitk=D,v.avail_in=y,v.total_in+=A-v.next_in_index,v.next_in_index=A,r.write=k,r.inflate_flush(v,b);b=0,y--,E|=(255&v.read_byte(A++))<<D,D+=8;}a+=E&u[x],E>>=x,D-=x,s=_,t=i,o=p,e=3;case 3:for(x=s;D<x;){if(0===y)return r.bitb=E,r.bitk=D,v.avail_in=y,v.total_in+=A-v.next_in_index,v.next_in_index=A,r.write=k,r.inflate_flush(v,b);b=0,y--,E|=(255&v.read_byte(A++))<<D,D+=8;}if(E>>=t[1+(m=3*(o+(E&u[x])))],D-=t[m+1],0!=(16&(g=t[m]))){f=15&g,d=t[m+2],e=4;break}if(0==(64&g)){s=g,o=m/3+t[m+2];break}return e=9,v.msg="invalid distance code",b=-3,r.bitb=E,r.bitk=D,v.avail_in=y,v.total_in+=A-v.next_in_index,v.next_in_index=A,r.write=k,r.inflate_flush(v,b);case 4:for(x=f;D<x;){if(0===y)return r.bitb=E,r.bitk=D,v.avail_in=y,v.total_in+=A-v.next_in_index,v.next_in_index=A,r.write=k,r.inflate_flush(v,b);b=0,y--,E|=(255&v.read_byte(A++))<<D,D+=8;}d+=E&u[x],E>>=x,D-=x,e=5;case 5:for(z=k-d;z<0;)z+=r.end;for(;0!==a;){if(0===U&&(k==r.end&&0!==r.read&&(U=(k=0)<r.read?r.read-k-1:r.end-k),0===U&&(r.write=k,b=r.inflate_flush(v,b),U=(k=r.write)<r.read?r.read-k-1:r.end-k,k==r.end&&0!==r.read&&(U=(k=0)<r.read?r.read-k-1:r.end-k),0===U)))return r.bitb=E,r.bitk=D,v.avail_in=y,v.total_in+=A-v.next_in_index,v.next_in_index=A,r.write=k,r.inflate_flush(v,b);r.window[k++]=r.window[z++],U--,z==r.end&&(z=0),a--;}e=0;break;case 6:if(0===U&&(k==r.end&&0!==r.read&&(U=(k=0)<r.read?r.read-k-1:r.end-k),0===U&&(r.write=k,b=r.inflate_flush(v,b),U=(k=r.write)<r.read?r.read-k-1:r.end-k,k==r.end&&0!==r.read&&(U=(k=0)<r.read?r.read-k-1:r.end-k),0===U)))return r.bitb=E,r.bitk=D,v.avail_in=y,v.total_in+=A-v.next_in_index,v.next_in_index=A,r.write=k,r.inflate_flush(v,b);b=0,r.window[k++]=l,U--,e=0;break;case 7:if(D>7&&(D-=8,y++,A--),r.write=k,b=r.inflate_flush(v,b),U=(k=r.write)<r.read?r.read-k-1:r.end-k,r.read!=r.write)return r.bitb=E,r.bitk=D,v.avail_in=y,v.total_in+=A-v.next_in_index,v.next_in_index=A,r.write=k,r.inflate_flush(v,b);e=8;case 8:return b=1,r.bitb=E,r.bitk=D,v.avail_in=y,v.total_in+=A-v.next_in_index,v.next_in_index=A,r.write=k,r.inflate_flush(v,b);case 9:return b=-3,r.bitb=E,r.bitk=D,v.avail_in=y,v.total_in+=A-v.next_in_index,v.next_in_index=A,r.write=k,r.inflate_flush(v,b);default:return b=-2,r.bitb=E,r.bitk=D,v.avail_in=y,v.total_in+=A-v.next_in_index,v.next_in_index=A,r.write=k,r.inflate_flush(v,b)}},r.free=function(){};}v.inflate_trees_fixed=function(e,t,n,i){return e[0]=9,t[0]=5,n[0]=d,i[0]=c,0};var x=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];function m(e,t){var n,i=this,r=0,a=0,o=0,s=0,l=[0],f=[0],d=new b,c=0,_=new Int32Array(4320),h=new v;i.bitk=0,i.bitb=0,i.window=new Uint8Array(t),i.end=t,i.read=0,i.write=0,i.reset=function(e,t){t&&(t[0]=0),6==r&&d.free(e),r=0,i.bitk=0,i.bitb=0,i.read=i.write=0;},i.reset(e,null),i.inflate_flush=function(e,t){var n,r,a;return r=e.next_out_index,(n=((a=i.read)<=i.write?i.write:i.end)-a)>e.avail_out&&(n=e.avail_out),0!==n&&-5==t&&(t=0),e.avail_out-=n,e.total_out+=n,e.next_out.set(i.window.subarray(a,a+n),r),r+=n,(a+=n)==i.end&&(a=0,i.write==i.end&&(i.write=0),(n=i.write-a)>e.avail_out&&(n=e.avail_out),0!==n&&-5==t&&(t=0),e.avail_out-=n,e.total_out+=n,e.next_out.set(i.window.subarray(a,a+n),r),r+=n,a+=n),e.next_out_index=r,i.read=a,t},i.proc=function(e,t){var p,w,b,m,g,y,k,U;for(m=e.next_in_index,g=e.avail_in,w=i.bitb,b=i.bitk,k=(y=i.write)<i.read?i.read-y-1:i.end-y;;)switch(r){case 0:for(;b<3;){if(0===g)return i.bitb=w,i.bitk=b,e.avail_in=g,e.total_in+=m-e.next_in_index,e.next_in_index=m,i.write=y,i.inflate_flush(e,t);t=0,g--,w|=(255&e.read_byte(m++))<<b,b+=8;}switch(c=1&(p=7&w),p>>>1){case 0:w>>>=3,w>>>=p=7&(b-=3),b-=p,r=1;break;case 1:var z=[],E=[],D=[[]],A=[[]];v.inflate_trees_fixed(z,E,D,A),d.init(z[0],E[0],D[0],0,A[0],0),w>>>=3,b-=3,r=6;break;case 2:w>>>=3,b-=3,r=3;break;case 3:return w>>>=3,b-=3,r=9,e.msg="invalid block type",t=-3,i.bitb=w,i.bitk=b,e.avail_in=g,e.total_in+=m-e.next_in_index,e.next_in_index=m,i.write=y,i.inflate_flush(e,t)}break;case 1:for(;b<32;){if(0===g)return i.bitb=w,i.bitk=b,e.avail_in=g,e.total_in+=m-e.next_in_index,e.next_in_index=m,i.write=y,i.inflate_flush(e,t);t=0,g--,w|=(255&e.read_byte(m++))<<b,b+=8;}if((~w>>>16&65535)!=(65535&w))return r=9,e.msg="invalid stored block lengths",t=-3,i.bitb=w,i.bitk=b,e.avail_in=g,e.total_in+=m-e.next_in_index,e.next_in_index=m,i.write=y,i.inflate_flush(e,t);a=65535&w,w=b=0,r=0!==a?2:0!==c?7:0;break;case 2:if(0===g)return i.bitb=w,i.bitk=b,e.avail_in=g,e.total_in+=m-e.next_in_index,e.next_in_index=m,i.write=y,i.inflate_flush(e,t);if(0===k&&(y==i.end&&0!==i.read&&(k=(y=0)<i.read?i.read-y-1:i.end-y),0===k&&(i.write=y,t=i.inflate_flush(e,t),k=(y=i.write)<i.read?i.read-y-1:i.end-y,y==i.end&&0!==i.read&&(k=(y=0)<i.read?i.read-y-1:i.end-y),0===k)))return i.bitb=w,i.bitk=b,e.avail_in=g,e.total_in+=m-e.next_in_index,e.next_in_index=m,i.write=y,i.inflate_flush(e,t);if(t=0,(p=a)>g&&(p=g),p>k&&(p=k),i.window.set(e.read_buf(m,p),y),m+=p,g-=p,y+=p,k-=p,0!=(a-=p))break;r=0!==c?7:0;break;case 3:for(;b<14;){if(0===g)return i.bitb=w,i.bitk=b,e.avail_in=g,e.total_in+=m-e.next_in_index,e.next_in_index=m,i.write=y,i.inflate_flush(e,t);t=0,g--,w|=(255&e.read_byte(m++))<<b,b+=8;}if(o=p=16383&w,(31&p)>29||(p>>5&31)>29)return r=9,e.msg="too many length or distance symbols",t=-3,i.bitb=w,i.bitk=b,e.avail_in=g,e.total_in+=m-e.next_in_index,e.next_in_index=m,i.write=y,i.inflate_flush(e,t);if(p=258+(31&p)+(p>>5&31),!n||n.length<p)n=[];else for(U=0;U<p;U++)n[U]=0;w>>>=14,b-=14,s=0,r=4;case 4:for(;s<4+(o>>>10);){for(;b<3;){if(0===g)return i.bitb=w,i.bitk=b,e.avail_in=g,e.total_in+=m-e.next_in_index,e.next_in_index=m,i.write=y,i.inflate_flush(e,t);t=0,g--,w|=(255&e.read_byte(m++))<<b,b+=8;}n[x[s++]]=7&w,w>>>=3,b-=3;}for(;s<19;)n[x[s++]]=0;if(l[0]=7,0!=(p=h.inflate_trees_bits(n,l,f,_,e)))return -3==(t=p)&&(n=null,r=9),i.bitb=w,i.bitk=b,e.avail_in=g,e.total_in+=m-e.next_in_index,e.next_in_index=m,i.write=y,i.inflate_flush(e,t);s=0,r=5;case 5:for(;!(s>=258+(31&(p=o))+(p>>5&31));){var S,R;for(p=l[0];b<p;){if(0===g)return i.bitb=w,i.bitk=b,e.avail_in=g,e.total_in+=m-e.next_in_index,e.next_in_index=m,i.write=y,i.inflate_flush(e,t);t=0,g--,w|=(255&e.read_byte(m++))<<b,b+=8;}if((R=_[3*(f[0]+(w&u[p=_[3*(f[0]+(w&u[p]))+1]]))+2])<16)w>>>=p,b-=p,n[s++]=R;else {for(U=18==R?7:R-14,S=18==R?11:3;b<p+U;){if(0===g)return i.bitb=w,i.bitk=b,e.avail_in=g,e.total_in+=m-e.next_in_index,e.next_in_index=m,i.write=y,i.inflate_flush(e,t);t=0,g--,w|=(255&e.read_byte(m++))<<b,b+=8;}if(b-=p,S+=(w>>>=p)&u[U],w>>>=U,b-=U,(U=s)+S>258+(31&(p=o))+(p>>5&31)||16==R&&U<1)return n=null,r=9,e.msg="invalid bit length repeat",t=-3,i.bitb=w,i.bitk=b,e.avail_in=g,e.total_in+=m-e.next_in_index,e.next_in_index=m,i.write=y,i.inflate_flush(e,t);R=16==R?n[U-1]:0;do{n[U++]=R;}while(0!=--S);s=U;}}f[0]=-1;var F=[],T=[],W=[],M=[];if(F[0]=9,T[0]=6,0!=(p=h.inflate_trees_dynamic(257+(31&(p=o)),1+(p>>5&31),n,F,T,W,M,_,e)))return -3==p&&(n=null,r=9),t=p,i.bitb=w,i.bitk=b,e.avail_in=g,e.total_in+=m-e.next_in_index,e.next_in_index=m,i.write=y,i.inflate_flush(e,t);d.init(F[0],T[0],_,W[0],_,M[0]),r=6;case 6:if(i.bitb=w,i.bitk=b,e.avail_in=g,e.total_in+=m-e.next_in_index,e.next_in_index=m,i.write=y,1!=(t=d.proc(i,e,t)))return i.inflate_flush(e,t);if(t=0,d.free(e),m=e.next_in_index,g=e.avail_in,w=i.bitb,b=i.bitk,k=(y=i.write)<i.read?i.read-y-1:i.end-y,0===c){r=0;break}r=7;case 7:if(i.write=y,t=i.inflate_flush(e,t),k=(y=i.write)<i.read?i.read-y-1:i.end-y,i.read!=i.write)return i.bitb=w,i.bitk=b,e.avail_in=g,e.total_in+=m-e.next_in_index,e.next_in_index=m,i.write=y,i.inflate_flush(e,t);r=8;case 8:return t=1,i.bitb=w,i.bitk=b,e.avail_in=g,e.total_in+=m-e.next_in_index,e.next_in_index=m,i.write=y,i.inflate_flush(e,t);case 9:return t=-3,i.bitb=w,i.bitk=b,e.avail_in=g,e.total_in+=m-e.next_in_index,e.next_in_index=m,i.write=y,i.inflate_flush(e,t);default:return t=-2,i.bitb=w,i.bitk=b,e.avail_in=g,e.total_in+=m-e.next_in_index,e.next_in_index=m,i.write=y,i.inflate_flush(e,t)}},i.free=function(e){i.reset(e,null),i.window=null,_=null;},i.set_dictionary=function(e,t,n){i.window.set(e.subarray(t,t+n),0),i.read=i.write=n;},i.sync_point=function(){return 1==r?1:0};}var g=[0,0,255,255];function y(){var e=this;function t(e){return e&&e.istate?(e.total_in=e.total_out=0,e.msg=null,e.istate.mode=7,e.istate.blocks.reset(e,null),0):-2}e.mode=0,e.method=0,e.was=[0],e.need=0,e.marker=0,e.wbits=0,e.inflateEnd=function(t){return e.blocks&&e.blocks.free(t),e.blocks=null,0},e.inflateInit=function(n,i){return n.msg=null,e.blocks=null,i<8||i>15?(e.inflateEnd(n),-2):(e.wbits=i,n.istate.blocks=new m(n,1<<i),t(n),0)},e.inflate=function(e,t){var n,i;if(!e||!e.istate||!e.next_in)return -2;for(t=4==t?-5:0,n=-5;;)switch(e.istate.mode){case 0:if(0===e.avail_in)return n;if(n=t,e.avail_in--,e.total_in++,8!=(15&(e.istate.method=e.read_byte(e.next_in_index++)))){e.istate.mode=13,e.msg="unknown compression method",e.istate.marker=5;break}if(8+(e.istate.method>>4)>e.istate.wbits){e.istate.mode=13,e.msg="invalid window size",e.istate.marker=5;break}e.istate.mode=1;case 1:if(0===e.avail_in)return n;if(n=t,e.avail_in--,e.total_in++,i=255&e.read_byte(e.next_in_index++),((e.istate.method<<8)+i)%31!=0){e.istate.mode=13,e.msg="incorrect header check",e.istate.marker=5;break}if(0==(32&i)){e.istate.mode=7;break}e.istate.mode=2;case 2:if(0===e.avail_in)return n;n=t,e.avail_in--,e.total_in++,e.istate.need=(255&e.read_byte(e.next_in_index++))<<24&4278190080,e.istate.mode=3;case 3:if(0===e.avail_in)return n;n=t,e.avail_in--,e.total_in++,e.istate.need+=(255&e.read_byte(e.next_in_index++))<<16&16711680,e.istate.mode=4;case 4:if(0===e.avail_in)return n;n=t,e.avail_in--,e.total_in++,e.istate.need+=(255&e.read_byte(e.next_in_index++))<<8&65280,e.istate.mode=5;case 5:return 0===e.avail_in?n:(n=t,e.avail_in--,e.total_in++,e.istate.need+=255&e.read_byte(e.next_in_index++),e.istate.mode=6,2);case 6:return e.istate.mode=13,e.msg="need dictionary",e.istate.marker=0,-2;case 7:if(-3==(n=e.istate.blocks.proc(e,n))){e.istate.mode=13,e.istate.marker=0;break}if(0==n&&(n=t),1!=n)return n;n=t,e.istate.blocks.reset(e,e.istate.was),e.istate.mode=12;case 12:return 1;case 13:return -3;default:return -2}},e.inflateSetDictionary=function(e,t,n){var i=0,r=n;return e&&e.istate&&6==e.istate.mode?(r>=1<<e.istate.wbits&&(i=n-(r=(1<<e.istate.wbits)-1)),e.istate.blocks.set_dictionary(t,i,r),e.istate.mode=7,0):-2},e.inflateSync=function(e){var n,i,r,a,o;if(!e||!e.istate)return -2;if(13!=e.istate.mode&&(e.istate.mode=13,e.istate.marker=0),0===(n=e.avail_in))return -5;for(i=e.next_in_index,r=e.istate.marker;0!==n&&r<4;)e.read_byte(i)==g[r]?r++:r=0!==e.read_byte(i)?0:4-r,i++,n--;return e.total_in+=i-e.next_in_index,e.next_in_index=i,e.avail_in=n,e.istate.marker=r,4!=r?-3:(a=e.total_in,o=e.total_out,t(e),e.total_in=a,e.total_out=o,e.istate.mode=7,0)},e.inflateSyncPoint=function(e){return e&&e.istate&&e.istate.blocks?e.istate.blocks.sync_point():-2};}function k(){}function U(){var e=new k,t=new Uint8Array(512),n=!1;e.inflateInit(),e.next_out=t,this.append=function(i,r){var a,o,s=[],l=0,f=0,u=0;if(0!==i.length){e.next_in_index=0,e.next_in=i,e.avail_in=i.length;do{if(e.next_out_index=0,e.avail_out=512,0!==e.avail_in||n||(e.next_in_index=0,n=!0),a=e.inflate(0),n&&-5===a){if(0!==e.avail_in)throw new Error("inflating: bad input")}else if(0!==a&&1!==a)throw new Error("inflating: "+e.msg);if((n||1===a)&&e.avail_in===i.length)throw new Error("inflating: bad input");e.next_out_index&&s.push(512===e.next_out_index?new Uint8Array(t):new Uint8Array(t.subarray(0,e.next_out_index))),u+=e.next_out_index,r&&e.next_in_index>0&&e.next_in_index!=l&&(r(e.next_in_index),l=e.next_in_index);}while(e.avail_in>0||0===e.avail_out);return o=new Uint8Array(u),s.forEach(function(e){o.set(e,f),f+=e.length;}),o}},this.flush=function(){e.inflateEnd();};}k.prototype={inflateInit:function(e){var t=this;return t.istate=new y,e||(e=15),t.istate.inflateInit(t,e)},inflate:function(e){var t=this;return t.istate?t.istate.inflate(t,e):-2},inflateEnd:function(){var e=this;if(!e.istate)return -2;var t=e.istate.inflateEnd(e);return e.istate=null,t},inflateSync:function(){var e=this;return e.istate?e.istate.inflateSync(e):-2},inflateSetDictionary:function(e,t){var n=this;return n.istate?n.istate.inflateSetDictionary(n,e,t):-2},read_byte:function(e){return this.next_in.subarray(e,e+1)[0]},read_buf:function(e,t){return this.next_in.subarray(e,e+t)}},self._zipjs_Inflater=U;var z,E$1="File format is not recognized.",D="Error while reading zip file.";try{z=0===new Blob([new DataView(new ArrayBuffer(0))]).size;}catch(e){}function A(){this.crc=-1;}function S(){}function R(e,t){var n,i;return n=new ArrayBuffer(e),i=new Uint8Array(n),t&&i.set(t,0),{buffer:n,array:i,view:new DataView(n)}}function F(){}function T(e){var t,n=this;n.size=0,n.init=function(i,r){var a=new Blob([e],{type:"text/plain"});(t=new M(a)).init(function(){n.size=t.size,i();},r);},n.readUint8Array=function(e,n,i,r){t.readUint8Array(e,n,i,r);};}function W(e){var t,n=this;n.size=0,n.init=function(i){for(var r=e.length;"="==e.charAt(r-1);)r--;t=e.indexOf(",")+1,n.size=Math.floor(.75*(r-t)),i();},n.readUint8Array=function(n,i,r){var a,o=R(i),s=4*Math.floor(n/3),l=4*Math.ceil((n+i)/3),f=self.atob(e.substring(s+t,l+t)),u=n-3*Math.floor(s/4);for(a=u;a<u+i;a++)o.array[a-u]=f.charCodeAt(a);r(o.array);};}function M(e){var t=this;t.size=0,t.init=function(n){t.size=e.size,n();},t.readUint8Array=function(t,n,i,r){var a=new FileReader;a.onload=function(e){i(new Uint8Array(e.target.result));},a.onerror=r;try{a.readAsArrayBuffer(function(e,t,n){if(t<0||n<0||t+n>e.size)throw new RangeError("offset:"+t+", length:"+n+", size:"+e.size);return e.slice?e.slice(t,t+n):e.webkitSlice?e.webkitSlice(t,t+n):e.mozSlice?e.mozSlice(t,t+n):e.msSlice?e.msSlice(t,t+n):void 0}(e,t,n));}catch(e){r(e);}};}function B(){}function I(e){var t,n=this;n.init=function(e){t=new Blob([],{type:"text/plain"}),e();},n.writeUint8Array=function(e,n){t=new Blob([t,z?e:e.buffer],{type:"text/plain"}),n();},n.getData=function(n,i){var r=new FileReader;r.onload=function(e){n(e.target.result);},r.onerror=i,r.readAsText(t,e);};}function C(e){var t=this,n="",i="";t.init=function(t){n+="data:"+(e||"")+";base64,",t();},t.writeUint8Array=function(e,t){var r,a=i.length,o=i;for(i="",r=0;r<3*Math.floor((a+e.length)/3)-a;r++)o+=String.fromCharCode(e[r]);for(;r<e.length;r++)i+=String.fromCharCode(e[r]);o.length>2?n+=self.btoa(o):i=o,t();},t.getData=function(e){e(n+self.btoa(i));};}function L(e){var t,n=this;n.init=function(n){t=new Blob([],{type:e}),n();},n.writeUint8Array=function(n,i){t=new Blob([t,z?n:n.buffer],{type:e}),i();},n.getData=function(e){e(t);};}function P(e,t,n,i,r,a,o,s,l,f){var u,d,c,_=0,h=t.sn;function p(){e.removeEventListener("message",w,!1),s(d,c);}function w(t){var n=t.data,r=n.data,s=n.error;if(s)return s.toString=function(){return "Error: "+this.message},void l(s);if(n.sn===h)switch("number"==typeof n.codecTime&&(e.codecTime+=n.codecTime),"number"==typeof n.crcTime&&(e.crcTime+=n.crcTime),n.type){case"append":r?(d+=r.length,i.writeUint8Array(r,function(){v();},f)):v();break;case"flush":c=n.crc,r?(d+=r.length,i.writeUint8Array(r,function(){p();},f)):p();break;case"progress":o&&o(u+n.loaded,a);break;case"importScripts":case"newTask":case"echo":break;default:console.warn("zip.js:launchWorkerProcess: unknown message: ",n);}}function v(){(u=524288*_)<=a?n.readUint8Array(r+u,Math.min(524288,a-u),function(n){o&&o(u,a);var i=0===u?t:{sn:h};i.type="append",i.data=n;try{e.postMessage(i,[n.buffer]);}catch(t){e.postMessage(i);}_++;},l):e.postMessage({sn:h,type:"flush"});}d=0,e.addEventListener("message",w,!1),v();}function Z(e,t,n,i,r,a,o,s,l,f){var u,d=0,c=0,_="input"===a,h="output"===a,p=new A;!function a(){var w;if((u=524288*d)<r)t.readUint8Array(i+u,Math.min(524288,r-u),function(t){var i;try{i=e.append(t,function(e){o&&o(u+e,r);});}catch(e){return void l(e)}i?(c+=i.length,n.writeUint8Array(i,function(){d++,setTimeout(a,1);},f),h&&p.append(i)):(d++,setTimeout(a,1)),_&&p.append(t),o&&o(u,r);},l);else {try{w=e.flush();}catch(e){return void l(e)}w?(h&&p.append(w),c+=w.length,n.writeUint8Array(w,function(){s(c,p.get());},f)):s(c,p.get());}}();}function N(e,t,n,i,r,a,o,s,l,f,u){var d="input";K.useWebWorkers&&o?P(e,{sn:t,codecClass:"_zipjs_NOOP",crcType:d},n,i,r,a,l,s,f,u):Z(new S,n,i,r,a,d,l,s,f,u);}function j(e){var t,n,i="",r=["Ç","ü","é","â","ä","à","å","ç","ê","ë","è","ï","î","ì","Ä","Å","É","æ","Æ","ô","ö","ò","û","ù","ÿ","Ö","Ü","ø","£","Ø","×","ƒ","á","í","ó","ú","ñ","Ñ","ª","º","¿","®","¬","½","¼","¡","«","»","_","_","_","¦","¦","Á","Â","À","©","¦","¦","+","+","¢","¥","+","+","-","-","+","-","+","ã","Ã","+","+","-","-","¦","-","+","¤","ð","Ð","Ê","Ë","È","i","Í","Î","Ï","+","+","_","_","¦","Ì","_","Ó","ß","Ô","Ò","õ","Õ","µ","þ","Þ","Ú","Û","Ù","ý","Ý","¯","´","­","±","_","¾","¶","§","÷","¸","°","¨","·","¹","³","²","_"," "];for(t=0;t<e.length;t++)i+=(n=255&e.charCodeAt(t))>127?r[n-128]:String.fromCharCode(n);return i}function O(e){return decodeURIComponent(escape(e))}function V(e){var t,n="";for(t=0;t<e.length;t++)n+=String.fromCharCode(e[t]);return n}function q(e,t,n,i,r){e.version=t.view.getUint16(n,!0),e.bitFlag=t.view.getUint16(n+2,!0),e.compressionMethod=t.view.getUint16(n+4,!0),e.lastModDateRaw=t.view.getUint32(n+6,!0),e.lastModDate=function(e){var t=(4294901760&e)>>16,n=65535&e;try{return new Date(1980+((65024&t)>>9),((480&t)>>5)-1,31&t,(63488&n)>>11,(2016&n)>>5,2*(31&n),0)}catch(e){}}(e.lastModDateRaw),1!=(1&e.bitFlag)?((i||8!=(8&e.bitFlag))&&(e.crc32=t.view.getUint32(n+10,!0),e.compressedSize=t.view.getUint32(n+14,!0),e.uncompressedSize=t.view.getUint32(n+18,!0)),4294967295!==e.compressedSize&&4294967295!==e.uncompressedSize?(e.filenameLength=t.view.getUint16(n+22,!0),e.extraFieldLength=t.view.getUint16(n+24,!0)):r("File is using Zip64 (4gb+ file size).")):r("File contains encrypted entry.");}function $(e){return unescape(encodeURIComponent(e))}function G(e){var t,n=[];for(t=0;t<e.length;t++)n.push(e.charCodeAt(t));return n}A.prototype.append=function(e){for(var t=0|this.crc,n=this.table,i=0,r=0|e.length;i<r;i++)t=t>>>8^n[255&(t^e[i])];this.crc=t;},A.prototype.get=function(){return ~this.crc},A.prototype.table=function(){var e,t,n,i=[];for(e=0;e<256;e++){for(n=e,t=0;t<8;t++)1&n?n=n>>>1^3988292384:n>>>=1;i[e]=n;}return i}(),S.prototype.append=function(e,t){return e},S.prototype.flush=function(){},(T.prototype=new F).constructor=T,(W.prototype=new F).constructor=W,(M.prototype=new F).constructor=M,B.prototype.getData=function(e){e(this.data);},(I.prototype=new B).constructor=I,(C.prototype=new B).constructor=C,(L.prototype=new B).constructor=L;var H={deflater:["z-worker.js","deflate.js"],inflater:["z-worker.js","inflate.js"]};function Y(e,t,n){if(null===K.workerScripts||null===K.workerScriptsPath){var i,r,a;if(K.workerScripts){if(i=K.workerScripts[e],!Array.isArray(i))return void n(new Error("zip.workerScripts."+e+" is not an array!"));r=i,a=document.createElement("a"),i=r.map(function(e){return a.href=e,a.href});}else (i=H[e].slice(0))[0]=(K.workerScriptsPath||"")+i[0];var o=new Worker(i[0]);o.codecTime=o.crcTime=0,o.postMessage({type:"importScripts",scripts:i.slice(1)}),o.addEventListener("message",function e(i){var r=i.data;if(r.error)return o.terminate(),void n(r.error);"importScripts"===r.type&&(o.removeEventListener("message",e),o.removeEventListener("error",s),t(o));}),o.addEventListener("error",s);}else n(new Error("Either zip.workerScripts or zip.workerScriptsPath may be set, not both."));function s(e){o.terminate(),n(e);}}function J(e){console.error(e);}const K={Reader:F,Writer:B,BlobReader:M,Data64URIReader:W,TextReader:T,BlobWriter:L,Data64URIWriter:C,TextWriter:I,createReader:function(e,t,n){e.init(function(){!function(e,t,n){var i=0;function r(){}r.prototype.getData=function(t,r,a,o){var s=this;function l(e,i){o&&!function(e){var t=R(4);return t.view.setUint32(0,e),s.crc32==t.view.getUint32(0)}(i)?n("CRC failed."):t.getData(function(e){r(e);});}function f(e){n(e||"Error while reading file data.");}function u(e){n(e||"Error while writing file data.");}e.readUint8Array(s.offset,30,function(r){var d,c=R(r.length,r);1347093252==c.view.getUint32(0)?(q(s,c,4,!1,n),d=s.offset+30+s.filenameLength+s.extraFieldLength,t.init(function(){0===s.compressionMethod?N(s._worker,i++,e,t,d,s.compressedSize,o,l,a,f,u):function(e,t,n,i,r,a,o,s,l,f,u){var d=o?"output":"none";K.useWebWorkers?P(e,{sn:t,codecClass:"_zipjs_Inflater",crcType:d},n,i,r,a,l,s,f,u):Z(new U,n,i,r,a,d,l,s,f,u);}(s._worker,i++,e,t,d,s.compressedSize,o,l,a,f,u);},u)):n(E$1);},f);};var a={getEntries:function(t){var i=this._worker;!function(t){function i(i,r){e.readUint8Array(e.size-i,i,function(e){for(var n=e.length-22;n>=0;n--)if(80===e[n]&&75===e[n+1]&&5===e[n+2]&&6===e[n+3])return void t(new DataView(e.buffer,n,22));r();},function(){n(D);});}e.size<22?n(E$1):i(22,function(){i(Math.min(65558,e.size),function(){n(E$1);});});}(function(a){var o,s;o=a.getUint32(16,!0),s=a.getUint16(8,!0),o<0||o>=e.size?n(E$1):e.readUint8Array(o,e.size-o,function(e){var a,o,l,f,u=0,d=[],c=R(e.length,e);for(a=0;a<s;a++){if((o=new r)._worker=i,1347092738!=c.view.getUint32(u))return void n(E$1);q(o,c,u+6,!0,n),o.commentLength=c.view.getUint16(u+32,!0),o.directory=16==(16&c.view.getUint8(u+38)),o.offset=c.view.getUint32(u+42,!0),l=V(c.array.subarray(u+46,u+46+o.filenameLength)),o.filename=2048==(2048&o.bitFlag)?O(l):j(l),o.directory||"/"!=o.filename.charAt(o.filename.length-1)||(o.directory=!0),f=V(c.array.subarray(u+46+o.filenameLength+o.extraFieldLength,u+46+o.filenameLength+o.extraFieldLength+o.commentLength)),o.comment=2048==(2048&o.bitFlag)?O(f):j(f),d.push(o),u+=46+o.filenameLength+o.extraFieldLength+o.commentLength;}t(d);},function(){n(D);});});},close:function(e){this._worker&&(this._worker.terminate(),this._worker=null),e&&e();},_worker:null};K.useWebWorkers?Y("inflater",function(e){a._worker=e,t(a);},function(e){n(e);}):t(a);}(e,t,n);},n=n||J);},createWriter:function(e,t,n,i){i=!!i,e.init(function(){!function(e,t,n,i){var r={},a=[],o=0,s=0;function l(e){n(e||"Error while writing zip file.");}function u(e){n(e||"Error while reading file data.");}var d={add:function(t,d,c,_,h){var p,w,v,b=this._worker;function x(t,n){var i=R(16);o+=t||0,i.view.setUint32(0,1347094280),void 0!==n&&(p.view.setUint32(10,n,!0),i.view.setUint32(4,n,!0)),d&&(i.view.setUint32(8,t,!0),p.view.setUint32(14,t,!0),i.view.setUint32(12,d.size,!0),p.view.setUint32(18,d.size,!0)),e.writeUint8Array(i.array,function(){o+=16,c();},l);}function m(){var c;h=h||{},t=t.trim(),h.directory&&"/"!=t.charAt(t.length-1)&&(t+="/"),r.hasOwnProperty(t)?n("File already exists."):(w=G($(t)),a.push(t),v=h.lastModDate||new Date,p=R(26),r[t]={headerArray:p.array,directory:h.directory,filename:w,offset:o,comment:G($(h.comment||""))},p.view.setUint32(0,335546376),h.version&&p.view.setUint8(0,h.version),i||0===h.level||h.directory||p.view.setUint16(4,2048),p.view.setUint16(6,(v.getHours()<<6|v.getMinutes())<<5|v.getSeconds()/2,!0),p.view.setUint16(8,(v.getFullYear()-1980<<4|v.getMonth()+1)<<5|v.getDate(),!0),p.view.setUint16(22,w.length,!0),(c=R(30+w.length)).view.setUint32(0,1347093252),c.array.set(p.array,4),c.array.set(w,30),o+=c.array.length,e.writeUint8Array(c.array,function(){d?i||0===h.level?N(b,s++,d,e,0,d.size,!0,x,_,u,l):function(e,t,n,i,r,a,o,s,l){var u="input";K.useWebWorkers?P(e,{sn:t,options:{level:r},codecClass:"_zipjs_Deflater",crcType:u},n,i,0,n.size,o,a,s,l):Z(new f,n,i,0,n.size,u,o,a,s,l);}(b,s++,d,e,h.level,x,_,u,l):x();},l));}d?d.init(m,u):m();},close:function(t){this._worker&&(this._worker.terminate(),this._worker=null);var n,i,s,f=0,u=0;for(i=0;i<a.length;i++)f+=46+(s=r[a[i]]).filename.length+s.comment.length;for(n=R(f+22),i=0;i<a.length;i++)s=r[a[i]],n.view.setUint32(u,1347092738),n.view.setUint16(u+4,5120),n.array.set(s.headerArray,u+6),n.view.setUint16(u+32,s.comment.length,!0),s.directory&&n.view.setUint8(u+38,16),n.view.setUint32(u+42,s.offset,!0),n.array.set(s.filename,u+46),n.array.set(s.comment,u+46+s.filename.length),u+=46+s.filename.length+s.comment.length;n.view.setUint32(u,1347093766),n.view.setUint16(u+8,a.length,!0),n.view.setUint16(u+10,a.length,!0),n.view.setUint32(u+12,f,!0),n.view.setUint32(u+16,o,!0),e.writeUint8Array(n.array,function(){e.getData(t);},l);},_worker:null};K.useWebWorkers?Y("deflater",function(e){d._worker=e,t(d);},function(e){n(e);}):t(d);}(e,t,n,i);},n=n||J);},useWebWorkers:!0,workerScriptsPath:null,workerScripts:null};var Q,X,ee=K.TextWriter,te=K.BlobWriter,ne=K.Data64URIWriter,ie=K.TextReader,re=K.BlobReader,ae=K.Data64URIReader,oe=K.createReader,se=K.createWriter;function le(e){var t,n=this;n.size=0,n.init=function(t){n.size=e.uncompressedSize,t();},n.readUint8Array=function(i,r,a,o){!function(i){n.data?i():e.getData(new te,function(e){n.data=e,t=new re(e),i();},null,n.checkCrc32);}(function(){t.readUint8Array(i,r,a,o);});};}function fe(e){var t=0;return function e(n){t+=n.uncompressedSize||0,n.children.forEach(e);}(e),t}function ue(e,t,n){var i=0;function r(){++i<e.children.length?a(e.children[i]):t();}function a(e){e.directory?ue(e,r,n):(e.reader=new e.Reader(e.data,n),e.reader.init(function(){e.uncompressedSize=e.reader.size,r();}));}e.children.length?a(e.children[i]):t();}function de(e){var t=e.parent.children;t.forEach(function(n,i){n.id==e.id&&t.splice(i,1);});}function ce(e){e.entries=[],e.root=new we(e);}function _e(e,t,n,i){if(e.directory)return i?new we(e.fs,t,n,e):new pe(e.fs,t,n,e);throw "Parent entry is not a directory."}function he(){}function pe(e,t,n,i){var r=this;he.prototype.init.call(r,e,t,n,i),r.Reader=n.Reader,r.Writer=n.Writer,r.data=n.data,n.getData&&(r.getData=n.getData);}function we(e,t,n,i){he.prototype.init.call(this,e,t,n,i),this.directory=!0;}function ve(){ce(this);}(le.prototype=new(K.Reader)).constructor=le,le.prototype.checkCrc32=!1,(he.prototype={init:function(e,t,n,i){var r=this;if(e.root&&i&&i.getChildByName(t))throw "Entry filename already exists.";n||(n={}),r.fs=e,r.name=t,r.id=e.entries.length,r.parent=i,r.children=[],r.zipVersion=n.zipVersion||20,r.uncompressedSize=0,e.entries.push(r),i&&r.parent.children.push(r);},getFileEntry:function(e,t,n,i,r){var a=this;ue(a,function(){!function(e,t,n,i,r,a,o){var s=0;t.directory?function e(t,n,i,r,a,l){var f=0;!function u(){var d=n.children[f];d?function(n){function i(t){s+=n.uncompressedSize||0,e(t,n,function(){f++,u();},r,a,l);}n.directory?t.getDirectory(n.name,{create:!0},i,a):t.getFile(n.name,{create:!0},function(e){n.getData(new K.FileWriter(e,K.getMimeType(n.name)),i,function(e){r&&r(s+e,l);},o);},a);}(d):i();}();}(e,t,n,i,r,a):t.getData(new K.FileWriter(e,K.getMimeType(t.name)),n,i,o);}(e,a,t,n,i,fe(a),r);},i);},moveTo:function(e){var t=this;if(!e.directory)throw "Target entry is not a directory.";if(e.isDescendantOf(t))throw "Entry is a ancestor of target entry.";if(t!=e){if(e.getChildByName(t.name))throw "Entry filename already exists.";de(t),t.parent=e,e.children.push(t);}},getFullname:function(){for(var e=this.name,t=this.parent;t;)e=(t.name?t.name+"/":"")+e,t=t.parent;return e},isDescendantOf:function(e){for(var t=this.parent;t&&t.id!=e.id;)t=t.parent;return !!t}}).constructor=he,pe.prototype=Q=new he,Q.constructor=pe,Q.getData=function(e,t,n,i){var r=this;!e||e.constructor==r.Writer&&r.data?t(r.data):(r.reader||(r.reader=new r.Reader(r.data,i)),r.reader.init(function(){e.init(function(){!function(e,t,n,i,r){var a=0;!function o(){var s=524288*a;i&&i(s,e.size),s<e.size?e.readUint8Array(s,Math.min(524288,e.size-s),function(e){t.writeUint8Array(new Uint8Array(e),function(){a++,o();});},r):t.getData(n);}();}(r.reader,e,t,n,i);},i);}));},Q.getText=function(e,t,n,i){this.getData(new ee(i),e,t,n);},Q.getBlob=function(e,t,n,i){this.getData(new te(e),t,n,i);},Q.getData64URI=function(e,t,n,i){this.getData(new ne(e),t,n,i);},we.prototype=X=new he,X.constructor=we,X.addDirectory=function(e){return _e(this,e,null,!0)},X.addText=function(e,t){return _e(this,e,{data:t,Reader:ie,Writer:ee})},X.addBlob=function(e,t){return _e(this,e,{data:t,Reader:re,Writer:te})},X.addData64URI=function(e,t){return _e(this,e,{data:t,Reader:ae,Writer:ne})},X.addFileEntry=function(e,t,n){!function(e,t,n,i){t.isDirectory?function e(t,n,r){!function(e,t){e.isDirectory&&e.createReader().readEntries(t),e.isFile&&t([]);}(n,function(n){var a=0;!function o(){var s=n[a];s?function(n){function r(t){e(t,n,function(){a++,o();});}n.isDirectory&&r(t.addDirectory(n.name)),n.isFile&&n.file(function(e){var i=t.addBlob(n.name,e);i.uncompressedSize=e.size,r(i);},i);}(s):r();}();});}(e,t,n):t.file(function(i){e.addBlob(t.name,i),n();},i);}(this,e,t,n);},X.addData=function(e,t){return _e(this,e,t)},X.importBlob=function(e,t,n){this.importZip(new re(e),t,n);},X.importText=function(e,t,n){this.importZip(new ie(e),t,n);},X.importData64URI=function(e,t,n){this.importZip(new ae(e),t,n);},X.exportBlob=function(e,t,n){this.exportZip(new te("application/zip"),e,t,n);},X.exportText=function(e,t,n){this.exportZip(new ee,e,t,n);},X.exportFileEntry=function(e,t,n,i){this.exportZip(new K.FileWriter(e,"application/zip"),t,n,i);},X.exportData64URI=function(e,t,n){this.exportZip(new ne("application/zip"),e,t,n);},X.importZip=function(e,t,n){var i=this;oe(e,function(e){e.getEntries(function(e){e.forEach(function(e){var t=i,n=e.filename.split("/"),r=n.pop();n.forEach(function(e){t=t.getChildByName(e)||new we(i.fs,e,null,t);}),e.directory||_e(t,r,{data:e,Reader:le});}),t();});},n);},X.exportZip=function(e,t,n,i){var r=this;ue(r,function(){se(e,function(e){!function(e,t,n,i,r){var a=0;!function e(t,n,i,r,o){var s=0;!function l(){var f=n.children[s];f?t.add(f.getFullname(),f.reader,function(){a+=f.uncompressedSize||0,e(t,f,function(){s++,l();},r,o);},function(e){r&&r(a+e,o);},{directory:f.directory,version:f.zipVersion}):i();}();}(e,t,n,i,r);}(e,r,function(){e.close(t);},n,fe(r));},i);},i);},X.getChildByName=function(e){var t,n;for(t=0;t<this.children.length;t++)if((n=this.children[t]).name==e)return n},ve.prototype={remove:function(e){de(e),this.entries[e.id]=null;},find:function(e){var t,n=e.split("/"),i=this.root;for(t=0;i&&t<n.length;t++)i=i.getChildByName(n[t]);return i},getById:function(e){return this.entries[e]},importBlob:function(e,t,n){ce(this),this.root.importBlob(e,t,n);},importText:function(e,t,n){ce(this),this.root.importText(e,t,n);},importData64URI:function(e,t,n){ce(this),this.root.importData64URI(e,t,n);},exportBlob:function(e,t,n){this.root.exportBlob(e,t,n);},exportText:function(e,t,n){this.root.exportText(e,t,n);},exportFileEntry:function(e,t,n,i){this.root.exportFileEntry(e,t,n,i);},exportData64URI:function(e,t,n){this.root.exportData64URI(e,t,n);}},K.getMimeType=function(){return "application/octet-stream"};var be={FS:ve,ZipDirectoryEntry:we,ZipFileEntry:pe};K.useWebWorkers=!1;var xe=/*#__PURE__*/function(){function e(e,t){this.el=e,this.inputEl=t,this.listeners={drop:[],dropstart:[],droperror:[]},this._onDragover=this._onDragover.bind(this),this._onDrop=this._onDrop.bind(this),this._onSelect=this._onSelect.bind(this),e.addEventListener("dragover",this._onDragover,!1),e.addEventListener("drop",this._onDrop,!1),t.addEventListener("change",this._onSelect);}var t=e.prototype;return t.on=function(e,t){return this.listeners[e].push(t),this},t._emit=function(e,t){return this.listeners[e].forEach(function(e){return e(t)}),this},t.destroy=function(){var e=this.el,t=this.inputEl;e.removeEventListener("dragover",this._onDragover,!1),e.removeEventListener("drop",this._onDrop,!1),t.removeEventListener("change",this._onSelect),delete this.el,delete this.inputEl,delete this.listeners;},t._onDrop=function(e){e.stopPropagation(),e.preventDefault(),this._emit("dropstart");var t=Array.from(e.dataTransfer.files||[]),n=Array.from(e.dataTransfer.items||[]);if(0!==t.length||0!==n.length)if(n.length>0){var i=n.map(function(e){return e.webkitGetAsEntry()}).filter(function(e){return null!==e});i.length>0&&(i[0].name.match(/\.zip$/)?this._loadZip(n[0].getAsFile()):this._loadNextEntry(new Map,i));}else 1===t.length&&t[0].name.match(/\.zip$/)&&this._loadZip(t[0]),this._emit("drop",{files:new Map(t.map(function(e){return [e.name,e]}))});else this._fail("Required drag-and-drop APIs are not supported in this browser.");},t._onDragover=function(e){e.stopPropagation(),e.preventDefault(),e.dataTransfer.dropEffect="copy";},t._onSelect=function(e){this._emit("dropstart");var t=[].slice.call(this.inputEl.files);if(1===t.length&&this._isZip(t[0]))this._loadZip(t[0]);else {var n=new Map;t.forEach(function(e){return n.set(e.webkitRelativePath||e.name,e)}),this._emit("drop",{files:n});}},t._loadNextEntry=function(e,t){var n=this,i=t.pop();if(i)if(i.isFile)i.file(function(r){e.set(i.fullPath,r),n._loadNextEntry(e,t);},function(){return console.error("Could not load file: %s",i.fullPath)});else if(i.isDirectory){var r=i.createReader();r.readEntries(function i(a){a.length?(t=t.concat(a),r.readEntries(i)):n._loadNextEntry(e,t);});}else console.warn("Unknown asset type: "+i.fullPath),this._loadNextEntry(e,t);else this._emit("drop",{files:e});},t._loadZip=function(e){var t=this,n=[],i=new Map,r=new be.FS,a=function e(t){t.directory?t.children.forEach(e):"."!==t.name[0]&&n.push(new Promise(function(e){t.getData(new K.BlobWriter,function(n){n.name=t.name,i.set(t.getFullname(),n),e();});}));};r.importBlob(e,function(){a(r.root),Promise.all(n).then(function(){t._emit("drop",{files:i,archive:e});});});},t._isZip=function(e){return "application/zip"===e.type||e.name.match(/\.zip$/)},t._fail=function(e){this._emit("droperror",{message:e});},e}();

/**
 * Common utilities
 * @module glMatrix
 */
// Configuration Constants
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
if (!Math.hypot) Math.hypot = function () {
  var y = 0,
      i = arguments.length;

  while (i--) {
    y += arguments[i] * arguments[i];
  }

  return Math.sqrt(y);
};

/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */

function create() {
  var out = new ARRAY_TYPE(2);

  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }

  return out;
}
/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */

function fromValues(x, y) {
  var out = new ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return Math.hypot(x, y);
}
/**
 * Alias for {@link vec2.distance}
 * @function
 */

var dist = distance;
/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

(function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 2;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }

    return a;
  };
})();

function getDefaultExportFromCjs$1 (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			if (this instanceof a) {
        return Reflect.construct(f, arguments, this.constructor);
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

/**
 * Copyright 2004-present Facebook. All Rights Reserved.
 *
 * @providesModule UserAgent_DEPRECATED
 */

/**
 *  Provides entirely client-side User Agent and OS detection. You should prefer
 *  the non-deprecated UserAgent module when possible, which exposes our
 *  authoritative server-side PHP-based detection to the client.
 *
 *  Usage is straightforward:
 *
 *    if (UserAgent_DEPRECATED.ie()) {
 *      //  IE
 *    }
 *
 *  You can also do version checks:
 *
 *    if (UserAgent_DEPRECATED.ie() >= 7) {
 *      //  IE7 or better
 *    }
 *
 *  The browser functions will return NaN if the browser does not match, so
 *  you can also do version compares the other way:
 *
 *    if (UserAgent_DEPRECATED.ie() < 7) {
 *      //  IE6 or worse
 *    }
 *
 *  Note that the version is a float and may include a minor version number,
 *  so you should always use range operators to perform comparisons, not
 *  strict equality.
 *
 *  **Note:** You should **strongly** prefer capability detection to browser
 *  version detection where it's reasonable:
 *
 *    http://www.quirksmode.org/js/support.html
 *
 *  Further, we have a large number of mature wrapper functions and classes
 *  which abstract away many browser irregularities. Check the documentation,
 *  grep for things, or ask on javascript@lists.facebook.com before writing yet
 *  another copy of "event || window.event".
 *
 */

var _populated = false;

// Browsers
var _ie, _firefox, _opera, _webkit, _chrome;

// Actual IE browser for compatibility mode
var _ie_real_version;

// Platforms
var _osx, _windows, _linux, _android;

// Architectures
var _win64;

// Devices
var _iphone, _ipad, _native;

var _mobile;

function _populate() {
  if (_populated) {
    return;
  }

  _populated = true;

  // To work around buggy JS libraries that can't handle multi-digit
  // version numbers, Opera 10's user agent string claims it's Opera
  // 9, then later includes a Version/X.Y field:
  //
  // Opera/9.80 (foo) Presto/2.2.15 Version/10.10
  var uas = navigator.userAgent;
  var agent = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(uas);
  var os    = /(Mac OS X)|(Windows)|(Linux)/.exec(uas);

  _iphone = /\b(iPhone|iP[ao]d)/.exec(uas);
  _ipad = /\b(iP[ao]d)/.exec(uas);
  _android = /Android/i.exec(uas);
  _native = /FBAN\/\w+;/i.exec(uas);
  _mobile = /Mobile/i.exec(uas);

  // Note that the IE team blog would have you believe you should be checking
  // for 'Win64; x64'.  But MSDN then reveals that you can actually be coming
  // from either x64 or ia64;  so ultimately, you should just check for Win64
  // as in indicator of whether you're in 64-bit IE.  32-bit IE on 64-bit
  // Windows will send 'WOW64' instead.
  _win64 = !!(/Win64/.exec(uas));

  if (agent) {
    _ie = agent[1] ? parseFloat(agent[1]) : (
          agent[5] ? parseFloat(agent[5]) : NaN);
    // IE compatibility mode
    if (_ie && document && document.documentMode) {
      _ie = document.documentMode;
    }
    // grab the "true" ie version from the trident token if available
    var trident = /(?:Trident\/(\d+.\d+))/.exec(uas);
    _ie_real_version = trident ? parseFloat(trident[1]) + 4 : _ie;

    _firefox = agent[2] ? parseFloat(agent[2]) : NaN;
    _opera   = agent[3] ? parseFloat(agent[3]) : NaN;
    _webkit  = agent[4] ? parseFloat(agent[4]) : NaN;
    if (_webkit) {
      // We do not add the regexp to the above test, because it will always
      // match 'safari' only since 'AppleWebKit' appears before 'Chrome' in
      // the userAgent string.
      agent = /(?:Chrome\/(\d+\.\d+))/.exec(uas);
      _chrome = agent && agent[1] ? parseFloat(agent[1]) : NaN;
    } else {
      _chrome = NaN;
    }
  } else {
    _ie = _firefox = _opera = _chrome = _webkit = NaN;
  }

  if (os) {
    if (os[1]) {
      // Detect OS X version.  If no version number matches, set _osx to true.
      // Version examples:  10, 10_6_1, 10.7
      // Parses version number as a float, taking only first two sets of
      // digits.  If only one set of digits is found, returns just the major
      // version number.
      var ver = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(uas);

      _osx = ver ? parseFloat(ver[1].replace('_', '.')) : true;
    } else {
      _osx = false;
    }
    _windows = !!os[2];
    _linux   = !!os[3];
  } else {
    _osx = _windows = _linux = false;
  }
}

var UserAgent_DEPRECATED$1 = {

  /**
   *  Check if the UA is Internet Explorer.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
  ie: function() {
    return _populate() || _ie;
  },

  /**
   * Check if we're in Internet Explorer compatibility mode.
   *
   * @return bool true if in compatibility mode, false if
   * not compatibility mode or not ie
   */
  ieCompatibilityMode: function() {
    return _populate() || (_ie_real_version > _ie);
  },


  /**
   * Whether the browser is 64-bit IE.  Really, this is kind of weak sauce;  we
   * only need this because Skype can't handle 64-bit IE yet.  We need to remove
   * this when we don't need it -- tracked by #601957.
   */
  ie64: function() {
    return UserAgent_DEPRECATED$1.ie() && _win64;
  },

  /**
   *  Check if the UA is Firefox.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
  firefox: function() {
    return _populate() || _firefox;
  },


  /**
   *  Check if the UA is Opera.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
  opera: function() {
    return _populate() || _opera;
  },


  /**
   *  Check if the UA is WebKit.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
  webkit: function() {
    return _populate() || _webkit;
  },

  /**
   *  For Push
   *  WILL BE REMOVED VERY SOON. Use UserAgent_DEPRECATED.webkit
   */
  safari: function() {
    return UserAgent_DEPRECATED$1.webkit();
  },

  /**
   *  Check if the UA is a Chrome browser.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
  chrome : function() {
    return _populate() || _chrome;
  },


  /**
   *  Check if the user is running Windows.
   *
   *  @return bool `true' if the user's OS is Windows.
   */
  windows: function() {
    return _populate() || _windows;
  },


  /**
   *  Check if the user is running Mac OS X.
   *
   *  @return float|bool   Returns a float if a version number is detected,
   *                       otherwise true/false.
   */
  osx: function() {
    return _populate() || _osx;
  },

  /**
   * Check if the user is running Linux.
   *
   * @return bool `true' if the user's OS is some flavor of Linux.
   */
  linux: function() {
    return _populate() || _linux;
  },

  /**
   * Check if the user is running on an iPhone or iPod platform.
   *
   * @return bool `true' if the user is running some flavor of the
   *    iPhone OS.
   */
  iphone: function() {
    return _populate() || _iphone;
  },

  mobile: function() {
    return _populate() || (_iphone || _ipad || _android || _mobile);
  },

  nativeApp: function() {
    // webviews inside of the native apps
    return _populate() || _native;
  },

  android: function() {
    return _populate() || _android;
  },

  ipad: function() {
    return _populate() || _ipad;
  }
};

var UserAgent_DEPRECATED_1 = UserAgent_DEPRECATED$1;

/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ExecutionEnvironment
 */

var canUseDOM = !!(
  typeof window !== 'undefined' &&
  window.document &&
  window.document.createElement
);

/**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */
var ExecutionEnvironment$1 = {

  canUseDOM: canUseDOM,

  canUseWorkers: typeof Worker !== 'undefined',

  canUseEventListeners:
    canUseDOM && !!(window.addEventListener || window.attachEvent),

  canUseViewport: canUseDOM && !!window.screen,

  isInWorker: !canUseDOM // For now, this is true - might change in the future.

};

var ExecutionEnvironment_1 = ExecutionEnvironment$1;

/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule isEventSupported
 */

var ExecutionEnvironment = ExecutionEnvironment_1;

var useHasFeature;
if (ExecutionEnvironment.canUseDOM) {
  useHasFeature =
    document.implementation &&
    document.implementation.hasFeature &&
    // always returns true in newer browsers as per the standard.
    // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
    document.implementation.hasFeature('', '') !== true;
}

/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function isEventSupported$1(eventNameSuffix, capture) {
  if (!ExecutionEnvironment.canUseDOM ||
      capture && !('addEventListener' in document)) {
    return false;
  }

  var eventName = 'on' + eventNameSuffix;
  var isSupported = eventName in document;

  if (!isSupported) {
    var element = document.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
    // This is the only way to test support for the `wheel` event in IE9+.
    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
  }

  return isSupported;
}

var isEventSupported_1 = isEventSupported$1;

/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule normalizeWheel
 * @typechecks
 */

var UserAgent_DEPRECATED = UserAgent_DEPRECATED_1;

var isEventSupported = isEventSupported_1;


// Reasonable defaults
var PIXEL_STEP  = 10;
var LINE_HEIGHT = 40;
var PAGE_HEIGHT = 800;

/**
 * Mouse wheel (and 2-finger trackpad) support on the web sucks.  It is
 * complicated, thus this doc is long and (hopefully) detailed enough to answer
 * your questions.
 *
 * If you need to react to the mouse wheel in a predictable way, this code is
 * like your bestest friend. * hugs *
 *
 * As of today, there are 4 DOM event types you can listen to:
 *
 *   'wheel'                -- Chrome(31+), FF(17+), IE(9+)
 *   'mousewheel'           -- Chrome, IE(6+), Opera, Safari
 *   'MozMousePixelScroll'  -- FF(3.5 only!) (2010-2013) -- don't bother!
 *   'DOMMouseScroll'       -- FF(0.9.7+) since 2003
 *
 * So what to do?  The is the best:
 *
 *   normalizeWheel.getEventType();
 *
 * In your event callback, use this code to get sane interpretation of the
 * deltas.  This code will return an object with properties:
 *
 *   spinX   -- normalized spin speed (use for zoom) - x plane
 *   spinY   -- " - y plane
 *   pixelX  -- normalized distance (to pixels) - x plane
 *   pixelY  -- " - y plane
 *
 * Wheel values are provided by the browser assuming you are using the wheel to
 * scroll a web page by a number of lines or pixels (or pages).  Values can vary
 * significantly on different platforms and browsers, forgetting that you can
 * scroll at different speeds.  Some devices (like trackpads) emit more events
 * at smaller increments with fine granularity, and some emit massive jumps with
 * linear speed or acceleration.
 *
 * This code does its best to normalize the deltas for you:
 *
 *   - spin is trying to normalize how far the wheel was spun (or trackpad
 *     dragged).  This is super useful for zoom support where you want to
 *     throw away the chunky scroll steps on the PC and make those equal to
 *     the slow and smooth tiny steps on the Mac. Key data: This code tries to
 *     resolve a single slow step on a wheel to 1.
 *
 *   - pixel is normalizing the desired scroll delta in pixel units.  You'll
 *     get the crazy differences between browsers, but at least it'll be in
 *     pixels!
 *
 *   - positive value indicates scrolling DOWN/RIGHT, negative UP/LEFT.  This
 *     should translate to positive value zooming IN, negative zooming OUT.
 *     This matches the newer 'wheel' event.
 *
 * Why are there spinX, spinY (or pixels)?
 *
 *   - spinX is a 2-finger side drag on the trackpad, and a shift + wheel turn
 *     with a mouse.  It results in side-scrolling in the browser by default.
 *
 *   - spinY is what you expect -- it's the classic axis of a mouse wheel.
 *
 *   - I dropped spinZ/pixelZ.  It is supported by the DOM 3 'wheel' event and
 *     probably is by browsers in conjunction with fancy 3D controllers .. but
 *     you know.
 *
 * Implementation info:
 *
 * Examples of 'wheel' event if you scroll slowly (down) by one step with an
 * average mouse:
 *
 *   OS X + Chrome  (mouse)     -    4   pixel delta  (wheelDelta -120)
 *   OS X + Safari  (mouse)     -  N/A   pixel delta  (wheelDelta  -12)
 *   OS X + Firefox (mouse)     -    0.1 line  delta  (wheelDelta  N/A)
 *   Win8 + Chrome  (mouse)     -  100   pixel delta  (wheelDelta -120)
 *   Win8 + Firefox (mouse)     -    3   line  delta  (wheelDelta -120)
 *
 * On the trackpad:
 *
 *   OS X + Chrome  (trackpad)  -    2   pixel delta  (wheelDelta   -6)
 *   OS X + Firefox (trackpad)  -    1   pixel delta  (wheelDelta  N/A)
 *
 * On other/older browsers.. it's more complicated as there can be multiple and
 * also missing delta values.
 *
 * The 'wheel' event is more standard:
 *
 * http://www.w3.org/TR/DOM-Level-3-Events/#events-wheelevents
 *
 * The basics is that it includes a unit, deltaMode (pixels, lines, pages), and
 * deltaX, deltaY and deltaZ.  Some browsers provide other values to maintain
 * backward compatibility with older events.  Those other values help us
 * better normalize spin speed.  Example of what the browsers provide:
 *
 *                          | event.wheelDelta | event.detail
 *        ------------------+------------------+--------------
 *          Safari v5/OS X  |       -120       |       0
 *          Safari v5/Win7  |       -120       |       0
 *         Chrome v17/OS X  |       -120       |       0
 *         Chrome v17/Win7  |       -120       |       0
 *                IE9/Win7  |       -120       |   undefined
 *         Firefox v4/OS X  |     undefined    |       1
 *         Firefox v4/Win7  |     undefined    |       3
 *
 */
function normalizeWheel$2(/*object*/ event) /*object*/ {
  var sX = 0, sY = 0,       // spinX, spinY
      pX = 0, pY = 0;       // pixelX, pixelY

  // Legacy
  if ('detail'      in event) { sY = event.detail; }
  if ('wheelDelta'  in event) { sY = -event.wheelDelta / 120; }
  if ('wheelDeltaY' in event) { sY = -event.wheelDeltaY / 120; }
  if ('wheelDeltaX' in event) { sX = -event.wheelDeltaX / 120; }

  // side scrolling on FF with DOMMouseScroll
  if ( 'axis' in event && event.axis === event.HORIZONTAL_AXIS ) {
    sX = sY;
    sY = 0;
  }

  pX = sX * PIXEL_STEP;
  pY = sY * PIXEL_STEP;

  if ('deltaY' in event) { pY = event.deltaY; }
  if ('deltaX' in event) { pX = event.deltaX; }

  if ((pX || pY) && event.deltaMode) {
    if (event.deltaMode == 1) {          // delta in LINE units
      pX *= LINE_HEIGHT;
      pY *= LINE_HEIGHT;
    } else {                             // delta in PAGE units
      pX *= PAGE_HEIGHT;
      pY *= PAGE_HEIGHT;
    }
  }

  // Fall-back if spin cannot be determined
  if (pX && !sX) { sX = (pX < 1) ? -1 : 1; }
  if (pY && !sY) { sY = (pY < 1) ? -1 : 1; }

  return { spinX  : sX,
           spinY  : sY,
           pixelX : pX,
           pixelY : pY };
}


/**
 * The best combination if you prefer spinX + spinY normalization.  It favors
 * the older DOMMouseScroll for Firefox, as FF does not include wheelDelta with
 * 'wheel' event, making spin speed determination impossible.
 */
normalizeWheel$2.getEventType = function() /*string*/ {
  return (UserAgent_DEPRECATED.firefox())
           ? 'DOMMouseScroll'
           : (isEventSupported('wheel'))
               ? 'wheel'
               : 'mousewheel';
};

var normalizeWheel_1 = normalizeWheel$2;

var normalizeWheel = normalizeWheel_1;

var normalizeWheel$1 = /*@__PURE__*/getDefaultExportFromCjs$1(normalizeWheel);

// this class wraps all the observables for the gltf sample viewer state
// the data streams coming out of this should match the data required in GltfState
// as close as possible
class UIModel
{
    constructor(app, modelPathProvider, environments) {
        this.app = app;

        this.app.models = modelPathProvider.getAllKeys();

        const queryString = window.location.search;
        const urlParams = new URLSearchParams(queryString);
        const modelURL = urlParams.get("model");

        this.scene = app.sceneChanged.pipe();
        this.camera = app.cameraChanged.pipe();
        this.environmentRotation = app.environmentRotationChanged.pipe();
        this.app.environments = environments;
        const selectedEnvironment = app.selectedEnvironmentChanged.pipe(
            map(environmentName => this.app.environments[environmentName])
        );
        const initialEnvironment = "Cannon_Exterior";
        this.app.selectedEnvironment = initialEnvironment;

        this.app.tonemaps = Object.keys(GltfState.ToneMaps).map((key) => ({title: GltfState.ToneMaps[key]}));
        this.tonemap = app.tonemapChanged.pipe(
            startWith(GltfState.ToneMaps.KHR_PBR_NEUTRAL)
        );

        this.app.debugchannels = Object.keys(GltfState.DebugOutput).map((key) => ({title: GltfState.DebugOutput[key]}));
        this.debugchannel = app.debugchannelChanged.pipe(
            startWith(GltfState.DebugOutput.NONE)
        );

        this.exposure = app.exposureChanged.pipe();
        this.skinningEnabled = app.skinningChanged.pipe();
        this.morphingEnabled = app.morphingChanged.pipe();
        this.clearcoatEnabled = app.clearcoatChanged.pipe();
        this.sheenEnabled = app.sheenChanged.pipe();
        this.transmissionEnabled = app.transmissionChanged.pipe();
        this.diffuseTransmissionEnabled = app.diffuseTransmissionChanged.pipe();
        this.volumeEnabled = app.volumeChanged.pipe();
        this.iorEnabled = app.iorChanged.pipe();
        this.iridescenceEnabled = app.iridescenceChanged.pipe();
        this.anisotropyEnabled = app.anisotropyChanged.pipe();
        this.dispersionEnabled = app.dispersionChanged.pipe();
        this.specularEnabled = app.specularChanged.pipe();
        this.emissiveStrengthEnabled = app.emissiveStrengthChanged.pipe();
        this.iblEnabled = app.iblChanged.pipe();
        this.iblIntensity = app.iblIntensityChanged.pipe();
        this.punctualLightsEnabled = app.punctualLightsChanged.pipe();
        this.renderEnvEnabled = app.renderEnvChanged.pipe();
        this.blurEnvEnabled = app.blurEnvChanged.pipe();
        this.addEnvironment = app.addEnvironmentChanged.pipe();
        this.captureCanvas = app.captureCanvas.pipe();
        this.cameraValuesExport = app.cameraExport.pipe();

        const initialClearColor = "#303542";
        this.app.clearColor = initialClearColor;
        this.clearColor = app.colorChanged.pipe(
            startWith(initialClearColor),
            map(hex => /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex)),
            filter(color => color !== null),
            map(color => [
                parseInt(color[1], 16) / 255.0,
                parseInt(color[2], 16) / 255.0,
                parseInt(color[3], 16) / 255.0,
                1.0
            ])
        );

        this.animationPlay = app.animationPlayChanged.pipe();
        this.activeAnimations = app.selectedAnimationsChanged.pipe();

        const canvas = document.getElementById("canvas");
        canvas.addEventListener('dragenter', () => this.app.showDropDownOverlay = true);
        canvas.addEventListener('dragleave', () => this.app.showDropDownOverlay = false);

        const inputObservables = getInputObservables(canvas, this.app);

        const dropdownGltfChanged = app.modelChanged.pipe(
            startWith(modelURL === null ? "DamagedHelmet" : null),
            filter(value => value !== null),
            map(value => {
                app.flavours = modelPathProvider.getModelFlavours(value);
                if (app.flavours.includes("glTF")){
                    app.selectedFlavour = "glTF";
                } else {
                    app.selectedFlavour = app.flavours[0];
                }
                return modelPathProvider.resolve(value, app.selectedFlavour);
            }),
            map(value => ({mainFile: value})),
        );

        const dropdownFlavourChanged = app.flavourChanged.pipe(
            map(value => modelPathProvider.resolve(app.selectedModel, value)),
            map(value => ({mainFile: value})),
        );

        this.model = merge$1(dropdownGltfChanged, dropdownFlavourChanged, inputObservables.droppedGltf);

        this.hdr = merge$1(selectedEnvironment, this.addEnvironment, inputObservables.droppedHdr).pipe(
            startWith(environments[initialEnvironment])
        );

        this.hdr.subscribe(async hdr => {
            if (hdr.license_path !== undefined) {
                try {
                    const response = await fetch(hdr.license_path);
                    if (!response.ok) {
                        throw new Error("License file not found");
                    }
                    let text = await response.text();
                    const license = text.split("SPDX-License-Identifier: ")[1];
                    console.log(license);
                    text = text.replace("SPDX-FileCopyrightText: ", "");
                    text = text.replace(/SPDX-License-Identifier:(.)*/g, `, <a href="${hdr.hdr_path}">Source</a>, License: `);
                    text += `<a href="${hdr.base_path}/LICENSES/${license}.txt">${license}</a>`;
                    text = "(c) " + text;
                    text = text.replaceAll("\n","");
                    text = text.replaceAll(" ,", ",");
                    this.app.environmentLicense = text;
                } catch (error) {
                    this.app.environmentLicense = "N/A";
                }
                
            } else {
                this.app.environmentLicense = "N/A";
            }
        });

        merge$1(this.addEnvironment, inputObservables.droppedHdr)
            .subscribe(hdr => {
                const hdrPath = hdr.hdr_path;
                this.app.environments[hdrPath.name] = {
                    title: hdrPath.name,
                    hdr_path: hdrPath,
                };
                this.app.selectedEnvironment = hdrPath.name;
            });

        this.variant = app.variantChanged.pipe();

        // remove last filename
        this.model
            .pipe(filter(() => this.app.models.at(-1) === this.lastDroppedFilename))
            .subscribe(() => {
                this.app.models.pop();
                this.lastDroppedFilename = undefined;
            });

        let droppedGLtfFileName = inputObservables.droppedGltf.pipe(map(droppedGltf => droppedGltf.mainFile.name));

        if (modelURL !== null) {
            const loadFromUrlObservable = new Observable(subscriber => subscriber.next({mainFile: modelURL}));
            droppedGLtfFileName = merge$1(droppedGLtfFileName, loadFromUrlObservable.pipe(map(data => data.mainFile)));
            this.model = merge$1(this.model, loadFromUrlObservable);
        }

        droppedGLtfFileName
            .pipe(filter(filename => filename !== undefined))
            .subscribe(filename => {
                filename = filename.split('/').pop();
                const fileExtension = filename.split('.').pop();
                filename = filename.substr(0, filename.lastIndexOf('.'));

                this.app.models.push(filename);
                this.app.selectedModel = filename;
                this.lastDroppedFilename = filename;

                app.flavours = [fileExtension];
                app.selectedFlavour = fileExtension;
            });

        this.orbit = inputObservables.orbit;
        this.pan = inputObservables.pan;
        this.zoom = inputObservables.zoom;
    }

    attachGltfLoaded(gltfLoaded)
    {
        this.attachCameraChangeObservable(gltfLoaded);
        gltfLoaded.subscribe(state => {
            const gltf = state.gltf;

            this.app.assetCopyright = gltf.asset.copyright ?? "N/A";
            this.app.assetGenerator = gltf.asset.generator ?? "N/A";
            
            this.app.selectedScene = state.sceneIndex;
            this.app.scenes = gltf.scenes.map((scene, index) => ({
                title: scene.name ?? `Scene ${index}`,
                index: index
            }));

            this.app.selectedAnimations = state.animationIndices;

            if (gltf && gltf.variants) {
                this.app.materialVariants = ["None", ...gltf.variants.map(variant => variant.name)];
            } else {
                this.app.materialVariants = ["None"];
            }

            this.app.setAnimationState(true);
            this.app.animations = gltf.animations.map((animation, index) => ({
                title: animation.name ?? `Animation ${index}`,
                index: index
            }));

            this.app.xmp = gltf?.extensions?.KHR_xmp_json_ld?.packets[gltf?.asset?.extensions?.KHR_xmp_json_ld.packet] ?? null;
        });
    }

    updateStatistics(statisticsUpdateObservable)
    {
        statisticsUpdateObservable.subscribe(
            data => this.app.statistics = {
                "Mesh Count": data.meshCount,
                "Triangle Count": data.faceCount,
                "Opaque Material Count": data.opaqueMaterialsCount,
                "Transparent Material Count": data.transparentMaterialsCount
            }
        );
    }

    updateValidationReport(validationReportObservable)
    {
        validationReportObservable.subscribe(data => this.app.validationReport = data);
    }

    disabledAnimations(disabledAnimationsObservable)
    {
        disabledAnimationsObservable.subscribe(data => this.app.disabledAnimations = data);
    }

    attachCameraChangeObservable(sceneChangeObservable)
    {
        const cameraIndices = sceneChangeObservable.pipe(
            map(state => {
                let gltf = state.gltf;
                let cameraIndices = [{title: "User Camera", index: -1}];
                if (gltf.scenes[state.sceneIndex] !== undefined)
                {
                    cameraIndices.push(...gltf.cameras.map( (camera, index) => {
                        if(gltf.scenes[state.sceneIndex].includesNode(gltf, camera.node))
                        {
                            let name = camera.name;
                            if(name === "" || name === undefined)
                            {
                                name = index;
                            }
                            return {title: name, index: index};
                        }
                    }));
                }
                cameraIndices = cameraIndices.filter(function(el) {
                    return el !== undefined;
                });
                return cameraIndices;
            })
        );
        cameraIndices.subscribe(cameras => this.app.cameras = cameras);
        const loadedCameraIndex = sceneChangeObservable.pipe(map(state => state.cameraIndex));
        loadedCameraIndex.subscribe(index => this.app.selectedCamera = index !== undefined ? index : -1 );
    }

    goToLoadingState() {
        this.app.goToLoadingState();
    }

    exitLoadingState()
    {
        this.app.exitLoadingState();
    }
}

const getInputObservables = (inputElement, app) => {
    const observables = {};
    
    const droppedFiles = new Observable(subscriber => {
        const dropZone = new xe(inputElement, inputElement);
        dropZone.on('drop', ({files}) => {
            app.showDropDownOverlay = false;
            subscriber.next(Array.from(files.entries()));
        });
        dropZone.on('droperror', () => {
            app.showDropDownOverlay = false;
            subscriber.error();
        });
    }).pipe(share());

    // Partition files into a .gltf or .glb and additional files like buffers and textures
    observables.droppedGltf = droppedFiles.pipe(
        map(files => ({
            mainFile: files.find(([path]) => path.endsWith(".glb") || path.endsWith(".gltf")),
            additionalFiles: files.filter(file => !file[0].endsWith(".glb") && !file[0].endsWith(".gltf"))
        })),
        filter(files => files.mainFile !== undefined),
    );

    observables.droppedHdr = droppedFiles.pipe(
        map(files => files.find(([path]) => path.endsWith(".hdr"))),
        filter(file => file !== undefined),
        pluck("1"),
        map(file => ({hdr_path: file}))
    );

    const mouseMove = fromEvent(document, 'mousemove');
    const mouseDown = fromEvent(inputElement, 'mousedown');
    const mouseUp = merge$1(fromEvent(document, 'mouseup'), fromEvent(document, 'mouseleave'));
    
    inputElement.addEventListener('mousemove', event => event.preventDefault());
    inputElement.addEventListener('mousedown', event => event.preventDefault());
    inputElement.addEventListener('mouseup', event => event.preventDefault());

    const mouseOrbit = mouseDown.pipe(
        filter(event => event.button === 0 && event.shiftKey === false),
        mergeMap(() => mouseMove.pipe(
            pairwise(),
            map( ([oldMouse, newMouse]) => {
                return {
                    deltaPhi: newMouse.pageX - oldMouse.pageX, 
                    deltaTheta: newMouse.pageY - oldMouse.pageY 
                };
            }),
            takeUntil(mouseUp)
        ))
    );

    const mousePan = mouseDown.pipe(
        filter( event => event.button === 1 || event.shiftKey === true),
        mergeMap(() => mouseMove.pipe(
            pairwise(),
            map( ([oldMouse, newMouse]) => {
                return {
                    deltaX: newMouse.pageX - oldMouse.pageX, 
                    deltaY: newMouse.pageY - oldMouse.pageY 
                };
            }),
            takeUntil(mouseUp)
        ))
    );

    const dragZoom = mouseDown.pipe(
        filter( event => event.button === 2),
        mergeMap(() => mouseMove.pipe(takeUntil(mouseUp))),
        map( mouse => ({deltaZoom: mouse.movementY}))
    );
    const wheelZoom = fromEvent(inputElement, 'wheel').pipe(
        map(wheelEvent => normalizeWheel$1(wheelEvent)),
        map(normalizedZoom => ({deltaZoom: normalizedZoom.spinY }))
    );
    inputElement.addEventListener('scroll', event => event.preventDefault(), { passive: false });
    inputElement.addEventListener('wheel', event => event.preventDefault(), { passive: false });
    const mouseZoom = merge$1(dragZoom, wheelZoom);

    const touchmove = fromEvent(document, 'touchmove');
    const touchstart = fromEvent(inputElement, 'touchstart');
    const touchend = merge$1(fromEvent(inputElement, 'touchend'), fromEvent(inputElement, 'touchcancel'));

    const touchOrbit = touchstart.pipe(
        filter(event => event.touches.length === 1),
        mergeMap(() => touchmove.pipe(
            filter(event => event.touches.length === 1),
            map(event => event.touches[0]),
            pairwise(),
            map(([oldTouch, newTouch]) => {
                return {
                    deltaPhi: 2.0 * (newTouch.clientX - oldTouch.clientX),
                    deltaTheta: 2.0 * (newTouch.clientY - oldTouch.clientY),
                };
            }),
            takeUntil(touchend)
        )),
    );

    const touchZoom = touchstart.pipe(
        filter(event => event.touches.length === 2),
        mergeMap(() => touchmove.pipe(
            filter(event => event.touches.length === 2),
            map(event => {
                const pos1 = fromValues(event.touches[0].clientX, event.touches[0].clientY);
                const pos2 = fromValues(event.touches[1].clientX, event.touches[1].clientY);
                return dist(pos1, pos2);
            }),
            pairwise(),
            map(([oldDist, newDist]) => ({ deltaZoom: 0.1 * (oldDist - newDist) })),
            takeUntil(touchend))
        ),
    );

    inputElement.addEventListener('ontouchmove', event => event.preventDefault(), { passive: false });
    inputElement.addEventListener('ontouchstart', event => event.preventDefault(), { passive: false });
    inputElement.addEventListener('ontouchend', event => event.preventDefault(), { passive: false });

    observables.orbit = merge$1(mouseOrbit, touchOrbit);
    observables.pan = mousePan;
    observables.zoom = merge$1(mouseZoom, touchZoom);

    // disable context menu
    inputElement.oncontextmenu = () => false;

    return observables;
};

var vue_cjs = {};

/**
* @vue/shared v3.5.10
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function makeMap(str) {
  const map = /* @__PURE__ */ Object.create(null);
  for (const key of str.split(",")) map[key] = 1;
  return (val) => val in map;
}

const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el) => {
  const i = arr.indexOf(el);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty$1 = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty$1.call(val, key);
const isArray = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isDate = (val) => toTypeString(val) === "[object Date]";
const isRegExp = (val) => toTypeString(val) === "[object RegExp]";
const isFunction = (val) => typeof val === "function";
const isString = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject$1 = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return (isObject$1(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const isBuiltInDirective = /* @__PURE__ */ makeMap(
  "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
);
const cacheStringFunction$1 = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
const camelizeRE$1 = /-(\w)/g;
const camelize$1 = cacheStringFunction$1(
  (str) => {
    return str.replace(camelizeRE$1, (_, c) => c ? c.toUpperCase() : "");
  }
);
const hyphenateRE$1 = /\B([A-Z])/g;
const hyphenate$1 = cacheStringFunction$1(
  (str) => str.replace(hyphenateRE$1, "-$1").toLowerCase()
);
const capitalize$1 = cacheStringFunction$1((str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
const toHandlerKey$1 = cacheStringFunction$1(
  (str) => {
    const s = str ? `on${capitalize$1(str)}` : ``;
    return s;
  }
);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, ...arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](...arg);
  }
};
const def = (obj, key, value, writable = false) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    writable,
    value
  });
};
const looseToNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
const toNumber = (val) => {
  const n = isString(val) ? Number(val) : NaN;
  return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
const identRE = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
function genPropsAccessExp(name) {
  return identRE.test(name) ? `__props.${name}` : `__props[${JSON.stringify(name)}]`;
}
function genCacheKey(source, options) {
  return source + JSON.stringify(
    options,
    (_, val) => typeof val === "function" ? val.toString() : val
  );
}

const PatchFlags = {
  "TEXT": 1,
  "1": "TEXT",
  "CLASS": 2,
  "2": "CLASS",
  "STYLE": 4,
  "4": "STYLE",
  "PROPS": 8,
  "8": "PROPS",
  "FULL_PROPS": 16,
  "16": "FULL_PROPS",
  "NEED_HYDRATION": 32,
  "32": "NEED_HYDRATION",
  "STABLE_FRAGMENT": 64,
  "64": "STABLE_FRAGMENT",
  "KEYED_FRAGMENT": 128,
  "128": "KEYED_FRAGMENT",
  "UNKEYED_FRAGMENT": 256,
  "256": "UNKEYED_FRAGMENT",
  "NEED_PATCH": 512,
  "512": "NEED_PATCH",
  "DYNAMIC_SLOTS": 1024,
  "1024": "DYNAMIC_SLOTS",
  "DEV_ROOT_FRAGMENT": 2048,
  "2048": "DEV_ROOT_FRAGMENT",
  "CACHED": -1,
  "-1": "CACHED",
  "BAIL": -2,
  "-2": "BAIL"
};
const PatchFlagNames = {
  [1]: `TEXT`,
  [2]: `CLASS`,
  [4]: `STYLE`,
  [8]: `PROPS`,
  [16]: `FULL_PROPS`,
  [32]: `NEED_HYDRATION`,
  [64]: `STABLE_FRAGMENT`,
  [128]: `KEYED_FRAGMENT`,
  [256]: `UNKEYED_FRAGMENT`,
  [512]: `NEED_PATCH`,
  [1024]: `DYNAMIC_SLOTS`,
  [2048]: `DEV_ROOT_FRAGMENT`,
  [-1]: `HOISTED`,
  [-2]: `BAIL`
};

const ShapeFlags = {
  "ELEMENT": 1,
  "1": "ELEMENT",
  "FUNCTIONAL_COMPONENT": 2,
  "2": "FUNCTIONAL_COMPONENT",
  "STATEFUL_COMPONENT": 4,
  "4": "STATEFUL_COMPONENT",
  "TEXT_CHILDREN": 8,
  "8": "TEXT_CHILDREN",
  "ARRAY_CHILDREN": 16,
  "16": "ARRAY_CHILDREN",
  "SLOTS_CHILDREN": 32,
  "32": "SLOTS_CHILDREN",
  "TELEPORT": 64,
  "64": "TELEPORT",
  "SUSPENSE": 128,
  "128": "SUSPENSE",
  "COMPONENT_SHOULD_KEEP_ALIVE": 256,
  "256": "COMPONENT_SHOULD_KEEP_ALIVE",
  "COMPONENT_KEPT_ALIVE": 512,
  "512": "COMPONENT_KEPT_ALIVE",
  "COMPONENT": 6,
  "6": "COMPONENT"
};

const SlotFlags = {
  "STABLE": 1,
  "1": "STABLE",
  "DYNAMIC": 2,
  "2": "DYNAMIC",
  "FORWARDED": 3,
  "3": "FORWARDED"
};
const slotFlagsText = {
  [1]: "STABLE",
  [2]: "DYNAMIC",
  [3]: "FORWARDED"
};

const GLOBALS_ALLOWED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol";
const isGloballyAllowed = /* @__PURE__ */ makeMap(GLOBALS_ALLOWED);
const isGloballyWhitelisted = isGloballyAllowed;

const range = 2;
function generateCodeFrame(source, start = 0, end = source.length) {
  start = Math.max(0, Math.min(start, source.length));
  end = Math.max(0, Math.min(end, source.length));
  if (start > end) return "";
  let lines = source.split(/(\r?\n)/);
  const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);
  lines = lines.filter((_, idx) => idx % 2 === 0);
  let count = 0;
  const res = [];
  for (let i = 0; i < lines.length; i++) {
    count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);
    if (count >= start) {
      for (let j = i - range; j <= i + range || end > count; j++) {
        if (j < 0 || j >= lines.length) continue;
        const line = j + 1;
        res.push(
          `${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`
        );
        const lineLength = lines[j].length;
        const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;
        if (j === i) {
          const pad = start - (count - (lineLength + newLineSeqLength));
          const length = Math.max(
            1,
            end > count ? lineLength - pad : end - start
          );
          res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
        } else if (j > i) {
          if (end > count) {
            const length = Math.max(Math.min(end - count, lineLength), 1);
            res.push(`   |  ` + "^".repeat(length));
          }
          count += lineLength + newLineSeqLength;
        }
      }
      break;
    }
  }
  return res.join("\n");
}

function normalizeStyle(value) {
  if (isArray(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString(value) || isObject$1(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function stringifyStyle(styles) {
  let ret = "";
  if (!styles || isString(styles)) {
    return ret;
  }
  for (const key in styles) {
    const value = styles[key];
    if (isString(value) || typeof value === "number") {
      const normalizedKey = key.startsWith(`--`) ? key : hyphenate$1(key);
      ret += `${normalizedKey}:${value};`;
    }
  }
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString(value)) {
    res = value;
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$1(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
function normalizeProps(props) {
  if (!props) return null;
  let { class: klass, style } = props;
  if (klass && !isString(klass)) {
    props.class = normalizeClass(klass);
  }
  if (style) {
    props.style = normalizeStyle(style);
  }
  return props;
}

const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
const MATH_TAGS = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics";
const VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
const isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
const isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
const isMathMLTag = /* @__PURE__ */ makeMap(MATH_TAGS);
const isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);

const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
const isBooleanAttr = /* @__PURE__ */ makeMap(
  specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`
);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
const attrValidationCache = {};
function isSSRSafeAttrName(name) {
  if (attrValidationCache.hasOwnProperty(name)) {
    return attrValidationCache[name];
  }
  const isUnsafe = unsafeAttrCharRE.test(name);
  if (isUnsafe) {
    console.error(`unsafe attribute name: ${name}`);
  }
  return attrValidationCache[name] = !isUnsafe;
}
const propsToAttrMap = {
  acceptCharset: "accept-charset",
  className: "class",
  htmlFor: "for",
  httpEquiv: "http-equiv"
};
const isKnownHtmlAttr = /* @__PURE__ */ makeMap(
  `accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`
);
const isKnownSvgAttr = /* @__PURE__ */ makeMap(
  `xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`
);
const isKnownMathMLAttr = /* @__PURE__ */ makeMap(
  `accent,accentunder,actiontype,align,alignmentscope,altimg,altimg-height,altimg-valign,altimg-width,alttext,bevelled,close,columnsalign,columnlines,columnspan,denomalign,depth,dir,display,displaystyle,encoding,equalcolumns,equalrows,fence,fontstyle,fontweight,form,frame,framespacing,groupalign,height,href,id,indentalign,indentalignfirst,indentalignlast,indentshift,indentshiftfirst,indentshiftlast,indextype,justify,largetop,largeop,lquote,lspace,mathbackground,mathcolor,mathsize,mathvariant,maxsize,minlabelspacing,mode,other,overflow,position,rowalign,rowlines,rowspan,rquote,rspace,scriptlevel,scriptminsize,scriptsizemultiplier,selection,separator,separators,shift,side,src,stackalign,stretchy,subscriptshift,superscriptshift,symmetric,voffset,width,widths,xlink:href,xlink:show,xlink:type,xmlns`
);
function isRenderableAttrValue(value) {
  if (value == null) {
    return false;
  }
  const type = typeof value;
  return type === "string" || type === "number" || type === "boolean";
}

const escapeRE = /["'&<>]/;
function escapeHtml(string) {
  const str = "" + string;
  const match = escapeRE.exec(str);
  if (!match) {
    return str;
  }
  let html = "";
  let escaped;
  let index;
  let lastIndex = 0;
  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        escaped = "&quot;";
        break;
      case 38:
        escaped = "&amp;";
        break;
      case 39:
        escaped = "&#39;";
        break;
      case 60:
        escaped = "&lt;";
        break;
      case 62:
        escaped = "&gt;";
        break;
      default:
        continue;
    }
    if (lastIndex !== index) {
      html += str.slice(lastIndex, index);
    }
    lastIndex = index + 1;
    html += escaped;
  }
  return lastIndex !== index ? html + str.slice(lastIndex, index) : html;
}
const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
function escapeHtmlComment(src) {
  return src.replace(commentStripRE, "");
}
const cssVarNameEscapeSymbolsRE = /[ !"#$%&'()*+,./:;<=>?@[\\\]^`{|}~]/g;
function getEscapedCssVarName(key, doubleEscape) {
  return key.replace(
    cssVarNameEscapeSymbolsRE,
    (s) => doubleEscape ? s === '"' ? '\\\\\\"' : `\\\\${s}` : `\\${s}`
  );
}

function looseCompareArrays(a, b) {
  if (a.length !== b.length) return false;
  let equal = true;
  for (let i = 0; equal && i < a.length; i++) {
    equal = looseEqual(a[i], b[i]);
  }
  return equal;
}
function looseEqual(a, b) {
  if (a === b) return true;
  let aValidType = isDate(a);
  let bValidType = isDate(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b.getTime() : false;
  }
  aValidType = isSymbol(a);
  bValidType = isSymbol(b);
  if (aValidType || bValidType) {
    return a === b;
  }
  aValidType = isArray(a);
  bValidType = isArray(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a, b) : false;
  }
  aValidType = isObject$1(a);
  bValidType = isObject$1(b);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a).length;
    const bKeysCount = Object.keys(b).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key in a) {
      const aHasKey = a.hasOwnProperty(key);
      const bHasKey = b.hasOwnProperty(key);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
        return false;
      }
    }
  }
  return String(a) === String(b);
}
function looseIndexOf(arr, val) {
  return arr.findIndex((item) => looseEqual(item, val));
}

const isRef$1 = (val) => {
  return !!(val && val["__v_isRef"] === true);
};
const toDisplayString = (val) => {
  return isString(val) ? val : val == null ? "" : isArray(val) || isObject$1(val) && (val.toString === objectToString || !isFunction(val.toString)) ? isRef$1(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (isRef$1(val)) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce(
        (entries, [key, val2], i) => {
          entries[stringifySymbol(key, i) + " =>"] = val2;
          return entries;
        },
        {}
      )
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
    };
  } else if (isSymbol(val)) {
    return stringifySymbol(val);
  } else if (isObject$1(val) && !isArray(val) && !isPlainObject(val)) {
    return String(val);
  }
  return val;
};
const stringifySymbol = (v, i = "") => {
  var _a;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    isSymbol(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v
  );
};

var shared_esmBundler = /*#__PURE__*/Object.freeze({
  __proto__: null,
  EMPTY_ARR: EMPTY_ARR,
  EMPTY_OBJ: EMPTY_OBJ,
  NO: NO,
  NOOP: NOOP,
  PatchFlagNames: PatchFlagNames,
  PatchFlags: PatchFlags,
  ShapeFlags: ShapeFlags,
  SlotFlags: SlotFlags,
  camelize: camelize$1,
  capitalize: capitalize$1,
  cssVarNameEscapeSymbolsRE: cssVarNameEscapeSymbolsRE,
  def: def,
  escapeHtml: escapeHtml,
  escapeHtmlComment: escapeHtmlComment,
  extend: extend,
  genCacheKey: genCacheKey,
  genPropsAccessExp: genPropsAccessExp,
  generateCodeFrame: generateCodeFrame,
  getEscapedCssVarName: getEscapedCssVarName,
  getGlobalThis: getGlobalThis,
  hasChanged: hasChanged,
  hasOwn: hasOwn,
  hyphenate: hyphenate$1,
  includeBooleanAttr: includeBooleanAttr,
  invokeArrayFns: invokeArrayFns,
  isArray: isArray,
  isBooleanAttr: isBooleanAttr,
  isBuiltInDirective: isBuiltInDirective,
  isDate: isDate,
  isFunction: isFunction,
  isGloballyAllowed: isGloballyAllowed,
  isGloballyWhitelisted: isGloballyWhitelisted,
  isHTMLTag: isHTMLTag,
  isIntegerKey: isIntegerKey,
  isKnownHtmlAttr: isKnownHtmlAttr,
  isKnownMathMLAttr: isKnownMathMLAttr,
  isKnownSvgAttr: isKnownSvgAttr,
  isMap: isMap,
  isMathMLTag: isMathMLTag,
  isModelListener: isModelListener,
  isObject: isObject$1,
  isOn: isOn,
  isPlainObject: isPlainObject,
  isPromise: isPromise,
  isRegExp: isRegExp,
  isRenderableAttrValue: isRenderableAttrValue,
  isReservedProp: isReservedProp,
  isSSRSafeAttrName: isSSRSafeAttrName,
  isSVGTag: isSVGTag,
  isSet: isSet,
  isSpecialBooleanAttr: isSpecialBooleanAttr,
  isString: isString,
  isSymbol: isSymbol,
  isVoidTag: isVoidTag,
  looseEqual: looseEqual,
  looseIndexOf: looseIndexOf,
  looseToNumber: looseToNumber,
  makeMap: makeMap,
  normalizeClass: normalizeClass,
  normalizeProps: normalizeProps,
  normalizeStyle: normalizeStyle,
  objectToString: objectToString,
  parseStringStyle: parseStringStyle,
  propsToAttrMap: propsToAttrMap,
  remove: remove,
  slotFlagsText: slotFlagsText,
  stringifyStyle: stringifyStyle,
  toDisplayString: toDisplayString,
  toHandlerKey: toHandlerKey$1,
  toNumber: toNumber,
  toRawType: toRawType,
  toTypeString: toTypeString
});

/**
* @vue/compiler-core v3.5.10
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/

const FRAGMENT = Symbol(``);
const TELEPORT = Symbol(``);
const SUSPENSE = Symbol(``);
const KEEP_ALIVE = Symbol(``);
const BASE_TRANSITION = Symbol(
  ``
);
const OPEN_BLOCK = Symbol(``);
const CREATE_BLOCK = Symbol(``);
const CREATE_ELEMENT_BLOCK = Symbol(
  ``
);
const CREATE_VNODE = Symbol(``);
const CREATE_ELEMENT_VNODE = Symbol(
  ``
);
const CREATE_COMMENT = Symbol(
  ``
);
const CREATE_TEXT = Symbol(
  ``
);
const CREATE_STATIC = Symbol(
  ``
);
const RESOLVE_COMPONENT = Symbol(
  ``
);
const RESOLVE_DYNAMIC_COMPONENT = Symbol(
  ``
);
const RESOLVE_DIRECTIVE = Symbol(
  ``
);
const RESOLVE_FILTER = Symbol(
  ``
);
const WITH_DIRECTIVES = Symbol(
  ``
);
const RENDER_LIST = Symbol(``);
const RENDER_SLOT = Symbol(``);
const CREATE_SLOTS = Symbol(``);
const TO_DISPLAY_STRING = Symbol(
  ``
);
const MERGE_PROPS = Symbol(``);
const NORMALIZE_CLASS = Symbol(
  ``
);
const NORMALIZE_STYLE = Symbol(
  ``
);
const NORMALIZE_PROPS = Symbol(
  ``
);
const GUARD_REACTIVE_PROPS = Symbol(
  ``
);
const TO_HANDLERS = Symbol(``);
const CAMELIZE = Symbol(``);
const CAPITALIZE = Symbol(``);
const TO_HANDLER_KEY = Symbol(
  ``
);
const SET_BLOCK_TRACKING = Symbol(
  ``
);
const PUSH_SCOPE_ID = Symbol(``);
const POP_SCOPE_ID = Symbol(``);
const WITH_CTX = Symbol(``);
const UNREF = Symbol(``);
const IS_REF = Symbol(``);
const WITH_MEMO = Symbol(``);
const IS_MEMO_SAME = Symbol(``);
const helperNameMap = {
  [FRAGMENT]: `Fragment`,
  [TELEPORT]: `Teleport`,
  [SUSPENSE]: `Suspense`,
  [KEEP_ALIVE]: `KeepAlive`,
  [BASE_TRANSITION]: `BaseTransition`,
  [OPEN_BLOCK]: `openBlock`,
  [CREATE_BLOCK]: `createBlock`,
  [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
  [CREATE_VNODE]: `createVNode`,
  [CREATE_ELEMENT_VNODE]: `createElementVNode`,
  [CREATE_COMMENT]: `createCommentVNode`,
  [CREATE_TEXT]: `createTextVNode`,
  [CREATE_STATIC]: `createStaticVNode`,
  [RESOLVE_COMPONENT]: `resolveComponent`,
  [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
  [RESOLVE_DIRECTIVE]: `resolveDirective`,
  [RESOLVE_FILTER]: `resolveFilter`,
  [WITH_DIRECTIVES]: `withDirectives`,
  [RENDER_LIST]: `renderList`,
  [RENDER_SLOT]: `renderSlot`,
  [CREATE_SLOTS]: `createSlots`,
  [TO_DISPLAY_STRING]: `toDisplayString`,
  [MERGE_PROPS]: `mergeProps`,
  [NORMALIZE_CLASS]: `normalizeClass`,
  [NORMALIZE_STYLE]: `normalizeStyle`,
  [NORMALIZE_PROPS]: `normalizeProps`,
  [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
  [TO_HANDLERS]: `toHandlers`,
  [CAMELIZE]: `camelize`,
  [CAPITALIZE]: `capitalize`,
  [TO_HANDLER_KEY]: `toHandlerKey`,
  [SET_BLOCK_TRACKING]: `setBlockTracking`,
  [PUSH_SCOPE_ID]: `pushScopeId`,
  [POP_SCOPE_ID]: `popScopeId`,
  [WITH_CTX]: `withCtx`,
  [UNREF]: `unref`,
  [IS_REF]: `isRef`,
  [WITH_MEMO]: `withMemo`,
  [IS_MEMO_SAME]: `isMemoSame`
};
function registerRuntimeHelpers(helpers) {
  Object.getOwnPropertySymbols(helpers).forEach((s) => {
    helperNameMap[s] = helpers[s];
  });
}

const Namespaces = {
  "HTML": 0,
  "0": "HTML",
  "SVG": 1,
  "1": "SVG",
  "MATH_ML": 2,
  "2": "MATH_ML"
};
const NodeTypes = {
  "ROOT": 0,
  "0": "ROOT",
  "ELEMENT": 1,
  "1": "ELEMENT",
  "TEXT": 2,
  "2": "TEXT",
  "COMMENT": 3,
  "3": "COMMENT",
  "SIMPLE_EXPRESSION": 4,
  "4": "SIMPLE_EXPRESSION",
  "INTERPOLATION": 5,
  "5": "INTERPOLATION",
  "ATTRIBUTE": 6,
  "6": "ATTRIBUTE",
  "DIRECTIVE": 7,
  "7": "DIRECTIVE",
  "COMPOUND_EXPRESSION": 8,
  "8": "COMPOUND_EXPRESSION",
  "IF": 9,
  "9": "IF",
  "IF_BRANCH": 10,
  "10": "IF_BRANCH",
  "FOR": 11,
  "11": "FOR",
  "TEXT_CALL": 12,
  "12": "TEXT_CALL",
  "VNODE_CALL": 13,
  "13": "VNODE_CALL",
  "JS_CALL_EXPRESSION": 14,
  "14": "JS_CALL_EXPRESSION",
  "JS_OBJECT_EXPRESSION": 15,
  "15": "JS_OBJECT_EXPRESSION",
  "JS_PROPERTY": 16,
  "16": "JS_PROPERTY",
  "JS_ARRAY_EXPRESSION": 17,
  "17": "JS_ARRAY_EXPRESSION",
  "JS_FUNCTION_EXPRESSION": 18,
  "18": "JS_FUNCTION_EXPRESSION",
  "JS_CONDITIONAL_EXPRESSION": 19,
  "19": "JS_CONDITIONAL_EXPRESSION",
  "JS_CACHE_EXPRESSION": 20,
  "20": "JS_CACHE_EXPRESSION",
  "JS_BLOCK_STATEMENT": 21,
  "21": "JS_BLOCK_STATEMENT",
  "JS_TEMPLATE_LITERAL": 22,
  "22": "JS_TEMPLATE_LITERAL",
  "JS_IF_STATEMENT": 23,
  "23": "JS_IF_STATEMENT",
  "JS_ASSIGNMENT_EXPRESSION": 24,
  "24": "JS_ASSIGNMENT_EXPRESSION",
  "JS_SEQUENCE_EXPRESSION": 25,
  "25": "JS_SEQUENCE_EXPRESSION",
  "JS_RETURN_STATEMENT": 26,
  "26": "JS_RETURN_STATEMENT"
};
const ElementTypes = {
  "ELEMENT": 0,
  "0": "ELEMENT",
  "COMPONENT": 1,
  "1": "COMPONENT",
  "SLOT": 2,
  "2": "SLOT",
  "TEMPLATE": 3,
  "3": "TEMPLATE"
};
const ConstantTypes = {
  "NOT_CONSTANT": 0,
  "0": "NOT_CONSTANT",
  "CAN_SKIP_PATCH": 1,
  "1": "CAN_SKIP_PATCH",
  "CAN_CACHE": 2,
  "2": "CAN_CACHE",
  "CAN_STRINGIFY": 3,
  "3": "CAN_STRINGIFY"
};
const locStub = {
  start: { line: 1, column: 1, offset: 0 },
  end: { line: 1, column: 1, offset: 0 },
  source: ""
};
function createRoot(children, source = "") {
  return {
    type: 0,
    source,
    children,
    helpers: /* @__PURE__ */ new Set(),
    components: [],
    directives: [],
    hoists: [],
    imports: [],
    cached: [],
    temps: 0,
    codegenNode: void 0,
    loc: locStub
  };
}
function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent = false, loc = locStub) {
  if (context) {
    if (isBlock) {
      context.helper(OPEN_BLOCK);
      context.helper(getVNodeBlockHelper(context.inSSR, isComponent));
    } else {
      context.helper(getVNodeHelper(context.inSSR, isComponent));
    }
    if (directives) {
      context.helper(WITH_DIRECTIVES);
    }
  }
  return {
    type: 13,
    tag,
    props,
    children,
    patchFlag,
    dynamicProps,
    directives,
    isBlock,
    disableTracking,
    isComponent,
    loc
  };
}
function createArrayExpression(elements, loc = locStub) {
  return {
    type: 17,
    loc,
    elements
  };
}
function createObjectExpression(properties, loc = locStub) {
  return {
    type: 15,
    loc,
    properties
  };
}
function createObjectProperty(key, value) {
  return {
    type: 16,
    loc: locStub,
    key: isString(key) ? createSimpleExpression(key, true) : key,
    value
  };
}
function createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0) {
  return {
    type: 4,
    loc,
    content,
    isStatic,
    constType: isStatic ? 3 : constType
  };
}
function createInterpolation(content, loc) {
  return {
    type: 5,
    loc,
    content: isString(content) ? createSimpleExpression(content, false, loc) : content
  };
}
function createCompoundExpression(children, loc = locStub) {
  return {
    type: 8,
    loc,
    children
  };
}
function createCallExpression(callee, args = [], loc = locStub) {
  return {
    type: 14,
    loc,
    callee,
    arguments: args
  };
}
function createFunctionExpression(params, returns = void 0, newline = false, isSlot = false, loc = locStub) {
  return {
    type: 18,
    params,
    returns,
    newline,
    isSlot,
    loc
  };
}
function createConditionalExpression(test, consequent, alternate, newline = true) {
  return {
    type: 19,
    test,
    consequent,
    alternate,
    newline,
    loc: locStub
  };
}
function createCacheExpression(index, value, needPauseTracking = false) {
  return {
    type: 20,
    index,
    value,
    needPauseTracking,
    needArraySpread: false,
    loc: locStub
  };
}
function createBlockStatement(body) {
  return {
    type: 21,
    body,
    loc: locStub
  };
}
function createTemplateLiteral(elements) {
  return {
    type: 22,
    elements,
    loc: locStub
  };
}
function createIfStatement(test, consequent, alternate) {
  return {
    type: 23,
    test,
    consequent,
    alternate,
    loc: locStub
  };
}
function createAssignmentExpression(left, right) {
  return {
    type: 24,
    left,
    right,
    loc: locStub
  };
}
function createSequenceExpression(expressions) {
  return {
    type: 25,
    expressions,
    loc: locStub
  };
}
function createReturnStatement(returns) {
  return {
    type: 26,
    returns,
    loc: locStub
  };
}
function getVNodeHelper(ssr, isComponent) {
  return ssr || isComponent ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
}
function getVNodeBlockHelper(ssr, isComponent) {
  return ssr || isComponent ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
}
function convertToBlock(node, { helper, removeHelper, inSSR }) {
  if (!node.isBlock) {
    node.isBlock = true;
    removeHelper(getVNodeHelper(inSSR, node.isComponent));
    helper(OPEN_BLOCK);
    helper(getVNodeBlockHelper(inSSR, node.isComponent));
  }
}

const defaultDelimitersOpen = new Uint8Array([123, 123]);
const defaultDelimitersClose = new Uint8Array([125, 125]);
function isTagStartChar(c) {
  return c >= 97 && c <= 122 || c >= 65 && c <= 90;
}
function isWhitespace(c) {
  return c === 32 || c === 10 || c === 9 || c === 12 || c === 13;
}
function isEndOfTagSection(c) {
  return c === 47 || c === 62 || isWhitespace(c);
}
function toCharCodes(str) {
  const ret = new Uint8Array(str.length);
  for (let i = 0; i < str.length; i++) {
    ret[i] = str.charCodeAt(i);
  }
  return ret;
}
const Sequences = {
  Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
  // CDATA[
  CdataEnd: new Uint8Array([93, 93, 62]),
  // ]]>
  CommentEnd: new Uint8Array([45, 45, 62]),
  // `-->`
  ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
  // `<\/script`
  StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
  // `</style`
  TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]),
  // `</title`
  TextareaEnd: new Uint8Array([
    60,
    47,
    116,
    101,
    120,
    116,
    97,
    114,
    101,
    97
  ])
  // `</textarea
};
class Tokenizer {
  constructor(stack, cbs) {
    this.stack = stack;
    this.cbs = cbs;
    /** The current state the tokenizer is in. */
    this.state = 1;
    /** The read buffer. */
    this.buffer = "";
    /** The beginning of the section that is currently being read. */
    this.sectionStart = 0;
    /** The index within the buffer that we are currently looking at. */
    this.index = 0;
    /** The start of the last entity. */
    this.entityStart = 0;
    /** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */
    this.baseState = 1;
    /** For special parsing behavior inside of script and style tags. */
    this.inRCDATA = false;
    /** For disabling RCDATA tags handling */
    this.inXML = false;
    /** For disabling interpolation parsing in v-pre */
    this.inVPre = false;
    /** Record newline positions for fast line / column calculation */
    this.newlines = [];
    this.mode = 0;
    this.delimiterOpen = defaultDelimitersOpen;
    this.delimiterClose = defaultDelimitersClose;
    this.delimiterIndex = -1;
    this.currentSequence = void 0;
    this.sequenceIndex = 0;
  }
  get inSFCRoot() {
    return this.mode === 2 && this.stack.length === 0;
  }
  reset() {
    this.state = 1;
    this.mode = 0;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = 1;
    this.inRCDATA = false;
    this.currentSequence = void 0;
    this.newlines.length = 0;
    this.delimiterOpen = defaultDelimitersOpen;
    this.delimiterClose = defaultDelimitersClose;
  }
  /**
   * Generate Position object with line / column information using recorded
   * newline positions. We know the index is always going to be an already
   * processed index, so all the newlines up to this index should have been
   * recorded.
   */
  getPos(index) {
    let line = 1;
    let column = index + 1;
    for (let i = this.newlines.length - 1; i >= 0; i--) {
      const newlineIndex = this.newlines[i];
      if (index > newlineIndex) {
        line = i + 2;
        column = index - newlineIndex;
        break;
      }
    }
    return {
      column,
      line,
      offset: index
    };
  }
  peek() {
    return this.buffer.charCodeAt(this.index + 1);
  }
  stateText(c) {
    if (c === 60) {
      if (this.index > this.sectionStart) {
        this.cbs.ontext(this.sectionStart, this.index);
      }
      this.state = 5;
      this.sectionStart = this.index;
    } else if (!this.inVPre && c === this.delimiterOpen[0]) {
      this.state = 2;
      this.delimiterIndex = 0;
      this.stateInterpolationOpen(c);
    }
  }
  stateInterpolationOpen(c) {
    if (c === this.delimiterOpen[this.delimiterIndex]) {
      if (this.delimiterIndex === this.delimiterOpen.length - 1) {
        const start = this.index + 1 - this.delimiterOpen.length;
        if (start > this.sectionStart) {
          this.cbs.ontext(this.sectionStart, start);
        }
        this.state = 3;
        this.sectionStart = start;
      } else {
        this.delimiterIndex++;
      }
    } else if (this.inRCDATA) {
      this.state = 32;
      this.stateInRCDATA(c);
    } else {
      this.state = 1;
      this.stateText(c);
    }
  }
  stateInterpolation(c) {
    if (c === this.delimiterClose[0]) {
      this.state = 4;
      this.delimiterIndex = 0;
      this.stateInterpolationClose(c);
    }
  }
  stateInterpolationClose(c) {
    if (c === this.delimiterClose[this.delimiterIndex]) {
      if (this.delimiterIndex === this.delimiterClose.length - 1) {
        this.cbs.oninterpolation(this.sectionStart, this.index + 1);
        if (this.inRCDATA) {
          this.state = 32;
        } else {
          this.state = 1;
        }
        this.sectionStart = this.index + 1;
      } else {
        this.delimiterIndex++;
      }
    } else {
      this.state = 3;
      this.stateInterpolation(c);
    }
  }
  stateSpecialStartSequence(c) {
    const isEnd = this.sequenceIndex === this.currentSequence.length;
    const isMatch = isEnd ? (
      // If we are at the end of the sequence, make sure the tag name has ended
      isEndOfTagSection(c)
    ) : (
      // Otherwise, do a case-insensitive comparison
      (c | 32) === this.currentSequence[this.sequenceIndex]
    );
    if (!isMatch) {
      this.inRCDATA = false;
    } else if (!isEnd) {
      this.sequenceIndex++;
      return;
    }
    this.sequenceIndex = 0;
    this.state = 6;
    this.stateInTagName(c);
  }
  /** Look for an end tag. For <title> and <textarea>, also decode entities. */
  stateInRCDATA(c) {
    if (this.sequenceIndex === this.currentSequence.length) {
      if (c === 62 || isWhitespace(c)) {
        const endOfText = this.index - this.currentSequence.length;
        if (this.sectionStart < endOfText) {
          const actualIndex = this.index;
          this.index = endOfText;
          this.cbs.ontext(this.sectionStart, endOfText);
          this.index = actualIndex;
        }
        this.sectionStart = endOfText + 2;
        this.stateInClosingTagName(c);
        this.inRCDATA = false;
        return;
      }
      this.sequenceIndex = 0;
    }
    if ((c | 32) === this.currentSequence[this.sequenceIndex]) {
      this.sequenceIndex += 1;
    } else if (this.sequenceIndex === 0) {
      if (this.currentSequence === Sequences.TitleEnd || this.currentSequence === Sequences.TextareaEnd && !this.inSFCRoot) {
        if (!this.inVPre && c === this.delimiterOpen[0]) {
          this.state = 2;
          this.delimiterIndex = 0;
          this.stateInterpolationOpen(c);
        }
      } else if (this.fastForwardTo(60)) {
        this.sequenceIndex = 1;
      }
    } else {
      this.sequenceIndex = Number(c === 60);
    }
  }
  stateCDATASequence(c) {
    if (c === Sequences.Cdata[this.sequenceIndex]) {
      if (++this.sequenceIndex === Sequences.Cdata.length) {
        this.state = 28;
        this.currentSequence = Sequences.CdataEnd;
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
      }
    } else {
      this.sequenceIndex = 0;
      this.state = 23;
      this.stateInDeclaration(c);
    }
  }
  /**
   * When we wait for one specific character, we can speed things up
   * by skipping through the buffer until we find it.
   *
   * @returns Whether the character was found.
   */
  fastForwardTo(c) {
    while (++this.index < this.buffer.length) {
      const cc = this.buffer.charCodeAt(this.index);
      if (cc === 10) {
        this.newlines.push(this.index);
      }
      if (cc === c) {
        return true;
      }
    }
    this.index = this.buffer.length - 1;
    return false;
  }
  /**
   * Comments and CDATA end with `-->` and `]]>`.
   *
   * Their common qualities are:
   * - Their end sequences have a distinct character they start with.
   * - That character is then repeated, so we have to check multiple repeats.
   * - All characters but the start character of the sequence can be skipped.
   */
  stateInCommentLike(c) {
    if (c === this.currentSequence[this.sequenceIndex]) {
      if (++this.sequenceIndex === this.currentSequence.length) {
        if (this.currentSequence === Sequences.CdataEnd) {
          this.cbs.oncdata(this.sectionStart, this.index - 2);
        } else {
          this.cbs.oncomment(this.sectionStart, this.index - 2);
        }
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
        this.state = 1;
      }
    } else if (this.sequenceIndex === 0) {
      if (this.fastForwardTo(this.currentSequence[0])) {
        this.sequenceIndex = 1;
      }
    } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
      this.sequenceIndex = 0;
    }
  }
  startSpecial(sequence, offset) {
    this.enterRCDATA(sequence, offset);
    this.state = 31;
  }
  enterRCDATA(sequence, offset) {
    this.inRCDATA = true;
    this.currentSequence = sequence;
    this.sequenceIndex = offset;
  }
  stateBeforeTagName(c) {
    if (c === 33) {
      this.state = 22;
      this.sectionStart = this.index + 1;
    } else if (c === 63) {
      this.state = 24;
      this.sectionStart = this.index + 1;
    } else if (isTagStartChar(c)) {
      this.sectionStart = this.index;
      if (this.mode === 0) {
        this.state = 6;
      } else if (this.inSFCRoot) {
        this.state = 34;
      } else if (!this.inXML) {
        if (c === 116) {
          this.state = 30;
        } else {
          this.state = c === 115 ? 29 : 6;
        }
      } else {
        this.state = 6;
      }
    } else if (c === 47) {
      this.state = 8;
    } else {
      this.state = 1;
      this.stateText(c);
    }
  }
  stateInTagName(c) {
    if (isEndOfTagSection(c)) {
      this.handleTagName(c);
    }
  }
  stateInSFCRootTagName(c) {
    if (isEndOfTagSection(c)) {
      const tag = this.buffer.slice(this.sectionStart, this.index);
      if (tag !== "template") {
        this.enterRCDATA(toCharCodes(`</` + tag), 0);
      }
      this.handleTagName(c);
    }
  }
  handleTagName(c) {
    this.cbs.onopentagname(this.sectionStart, this.index);
    this.sectionStart = -1;
    this.state = 11;
    this.stateBeforeAttrName(c);
  }
  stateBeforeClosingTagName(c) {
    if (isWhitespace(c)) ; else if (c === 62) {
      this.state = 1;
      this.sectionStart = this.index + 1;
    } else {
      this.state = isTagStartChar(c) ? 9 : 27;
      this.sectionStart = this.index;
    }
  }
  stateInClosingTagName(c) {
    if (c === 62 || isWhitespace(c)) {
      this.cbs.onclosetag(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = 10;
      this.stateAfterClosingTagName(c);
    }
  }
  stateAfterClosingTagName(c) {
    if (c === 62) {
      this.state = 1;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeAttrName(c) {
    if (c === 62) {
      this.cbs.onopentagend(this.index);
      if (this.inRCDATA) {
        this.state = 32;
      } else {
        this.state = 1;
      }
      this.sectionStart = this.index + 1;
    } else if (c === 47) {
      this.state = 7;
    } else if (c === 60 && this.peek() === 47) {
      this.cbs.onopentagend(this.index);
      this.state = 5;
      this.sectionStart = this.index;
    } else if (!isWhitespace(c)) {
      this.handleAttrStart(c);
    }
  }
  handleAttrStart(c) {
    if (c === 118 && this.peek() === 45) {
      this.state = 13;
      this.sectionStart = this.index;
    } else if (c === 46 || c === 58 || c === 64 || c === 35) {
      this.cbs.ondirname(this.index, this.index + 1);
      this.state = 14;
      this.sectionStart = this.index + 1;
    } else {
      this.state = 12;
      this.sectionStart = this.index;
    }
  }
  stateInSelfClosingTag(c) {
    if (c === 62) {
      this.cbs.onselfclosingtag(this.index);
      this.state = 1;
      this.sectionStart = this.index + 1;
      this.inRCDATA = false;
    } else if (!isWhitespace(c)) {
      this.state = 11;
      this.stateBeforeAttrName(c);
    }
  }
  stateInAttrName(c) {
    if (c === 61 || isEndOfTagSection(c)) {
      this.cbs.onattribname(this.sectionStart, this.index);
      this.handleAttrNameEnd(c);
    }
  }
  stateInDirName(c) {
    if (c === 61 || isEndOfTagSection(c)) {
      this.cbs.ondirname(this.sectionStart, this.index);
      this.handleAttrNameEnd(c);
    } else if (c === 58) {
      this.cbs.ondirname(this.sectionStart, this.index);
      this.state = 14;
      this.sectionStart = this.index + 1;
    } else if (c === 46) {
      this.cbs.ondirname(this.sectionStart, this.index);
      this.state = 16;
      this.sectionStart = this.index + 1;
    }
  }
  stateInDirArg(c) {
    if (c === 61 || isEndOfTagSection(c)) {
      this.cbs.ondirarg(this.sectionStart, this.index);
      this.handleAttrNameEnd(c);
    } else if (c === 91) {
      this.state = 15;
    } else if (c === 46) {
      this.cbs.ondirarg(this.sectionStart, this.index);
      this.state = 16;
      this.sectionStart = this.index + 1;
    }
  }
  stateInDynamicDirArg(c) {
    if (c === 93) {
      this.state = 14;
    } else if (c === 61 || isEndOfTagSection(c)) {
      this.cbs.ondirarg(this.sectionStart, this.index + 1);
      this.handleAttrNameEnd(c);
    }
  }
  stateInDirModifier(c) {
    if (c === 61 || isEndOfTagSection(c)) {
      this.cbs.ondirmodifier(this.sectionStart, this.index);
      this.handleAttrNameEnd(c);
    } else if (c === 46) {
      this.cbs.ondirmodifier(this.sectionStart, this.index);
      this.sectionStart = this.index + 1;
    }
  }
  handleAttrNameEnd(c) {
    this.sectionStart = this.index;
    this.state = 17;
    this.cbs.onattribnameend(this.index);
    this.stateAfterAttrName(c);
  }
  stateAfterAttrName(c) {
    if (c === 61) {
      this.state = 18;
    } else if (c === 47 || c === 62) {
      this.cbs.onattribend(0, this.sectionStart);
      this.sectionStart = -1;
      this.state = 11;
      this.stateBeforeAttrName(c);
    } else if (!isWhitespace(c)) {
      this.cbs.onattribend(0, this.sectionStart);
      this.handleAttrStart(c);
    }
  }
  stateBeforeAttrValue(c) {
    if (c === 34) {
      this.state = 19;
      this.sectionStart = this.index + 1;
    } else if (c === 39) {
      this.state = 20;
      this.sectionStart = this.index + 1;
    } else if (!isWhitespace(c)) {
      this.sectionStart = this.index;
      this.state = 21;
      this.stateInAttrValueNoQuotes(c);
    }
  }
  handleInAttrValue(c, quote) {
    if (c === quote || this.fastForwardTo(quote)) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(
        quote === 34 ? 3 : 2,
        this.index + 1
      );
      this.state = 11;
    }
  }
  stateInAttrValueDoubleQuotes(c) {
    this.handleInAttrValue(c, 34);
  }
  stateInAttrValueSingleQuotes(c) {
    this.handleInAttrValue(c, 39);
  }
  stateInAttrValueNoQuotes(c) {
    if (isWhitespace(c) || c === 62) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(1, this.index);
      this.state = 11;
      this.stateBeforeAttrName(c);
    } else if (c === 39 || c === 60 || c === 61 || c === 96) {
      this.cbs.onerr(
        18,
        this.index
      );
    } else ;
  }
  stateBeforeDeclaration(c) {
    if (c === 91) {
      this.state = 26;
      this.sequenceIndex = 0;
    } else {
      this.state = c === 45 ? 25 : 23;
    }
  }
  stateInDeclaration(c) {
    if (c === 62 || this.fastForwardTo(62)) {
      this.state = 1;
      this.sectionStart = this.index + 1;
    }
  }
  stateInProcessingInstruction(c) {
    if (c === 62 || this.fastForwardTo(62)) {
      this.cbs.onprocessinginstruction(this.sectionStart, this.index);
      this.state = 1;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeComment(c) {
    if (c === 45) {
      this.state = 28;
      this.currentSequence = Sequences.CommentEnd;
      this.sequenceIndex = 2;
      this.sectionStart = this.index + 1;
    } else {
      this.state = 23;
    }
  }
  stateInSpecialComment(c) {
    if (c === 62 || this.fastForwardTo(62)) {
      this.cbs.oncomment(this.sectionStart, this.index);
      this.state = 1;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeSpecialS(c) {
    if (c === Sequences.ScriptEnd[3]) {
      this.startSpecial(Sequences.ScriptEnd, 4);
    } else if (c === Sequences.StyleEnd[3]) {
      this.startSpecial(Sequences.StyleEnd, 4);
    } else {
      this.state = 6;
      this.stateInTagName(c);
    }
  }
  stateBeforeSpecialT(c) {
    if (c === Sequences.TitleEnd[3]) {
      this.startSpecial(Sequences.TitleEnd, 4);
    } else if (c === Sequences.TextareaEnd[3]) {
      this.startSpecial(Sequences.TextareaEnd, 4);
    } else {
      this.state = 6;
      this.stateInTagName(c);
    }
  }
  startEntity() {
  }
  stateInEntity() {
  }
  /**
   * Iterates through the buffer, calling the function corresponding to the current state.
   *
   * States that are more likely to be hit are higher up, as a performance improvement.
   */
  parse(input) {
    this.buffer = input;
    while (this.index < this.buffer.length) {
      const c = this.buffer.charCodeAt(this.index);
      if (c === 10) {
        this.newlines.push(this.index);
      }
      switch (this.state) {
        case 1: {
          this.stateText(c);
          break;
        }
        case 2: {
          this.stateInterpolationOpen(c);
          break;
        }
        case 3: {
          this.stateInterpolation(c);
          break;
        }
        case 4: {
          this.stateInterpolationClose(c);
          break;
        }
        case 31: {
          this.stateSpecialStartSequence(c);
          break;
        }
        case 32: {
          this.stateInRCDATA(c);
          break;
        }
        case 26: {
          this.stateCDATASequence(c);
          break;
        }
        case 19: {
          this.stateInAttrValueDoubleQuotes(c);
          break;
        }
        case 12: {
          this.stateInAttrName(c);
          break;
        }
        case 13: {
          this.stateInDirName(c);
          break;
        }
        case 14: {
          this.stateInDirArg(c);
          break;
        }
        case 15: {
          this.stateInDynamicDirArg(c);
          break;
        }
        case 16: {
          this.stateInDirModifier(c);
          break;
        }
        case 28: {
          this.stateInCommentLike(c);
          break;
        }
        case 27: {
          this.stateInSpecialComment(c);
          break;
        }
        case 11: {
          this.stateBeforeAttrName(c);
          break;
        }
        case 6: {
          this.stateInTagName(c);
          break;
        }
        case 34: {
          this.stateInSFCRootTagName(c);
          break;
        }
        case 9: {
          this.stateInClosingTagName(c);
          break;
        }
        case 5: {
          this.stateBeforeTagName(c);
          break;
        }
        case 17: {
          this.stateAfterAttrName(c);
          break;
        }
        case 20: {
          this.stateInAttrValueSingleQuotes(c);
          break;
        }
        case 18: {
          this.stateBeforeAttrValue(c);
          break;
        }
        case 8: {
          this.stateBeforeClosingTagName(c);
          break;
        }
        case 10: {
          this.stateAfterClosingTagName(c);
          break;
        }
        case 29: {
          this.stateBeforeSpecialS(c);
          break;
        }
        case 30: {
          this.stateBeforeSpecialT(c);
          break;
        }
        case 21: {
          this.stateInAttrValueNoQuotes(c);
          break;
        }
        case 7: {
          this.stateInSelfClosingTag(c);
          break;
        }
        case 23: {
          this.stateInDeclaration(c);
          break;
        }
        case 22: {
          this.stateBeforeDeclaration(c);
          break;
        }
        case 25: {
          this.stateBeforeComment(c);
          break;
        }
        case 24: {
          this.stateInProcessingInstruction(c);
          break;
        }
        case 33: {
          this.stateInEntity();
          break;
        }
      }
      this.index++;
    }
    this.cleanup();
    this.finish();
  }
  /**
   * Remove data that has already been consumed from the buffer.
   */
  cleanup() {
    if (this.sectionStart !== this.index) {
      if (this.state === 1 || this.state === 32 && this.sequenceIndex === 0) {
        this.cbs.ontext(this.sectionStart, this.index);
        this.sectionStart = this.index;
      } else if (this.state === 19 || this.state === 20 || this.state === 21) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = this.index;
      }
    }
  }
  finish() {
    this.handleTrailingData();
    this.cbs.onend();
  }
  /** Handle any trailing data. */
  handleTrailingData() {
    const endIndex = this.buffer.length;
    if (this.sectionStart >= endIndex) {
      return;
    }
    if (this.state === 28) {
      if (this.currentSequence === Sequences.CdataEnd) {
        this.cbs.oncdata(this.sectionStart, endIndex);
      } else {
        this.cbs.oncomment(this.sectionStart, endIndex);
      }
    } else if (this.state === 6 || this.state === 11 || this.state === 18 || this.state === 17 || this.state === 12 || this.state === 13 || this.state === 14 || this.state === 15 || this.state === 16 || this.state === 20 || this.state === 19 || this.state === 21 || this.state === 9) ; else {
      this.cbs.ontext(this.sectionStart, endIndex);
    }
  }
  emitCodePoint(cp, consumed) {
  }
}

const CompilerDeprecationTypes = {
  "COMPILER_IS_ON_ELEMENT": "COMPILER_IS_ON_ELEMENT",
  "COMPILER_V_BIND_SYNC": "COMPILER_V_BIND_SYNC",
  "COMPILER_V_BIND_OBJECT_ORDER": "COMPILER_V_BIND_OBJECT_ORDER",
  "COMPILER_V_ON_NATIVE": "COMPILER_V_ON_NATIVE",
  "COMPILER_V_IF_V_FOR_PRECEDENCE": "COMPILER_V_IF_V_FOR_PRECEDENCE",
  "COMPILER_NATIVE_TEMPLATE": "COMPILER_NATIVE_TEMPLATE",
  "COMPILER_INLINE_TEMPLATE": "COMPILER_INLINE_TEMPLATE",
  "COMPILER_FILTERS": "COMPILER_FILTERS"
};
const deprecationData = {
  ["COMPILER_IS_ON_ELEMENT"]: {
    message: `Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".`,
    link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`
  },
  ["COMPILER_V_BIND_SYNC"]: {
    message: (key) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${key}.sync\` should be changed to \`v-model:${key}\`.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`
  },
  ["COMPILER_V_BIND_OBJECT_ORDER"]: {
    message: `v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`
  },
  ["COMPILER_V_ON_NATIVE"]: {
    message: `.native modifier for v-on has been removed as is no longer necessary.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`
  },
  ["COMPILER_V_IF_V_FOR_PRECEDENCE"]: {
    message: `v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`
  },
  ["COMPILER_NATIVE_TEMPLATE"]: {
    message: `<template> with no special directives will render as a native template element instead of its inner content in Vue 3.`
  },
  ["COMPILER_INLINE_TEMPLATE"]: {
    message: `"inline-template" has been removed in Vue 3.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`
  },
  ["COMPILER_FILTERS"]: {
    message: `filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`
  }
};
function getCompatValue(key, { compatConfig }) {
  const value = compatConfig && compatConfig[key];
  if (key === "MODE") {
    return value || 3;
  } else {
    return value;
  }
}
function isCompatEnabled(key, context) {
  const mode = getCompatValue("MODE", context);
  const value = getCompatValue(key, context);
  return mode === 3 ? value === true : value !== false;
}
function checkCompatEnabled(key, context, loc, ...args) {
  const enabled = isCompatEnabled(key, context);
  return enabled;
}
function warnDeprecation(key, context, loc, ...args) {
  const val = getCompatValue(key, context);
  if (val === "suppress-warning") {
    return;
  }
  const { message, link } = deprecationData[key];
  const msg = `(deprecation ${key}) ${typeof message === "function" ? message(...args) : message}${link ? `
  Details: ${link}` : ``}`;
  const err = new SyntaxError(msg);
  err.code = key;
  if (loc) err.loc = loc;
  context.onWarn(err);
}

function defaultOnError(error) {
  throw error;
}
function defaultOnWarn(msg) {
}
function createCompilerError(code, loc, messages, additionalMessage) {
  const msg = `https://vuejs.org/error-reference/#compiler-${code}`;
  const error = new SyntaxError(String(msg));
  error.code = code;
  error.loc = loc;
  return error;
}
const ErrorCodes$1 = {
  "ABRUPT_CLOSING_OF_EMPTY_COMMENT": 0,
  "0": "ABRUPT_CLOSING_OF_EMPTY_COMMENT",
  "CDATA_IN_HTML_CONTENT": 1,
  "1": "CDATA_IN_HTML_CONTENT",
  "DUPLICATE_ATTRIBUTE": 2,
  "2": "DUPLICATE_ATTRIBUTE",
  "END_TAG_WITH_ATTRIBUTES": 3,
  "3": "END_TAG_WITH_ATTRIBUTES",
  "END_TAG_WITH_TRAILING_SOLIDUS": 4,
  "4": "END_TAG_WITH_TRAILING_SOLIDUS",
  "EOF_BEFORE_TAG_NAME": 5,
  "5": "EOF_BEFORE_TAG_NAME",
  "EOF_IN_CDATA": 6,
  "6": "EOF_IN_CDATA",
  "EOF_IN_COMMENT": 7,
  "7": "EOF_IN_COMMENT",
  "EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT": 8,
  "8": "EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT",
  "EOF_IN_TAG": 9,
  "9": "EOF_IN_TAG",
  "INCORRECTLY_CLOSED_COMMENT": 10,
  "10": "INCORRECTLY_CLOSED_COMMENT",
  "INCORRECTLY_OPENED_COMMENT": 11,
  "11": "INCORRECTLY_OPENED_COMMENT",
  "INVALID_FIRST_CHARACTER_OF_TAG_NAME": 12,
  "12": "INVALID_FIRST_CHARACTER_OF_TAG_NAME",
  "MISSING_ATTRIBUTE_VALUE": 13,
  "13": "MISSING_ATTRIBUTE_VALUE",
  "MISSING_END_TAG_NAME": 14,
  "14": "MISSING_END_TAG_NAME",
  "MISSING_WHITESPACE_BETWEEN_ATTRIBUTES": 15,
  "15": "MISSING_WHITESPACE_BETWEEN_ATTRIBUTES",
  "NESTED_COMMENT": 16,
  "16": "NESTED_COMMENT",
  "UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME": 17,
  "17": "UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME",
  "UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE": 18,
  "18": "UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE",
  "UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME": 19,
  "19": "UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME",
  "UNEXPECTED_NULL_CHARACTER": 20,
  "20": "UNEXPECTED_NULL_CHARACTER",
  "UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME": 21,
  "21": "UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME",
  "UNEXPECTED_SOLIDUS_IN_TAG": 22,
  "22": "UNEXPECTED_SOLIDUS_IN_TAG",
  "X_INVALID_END_TAG": 23,
  "23": "X_INVALID_END_TAG",
  "X_MISSING_END_TAG": 24,
  "24": "X_MISSING_END_TAG",
  "X_MISSING_INTERPOLATION_END": 25,
  "25": "X_MISSING_INTERPOLATION_END",
  "X_MISSING_DIRECTIVE_NAME": 26,
  "26": "X_MISSING_DIRECTIVE_NAME",
  "X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END": 27,
  "27": "X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END",
  "X_V_IF_NO_EXPRESSION": 28,
  "28": "X_V_IF_NO_EXPRESSION",
  "X_V_IF_SAME_KEY": 29,
  "29": "X_V_IF_SAME_KEY",
  "X_V_ELSE_NO_ADJACENT_IF": 30,
  "30": "X_V_ELSE_NO_ADJACENT_IF",
  "X_V_FOR_NO_EXPRESSION": 31,
  "31": "X_V_FOR_NO_EXPRESSION",
  "X_V_FOR_MALFORMED_EXPRESSION": 32,
  "32": "X_V_FOR_MALFORMED_EXPRESSION",
  "X_V_FOR_TEMPLATE_KEY_PLACEMENT": 33,
  "33": "X_V_FOR_TEMPLATE_KEY_PLACEMENT",
  "X_V_BIND_NO_EXPRESSION": 34,
  "34": "X_V_BIND_NO_EXPRESSION",
  "X_V_ON_NO_EXPRESSION": 35,
  "35": "X_V_ON_NO_EXPRESSION",
  "X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET": 36,
  "36": "X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET",
  "X_V_SLOT_MIXED_SLOT_USAGE": 37,
  "37": "X_V_SLOT_MIXED_SLOT_USAGE",
  "X_V_SLOT_DUPLICATE_SLOT_NAMES": 38,
  "38": "X_V_SLOT_DUPLICATE_SLOT_NAMES",
  "X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN": 39,
  "39": "X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN",
  "X_V_SLOT_MISPLACED": 40,
  "40": "X_V_SLOT_MISPLACED",
  "X_V_MODEL_NO_EXPRESSION": 41,
  "41": "X_V_MODEL_NO_EXPRESSION",
  "X_V_MODEL_MALFORMED_EXPRESSION": 42,
  "42": "X_V_MODEL_MALFORMED_EXPRESSION",
  "X_V_MODEL_ON_SCOPE_VARIABLE": 43,
  "43": "X_V_MODEL_ON_SCOPE_VARIABLE",
  "X_V_MODEL_ON_PROPS": 44,
  "44": "X_V_MODEL_ON_PROPS",
  "X_INVALID_EXPRESSION": 45,
  "45": "X_INVALID_EXPRESSION",
  "X_KEEP_ALIVE_INVALID_CHILDREN": 46,
  "46": "X_KEEP_ALIVE_INVALID_CHILDREN",
  "X_PREFIX_ID_NOT_SUPPORTED": 47,
  "47": "X_PREFIX_ID_NOT_SUPPORTED",
  "X_MODULE_MODE_NOT_SUPPORTED": 48,
  "48": "X_MODULE_MODE_NOT_SUPPORTED",
  "X_CACHE_HANDLER_NOT_SUPPORTED": 49,
  "49": "X_CACHE_HANDLER_NOT_SUPPORTED",
  "X_SCOPE_ID_NOT_SUPPORTED": 50,
  "50": "X_SCOPE_ID_NOT_SUPPORTED",
  "X_VNODE_HOOKS": 51,
  "51": "X_VNODE_HOOKS",
  "X_V_BIND_INVALID_SAME_NAME_ARGUMENT": 52,
  "52": "X_V_BIND_INVALID_SAME_NAME_ARGUMENT",
  "__EXTEND_POINT__": 53,
  "53": "__EXTEND_POINT__"
};
const errorMessages = {
  // parse errors
  [0]: "Illegal comment.",
  [1]: "CDATA section is allowed only in XML context.",
  [2]: "Duplicate attribute.",
  [3]: "End tag cannot have attributes.",
  [4]: "Illegal '/' in tags.",
  [5]: "Unexpected EOF in tag.",
  [6]: "Unexpected EOF in CDATA section.",
  [7]: "Unexpected EOF in comment.",
  [8]: "Unexpected EOF in script.",
  [9]: "Unexpected EOF in tag.",
  [10]: "Incorrectly closed comment.",
  [11]: "Incorrectly opened comment.",
  [12]: "Illegal tag name. Use '&lt;' to print '<'.",
  [13]: "Attribute value was expected.",
  [14]: "End tag name was expected.",
  [15]: "Whitespace was expected.",
  [16]: "Unexpected '<!--' in comment.",
  [17]: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`,
  [18]: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
  [19]: "Attribute name cannot start with '='.",
  [21]: "'<?' is allowed only in XML context.",
  [20]: `Unexpected null character.`,
  [22]: "Illegal '/' in tags.",
  // Vue-specific parse errors
  [23]: "Invalid end tag.",
  [24]: "Element is missing end tag.",
  [25]: "Interpolation end sign was not found.",
  [27]: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",
  [26]: "Legal directive name was expected.",
  // transform errors
  [28]: `v-if/v-else-if is missing expression.`,
  [29]: `v-if/else branches must use unique keys.`,
  [30]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,
  [31]: `v-for is missing expression.`,
  [32]: `v-for has invalid expression.`,
  [33]: `<template v-for> key should be placed on the <template> tag.`,
  [34]: `v-bind is missing expression.`,
  [52]: `v-bind with same-name shorthand only allows static argument.`,
  [35]: `v-on is missing expression.`,
  [36]: `Unexpected custom directive on <slot> outlet.`,
  [37]: `Mixed v-slot usage on both the component and nested <template>. When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.`,
  [38]: `Duplicate slot names found. `,
  [39]: `Extraneous children found when component already has explicitly named default slot. These children will be ignored.`,
  [40]: `v-slot can only be used on components or <template> tags.`,
  [41]: `v-model is missing expression.`,
  [42]: `v-model value must be a valid JavaScript member expression.`,
  [43]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
  [44]: `v-model cannot be used on a prop, because local prop bindings are not writable.
Use a v-bind binding combined with a v-on listener that emits update:x event instead.`,
  [45]: `Error parsing JavaScript expression: `,
  [46]: `<KeepAlive> expects exactly one child component.`,
  [51]: `@vnode-* hooks in templates are no longer supported. Use the vue: prefix instead. For example, @vnode-mounted should be changed to @vue:mounted. @vnode-* hooks support has been removed in 3.4.`,
  // generic errors
  [47]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
  [48]: `ES module mode is not supported in this build of compiler.`,
  [49]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
  [50]: `"scopeId" option is only supported in module mode.`,
  // just to fulfill types
  [53]: ``
};

function walkIdentifiers(root, onIdentifier, includeAll = false, parentStack = [], knownIds = /* @__PURE__ */ Object.create(null)) {
  {
    return;
  }
}
function isReferencedIdentifier(id, parent, parentStack) {
  {
    return false;
  }
}
function isInDestructureAssignment(parent, parentStack) {
  if (parent && (parent.type === "ObjectProperty" || parent.type === "ArrayPattern")) {
    let i = parentStack.length;
    while (i--) {
      const p = parentStack[i];
      if (p.type === "AssignmentExpression") {
        return true;
      } else if (p.type !== "ObjectProperty" && !p.type.endsWith("Pattern")) {
        break;
      }
    }
  }
  return false;
}
function isInNewExpression(parentStack) {
  let i = parentStack.length;
  while (i--) {
    const p = parentStack[i];
    if (p.type === "NewExpression") {
      return true;
    } else if (p.type !== "MemberExpression") {
      break;
    }
  }
  return false;
}
function walkFunctionParams(node, onIdent) {
  for (const p of node.params) {
    for (const id of extractIdentifiers(p)) {
      onIdent(id);
    }
  }
}
function walkBlockDeclarations(block, onIdent) {
  for (const stmt of block.body) {
    if (stmt.type === "VariableDeclaration") {
      if (stmt.declare) continue;
      for (const decl of stmt.declarations) {
        for (const id of extractIdentifiers(decl.id)) {
          onIdent(id);
        }
      }
    } else if (stmt.type === "FunctionDeclaration" || stmt.type === "ClassDeclaration") {
      if (stmt.declare || !stmt.id) continue;
      onIdent(stmt.id);
    } else if (isForStatement(stmt)) {
      walkForStatement(stmt, true, onIdent);
    }
  }
}
function isForStatement(stmt) {
  return stmt.type === "ForOfStatement" || stmt.type === "ForInStatement" || stmt.type === "ForStatement";
}
function walkForStatement(stmt, isVar, onIdent) {
  const variable = stmt.type === "ForStatement" ? stmt.init : stmt.left;
  if (variable && variable.type === "VariableDeclaration" && (variable.kind === "var" ? isVar : !isVar)) {
    for (const decl of variable.declarations) {
      for (const id of extractIdentifiers(decl.id)) {
        onIdent(id);
      }
    }
  }
}
function extractIdentifiers(param, nodes = []) {
  switch (param.type) {
    case "Identifier":
      nodes.push(param);
      break;
    case "MemberExpression":
      let object = param;
      while (object.type === "MemberExpression") {
        object = object.object;
      }
      nodes.push(object);
      break;
    case "ObjectPattern":
      for (const prop of param.properties) {
        if (prop.type === "RestElement") {
          extractIdentifiers(prop.argument, nodes);
        } else {
          extractIdentifiers(prop.value, nodes);
        }
      }
      break;
    case "ArrayPattern":
      param.elements.forEach((element) => {
        if (element) extractIdentifiers(element, nodes);
      });
      break;
    case "RestElement":
      extractIdentifiers(param.argument, nodes);
      break;
    case "AssignmentPattern":
      extractIdentifiers(param.left, nodes);
      break;
  }
  return nodes;
}
const isFunctionType = (node) => {
  return /Function(?:Expression|Declaration)$|Method$/.test(node.type);
};
const isStaticProperty = (node) => node && (node.type === "ObjectProperty" || node.type === "ObjectMethod") && !node.computed;
const isStaticPropertyKey = (node, parent) => isStaticProperty(parent) && parent.key === node;
const TS_NODE_TYPES = [
  "TSAsExpression",
  // foo as number
  "TSTypeAssertion",
  // (<number>foo)
  "TSNonNullExpression",
  // foo!
  "TSInstantiationExpression",
  // foo<string>
  "TSSatisfiesExpression"
  // foo satisfies T
];
function unwrapTSNode(node) {
  if (TS_NODE_TYPES.includes(node.type)) {
    return unwrapTSNode(node.expression);
  } else {
    return node;
  }
}

const isStaticExp = (p) => p.type === 4 && p.isStatic;
function isCoreComponent(tag) {
  switch (tag) {
    case "Teleport":
    case "teleport":
      return TELEPORT;
    case "Suspense":
    case "suspense":
      return SUSPENSE;
    case "KeepAlive":
    case "keep-alive":
      return KEEP_ALIVE;
    case "BaseTransition":
    case "base-transition":
      return BASE_TRANSITION;
  }
}
const nonIdentifierRE = /^\d|[^\$\w\xA0-\uFFFF]/;
const isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
const validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
const validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
const whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
const getExpSource = (exp) => exp.type === 4 ? exp.content : exp.loc.source;
const isMemberExpressionBrowser = (exp) => {
  const path = getExpSource(exp).trim().replace(whitespaceRE, (s) => s.trim());
  let state = 0 /* inMemberExp */;
  let stateStack = [];
  let currentOpenBracketCount = 0;
  let currentOpenParensCount = 0;
  let currentStringType = null;
  for (let i = 0; i < path.length; i++) {
    const char = path.charAt(i);
    switch (state) {
      case 0 /* inMemberExp */:
        if (char === "[") {
          stateStack.push(state);
          state = 1 /* inBrackets */;
          currentOpenBracketCount++;
        } else if (char === "(") {
          stateStack.push(state);
          state = 2 /* inParens */;
          currentOpenParensCount++;
        } else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
          return false;
        }
        break;
      case 1 /* inBrackets */:
        if (char === `'` || char === `"` || char === "`") {
          stateStack.push(state);
          state = 3 /* inString */;
          currentStringType = char;
        } else if (char === `[`) {
          currentOpenBracketCount++;
        } else if (char === `]`) {
          if (!--currentOpenBracketCount) {
            state = stateStack.pop();
          }
        }
        break;
      case 2 /* inParens */:
        if (char === `'` || char === `"` || char === "`") {
          stateStack.push(state);
          state = 3 /* inString */;
          currentStringType = char;
        } else if (char === `(`) {
          currentOpenParensCount++;
        } else if (char === `)`) {
          if (i === path.length - 1) {
            return false;
          }
          if (!--currentOpenParensCount) {
            state = stateStack.pop();
          }
        }
        break;
      case 3 /* inString */:
        if (char === currentStringType) {
          state = stateStack.pop();
          currentStringType = null;
        }
        break;
    }
  }
  return !currentOpenBracketCount && !currentOpenParensCount;
};
const isMemberExpressionNode = NOOP ;
const isMemberExpression = isMemberExpressionBrowser ;
const fnExpRE = /^\s*(async\s*)?(\([^)]*?\)|[\w$_]+)\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;
const isFnExpressionBrowser = (exp) => fnExpRE.test(getExpSource(exp));
const isFnExpressionNode = NOOP ;
const isFnExpression = isFnExpressionBrowser ;
function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
  return advancePositionWithMutation(
    {
      offset: pos.offset,
      line: pos.line,
      column: pos.column
    },
    source,
    numberOfCharacters
  );
}
function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
  let linesCount = 0;
  let lastNewLinePos = -1;
  for (let i = 0; i < numberOfCharacters; i++) {
    if (source.charCodeAt(i) === 10) {
      linesCount++;
      lastNewLinePos = i;
    }
  }
  pos.offset += numberOfCharacters;
  pos.line += linesCount;
  pos.column = lastNewLinePos === -1 ? pos.column + numberOfCharacters : numberOfCharacters - lastNewLinePos;
  return pos;
}
function assert(condition, msg) {
  if (!condition) {
    throw new Error(msg || `unexpected compiler condition`);
  }
}
function findDir(node, name, allowEmpty = false) {
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 7 && (allowEmpty || p.exp) && (isString(name) ? p.name === name : name.test(p.name))) {
      return p;
    }
  }
}
function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 6) {
      if (dynamicOnly) continue;
      if (p.name === name && (p.value || allowEmpty)) {
        return p;
      }
    } else if (p.name === "bind" && (p.exp || allowEmpty) && isStaticArgOf(p.arg, name)) {
      return p;
    }
  }
}
function isStaticArgOf(arg, name) {
  return !!(arg && isStaticExp(arg) && arg.content === name);
}
function hasDynamicKeyVBind(node) {
  return node.props.some(
    (p) => p.type === 7 && p.name === "bind" && (!p.arg || // v-bind="obj"
    p.arg.type !== 4 || // v-bind:[_ctx.foo]
    !p.arg.isStatic)
    // v-bind:[foo]
  );
}
function isText$1(node) {
  return node.type === 5 || node.type === 2;
}
function isVSlot(p) {
  return p.type === 7 && p.name === "slot";
}
function isTemplateNode(node) {
  return node.type === 1 && node.tagType === 3;
}
function isSlotOutlet(node) {
  return node.type === 1 && node.tagType === 2;
}
const propsHelperSet = /* @__PURE__ */ new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
function getUnnormalizedProps(props, callPath = []) {
  if (props && !isString(props) && props.type === 14) {
    const callee = props.callee;
    if (!isString(callee) && propsHelperSet.has(callee)) {
      return getUnnormalizedProps(
        props.arguments[0],
        callPath.concat(props)
      );
    }
  }
  return [props, callPath];
}
function injectProp(node, prop, context) {
  let propsWithInjection;
  let props = node.type === 13 ? node.props : node.arguments[2];
  let callPath = [];
  let parentCall;
  if (props && !isString(props) && props.type === 14) {
    const ret = getUnnormalizedProps(props);
    props = ret[0];
    callPath = ret[1];
    parentCall = callPath[callPath.length - 1];
  }
  if (props == null || isString(props)) {
    propsWithInjection = createObjectExpression([prop]);
  } else if (props.type === 14) {
    const first = props.arguments[0];
    if (!isString(first) && first.type === 15) {
      if (!hasProp(prop, first)) {
        first.properties.unshift(prop);
      }
    } else {
      if (props.callee === TO_HANDLERS) {
        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
          createObjectExpression([prop]),
          props
        ]);
      } else {
        props.arguments.unshift(createObjectExpression([prop]));
      }
    }
    !propsWithInjection && (propsWithInjection = props);
  } else if (props.type === 15) {
    if (!hasProp(prop, props)) {
      props.properties.unshift(prop);
    }
    propsWithInjection = props;
  } else {
    propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
      createObjectExpression([prop]),
      props
    ]);
    if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
      parentCall = callPath[callPath.length - 2];
    }
  }
  if (node.type === 13) {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.props = propsWithInjection;
    }
  } else {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.arguments[2] = propsWithInjection;
    }
  }
}
function hasProp(prop, props) {
  let result = false;
  if (prop.key.type === 4) {
    const propKeyName = prop.key.content;
    result = props.properties.some(
      (p) => p.key.type === 4 && p.key.content === propKeyName
    );
  }
  return result;
}
function toValidAssetId(name, type) {
  return `_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) => {
    return searchValue === "-" ? "_" : name.charCodeAt(replaceValue).toString();
  })}`;
}
function hasScopeRef(node, ids) {
  if (!node || Object.keys(ids).length === 0) {
    return false;
  }
  switch (node.type) {
    case 1:
      for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 7 && (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))) {
          return true;
        }
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 11:
      if (hasScopeRef(node.source, ids)) {
        return true;
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 9:
      return node.branches.some((b) => hasScopeRef(b, ids));
    case 10:
      if (hasScopeRef(node.condition, ids)) {
        return true;
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 4:
      return !node.isStatic && isSimpleIdentifier(node.content) && !!ids[node.content];
    case 8:
      return node.children.some((c) => isObject$1(c) && hasScopeRef(c, ids));
    case 5:
    case 12:
      return hasScopeRef(node.content, ids);
    case 2:
    case 3:
    case 20:
      return false;
    default:
      return false;
  }
}
function getMemoedVNodeCall(node) {
  if (node.type === 14 && node.callee === WITH_MEMO) {
    return node.arguments[1].returns;
  } else {
    return node;
  }
}
const forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+(\S[\s\S]*)/;

const defaultParserOptions = {
  parseMode: "base",
  ns: 0,
  delimiters: [`{{`, `}}`],
  getNamespace: () => 0,
  isVoidTag: NO,
  isPreTag: NO,
  isIgnoreNewlineTag: NO,
  isCustomElement: NO,
  onError: defaultOnError,
  onWarn: defaultOnWarn,
  comments: !!("production" !== "production"),
  prefixIdentifiers: false
};
let currentOptions = defaultParserOptions;
let currentRoot = null;
let currentInput = "";
let currentOpenTag = null;
let currentProp = null;
let currentAttrValue = "";
let currentAttrStartIndex = -1;
let currentAttrEndIndex = -1;
let inPre = 0;
let inVPre = false;
let currentVPreBoundary = null;
const stack$1 = [];
const tokenizer = new Tokenizer(stack$1, {
  onerr: emitError,
  ontext(start, end) {
    onText(getSlice(start, end), start, end);
  },
  ontextentity(char, start, end) {
    onText(char, start, end);
  },
  oninterpolation(start, end) {
    if (inVPre) {
      return onText(getSlice(start, end), start, end);
    }
    let innerStart = start + tokenizer.delimiterOpen.length;
    let innerEnd = end - tokenizer.delimiterClose.length;
    while (isWhitespace(currentInput.charCodeAt(innerStart))) {
      innerStart++;
    }
    while (isWhitespace(currentInput.charCodeAt(innerEnd - 1))) {
      innerEnd--;
    }
    let exp = getSlice(innerStart, innerEnd);
    if (exp.includes("&")) {
      {
        exp = currentOptions.decodeEntities(exp, false);
      }
    }
    addNode({
      type: 5,
      content: createExp(exp, false, getLoc(innerStart, innerEnd)),
      loc: getLoc(start, end)
    });
  },
  onopentagname(start, end) {
    const name = getSlice(start, end);
    currentOpenTag = {
      type: 1,
      tag: name,
      ns: currentOptions.getNamespace(name, stack$1[0], currentOptions.ns),
      tagType: 0,
      // will be refined on tag close
      props: [],
      children: [],
      loc: getLoc(start - 1, end),
      codegenNode: void 0
    };
  },
  onopentagend(end) {
    endOpenTag(end);
  },
  onclosetag(start, end) {
    const name = getSlice(start, end);
    if (!currentOptions.isVoidTag(name)) {
      let found = false;
      for (let i = 0; i < stack$1.length; i++) {
        const e = stack$1[i];
        if (e.tag.toLowerCase() === name.toLowerCase()) {
          found = true;
          if (i > 0) {
            emitError(24, stack$1[0].loc.start.offset);
          }
          for (let j = 0; j <= i; j++) {
            const el = stack$1.shift();
            onCloseTag(el, end, j < i);
          }
          break;
        }
      }
      if (!found) {
        emitError(23, backTrack(start, 60));
      }
    }
  },
  onselfclosingtag(end) {
    const name = currentOpenTag.tag;
    currentOpenTag.isSelfClosing = true;
    endOpenTag(end);
    if (stack$1[0] && stack$1[0].tag === name) {
      onCloseTag(stack$1.shift(), end);
    }
  },
  onattribname(start, end) {
    currentProp = {
      type: 6,
      name: getSlice(start, end),
      nameLoc: getLoc(start, end),
      value: void 0,
      loc: getLoc(start)
    };
  },
  ondirname(start, end) {
    const raw = getSlice(start, end);
    const name = raw === "." || raw === ":" ? "bind" : raw === "@" ? "on" : raw === "#" ? "slot" : raw.slice(2);
    if (!inVPre && name === "") {
      emitError(26, start);
    }
    if (inVPre || name === "") {
      currentProp = {
        type: 6,
        name: raw,
        nameLoc: getLoc(start, end),
        value: void 0,
        loc: getLoc(start)
      };
    } else {
      currentProp = {
        type: 7,
        name,
        rawName: raw,
        exp: void 0,
        arg: void 0,
        modifiers: raw === "." ? [createSimpleExpression("prop")] : [],
        loc: getLoc(start)
      };
      if (name === "pre") {
        inVPre = tokenizer.inVPre = true;
        currentVPreBoundary = currentOpenTag;
        const props = currentOpenTag.props;
        for (let i = 0; i < props.length; i++) {
          if (props[i].type === 7) {
            props[i] = dirToAttr(props[i]);
          }
        }
      }
    }
  },
  ondirarg(start, end) {
    if (start === end) return;
    const arg = getSlice(start, end);
    if (inVPre) {
      currentProp.name += arg;
      setLocEnd(currentProp.nameLoc, end);
    } else {
      const isStatic = arg[0] !== `[`;
      currentProp.arg = createExp(
        isStatic ? arg : arg.slice(1, -1),
        isStatic,
        getLoc(start, end),
        isStatic ? 3 : 0
      );
    }
  },
  ondirmodifier(start, end) {
    const mod = getSlice(start, end);
    if (inVPre) {
      currentProp.name += "." + mod;
      setLocEnd(currentProp.nameLoc, end);
    } else if (currentProp.name === "slot") {
      const arg = currentProp.arg;
      if (arg) {
        arg.content += "." + mod;
        setLocEnd(arg.loc, end);
      }
    } else {
      const exp = createSimpleExpression(mod, true, getLoc(start, end));
      currentProp.modifiers.push(exp);
    }
  },
  onattribdata(start, end) {
    currentAttrValue += getSlice(start, end);
    if (currentAttrStartIndex < 0) currentAttrStartIndex = start;
    currentAttrEndIndex = end;
  },
  onattribentity(char, start, end) {
    currentAttrValue += char;
    if (currentAttrStartIndex < 0) currentAttrStartIndex = start;
    currentAttrEndIndex = end;
  },
  onattribnameend(end) {
    const start = currentProp.loc.start.offset;
    const name = getSlice(start, end);
    if (currentProp.type === 7) {
      currentProp.rawName = name;
    }
    if (currentOpenTag.props.some(
      (p) => (p.type === 7 ? p.rawName : p.name) === name
    )) {
      emitError(2, start);
    }
  },
  onattribend(quote, end) {
    if (currentOpenTag && currentProp) {
      setLocEnd(currentProp.loc, end);
      if (quote !== 0) {
        if (currentAttrValue.includes("&")) {
          currentAttrValue = currentOptions.decodeEntities(
            currentAttrValue,
            true
          );
        }
        if (currentProp.type === 6) {
          if (currentProp.name === "class") {
            currentAttrValue = condense(currentAttrValue).trim();
          }
          if (quote === 1 && !currentAttrValue) {
            emitError(13, end);
          }
          currentProp.value = {
            type: 2,
            content: currentAttrValue,
            loc: quote === 1 ? getLoc(currentAttrStartIndex, currentAttrEndIndex) : getLoc(currentAttrStartIndex - 1, currentAttrEndIndex + 1)
          };
          if (tokenizer.inSFCRoot && currentOpenTag.tag === "template" && currentProp.name === "lang" && currentAttrValue && currentAttrValue !== "html") {
            tokenizer.enterRCDATA(toCharCodes(`</template`), 0);
          }
        } else {
          let expParseMode = 0 /* Normal */;
          currentProp.exp = createExp(
            currentAttrValue,
            false,
            getLoc(currentAttrStartIndex, currentAttrEndIndex),
            0,
            expParseMode
          );
          if (currentProp.name === "for") {
            currentProp.forParseResult = parseForExpression(currentProp.exp);
          }
          let syncIndex = -1;
          if (currentProp.name === "bind" && (syncIndex = currentProp.modifiers.findIndex(
            (mod) => mod.content === "sync"
          )) > -1 && checkCompatEnabled(
            "COMPILER_V_BIND_SYNC",
            currentOptions,
            currentProp.loc,
            currentProp.rawName
          )) {
            currentProp.name = "model";
            currentProp.modifiers.splice(syncIndex, 1);
          }
        }
      }
      if (currentProp.type !== 7 || currentProp.name !== "pre") {
        currentOpenTag.props.push(currentProp);
      }
    }
    currentAttrValue = "";
    currentAttrStartIndex = currentAttrEndIndex = -1;
  },
  oncomment(start, end) {
    if (currentOptions.comments) {
      addNode({
        type: 3,
        content: getSlice(start, end),
        loc: getLoc(start - 4, end + 3)
      });
    }
  },
  onend() {
    const end = currentInput.length;
    for (let index = 0; index < stack$1.length; index++) {
      onCloseTag(stack$1[index], end - 1);
      emitError(24, stack$1[index].loc.start.offset);
    }
  },
  oncdata(start, end) {
    if (stack$1[0].ns !== 0) {
      onText(getSlice(start, end), start, end);
    } else {
      emitError(1, start - 9);
    }
  },
  onprocessinginstruction(start) {
    if ((stack$1[0] ? stack$1[0].ns : currentOptions.ns) === 0) {
      emitError(
        21,
        start - 1
      );
    }
  }
});
const forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
const stripParensRE = /^\(|\)$/g;
function parseForExpression(input) {
  const loc = input.loc;
  const exp = input.content;
  const inMatch = exp.match(forAliasRE);
  if (!inMatch) return;
  const [, LHS, RHS] = inMatch;
  const createAliasExpression = (content, offset, asParam = false) => {
    const start = loc.start.offset + offset;
    const end = start + content.length;
    return createExp(
      content,
      false,
      getLoc(start, end),
      0,
      asParam ? 1 /* Params */ : 0 /* Normal */
    );
  };
  const result = {
    source: createAliasExpression(RHS.trim(), exp.indexOf(RHS, LHS.length)),
    value: void 0,
    key: void 0,
    index: void 0,
    finalized: false
  };
  let valueContent = LHS.trim().replace(stripParensRE, "").trim();
  const trimmedOffset = LHS.indexOf(valueContent);
  const iteratorMatch = valueContent.match(forIteratorRE);
  if (iteratorMatch) {
    valueContent = valueContent.replace(forIteratorRE, "").trim();
    const keyContent = iteratorMatch[1].trim();
    let keyOffset;
    if (keyContent) {
      keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
      result.key = createAliasExpression(keyContent, keyOffset, true);
    }
    if (iteratorMatch[2]) {
      const indexContent = iteratorMatch[2].trim();
      if (indexContent) {
        result.index = createAliasExpression(
          indexContent,
          exp.indexOf(
            indexContent,
            result.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length
          ),
          true
        );
      }
    }
  }
  if (valueContent) {
    result.value = createAliasExpression(valueContent, trimmedOffset, true);
  }
  return result;
}
function getSlice(start, end) {
  return currentInput.slice(start, end);
}
function endOpenTag(end) {
  if (tokenizer.inSFCRoot) {
    currentOpenTag.innerLoc = getLoc(end + 1, end + 1);
  }
  addNode(currentOpenTag);
  const { tag, ns } = currentOpenTag;
  if (ns === 0 && currentOptions.isPreTag(tag)) {
    inPre++;
  }
  if (currentOptions.isVoidTag(tag)) {
    onCloseTag(currentOpenTag, end);
  } else {
    stack$1.unshift(currentOpenTag);
    if (ns === 1 || ns === 2) {
      tokenizer.inXML = true;
    }
  }
  currentOpenTag = null;
}
function onText(content, start, end) {
  {
    const tag = stack$1[0] && stack$1[0].tag;
    if (tag !== "script" && tag !== "style" && content.includes("&")) {
      content = currentOptions.decodeEntities(content, false);
    }
  }
  const parent = stack$1[0] || currentRoot;
  const lastNode = parent.children[parent.children.length - 1];
  if (lastNode && lastNode.type === 2) {
    lastNode.content += content;
    setLocEnd(lastNode.loc, end);
  } else {
    parent.children.push({
      type: 2,
      content,
      loc: getLoc(start, end)
    });
  }
}
function onCloseTag(el, end, isImplied = false) {
  if (isImplied) {
    setLocEnd(el.loc, backTrack(end, 60));
  } else {
    setLocEnd(el.loc, lookAhead(end, 62) + 1);
  }
  if (tokenizer.inSFCRoot) {
    if (el.children.length) {
      el.innerLoc.end = extend({}, el.children[el.children.length - 1].loc.end);
    } else {
      el.innerLoc.end = extend({}, el.innerLoc.start);
    }
    el.innerLoc.source = getSlice(
      el.innerLoc.start.offset,
      el.innerLoc.end.offset
    );
  }
  const { tag, ns, children } = el;
  if (!inVPre) {
    if (tag === "slot") {
      el.tagType = 2;
    } else if (isFragmentTemplate(el)) {
      el.tagType = 3;
    } else if (isComponent(el)) {
      el.tagType = 1;
    }
  }
  if (!tokenizer.inRCDATA) {
    el.children = condenseWhitespace(children);
  }
  if (ns === 0 && currentOptions.isIgnoreNewlineTag(tag)) {
    const first = children[0];
    if (first && first.type === 2) {
      first.content = first.content.replace(/^\r?\n/, "");
    }
  }
  if (ns === 0 && currentOptions.isPreTag(tag)) {
    inPre--;
  }
  if (currentVPreBoundary === el) {
    inVPre = tokenizer.inVPre = false;
    currentVPreBoundary = null;
  }
  if (tokenizer.inXML && (stack$1[0] ? stack$1[0].ns : currentOptions.ns) === 0) {
    tokenizer.inXML = false;
  }
  {
    const props = el.props;
    if (!tokenizer.inSFCRoot && isCompatEnabled(
      "COMPILER_NATIVE_TEMPLATE",
      currentOptions
    ) && el.tag === "template" && !isFragmentTemplate(el)) {
      const parent = stack$1[0] || currentRoot;
      const index = parent.children.indexOf(el);
      parent.children.splice(index, 1, ...el.children);
    }
    const inlineTemplateProp = props.find(
      (p) => p.type === 6 && p.name === "inline-template"
    );
    if (inlineTemplateProp && checkCompatEnabled(
      "COMPILER_INLINE_TEMPLATE",
      currentOptions,
      inlineTemplateProp.loc
    ) && el.children.length) {
      inlineTemplateProp.value = {
        type: 2,
        content: getSlice(
          el.children[0].loc.start.offset,
          el.children[el.children.length - 1].loc.end.offset
        ),
        loc: inlineTemplateProp.loc
      };
    }
  }
}
function lookAhead(index, c) {
  let i = index;
  while (currentInput.charCodeAt(i) !== c && i < currentInput.length - 1) i++;
  return i;
}
function backTrack(index, c) {
  let i = index;
  while (currentInput.charCodeAt(i) !== c && i >= 0) i--;
  return i;
}
const specialTemplateDir = /* @__PURE__ */ new Set(["if", "else", "else-if", "for", "slot"]);
function isFragmentTemplate({ tag, props }) {
  if (tag === "template") {
    for (let i = 0; i < props.length; i++) {
      if (props[i].type === 7 && specialTemplateDir.has(props[i].name)) {
        return true;
      }
    }
  }
  return false;
}
function isComponent({ tag, props }) {
  if (currentOptions.isCustomElement(tag)) {
    return false;
  }
  if (tag === "component" || isUpperCase(tag.charCodeAt(0)) || isCoreComponent(tag) || currentOptions.isBuiltInComponent && currentOptions.isBuiltInComponent(tag) || currentOptions.isNativeTag && !currentOptions.isNativeTag(tag)) {
    return true;
  }
  for (let i = 0; i < props.length; i++) {
    const p = props[i];
    if (p.type === 6) {
      if (p.name === "is" && p.value) {
        if (p.value.content.startsWith("vue:")) {
          return true;
        } else if (checkCompatEnabled(
          "COMPILER_IS_ON_ELEMENT",
          currentOptions,
          p.loc
        )) {
          return true;
        }
      }
    } else if (// :is on plain element - only treat as component in compat mode
    p.name === "bind" && isStaticArgOf(p.arg, "is") && checkCompatEnabled(
      "COMPILER_IS_ON_ELEMENT",
      currentOptions,
      p.loc
    )) {
      return true;
    }
  }
  return false;
}
function isUpperCase(c) {
  return c > 64 && c < 91;
}
const windowsNewlineRE = /\r\n/g;
function condenseWhitespace(nodes, tag) {
  const shouldCondense = currentOptions.whitespace !== "preserve";
  let removedWhitespace = false;
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (node.type === 2) {
      if (!inPre) {
        if (isAllWhitespace(node.content)) {
          const prev = nodes[i - 1] && nodes[i - 1].type;
          const next = nodes[i + 1] && nodes[i + 1].type;
          if (!prev || !next || shouldCondense && (prev === 3 && (next === 3 || next === 1) || prev === 1 && (next === 3 || next === 1 && hasNewlineChar(node.content)))) {
            removedWhitespace = true;
            nodes[i] = null;
          } else {
            node.content = " ";
          }
        } else if (shouldCondense) {
          node.content = condense(node.content);
        }
      } else {
        node.content = node.content.replace(windowsNewlineRE, "\n");
      }
    }
  }
  return removedWhitespace ? nodes.filter(Boolean) : nodes;
}
function isAllWhitespace(str) {
  for (let i = 0; i < str.length; i++) {
    if (!isWhitespace(str.charCodeAt(i))) {
      return false;
    }
  }
  return true;
}
function hasNewlineChar(str) {
  for (let i = 0; i < str.length; i++) {
    const c = str.charCodeAt(i);
    if (c === 10 || c === 13) {
      return true;
    }
  }
  return false;
}
function condense(str) {
  let ret = "";
  let prevCharIsWhitespace = false;
  for (let i = 0; i < str.length; i++) {
    if (isWhitespace(str.charCodeAt(i))) {
      if (!prevCharIsWhitespace) {
        ret += " ";
        prevCharIsWhitespace = true;
      }
    } else {
      ret += str[i];
      prevCharIsWhitespace = false;
    }
  }
  return ret;
}
function addNode(node) {
  (stack$1[0] || currentRoot).children.push(node);
}
function getLoc(start, end) {
  return {
    start: tokenizer.getPos(start),
    // @ts-expect-error allow late attachment
    end: end == null ? end : tokenizer.getPos(end),
    // @ts-expect-error allow late attachment
    source: end == null ? end : getSlice(start, end)
  };
}
function setLocEnd(loc, end) {
  loc.end = tokenizer.getPos(end);
  loc.source = getSlice(loc.start.offset, end);
}
function dirToAttr(dir) {
  const attr = {
    type: 6,
    name: dir.rawName,
    nameLoc: getLoc(
      dir.loc.start.offset,
      dir.loc.start.offset + dir.rawName.length
    ),
    value: void 0,
    loc: dir.loc
  };
  if (dir.exp) {
    const loc = dir.exp.loc;
    if (loc.end.offset < dir.loc.end.offset) {
      loc.start.offset--;
      loc.start.column--;
      loc.end.offset++;
      loc.end.column++;
    }
    attr.value = {
      type: 2,
      content: dir.exp.content,
      loc
    };
  }
  return attr;
}
function createExp(content, isStatic = false, loc, constType = 0, parseMode = 0 /* Normal */) {
  const exp = createSimpleExpression(content, isStatic, loc, constType);
  return exp;
}
function emitError(code, index, message) {
  currentOptions.onError(
    createCompilerError(code, getLoc(index, index))
  );
}
function reset() {
  tokenizer.reset();
  currentOpenTag = null;
  currentProp = null;
  currentAttrValue = "";
  currentAttrStartIndex = -1;
  currentAttrEndIndex = -1;
  stack$1.length = 0;
}
function baseParse(input, options) {
  reset();
  currentInput = input;
  currentOptions = extend({}, defaultParserOptions);
  if (options) {
    let key;
    for (key in options) {
      if (options[key] != null) {
        currentOptions[key] = options[key];
      }
    }
  }
  tokenizer.mode = currentOptions.parseMode === "html" ? 1 : currentOptions.parseMode === "sfc" ? 2 : 0;
  tokenizer.inXML = currentOptions.ns === 1 || currentOptions.ns === 2;
  const delimiters = options && options.delimiters;
  if (delimiters) {
    tokenizer.delimiterOpen = toCharCodes(delimiters[0]);
    tokenizer.delimiterClose = toCharCodes(delimiters[1]);
  }
  const root = currentRoot = createRoot([], input);
  tokenizer.parse(currentInput);
  root.loc = getLoc(0, input.length);
  root.children = condenseWhitespace(root.children);
  currentRoot = null;
  return root;
}

function cacheStatic(root, context) {
  walk(
    root,
    void 0,
    context,
    // Root node is unfortunately non-hoistable due to potential parent
    // fallthrough attributes.
    isSingleElementRoot(root, root.children[0])
  );
}
function isSingleElementRoot(root, child) {
  const { children } = root;
  return children.length === 1 && child.type === 1 && !isSlotOutlet(child);
}
function walk(node, parent, context, doNotHoistNode = false, inFor = false) {
  const { children } = node;
  const toCache = [];
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (child.type === 1 && child.tagType === 0) {
      const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
      if (constantType > 0) {
        if (constantType >= 2) {
          child.codegenNode.patchFlag = -1;
          toCache.push(child);
          continue;
        }
      } else {
        const codegenNode = child.codegenNode;
        if (codegenNode.type === 13) {
          const flag = codegenNode.patchFlag;
          if ((flag === void 0 || flag === 512 || flag === 1) && getGeneratedPropsConstantType(child, context) >= 2) {
            const props = getNodeProps(child);
            if (props) {
              codegenNode.props = context.hoist(props);
            }
          }
          if (codegenNode.dynamicProps) {
            codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);
          }
        }
      }
    } else if (child.type === 12) {
      const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
      if (constantType >= 2) {
        toCache.push(child);
        continue;
      }
    }
    if (child.type === 1) {
      const isComponent = child.tagType === 1;
      if (isComponent) {
        context.scopes.vSlot++;
      }
      walk(child, node, context, false, inFor);
      if (isComponent) {
        context.scopes.vSlot--;
      }
    } else if (child.type === 11) {
      walk(child, node, context, child.children.length === 1, true);
    } else if (child.type === 9) {
      for (let i2 = 0; i2 < child.branches.length; i2++) {
        walk(
          child.branches[i2],
          node,
          context,
          child.branches[i2].children.length === 1,
          inFor
        );
      }
    }
  }
  let cachedAsArray = false;
  if (toCache.length === children.length && node.type === 1) {
    if (node.tagType === 0 && node.codegenNode && node.codegenNode.type === 13 && isArray(node.codegenNode.children)) {
      node.codegenNode.children = getCacheExpression(
        createArrayExpression(node.codegenNode.children)
      );
      cachedAsArray = true;
    } else if (node.tagType === 1 && node.codegenNode && node.codegenNode.type === 13 && node.codegenNode.children && !isArray(node.codegenNode.children) && node.codegenNode.children.type === 15) {
      const slot = getSlotNode(node.codegenNode, "default");
      if (slot) {
        slot.returns = getCacheExpression(
          createArrayExpression(slot.returns)
        );
        cachedAsArray = true;
      }
    } else if (node.tagType === 3 && parent && parent.type === 1 && parent.tagType === 1 && parent.codegenNode && parent.codegenNode.type === 13 && parent.codegenNode.children && !isArray(parent.codegenNode.children) && parent.codegenNode.children.type === 15) {
      const slotName = findDir(node, "slot", true);
      const slot = slotName && slotName.arg && getSlotNode(parent.codegenNode, slotName.arg);
      if (slot) {
        slot.returns = getCacheExpression(
          createArrayExpression(slot.returns)
        );
        cachedAsArray = true;
      }
    }
  }
  if (!cachedAsArray) {
    for (const child of toCache) {
      child.codegenNode = context.cache(child.codegenNode);
    }
  }
  function getCacheExpression(value) {
    const exp = context.cache(value);
    if (inFor && context.hmr) {
      exp.needArraySpread = true;
    }
    return exp;
  }
  function getSlotNode(node2, name) {
    if (node2.children && !isArray(node2.children) && node2.children.type === 15) {
      const slot = node2.children.properties.find(
        (p) => p.key === name || p.key.content === name
      );
      return slot && slot.value;
    }
  }
  if (toCache.length && context.transformHoist) {
    context.transformHoist(children, context, node);
  }
}
function getConstantType(node, context) {
  const { constantCache } = context;
  switch (node.type) {
    case 1:
      if (node.tagType !== 0) {
        return 0;
      }
      const cached = constantCache.get(node);
      if (cached !== void 0) {
        return cached;
      }
      const codegenNode = node.codegenNode;
      if (codegenNode.type !== 13) {
        return 0;
      }
      if (codegenNode.isBlock && node.tag !== "svg" && node.tag !== "foreignObject" && node.tag !== "math") {
        return 0;
      }
      if (codegenNode.patchFlag === void 0) {
        let returnType2 = 3;
        const generatedPropsType = getGeneratedPropsConstantType(node, context);
        if (generatedPropsType === 0) {
          constantCache.set(node, 0);
          return 0;
        }
        if (generatedPropsType < returnType2) {
          returnType2 = generatedPropsType;
        }
        for (let i = 0; i < node.children.length; i++) {
          const childType = getConstantType(node.children[i], context);
          if (childType === 0) {
            constantCache.set(node, 0);
            return 0;
          }
          if (childType < returnType2) {
            returnType2 = childType;
          }
        }
        if (returnType2 > 1) {
          for (let i = 0; i < node.props.length; i++) {
            const p = node.props[i];
            if (p.type === 7 && p.name === "bind" && p.exp) {
              const expType = getConstantType(p.exp, context);
              if (expType === 0) {
                constantCache.set(node, 0);
                return 0;
              }
              if (expType < returnType2) {
                returnType2 = expType;
              }
            }
          }
        }
        if (codegenNode.isBlock) {
          for (let i = 0; i < node.props.length; i++) {
            const p = node.props[i];
            if (p.type === 7) {
              constantCache.set(node, 0);
              return 0;
            }
          }
          context.removeHelper(OPEN_BLOCK);
          context.removeHelper(
            getVNodeBlockHelper(context.inSSR, codegenNode.isComponent)
          );
          codegenNode.isBlock = false;
          context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));
        }
        constantCache.set(node, returnType2);
        return returnType2;
      } else {
        constantCache.set(node, 0);
        return 0;
      }
    case 2:
    case 3:
      return 3;
    case 9:
    case 11:
    case 10:
      return 0;
    case 5:
    case 12:
      return getConstantType(node.content, context);
    case 4:
      return node.constType;
    case 8:
      let returnType = 3;
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if (isString(child) || isSymbol(child)) {
          continue;
        }
        const childType = getConstantType(child, context);
        if (childType === 0) {
          return 0;
        } else if (childType < returnType) {
          returnType = childType;
        }
      }
      return returnType;
    case 20:
      return 2;
    default:
      return 0;
  }
}
const allowHoistedHelperSet = /* @__PURE__ */ new Set([
  NORMALIZE_CLASS,
  NORMALIZE_STYLE,
  NORMALIZE_PROPS,
  GUARD_REACTIVE_PROPS
]);
function getConstantTypeOfHelperCall(value, context) {
  if (value.type === 14 && !isString(value.callee) && allowHoistedHelperSet.has(value.callee)) {
    const arg = value.arguments[0];
    if (arg.type === 4) {
      return getConstantType(arg, context);
    } else if (arg.type === 14) {
      return getConstantTypeOfHelperCall(arg, context);
    }
  }
  return 0;
}
function getGeneratedPropsConstantType(node, context) {
  let returnType = 3;
  const props = getNodeProps(node);
  if (props && props.type === 15) {
    const { properties } = props;
    for (let i = 0; i < properties.length; i++) {
      const { key, value } = properties[i];
      const keyType = getConstantType(key, context);
      if (keyType === 0) {
        return keyType;
      }
      if (keyType < returnType) {
        returnType = keyType;
      }
      let valueType;
      if (value.type === 4) {
        valueType = getConstantType(value, context);
      } else if (value.type === 14) {
        valueType = getConstantTypeOfHelperCall(value, context);
      } else {
        valueType = 0;
      }
      if (valueType === 0) {
        return valueType;
      }
      if (valueType < returnType) {
        returnType = valueType;
      }
    }
  }
  return returnType;
}
function getNodeProps(node) {
  const codegenNode = node.codegenNode;
  if (codegenNode.type === 13) {
    return codegenNode.props;
  }
}

function createTransformContext(root, {
  filename = "",
  prefixIdentifiers = false,
  hoistStatic = false,
  hmr = false,
  cacheHandlers = false,
  nodeTransforms = [],
  directiveTransforms = {},
  transformHoist = null,
  isBuiltInComponent = NOOP,
  isCustomElement = NOOP,
  expressionPlugins = [],
  scopeId = null,
  slotted = true,
  ssr = false,
  inSSR = false,
  ssrCssVars = ``,
  bindingMetadata = EMPTY_OBJ,
  inline = false,
  isTS = false,
  onError = defaultOnError,
  onWarn = defaultOnWarn,
  compatConfig
}) {
  const nameMatch = filename.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/);
  const context = {
    // options
    filename,
    selfName: nameMatch && capitalize$1(camelize$1(nameMatch[1])),
    prefixIdentifiers,
    hoistStatic,
    hmr,
    cacheHandlers,
    nodeTransforms,
    directiveTransforms,
    transformHoist,
    isBuiltInComponent,
    isCustomElement,
    expressionPlugins,
    scopeId,
    slotted,
    ssr,
    inSSR,
    ssrCssVars,
    bindingMetadata,
    inline,
    isTS,
    onError,
    onWarn,
    compatConfig,
    // state
    root,
    helpers: /* @__PURE__ */ new Map(),
    components: /* @__PURE__ */ new Set(),
    directives: /* @__PURE__ */ new Set(),
    hoists: [],
    imports: [],
    cached: [],
    constantCache: /* @__PURE__ */ new WeakMap(),
    temps: 0,
    identifiers: /* @__PURE__ */ Object.create(null),
    scopes: {
      vFor: 0,
      vSlot: 0,
      vPre: 0,
      vOnce: 0
    },
    parent: null,
    grandParent: null,
    currentNode: root,
    childIndex: 0,
    inVOnce: false,
    // methods
    helper(name) {
      const count = context.helpers.get(name) || 0;
      context.helpers.set(name, count + 1);
      return name;
    },
    removeHelper(name) {
      const count = context.helpers.get(name);
      if (count) {
        const currentCount = count - 1;
        if (!currentCount) {
          context.helpers.delete(name);
        } else {
          context.helpers.set(name, currentCount);
        }
      }
    },
    helperString(name) {
      return `_${helperNameMap[context.helper(name)]}`;
    },
    replaceNode(node) {
      context.parent.children[context.childIndex] = context.currentNode = node;
    },
    removeNode(node) {
      const list = context.parent.children;
      const removalIndex = node ? list.indexOf(node) : context.currentNode ? context.childIndex : -1;
      if (!node || node === context.currentNode) {
        context.currentNode = null;
        context.onNodeRemoved();
      } else {
        if (context.childIndex > removalIndex) {
          context.childIndex--;
          context.onNodeRemoved();
        }
      }
      context.parent.children.splice(removalIndex, 1);
    },
    onNodeRemoved: NOOP,
    addIdentifiers(exp) {
    },
    removeIdentifiers(exp) {
    },
    hoist(exp) {
      if (isString(exp)) exp = createSimpleExpression(exp);
      context.hoists.push(exp);
      const identifier = createSimpleExpression(
        `_hoisted_${context.hoists.length}`,
        false,
        exp.loc,
        2
      );
      identifier.hoisted = exp;
      return identifier;
    },
    cache(exp, isVNode = false) {
      const cacheExp = createCacheExpression(
        context.cached.length,
        exp,
        isVNode
      );
      context.cached.push(cacheExp);
      return cacheExp;
    }
  };
  {
    context.filters = /* @__PURE__ */ new Set();
  }
  return context;
}
function transform(root, options) {
  const context = createTransformContext(root, options);
  traverseNode(root, context);
  if (options.hoistStatic) {
    cacheStatic(root, context);
  }
  if (!options.ssr) {
    createRootCodegen(root, context);
  }
  root.helpers = /* @__PURE__ */ new Set([...context.helpers.keys()]);
  root.components = [...context.components];
  root.directives = [...context.directives];
  root.imports = context.imports;
  root.hoists = context.hoists;
  root.temps = context.temps;
  root.cached = context.cached;
  root.transformed = true;
  {
    root.filters = [...context.filters];
  }
}
function createRootCodegen(root, context) {
  const { helper } = context;
  const { children } = root;
  if (children.length === 1) {
    const child = children[0];
    if (isSingleElementRoot(root, child) && child.codegenNode) {
      const codegenNode = child.codegenNode;
      if (codegenNode.type === 13) {
        convertToBlock(codegenNode, context);
      }
      root.codegenNode = codegenNode;
    } else {
      root.codegenNode = child;
    }
  } else if (children.length > 1) {
    let patchFlag = 64;
    root.codegenNode = createVNodeCall(
      context,
      helper(FRAGMENT),
      void 0,
      root.children,
      patchFlag,
      void 0,
      void 0,
      true,
      void 0,
      false
    );
  } else ;
}
function traverseChildren(parent, context) {
  let i = 0;
  const nodeRemoved = () => {
    i--;
  };
  for (; i < parent.children.length; i++) {
    const child = parent.children[i];
    if (isString(child)) continue;
    context.grandParent = context.parent;
    context.parent = parent;
    context.childIndex = i;
    context.onNodeRemoved = nodeRemoved;
    traverseNode(child, context);
  }
}
function traverseNode(node, context) {
  context.currentNode = node;
  const { nodeTransforms } = context;
  const exitFns = [];
  for (let i2 = 0; i2 < nodeTransforms.length; i2++) {
    const onExit = nodeTransforms[i2](node, context);
    if (onExit) {
      if (isArray(onExit)) {
        exitFns.push(...onExit);
      } else {
        exitFns.push(onExit);
      }
    }
    if (!context.currentNode) {
      return;
    } else {
      node = context.currentNode;
    }
  }
  switch (node.type) {
    case 3:
      if (!context.ssr) {
        context.helper(CREATE_COMMENT);
      }
      break;
    case 5:
      if (!context.ssr) {
        context.helper(TO_DISPLAY_STRING);
      }
      break;
    // for container types, further traverse downwards
    case 9:
      for (let i2 = 0; i2 < node.branches.length; i2++) {
        traverseNode(node.branches[i2], context);
      }
      break;
    case 10:
    case 11:
    case 1:
    case 0:
      traverseChildren(node, context);
      break;
  }
  context.currentNode = node;
  let i = exitFns.length;
  while (i--) {
    exitFns[i]();
  }
}
function createStructuralDirectiveTransform(name, fn) {
  const matches = isString(name) ? (n) => n === name : (n) => name.test(n);
  return (node, context) => {
    if (node.type === 1) {
      const { props } = node;
      if (node.tagType === 3 && props.some(isVSlot)) {
        return;
      }
      const exitFns = [];
      for (let i = 0; i < props.length; i++) {
        const prop = props[i];
        if (prop.type === 7 && matches(prop.name)) {
          props.splice(i, 1);
          i--;
          const onExit = fn(node, prop, context);
          if (onExit) exitFns.push(onExit);
        }
      }
      return exitFns;
    }
  };
}

const PURE_ANNOTATION = `/*@__PURE__*/`;
const aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;
function createCodegenContext(ast, {
  mode = "function",
  prefixIdentifiers = mode === "module",
  sourceMap = false,
  filename = `template.vue.html`,
  scopeId = null,
  optimizeImports = false,
  runtimeGlobalName = `Vue`,
  runtimeModuleName = `vue`,
  ssrRuntimeModuleName = "vue/server-renderer",
  ssr = false,
  isTS = false,
  inSSR = false
}) {
  const context = {
    mode,
    prefixIdentifiers,
    sourceMap,
    filename,
    scopeId,
    optimizeImports,
    runtimeGlobalName,
    runtimeModuleName,
    ssrRuntimeModuleName,
    ssr,
    isTS,
    inSSR,
    source: ast.source,
    code: ``,
    column: 1,
    line: 1,
    offset: 0,
    indentLevel: 0,
    pure: false,
    map: void 0,
    helper(key) {
      return `_${helperNameMap[key]}`;
    },
    push(code, newlineIndex = -2 /* None */, node) {
      context.code += code;
    },
    indent() {
      newline(++context.indentLevel);
    },
    deindent(withoutNewLine = false) {
      if (withoutNewLine) {
        --context.indentLevel;
      } else {
        newline(--context.indentLevel);
      }
    },
    newline() {
      newline(context.indentLevel);
    }
  };
  function newline(n) {
    context.push("\n" + `  `.repeat(n), 0 /* Start */);
  }
  return context;
}
function generate(ast, options = {}) {
  const context = createCodegenContext(ast, options);
  if (options.onContextCreated) options.onContextCreated(context);
  const {
    mode,
    push,
    prefixIdentifiers,
    indent,
    deindent,
    newline,
    scopeId,
    ssr
  } = context;
  const helpers = Array.from(ast.helpers);
  const hasHelpers = helpers.length > 0;
  const useWithBlock = !prefixIdentifiers && mode !== "module";
  const preambleContext = context;
  {
    genFunctionPreamble(ast, preambleContext);
  }
  const functionName = ssr ? `ssrRender` : `render`;
  const args = ssr ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
  const signature = args.join(", ");
  {
    push(`function ${functionName}(${signature}) {`);
  }
  indent();
  if (useWithBlock) {
    push(`with (_ctx) {`);
    indent();
    if (hasHelpers) {
      push(
        `const { ${helpers.map(aliasHelper).join(", ")} } = _Vue
`,
        -1 /* End */
      );
      newline();
    }
  }
  if (ast.components.length) {
    genAssets(ast.components, "component", context);
    if (ast.directives.length || ast.temps > 0) {
      newline();
    }
  }
  if (ast.directives.length) {
    genAssets(ast.directives, "directive", context);
    if (ast.temps > 0) {
      newline();
    }
  }
  if (ast.filters && ast.filters.length) {
    newline();
    genAssets(ast.filters, "filter", context);
    newline();
  }
  if (ast.temps > 0) {
    push(`let `);
    for (let i = 0; i < ast.temps; i++) {
      push(`${i > 0 ? `, ` : ``}_temp${i}`);
    }
  }
  if (ast.components.length || ast.directives.length || ast.temps) {
    push(`
`, 0 /* Start */);
    newline();
  }
  if (!ssr) {
    push(`return `);
  }
  if (ast.codegenNode) {
    genNode(ast.codegenNode, context);
  } else {
    push(`null`);
  }
  if (useWithBlock) {
    deindent();
    push(`}`);
  }
  deindent();
  push(`}`);
  return {
    ast,
    code: context.code,
    preamble: ``,
    map: context.map ? context.map.toJSON() : void 0
  };
}
function genFunctionPreamble(ast, context) {
  const {
    ssr,
    prefixIdentifiers,
    push,
    newline,
    runtimeModuleName,
    runtimeGlobalName,
    ssrRuntimeModuleName
  } = context;
  const VueBinding = runtimeGlobalName;
  const helpers = Array.from(ast.helpers);
  if (helpers.length > 0) {
    {
      push(`const _Vue = ${VueBinding}
`, -1 /* End */);
      if (ast.hoists.length) {
        const staticHelpers = [
          CREATE_VNODE,
          CREATE_ELEMENT_VNODE,
          CREATE_COMMENT,
          CREATE_TEXT,
          CREATE_STATIC
        ].filter((helper) => helpers.includes(helper)).map(aliasHelper).join(", ");
        push(`const { ${staticHelpers} } = _Vue
`, -1 /* End */);
      }
    }
  }
  genHoists(ast.hoists, context);
  newline();
  push(`return `);
}
function genAssets(assets, type, { helper, push, newline, isTS }) {
  const resolver = helper(
    type === "filter" ? RESOLVE_FILTER : type === "component" ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE
  );
  for (let i = 0; i < assets.length; i++) {
    let id = assets[i];
    const maybeSelfReference = id.endsWith("__self");
    if (maybeSelfReference) {
      id = id.slice(0, -6);
    }
    push(
      `const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`
    );
    if (i < assets.length - 1) {
      newline();
    }
  }
}
function genHoists(hoists, context) {
  if (!hoists.length) {
    return;
  }
  context.pure = true;
  const { push, newline } = context;
  newline();
  for (let i = 0; i < hoists.length; i++) {
    const exp = hoists[i];
    if (exp) {
      push(`const _hoisted_${i + 1} = `);
      genNode(exp, context);
      newline();
    }
  }
  context.pure = false;
}
function genNodeListAsArray(nodes, context) {
  const multilines = nodes.length > 3 || !!("production" !== "production");
  context.push(`[`);
  multilines && context.indent();
  genNodeList(nodes, context, multilines);
  multilines && context.deindent();
  context.push(`]`);
}
function genNodeList(nodes, context, multilines = false, comma = true) {
  const { push, newline } = context;
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (isString(node)) {
      push(node, -3 /* Unknown */);
    } else if (isArray(node)) {
      genNodeListAsArray(node, context);
    } else {
      genNode(node, context);
    }
    if (i < nodes.length - 1) {
      if (multilines) {
        comma && push(",");
        newline();
      } else {
        comma && push(", ");
      }
    }
  }
}
function genNode(node, context) {
  if (isString(node)) {
    context.push(node, -3 /* Unknown */);
    return;
  }
  if (isSymbol(node)) {
    context.push(context.helper(node));
    return;
  }
  switch (node.type) {
    case 1:
    case 9:
    case 11:
      genNode(node.codegenNode, context);
      break;
    case 2:
      genText(node, context);
      break;
    case 4:
      genExpression(node, context);
      break;
    case 5:
      genInterpolation(node, context);
      break;
    case 12:
      genNode(node.codegenNode, context);
      break;
    case 8:
      genCompoundExpression(node, context);
      break;
    case 3:
      genComment(node, context);
      break;
    case 13:
      genVNodeCall(node, context);
      break;
    case 14:
      genCallExpression(node, context);
      break;
    case 15:
      genObjectExpression(node, context);
      break;
    case 17:
      genArrayExpression(node, context);
      break;
    case 18:
      genFunctionExpression(node, context);
      break;
    case 19:
      genConditionalExpression(node, context);
      break;
    case 20:
      genCacheExpression(node, context);
      break;
    case 21:
      genNodeList(node.body, context, true, false);
      break;
  }
}
function genText(node, context) {
  context.push(JSON.stringify(node.content), -3 /* Unknown */, node);
}
function genExpression(node, context) {
  const { content, isStatic } = node;
  context.push(
    isStatic ? JSON.stringify(content) : content,
    -3 /* Unknown */,
    node
  );
}
function genInterpolation(node, context) {
  const { push, helper, pure } = context;
  if (pure) push(PURE_ANNOTATION);
  push(`${helper(TO_DISPLAY_STRING)}(`);
  genNode(node.content, context);
  push(`)`);
}
function genCompoundExpression(node, context) {
  for (let i = 0; i < node.children.length; i++) {
    const child = node.children[i];
    if (isString(child)) {
      context.push(child, -3 /* Unknown */);
    } else {
      genNode(child, context);
    }
  }
}
function genExpressionAsPropertyKey(node, context) {
  const { push } = context;
  if (node.type === 8) {
    push(`[`);
    genCompoundExpression(node, context);
    push(`]`);
  } else if (node.isStatic) {
    const text = isSimpleIdentifier(node.content) ? node.content : JSON.stringify(node.content);
    push(text, -2 /* None */, node);
  } else {
    push(`[${node.content}]`, -3 /* Unknown */, node);
  }
}
function genComment(node, context) {
  const { push, helper, pure } = context;
  if (pure) {
    push(PURE_ANNOTATION);
  }
  push(
    `${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`,
    -3 /* Unknown */,
    node
  );
}
function genVNodeCall(node, context) {
  const { push, helper, pure } = context;
  const {
    tag,
    props,
    children,
    patchFlag,
    dynamicProps,
    directives,
    isBlock,
    disableTracking,
    isComponent
  } = node;
  let patchFlagString;
  if (patchFlag) {
    {
      patchFlagString = String(patchFlag);
    }
  }
  if (directives) {
    push(helper(WITH_DIRECTIVES) + `(`);
  }
  if (isBlock) {
    push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
  }
  if (pure) {
    push(PURE_ANNOTATION);
  }
  const callHelper = isBlock ? getVNodeBlockHelper(context.inSSR, isComponent) : getVNodeHelper(context.inSSR, isComponent);
  push(helper(callHelper) + `(`, -2 /* None */, node);
  genNodeList(
    genNullableArgs([tag, props, children, patchFlagString, dynamicProps]),
    context
  );
  push(`)`);
  if (isBlock) {
    push(`)`);
  }
  if (directives) {
    push(`, `);
    genNode(directives, context);
    push(`)`);
  }
}
function genNullableArgs(args) {
  let i = args.length;
  while (i--) {
    if (args[i] != null) break;
  }
  return args.slice(0, i + 1).map((arg) => arg || `null`);
}
function genCallExpression(node, context) {
  const { push, helper, pure } = context;
  const callee = isString(node.callee) ? node.callee : helper(node.callee);
  if (pure) {
    push(PURE_ANNOTATION);
  }
  push(callee + `(`, -2 /* None */, node);
  genNodeList(node.arguments, context);
  push(`)`);
}
function genObjectExpression(node, context) {
  const { push, indent, deindent, newline } = context;
  const { properties } = node;
  if (!properties.length) {
    push(`{}`, -2 /* None */, node);
    return;
  }
  const multilines = properties.length > 1 || !!("production" !== "production");
  push(multilines ? `{` : `{ `);
  multilines && indent();
  for (let i = 0; i < properties.length; i++) {
    const { key, value } = properties[i];
    genExpressionAsPropertyKey(key, context);
    push(`: `);
    genNode(value, context);
    if (i < properties.length - 1) {
      push(`,`);
      newline();
    }
  }
  multilines && deindent();
  push(multilines ? `}` : ` }`);
}
function genArrayExpression(node, context) {
  genNodeListAsArray(node.elements, context);
}
function genFunctionExpression(node, context) {
  const { push, indent, deindent } = context;
  const { params, returns, body, newline, isSlot } = node;
  if (isSlot) {
    push(`_${helperNameMap[WITH_CTX]}(`);
  }
  push(`(`, -2 /* None */, node);
  if (isArray(params)) {
    genNodeList(params, context);
  } else if (params) {
    genNode(params, context);
  }
  push(`) => `);
  if (newline || body) {
    push(`{`);
    indent();
  }
  if (returns) {
    if (newline) {
      push(`return `);
    }
    if (isArray(returns)) {
      genNodeListAsArray(returns, context);
    } else {
      genNode(returns, context);
    }
  } else if (body) {
    genNode(body, context);
  }
  if (newline || body) {
    deindent();
    push(`}`);
  }
  if (isSlot) {
    if (node.isNonScopedSlot) {
      push(`, undefined, true`);
    }
    push(`)`);
  }
}
function genConditionalExpression(node, context) {
  const { test, consequent, alternate, newline: needNewline } = node;
  const { push, indent, deindent, newline } = context;
  if (test.type === 4) {
    const needsParens = !isSimpleIdentifier(test.content);
    needsParens && push(`(`);
    genExpression(test, context);
    needsParens && push(`)`);
  } else {
    push(`(`);
    genNode(test, context);
    push(`)`);
  }
  needNewline && indent();
  context.indentLevel++;
  needNewline || push(` `);
  push(`? `);
  genNode(consequent, context);
  context.indentLevel--;
  needNewline && newline();
  needNewline || push(` `);
  push(`: `);
  const isNested = alternate.type === 19;
  if (!isNested) {
    context.indentLevel++;
  }
  genNode(alternate, context);
  if (!isNested) {
    context.indentLevel--;
  }
  needNewline && deindent(
    true
    /* without newline */
  );
}
function genCacheExpression(node, context) {
  const { push, helper, indent, deindent, newline } = context;
  const { needPauseTracking, needArraySpread } = node;
  if (needArraySpread) {
    push(`[...(`);
  }
  push(`_cache[${node.index}] || (`);
  if (needPauseTracking) {
    indent();
    push(`${helper(SET_BLOCK_TRACKING)}(-1),`);
    newline();
    push(`(`);
  }
  push(`_cache[${node.index}] = `);
  genNode(node.value, context);
  if (needPauseTracking) {
    push(`).cacheIndex = ${node.index},`);
    newline();
    push(`${helper(SET_BLOCK_TRACKING)}(1),`);
    newline();
    push(`_cache[${node.index}]`);
    deindent();
  }
  push(`)`);
  if (needArraySpread) {
    push(`)]`);
  }
}

new RegExp(
  "\\b" + "arguments,await,break,case,catch,class,const,continue,debugger,default,delete,do,else,export,extends,finally,for,function,if,import,let,new,return,super,switch,throw,try,var,void,while,with,yield".split(",").join("\\b|\\b") + "\\b"
);

const transformExpression = (node, context) => {
  if (node.type === 5) {
    node.content = processExpression(
      node.content,
      context
    );
  } else if (node.type === 1) {
    for (let i = 0; i < node.props.length; i++) {
      const dir = node.props[i];
      if (dir.type === 7 && dir.name !== "for") {
        const exp = dir.exp;
        const arg = dir.arg;
        if (exp && exp.type === 4 && !(dir.name === "on" && arg)) {
          dir.exp = processExpression(
            exp,
            context,
            // slot args must be processed as function params
            dir.name === "slot"
          );
        }
        if (arg && arg.type === 4 && !arg.isStatic) {
          dir.arg = processExpression(arg, context);
        }
      }
    }
  }
};
function processExpression(node, context, asParams = false, asRawStatements = false, localVars = Object.create(context.identifiers)) {
  {
    return node;
  }
}
function stringifyExpression(exp) {
  if (isString(exp)) {
    return exp;
  } else if (exp.type === 4) {
    return exp.content;
  } else {
    return exp.children.map(stringifyExpression).join("");
  }
}

const transformIf = createStructuralDirectiveTransform(
  /^(if|else|else-if)$/,
  (node, dir, context) => {
    return processIf(node, dir, context, (ifNode, branch, isRoot) => {
      const siblings = context.parent.children;
      let i = siblings.indexOf(ifNode);
      let key = 0;
      while (i-- >= 0) {
        const sibling = siblings[i];
        if (sibling && sibling.type === 9) {
          key += sibling.branches.length;
        }
      }
      return () => {
        if (isRoot) {
          ifNode.codegenNode = createCodegenNodeForBranch(
            branch,
            key,
            context
          );
        } else {
          const parentCondition = getParentCondition(ifNode.codegenNode);
          parentCondition.alternate = createCodegenNodeForBranch(
            branch,
            key + ifNode.branches.length - 1,
            context
          );
        }
      };
    });
  }
);
function processIf(node, dir, context, processCodegen) {
  if (dir.name !== "else" && (!dir.exp || !dir.exp.content.trim())) {
    const loc = dir.exp ? dir.exp.loc : node.loc;
    context.onError(
      createCompilerError(28, dir.loc)
    );
    dir.exp = createSimpleExpression(`true`, false, loc);
  }
  if (dir.name === "if") {
    const branch = createIfBranch(node, dir);
    const ifNode = {
      type: 9,
      loc: node.loc,
      branches: [branch]
    };
    context.replaceNode(ifNode);
    if (processCodegen) {
      return processCodegen(ifNode, branch, true);
    }
  } else {
    const siblings = context.parent.children;
    let i = siblings.indexOf(node);
    while (i-- >= -1) {
      const sibling = siblings[i];
      if (sibling && sibling.type === 3) {
        context.removeNode(sibling);
        continue;
      }
      if (sibling && sibling.type === 2 && !sibling.content.trim().length) {
        context.removeNode(sibling);
        continue;
      }
      if (sibling && sibling.type === 9) {
        if (dir.name === "else-if" && sibling.branches[sibling.branches.length - 1].condition === void 0) {
          context.onError(
            createCompilerError(30, node.loc)
          );
        }
        context.removeNode();
        const branch = createIfBranch(node, dir);
        sibling.branches.push(branch);
        const onExit = processCodegen && processCodegen(sibling, branch, false);
        traverseNode(branch, context);
        if (onExit) onExit();
        context.currentNode = null;
      } else {
        context.onError(
          createCompilerError(30, node.loc)
        );
      }
      break;
    }
  }
}
function createIfBranch(node, dir) {
  const isTemplateIf = node.tagType === 3;
  return {
    type: 10,
    loc: node.loc,
    condition: dir.name === "else" ? void 0 : dir.exp,
    children: isTemplateIf && !findDir(node, "for") ? node.children : [node],
    userKey: findProp(node, `key`),
    isTemplateIf
  };
}
function createCodegenNodeForBranch(branch, keyIndex, context) {
  if (branch.condition) {
    return createConditionalExpression(
      branch.condition,
      createChildrenCodegenNode(branch, keyIndex, context),
      // make sure to pass in asBlock: true so that the comment node call
      // closes the current block.
      createCallExpression(context.helper(CREATE_COMMENT), [
        '""',
        "true"
      ])
    );
  } else {
    return createChildrenCodegenNode(branch, keyIndex, context);
  }
}
function createChildrenCodegenNode(branch, keyIndex, context) {
  const { helper } = context;
  const keyProperty = createObjectProperty(
    `key`,
    createSimpleExpression(
      `${keyIndex}`,
      false,
      locStub,
      2
    )
  );
  const { children } = branch;
  const firstChild = children[0];
  const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1;
  if (needFragmentWrapper) {
    if (children.length === 1 && firstChild.type === 11) {
      const vnodeCall = firstChild.codegenNode;
      injectProp(vnodeCall, keyProperty, context);
      return vnodeCall;
    } else {
      let patchFlag = 64;
      return createVNodeCall(
        context,
        helper(FRAGMENT),
        createObjectExpression([keyProperty]),
        children,
        patchFlag,
        void 0,
        void 0,
        true,
        false,
        false,
        branch.loc
      );
    }
  } else {
    const ret = firstChild.codegenNode;
    const vnodeCall = getMemoedVNodeCall(ret);
    if (vnodeCall.type === 13) {
      convertToBlock(vnodeCall, context);
    }
    injectProp(vnodeCall, keyProperty, context);
    return ret;
  }
}
function getParentCondition(node) {
  while (true) {
    if (node.type === 19) {
      if (node.alternate.type === 19) {
        node = node.alternate;
      } else {
        return node;
      }
    } else if (node.type === 20) {
      node = node.value;
    }
  }
}

const transformBind = (dir, _node, context) => {
  const { modifiers, loc } = dir;
  const arg = dir.arg;
  let { exp } = dir;
  if (exp && exp.type === 4 && !exp.content.trim()) {
    {
      exp = void 0;
    }
  }
  if (!exp) {
    if (arg.type !== 4 || !arg.isStatic) {
      context.onError(
        createCompilerError(
          52,
          arg.loc
        )
      );
      return {
        props: [
          createObjectProperty(arg, createSimpleExpression("", true, loc))
        ]
      };
    }
    transformBindShorthand(dir);
    exp = dir.exp;
  }
  if (arg.type !== 4) {
    arg.children.unshift(`(`);
    arg.children.push(`) || ""`);
  } else if (!arg.isStatic) {
    arg.content = `${arg.content} || ""`;
  }
  if (modifiers.some((mod) => mod.content === "camel")) {
    if (arg.type === 4) {
      if (arg.isStatic) {
        arg.content = camelize$1(arg.content);
      } else {
        arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
      }
    } else {
      arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
      arg.children.push(`)`);
    }
  }
  if (!context.inSSR) {
    if (modifiers.some((mod) => mod.content === "prop")) {
      injectPrefix(arg, ".");
    }
    if (modifiers.some((mod) => mod.content === "attr")) {
      injectPrefix(arg, "^");
    }
  }
  return {
    props: [createObjectProperty(arg, exp)]
  };
};
const transformBindShorthand = (dir, context) => {
  const arg = dir.arg;
  const propName = camelize$1(arg.content);
  dir.exp = createSimpleExpression(propName, false, arg.loc);
};
const injectPrefix = (arg, prefix) => {
  if (arg.type === 4) {
    if (arg.isStatic) {
      arg.content = prefix + arg.content;
    } else {
      arg.content = `\`${prefix}\${${arg.content}}\``;
    }
  } else {
    arg.children.unshift(`'${prefix}' + (`);
    arg.children.push(`)`);
  }
};

const transformFor = createStructuralDirectiveTransform(
  "for",
  (node, dir, context) => {
    const { helper, removeHelper } = context;
    return processFor(node, dir, context, (forNode) => {
      const renderExp = createCallExpression(helper(RENDER_LIST), [
        forNode.source
      ]);
      const isTemplate = isTemplateNode(node);
      const memo = findDir(node, "memo");
      const keyProp = findProp(node, `key`, false, true);
      if (keyProp && keyProp.type === 7 && !keyProp.exp) {
        transformBindShorthand(keyProp);
      }
      const keyExp = keyProp && (keyProp.type === 6 ? keyProp.value ? createSimpleExpression(keyProp.value.content, true) : void 0 : keyProp.exp);
      const keyProperty = keyProp && keyExp ? createObjectProperty(`key`, keyExp) : null;
      const isStableFragment = forNode.source.type === 4 && forNode.source.constType > 0;
      const fragmentFlag = isStableFragment ? 64 : keyProp ? 128 : 256;
      forNode.codegenNode = createVNodeCall(
        context,
        helper(FRAGMENT),
        void 0,
        renderExp,
        fragmentFlag,
        void 0,
        void 0,
        true,
        !isStableFragment,
        false,
        node.loc
      );
      return () => {
        let childBlock;
        const { children } = forNode;
        const needFragmentWrapper = children.length !== 1 || children[0].type !== 1;
        const slotOutlet = isSlotOutlet(node) ? node : isTemplate && node.children.length === 1 && isSlotOutlet(node.children[0]) ? node.children[0] : null;
        if (slotOutlet) {
          childBlock = slotOutlet.codegenNode;
          if (isTemplate && keyProperty) {
            injectProp(childBlock, keyProperty, context);
          }
        } else if (needFragmentWrapper) {
          childBlock = createVNodeCall(
            context,
            helper(FRAGMENT),
            keyProperty ? createObjectExpression([keyProperty]) : void 0,
            node.children,
            64,
            void 0,
            void 0,
            true,
            void 0,
            false
          );
        } else {
          childBlock = children[0].codegenNode;
          if (isTemplate && keyProperty) {
            injectProp(childBlock, keyProperty, context);
          }
          if (childBlock.isBlock !== !isStableFragment) {
            if (childBlock.isBlock) {
              removeHelper(OPEN_BLOCK);
              removeHelper(
                getVNodeBlockHelper(context.inSSR, childBlock.isComponent)
              );
            } else {
              removeHelper(
                getVNodeHelper(context.inSSR, childBlock.isComponent)
              );
            }
          }
          childBlock.isBlock = !isStableFragment;
          if (childBlock.isBlock) {
            helper(OPEN_BLOCK);
            helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
          } else {
            helper(getVNodeHelper(context.inSSR, childBlock.isComponent));
          }
        }
        if (memo) {
          const loop = createFunctionExpression(
            createForLoopParams(forNode.parseResult, [
              createSimpleExpression(`_cached`)
            ])
          );
          loop.body = createBlockStatement([
            createCompoundExpression([`const _memo = (`, memo.exp, `)`]),
            createCompoundExpression([
              `if (_cached`,
              ...keyExp ? [` && _cached.key === `, keyExp] : [],
              ` && ${context.helperString(
                IS_MEMO_SAME
              )}(_cached, _memo)) return _cached`
            ]),
            createCompoundExpression([`const _item = `, childBlock]),
            createSimpleExpression(`_item.memo = _memo`),
            createSimpleExpression(`return _item`)
          ]);
          renderExp.arguments.push(
            loop,
            createSimpleExpression(`_cache`),
            createSimpleExpression(String(context.cached.length))
          );
          context.cached.push(null);
        } else {
          renderExp.arguments.push(
            createFunctionExpression(
              createForLoopParams(forNode.parseResult),
              childBlock,
              true
            )
          );
        }
      };
    });
  }
);
function processFor(node, dir, context, processCodegen) {
  if (!dir.exp) {
    context.onError(
      createCompilerError(31, dir.loc)
    );
    return;
  }
  const parseResult = dir.forParseResult;
  if (!parseResult) {
    context.onError(
      createCompilerError(32, dir.loc)
    );
    return;
  }
  finalizeForParseResult(parseResult);
  const { addIdentifiers, removeIdentifiers, scopes } = context;
  const { source, value, key, index } = parseResult;
  const forNode = {
    type: 11,
    loc: dir.loc,
    source,
    valueAlias: value,
    keyAlias: key,
    objectIndexAlias: index,
    parseResult,
    children: isTemplateNode(node) ? node.children : [node]
  };
  context.replaceNode(forNode);
  scopes.vFor++;
  const onExit = processCodegen && processCodegen(forNode);
  return () => {
    scopes.vFor--;
    if (onExit) onExit();
  };
}
function finalizeForParseResult(result, context) {
  if (result.finalized) return;
  result.finalized = true;
}
function createForLoopParams({ value, key, index }, memoArgs = []) {
  return createParamsList([value, key, index, ...memoArgs]);
}
function createParamsList(args) {
  let i = args.length;
  while (i--) {
    if (args[i]) break;
  }
  return args.slice(0, i + 1).map((arg, i2) => arg || createSimpleExpression(`_`.repeat(i2 + 1), false));
}

const defaultFallback = createSimpleExpression(`undefined`, false);
const trackSlotScopes = (node, context) => {
  if (node.type === 1 && (node.tagType === 1 || node.tagType === 3)) {
    const vSlot = findDir(node, "slot");
    if (vSlot) {
      vSlot.exp;
      context.scopes.vSlot++;
      return () => {
        context.scopes.vSlot--;
      };
    }
  }
};
const trackVForSlotScopes = (node, context) => {
  let vFor;
  if (isTemplateNode(node) && node.props.some(isVSlot) && (vFor = findDir(node, "for"))) {
    const result = vFor.forParseResult;
    if (result) {
      finalizeForParseResult(result);
      const { value, key, index } = result;
      const { addIdentifiers, removeIdentifiers } = context;
      value && addIdentifiers(value);
      key && addIdentifiers(key);
      index && addIdentifiers(index);
      return () => {
        value && removeIdentifiers(value);
        key && removeIdentifiers(key);
        index && removeIdentifiers(index);
      };
    }
  }
};
const buildClientSlotFn = (props, _vForExp, children, loc) => createFunctionExpression(
  props,
  children,
  false,
  true,
  children.length ? children[0].loc : loc
);
function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {
  context.helper(WITH_CTX);
  const { children, loc } = node;
  const slotsProperties = [];
  const dynamicSlots = [];
  let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
  const onComponentSlot = findDir(node, "slot", true);
  if (onComponentSlot) {
    const { arg, exp } = onComponentSlot;
    if (arg && !isStaticExp(arg)) {
      hasDynamicSlots = true;
    }
    slotsProperties.push(
      createObjectProperty(
        arg || createSimpleExpression("default", true),
        buildSlotFn(exp, void 0, children, loc)
      )
    );
  }
  let hasTemplateSlots = false;
  let hasNamedDefaultSlot = false;
  const implicitDefaultChildren = [];
  const seenSlotNames = /* @__PURE__ */ new Set();
  let conditionalBranchIndex = 0;
  for (let i = 0; i < children.length; i++) {
    const slotElement = children[i];
    let slotDir;
    if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, "slot", true))) {
      if (slotElement.type !== 3) {
        implicitDefaultChildren.push(slotElement);
      }
      continue;
    }
    if (onComponentSlot) {
      context.onError(
        createCompilerError(37, slotDir.loc)
      );
      break;
    }
    hasTemplateSlots = true;
    const { children: slotChildren, loc: slotLoc } = slotElement;
    const {
      arg: slotName = createSimpleExpression(`default`, true),
      exp: slotProps,
      loc: dirLoc
    } = slotDir;
    let staticSlotName;
    if (isStaticExp(slotName)) {
      staticSlotName = slotName ? slotName.content : `default`;
    } else {
      hasDynamicSlots = true;
    }
    const vFor = findDir(slotElement, "for");
    const slotFunction = buildSlotFn(slotProps, vFor, slotChildren, slotLoc);
    let vIf;
    let vElse;
    if (vIf = findDir(slotElement, "if")) {
      hasDynamicSlots = true;
      dynamicSlots.push(
        createConditionalExpression(
          vIf.exp,
          buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++),
          defaultFallback
        )
      );
    } else if (vElse = findDir(
      slotElement,
      /^else(-if)?$/,
      true
      /* allowEmpty */
    )) {
      let j = i;
      let prev;
      while (j--) {
        prev = children[j];
        if (prev.type !== 3) {
          break;
        }
      }
      if (prev && isTemplateNode(prev) && findDir(prev, /^(else-)?if$/)) {
        let conditional = dynamicSlots[dynamicSlots.length - 1];
        while (conditional.alternate.type === 19) {
          conditional = conditional.alternate;
        }
        conditional.alternate = vElse.exp ? createConditionalExpression(
          vElse.exp,
          buildDynamicSlot(
            slotName,
            slotFunction,
            conditionalBranchIndex++
          ),
          defaultFallback
        ) : buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++);
      } else {
        context.onError(
          createCompilerError(30, vElse.loc)
        );
      }
    } else if (vFor) {
      hasDynamicSlots = true;
      const parseResult = vFor.forParseResult;
      if (parseResult) {
        finalizeForParseResult(parseResult);
        dynamicSlots.push(
          createCallExpression(context.helper(RENDER_LIST), [
            parseResult.source,
            createFunctionExpression(
              createForLoopParams(parseResult),
              buildDynamicSlot(slotName, slotFunction),
              true
            )
          ])
        );
      } else {
        context.onError(
          createCompilerError(
            32,
            vFor.loc
          )
        );
      }
    } else {
      if (staticSlotName) {
        if (seenSlotNames.has(staticSlotName)) {
          context.onError(
            createCompilerError(
              38,
              dirLoc
            )
          );
          continue;
        }
        seenSlotNames.add(staticSlotName);
        if (staticSlotName === "default") {
          hasNamedDefaultSlot = true;
        }
      }
      slotsProperties.push(createObjectProperty(slotName, slotFunction));
    }
  }
  if (!onComponentSlot) {
    const buildDefaultSlotProperty = (props, children2) => {
      const fn = buildSlotFn(props, void 0, children2, loc);
      if (context.compatConfig) {
        fn.isNonScopedSlot = true;
      }
      return createObjectProperty(`default`, fn);
    };
    if (!hasTemplateSlots) {
      slotsProperties.push(buildDefaultSlotProperty(void 0, children));
    } else if (implicitDefaultChildren.length && // #3766
    // with whitespace: 'preserve', whitespaces between slots will end up in
    // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
    implicitDefaultChildren.some((node2) => isNonWhitespaceContent(node2))) {
      if (hasNamedDefaultSlot) {
        context.onError(
          createCompilerError(
            39,
            implicitDefaultChildren[0].loc
          )
        );
      } else {
        slotsProperties.push(
          buildDefaultSlotProperty(void 0, implicitDefaultChildren)
        );
      }
    }
  }
  const slotFlag = hasDynamicSlots ? 2 : hasForwardedSlots(node.children) ? 3 : 1;
  let slots = createObjectExpression(
    slotsProperties.concat(
      createObjectProperty(
        `_`,
        // 2 = compiled but dynamic = can skip normalization, but must run diff
        // 1 = compiled and static = can skip normalization AND diff as optimized
        createSimpleExpression(
          slotFlag + (``),
          false
        )
      )
    ),
    loc
  );
  if (dynamicSlots.length) {
    slots = createCallExpression(context.helper(CREATE_SLOTS), [
      slots,
      createArrayExpression(dynamicSlots)
    ]);
  }
  return {
    slots,
    hasDynamicSlots
  };
}
function buildDynamicSlot(name, fn, index) {
  const props = [
    createObjectProperty(`name`, name),
    createObjectProperty(`fn`, fn)
  ];
  if (index != null) {
    props.push(
      createObjectProperty(`key`, createSimpleExpression(String(index), true))
    );
  }
  return createObjectExpression(props);
}
function hasForwardedSlots(children) {
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    switch (child.type) {
      case 1:
        if (child.tagType === 2 || hasForwardedSlots(child.children)) {
          return true;
        }
        break;
      case 9:
        if (hasForwardedSlots(child.branches)) return true;
        break;
      case 10:
      case 11:
        if (hasForwardedSlots(child.children)) return true;
        break;
    }
  }
  return false;
}
function isNonWhitespaceContent(node) {
  if (node.type !== 2 && node.type !== 12)
    return true;
  return node.type === 2 ? !!node.content.trim() : isNonWhitespaceContent(node.content);
}

const directiveImportMap = /* @__PURE__ */ new WeakMap();
const transformElement = (node, context) => {
  return function postTransformElement() {
    node = context.currentNode;
    if (!(node.type === 1 && (node.tagType === 0 || node.tagType === 1))) {
      return;
    }
    const { tag, props } = node;
    const isComponent = node.tagType === 1;
    let vnodeTag = isComponent ? resolveComponentType(node, context) : `"${tag}"`;
    const isDynamicComponent = isObject$1(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
    let vnodeProps;
    let vnodeChildren;
    let patchFlag = 0;
    let vnodeDynamicProps;
    let dynamicPropNames;
    let vnodeDirectives;
    let shouldUseBlock = (
      // dynamic component may resolve to plain elements
      isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent && // <svg> and <foreignObject> must be forced into blocks so that block
      // updates inside get proper isSVG flag at runtime. (#639, #643)
      // This is technically web-specific, but splitting the logic out of core
      // leads to too much unnecessary complexity.
      (tag === "svg" || tag === "foreignObject" || tag === "math")
    );
    if (props.length > 0) {
      const propsBuildResult = buildProps(
        node,
        context,
        void 0,
        isComponent,
        isDynamicComponent
      );
      vnodeProps = propsBuildResult.props;
      patchFlag = propsBuildResult.patchFlag;
      dynamicPropNames = propsBuildResult.dynamicPropNames;
      const directives = propsBuildResult.directives;
      vnodeDirectives = directives && directives.length ? createArrayExpression(
        directives.map((dir) => buildDirectiveArgs(dir, context))
      ) : void 0;
      if (propsBuildResult.shouldUseBlock) {
        shouldUseBlock = true;
      }
    }
    if (node.children.length > 0) {
      if (vnodeTag === KEEP_ALIVE) {
        shouldUseBlock = true;
        patchFlag |= 1024;
      }
      const shouldBuildAsSlots = isComponent && // Teleport is not a real component and has dedicated runtime handling
      vnodeTag !== TELEPORT && // explained above.
      vnodeTag !== KEEP_ALIVE;
      if (shouldBuildAsSlots) {
        const { slots, hasDynamicSlots } = buildSlots(node, context);
        vnodeChildren = slots;
        if (hasDynamicSlots) {
          patchFlag |= 1024;
        }
      } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
        const child = node.children[0];
        const type = child.type;
        const hasDynamicTextChild = type === 5 || type === 8;
        if (hasDynamicTextChild && getConstantType(child, context) === 0) {
          patchFlag |= 1;
        }
        if (hasDynamicTextChild || type === 2) {
          vnodeChildren = child;
        } else {
          vnodeChildren = node.children;
        }
      } else {
        vnodeChildren = node.children;
      }
    }
    if (dynamicPropNames && dynamicPropNames.length) {
      vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
    }
    node.codegenNode = createVNodeCall(
      context,
      vnodeTag,
      vnodeProps,
      vnodeChildren,
      patchFlag === 0 ? void 0 : patchFlag,
      vnodeDynamicProps,
      vnodeDirectives,
      !!shouldUseBlock,
      false,
      isComponent,
      node.loc
    );
  };
};
function resolveComponentType(node, context, ssr = false) {
  let { tag } = node;
  const isExplicitDynamic = isComponentTag(tag);
  const isProp = findProp(
    node,
    "is",
    false,
    true
    /* allow empty */
  );
  if (isProp) {
    if (isExplicitDynamic || isCompatEnabled(
      "COMPILER_IS_ON_ELEMENT",
      context
    )) {
      let exp;
      if (isProp.type === 6) {
        exp = isProp.value && createSimpleExpression(isProp.value.content, true);
      } else {
        exp = isProp.exp;
        if (!exp) {
          exp = createSimpleExpression(`is`, false, isProp.arg.loc);
        }
      }
      if (exp) {
        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
          exp
        ]);
      }
    } else if (isProp.type === 6 && isProp.value.content.startsWith("vue:")) {
      tag = isProp.value.content.slice(4);
    }
  }
  const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
  if (builtIn) {
    if (!ssr) context.helper(builtIn);
    return builtIn;
  }
  context.helper(RESOLVE_COMPONENT);
  context.components.add(tag);
  return toValidAssetId(tag, `component`);
}
function buildProps(node, context, props = node.props, isComponent, isDynamicComponent, ssr = false) {
  const { tag, loc: elementLoc, children } = node;
  let properties = [];
  const mergeArgs = [];
  const runtimeDirectives = [];
  const hasChildren = children.length > 0;
  let shouldUseBlock = false;
  let patchFlag = 0;
  let hasRef = false;
  let hasClassBinding = false;
  let hasStyleBinding = false;
  let hasHydrationEventBinding = false;
  let hasDynamicKeys = false;
  let hasVnodeHook = false;
  const dynamicPropNames = [];
  const pushMergeArg = (arg) => {
    if (properties.length) {
      mergeArgs.push(
        createObjectExpression(dedupeProperties(properties), elementLoc)
      );
      properties = [];
    }
    if (arg) mergeArgs.push(arg);
  };
  const pushRefVForMarker = () => {
    if (context.scopes.vFor > 0) {
      properties.push(
        createObjectProperty(
          createSimpleExpression("ref_for", true),
          createSimpleExpression("true")
        )
      );
    }
  };
  const analyzePatchFlag = ({ key, value }) => {
    if (isStaticExp(key)) {
      const name = key.content;
      const isEventHandler = isOn(name);
      if (isEventHandler && (!isComponent || isDynamicComponent) && // omit the flag for click handlers because hydration gives click
      // dedicated fast path.
      name.toLowerCase() !== "onclick" && // omit v-model handlers
      name !== "onUpdate:modelValue" && // omit onVnodeXXX hooks
      !isReservedProp(name)) {
        hasHydrationEventBinding = true;
      }
      if (isEventHandler && isReservedProp(name)) {
        hasVnodeHook = true;
      }
      if (isEventHandler && value.type === 14) {
        value = value.arguments[0];
      }
      if (value.type === 20 || (value.type === 4 || value.type === 8) && getConstantType(value, context) > 0) {
        return;
      }
      if (name === "ref") {
        hasRef = true;
      } else if (name === "class") {
        hasClassBinding = true;
      } else if (name === "style") {
        hasStyleBinding = true;
      } else if (name !== "key" && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      }
      if (isComponent && (name === "class" || name === "style") && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      }
    } else {
      hasDynamicKeys = true;
    }
  };
  for (let i = 0; i < props.length; i++) {
    const prop = props[i];
    if (prop.type === 6) {
      const { loc, name, nameLoc, value } = prop;
      let isStatic = true;
      if (name === "ref") {
        hasRef = true;
        pushRefVForMarker();
      }
      if (name === "is" && (isComponentTag(tag) || value && value.content.startsWith("vue:") || isCompatEnabled(
        "COMPILER_IS_ON_ELEMENT",
        context
      ))) {
        continue;
      }
      properties.push(
        createObjectProperty(
          createSimpleExpression(name, true, nameLoc),
          createSimpleExpression(
            value ? value.content : "",
            isStatic,
            value ? value.loc : loc
          )
        )
      );
    } else {
      const { name, arg, exp, loc, modifiers } = prop;
      const isVBind = name === "bind";
      const isVOn = name === "on";
      if (name === "slot") {
        if (!isComponent) {
          context.onError(
            createCompilerError(40, loc)
          );
        }
        continue;
      }
      if (name === "once" || name === "memo") {
        continue;
      }
      if (name === "is" || isVBind && isStaticArgOf(arg, "is") && (isComponentTag(tag) || isCompatEnabled(
        "COMPILER_IS_ON_ELEMENT",
        context
      ))) {
        continue;
      }
      if (isVOn && ssr) {
        continue;
      }
      if (
        // #938: elements with dynamic keys should be forced into blocks
        isVBind && isStaticArgOf(arg, "key") || // inline before-update hooks need to force block so that it is invoked
        // before children
        isVOn && hasChildren && isStaticArgOf(arg, "vue:before-update")
      ) {
        shouldUseBlock = true;
      }
      if (isVBind && isStaticArgOf(arg, "ref")) {
        pushRefVForMarker();
      }
      if (!arg && (isVBind || isVOn)) {
        hasDynamicKeys = true;
        if (exp) {
          if (isVBind) {
            pushRefVForMarker();
            pushMergeArg();
            {
              if (isCompatEnabled(
                "COMPILER_V_BIND_OBJECT_ORDER",
                context
              )) {
                mergeArgs.unshift(exp);
                continue;
              }
            }
            mergeArgs.push(exp);
          } else {
            pushMergeArg({
              type: 14,
              loc,
              callee: context.helper(TO_HANDLERS),
              arguments: isComponent ? [exp] : [exp, `true`]
            });
          }
        } else {
          context.onError(
            createCompilerError(
              isVBind ? 34 : 35,
              loc
            )
          );
        }
        continue;
      }
      if (isVBind && modifiers.some((mod) => mod.content === "prop")) {
        patchFlag |= 32;
      }
      const directiveTransform = context.directiveTransforms[name];
      if (directiveTransform) {
        const { props: props2, needRuntime } = directiveTransform(prop, node, context);
        !ssr && props2.forEach(analyzePatchFlag);
        if (isVOn && arg && !isStaticExp(arg)) {
          pushMergeArg(createObjectExpression(props2, elementLoc));
        } else {
          properties.push(...props2);
        }
        if (needRuntime) {
          runtimeDirectives.push(prop);
          if (isSymbol(needRuntime)) {
            directiveImportMap.set(prop, needRuntime);
          }
        }
      } else if (!isBuiltInDirective(name)) {
        runtimeDirectives.push(prop);
        if (hasChildren) {
          shouldUseBlock = true;
        }
      }
    }
  }
  let propsExpression = void 0;
  if (mergeArgs.length) {
    pushMergeArg();
    if (mergeArgs.length > 1) {
      propsExpression = createCallExpression(
        context.helper(MERGE_PROPS),
        mergeArgs,
        elementLoc
      );
    } else {
      propsExpression = mergeArgs[0];
    }
  } else if (properties.length) {
    propsExpression = createObjectExpression(
      dedupeProperties(properties),
      elementLoc
    );
  }
  if (hasDynamicKeys) {
    patchFlag |= 16;
  } else {
    if (hasClassBinding && !isComponent) {
      patchFlag |= 2;
    }
    if (hasStyleBinding && !isComponent) {
      patchFlag |= 4;
    }
    if (dynamicPropNames.length) {
      patchFlag |= 8;
    }
    if (hasHydrationEventBinding) {
      patchFlag |= 32;
    }
  }
  if (!shouldUseBlock && (patchFlag === 0 || patchFlag === 32) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
    patchFlag |= 512;
  }
  if (!context.inSSR && propsExpression) {
    switch (propsExpression.type) {
      case 15:
        let classKeyIndex = -1;
        let styleKeyIndex = -1;
        let hasDynamicKey = false;
        for (let i = 0; i < propsExpression.properties.length; i++) {
          const key = propsExpression.properties[i].key;
          if (isStaticExp(key)) {
            if (key.content === "class") {
              classKeyIndex = i;
            } else if (key.content === "style") {
              styleKeyIndex = i;
            }
          } else if (!key.isHandlerKey) {
            hasDynamicKey = true;
          }
        }
        const classProp = propsExpression.properties[classKeyIndex];
        const styleProp = propsExpression.properties[styleKeyIndex];
        if (!hasDynamicKey) {
          if (classProp && !isStaticExp(classProp.value)) {
            classProp.value = createCallExpression(
              context.helper(NORMALIZE_CLASS),
              [classProp.value]
            );
          }
          if (styleProp && // the static style is compiled into an object,
          // so use `hasStyleBinding` to ensure that it is a dynamic style binding
          (hasStyleBinding || styleProp.value.type === 4 && styleProp.value.content.trim()[0] === `[` || // v-bind:style and style both exist,
          // v-bind:style with static literal object
          styleProp.value.type === 17)) {
            styleProp.value = createCallExpression(
              context.helper(NORMALIZE_STYLE),
              [styleProp.value]
            );
          }
        } else {
          propsExpression = createCallExpression(
            context.helper(NORMALIZE_PROPS),
            [propsExpression]
          );
        }
        break;
      case 14:
        break;
      default:
        propsExpression = createCallExpression(
          context.helper(NORMALIZE_PROPS),
          [
            createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [
              propsExpression
            ])
          ]
        );
        break;
    }
  }
  return {
    props: propsExpression,
    directives: runtimeDirectives,
    patchFlag,
    dynamicPropNames,
    shouldUseBlock
  };
}
function dedupeProperties(properties) {
  const knownProps = /* @__PURE__ */ new Map();
  const deduped = [];
  for (let i = 0; i < properties.length; i++) {
    const prop = properties[i];
    if (prop.key.type === 8 || !prop.key.isStatic) {
      deduped.push(prop);
      continue;
    }
    const name = prop.key.content;
    const existing = knownProps.get(name);
    if (existing) {
      if (name === "style" || name === "class" || isOn(name)) {
        mergeAsArray$1(existing, prop);
      }
    } else {
      knownProps.set(name, prop);
      deduped.push(prop);
    }
  }
  return deduped;
}
function mergeAsArray$1(existing, incoming) {
  if (existing.value.type === 17) {
    existing.value.elements.push(incoming.value);
  } else {
    existing.value = createArrayExpression(
      [existing.value, incoming.value],
      existing.loc
    );
  }
}
function buildDirectiveArgs(dir, context) {
  const dirArgs = [];
  const runtime = directiveImportMap.get(dir);
  if (runtime) {
    dirArgs.push(context.helperString(runtime));
  } else {
    {
      context.helper(RESOLVE_DIRECTIVE);
      context.directives.add(dir.name);
      dirArgs.push(toValidAssetId(dir.name, `directive`));
    }
  }
  const { loc } = dir;
  if (dir.exp) dirArgs.push(dir.exp);
  if (dir.arg) {
    if (!dir.exp) {
      dirArgs.push(`void 0`);
    }
    dirArgs.push(dir.arg);
  }
  if (Object.keys(dir.modifiers).length) {
    if (!dir.arg) {
      if (!dir.exp) {
        dirArgs.push(`void 0`);
      }
      dirArgs.push(`void 0`);
    }
    const trueExpression = createSimpleExpression(`true`, false, loc);
    dirArgs.push(
      createObjectExpression(
        dir.modifiers.map(
          (modifier) => createObjectProperty(modifier, trueExpression)
        ),
        loc
      )
    );
  }
  return createArrayExpression(dirArgs, dir.loc);
}
function stringifyDynamicPropNames(props) {
  let propsNamesString = `[`;
  for (let i = 0, l = props.length; i < l; i++) {
    propsNamesString += JSON.stringify(props[i]);
    if (i < l - 1) propsNamesString += ", ";
  }
  return propsNamesString + `]`;
}
function isComponentTag(tag) {
  return tag === "component" || tag === "Component";
}

const transformSlotOutlet = (node, context) => {
  if (isSlotOutlet(node)) {
    const { children, loc } = node;
    const { slotName, slotProps } = processSlotOutlet(node, context);
    const slotArgs = [
      context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
      slotName,
      "{}",
      "undefined",
      "true"
    ];
    let expectedLen = 2;
    if (slotProps) {
      slotArgs[2] = slotProps;
      expectedLen = 3;
    }
    if (children.length) {
      slotArgs[3] = createFunctionExpression([], children, false, false, loc);
      expectedLen = 4;
    }
    if (context.scopeId && !context.slotted) {
      expectedLen = 5;
    }
    slotArgs.splice(expectedLen);
    node.codegenNode = createCallExpression(
      context.helper(RENDER_SLOT),
      slotArgs,
      loc
    );
  }
};
function processSlotOutlet(node, context) {
  let slotName = `"default"`;
  let slotProps = void 0;
  const nonNameProps = [];
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 6) {
      if (p.value) {
        if (p.name === "name") {
          slotName = JSON.stringify(p.value.content);
        } else {
          p.name = camelize$1(p.name);
          nonNameProps.push(p);
        }
      }
    } else {
      if (p.name === "bind" && isStaticArgOf(p.arg, "name")) {
        if (p.exp) {
          slotName = p.exp;
        } else if (p.arg && p.arg.type === 4) {
          const name = camelize$1(p.arg.content);
          slotName = p.exp = createSimpleExpression(name, false, p.arg.loc);
        }
      } else {
        if (p.name === "bind" && p.arg && isStaticExp(p.arg)) {
          p.arg.content = camelize$1(p.arg.content);
        }
        nonNameProps.push(p);
      }
    }
  }
  if (nonNameProps.length > 0) {
    const { props, directives } = buildProps(
      node,
      context,
      nonNameProps,
      false,
      false
    );
    slotProps = props;
    if (directives.length) {
      context.onError(
        createCompilerError(
          36,
          directives[0].loc
        )
      );
    }
  }
  return {
    slotName,
    slotProps
  };
}

const transformOn$1 = (dir, node, context, augmentor) => {
  const { loc, modifiers, arg } = dir;
  if (!dir.exp && !modifiers.length) {
    context.onError(createCompilerError(35, loc));
  }
  let eventName;
  if (arg.type === 4) {
    if (arg.isStatic) {
      let rawName = arg.content;
      if (rawName.startsWith("vue:")) {
        rawName = `vnode-${rawName.slice(4)}`;
      }
      const eventString = node.tagType !== 0 || rawName.startsWith("vnode") || !/[A-Z]/.test(rawName) ? (
        // for non-element and vnode lifecycle event listeners, auto convert
        // it to camelCase. See issue #2249
        toHandlerKey$1(camelize$1(rawName))
      ) : (
        // preserve case for plain element listeners that have uppercase
        // letters, as these may be custom elements' custom events
        `on:${rawName}`
      );
      eventName = createSimpleExpression(eventString, true, arg.loc);
    } else {
      eventName = createCompoundExpression([
        `${context.helperString(TO_HANDLER_KEY)}(`,
        arg,
        `)`
      ]);
    }
  } else {
    eventName = arg;
    eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);
    eventName.children.push(`)`);
  }
  let exp = dir.exp;
  if (exp && !exp.content.trim()) {
    exp = void 0;
  }
  let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;
  if (exp) {
    const isMemberExp = isMemberExpression(exp);
    const isInlineStatement = !(isMemberExp || isFnExpression(exp));
    const hasMultipleStatements = exp.content.includes(`;`);
    if (isInlineStatement || shouldCache && isMemberExp) {
      exp = createCompoundExpression([
        `${isInlineStatement ? `$event` : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
        exp,
        hasMultipleStatements ? `}` : `)`
      ]);
    }
  }
  let ret = {
    props: [
      createObjectProperty(
        eventName,
        exp || createSimpleExpression(`() => {}`, false, loc)
      )
    ]
  };
  if (augmentor) {
    ret = augmentor(ret);
  }
  if (shouldCache) {
    ret.props[0].value = context.cache(ret.props[0].value);
  }
  ret.props.forEach((p) => p.key.isHandlerKey = true);
  return ret;
};

const transformText = (node, context) => {
  if (node.type === 0 || node.type === 1 || node.type === 11 || node.type === 10) {
    return () => {
      const children = node.children;
      let currentContainer = void 0;
      let hasText = false;
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (isText$1(child)) {
          hasText = true;
          for (let j = i + 1; j < children.length; j++) {
            const next = children[j];
            if (isText$1(next)) {
              if (!currentContainer) {
                currentContainer = children[i] = createCompoundExpression(
                  [child],
                  child.loc
                );
              }
              currentContainer.children.push(` + `, next);
              children.splice(j, 1);
              j--;
            } else {
              currentContainer = void 0;
              break;
            }
          }
        }
      }
      if (!hasText || // if this is a plain element with a single text child, leave it
      // as-is since the runtime has dedicated fast path for this by directly
      // setting textContent of the element.
      // for component root it's always normalized anyway.
      children.length === 1 && (node.type === 0 || node.type === 1 && node.tagType === 0 && // #3756
      // custom directives can potentially add DOM elements arbitrarily,
      // we need to avoid setting textContent of the element at runtime
      // to avoid accidentally overwriting the DOM elements added
      // by the user through custom directives.
      !node.props.find(
        (p) => p.type === 7 && !context.directiveTransforms[p.name]
      ) && // in compat mode, <template> tags with no special directives
      // will be rendered as a fragment so its children must be
      // converted into vnodes.
      !(node.tag === "template"))) {
        return;
      }
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (isText$1(child) || child.type === 8) {
          const callArgs = [];
          if (child.type !== 2 || child.content !== " ") {
            callArgs.push(child);
          }
          if (!context.ssr && getConstantType(child, context) === 0) {
            callArgs.push(
              1 + (``)
            );
          }
          children[i] = {
            type: 12,
            content: child,
            loc: child.loc,
            codegenNode: createCallExpression(
              context.helper(CREATE_TEXT),
              callArgs
            )
          };
        }
      }
    };
  }
};

const seen$1 = /* @__PURE__ */ new WeakSet();
const transformOnce = (node, context) => {
  if (node.type === 1 && findDir(node, "once", true)) {
    if (seen$1.has(node) || context.inVOnce || context.inSSR) {
      return;
    }
    seen$1.add(node);
    context.inVOnce = true;
    context.helper(SET_BLOCK_TRACKING);
    return () => {
      context.inVOnce = false;
      const cur = context.currentNode;
      if (cur.codegenNode) {
        cur.codegenNode = context.cache(
          cur.codegenNode,
          true
          /* isVNode */
        );
      }
    };
  }
};

const transformModel$1 = (dir, node, context) => {
  const { exp, arg } = dir;
  if (!exp) {
    context.onError(
      createCompilerError(41, dir.loc)
    );
    return createTransformProps();
  }
  const rawExp = exp.loc.source.trim();
  const expString = exp.type === 4 ? exp.content : rawExp;
  const bindingType = context.bindingMetadata[rawExp];
  if (bindingType === "props" || bindingType === "props-aliased") {
    context.onError(createCompilerError(44, exp.loc));
    return createTransformProps();
  }
  const maybeRef = false;
  if (!expString.trim() || !isMemberExpression(exp) && !maybeRef) {
    context.onError(
      createCompilerError(42, exp.loc)
    );
    return createTransformProps();
  }
  const propName = arg ? arg : createSimpleExpression("modelValue", true);
  const eventName = arg ? isStaticExp(arg) ? `onUpdate:${camelize$1(arg.content)}` : createCompoundExpression(['"onUpdate:" + ', arg]) : `onUpdate:modelValue`;
  let assignmentExp;
  const eventArg = context.isTS ? `($event: any)` : `$event`;
  {
    assignmentExp = createCompoundExpression([
      `${eventArg} => ((`,
      exp,
      `) = $event)`
    ]);
  }
  const props = [
    // modelValue: foo
    createObjectProperty(propName, dir.exp),
    // "onUpdate:modelValue": $event => (foo = $event)
    createObjectProperty(eventName, assignmentExp)
  ];
  if (dir.modifiers.length && node.tagType === 1) {
    const modifiers = dir.modifiers.map((m) => m.content).map((m) => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`).join(`, `);
    const modifiersKey = arg ? isStaticExp(arg) ? `${arg.content}Modifiers` : createCompoundExpression([arg, ' + "Modifiers"']) : `modelModifiers`;
    props.push(
      createObjectProperty(
        modifiersKey,
        createSimpleExpression(
          `{ ${modifiers} }`,
          false,
          dir.loc,
          2
        )
      )
    );
  }
  return createTransformProps(props);
};
function createTransformProps(props = []) {
  return { props };
}

const validDivisionCharRE = /[\w).+\-_$\]]/;
const transformFilter = (node, context) => {
  if (!isCompatEnabled("COMPILER_FILTERS", context)) {
    return;
  }
  if (node.type === 5) {
    rewriteFilter(node.content, context);
  } else if (node.type === 1) {
    node.props.forEach((prop) => {
      if (prop.type === 7 && prop.name !== "for" && prop.exp) {
        rewriteFilter(prop.exp, context);
      }
    });
  }
};
function rewriteFilter(node, context) {
  if (node.type === 4) {
    parseFilter(node, context);
  } else {
    for (let i = 0; i < node.children.length; i++) {
      const child = node.children[i];
      if (typeof child !== "object") continue;
      if (child.type === 4) {
        parseFilter(child, context);
      } else if (child.type === 8) {
        rewriteFilter(node, context);
      } else if (child.type === 5) {
        rewriteFilter(child.content, context);
      }
    }
  }
}
function parseFilter(node, context) {
  const exp = node.content;
  let inSingle = false;
  let inDouble = false;
  let inTemplateString = false;
  let inRegex = false;
  let curly = 0;
  let square = 0;
  let paren = 0;
  let lastFilterIndex = 0;
  let c, prev, i, expression, filters = [];
  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);
    if (inSingle) {
      if (c === 39 && prev !== 92) inSingle = false;
    } else if (inDouble) {
      if (c === 34 && prev !== 92) inDouble = false;
    } else if (inTemplateString) {
      if (c === 96 && prev !== 92) inTemplateString = false;
    } else if (inRegex) {
      if (c === 47 && prev !== 92) inRegex = false;
    } else if (c === 124 && // pipe
    exp.charCodeAt(i + 1) !== 124 && exp.charCodeAt(i - 1) !== 124 && !curly && !square && !paren) {
      if (expression === void 0) {
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 34:
          inDouble = true;
          break;
        // "
        case 39:
          inSingle = true;
          break;
        // '
        case 96:
          inTemplateString = true;
          break;
        // `
        case 40:
          paren++;
          break;
        // (
        case 41:
          paren--;
          break;
        // )
        case 91:
          square++;
          break;
        // [
        case 93:
          square--;
          break;
        // ]
        case 123:
          curly++;
          break;
        // {
        case 125:
          curly--;
          break;
      }
      if (c === 47) {
        let j = i - 1;
        let p;
        for (; j >= 0; j--) {
          p = exp.charAt(j);
          if (p !== " ") break;
        }
        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }
  if (expression === void 0) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }
  function pushFilter() {
    filters.push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }
  if (filters.length) {
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i], context);
    }
    node.content = expression;
    node.ast = void 0;
  }
}
function wrapFilter(exp, filter, context) {
  context.helper(RESOLVE_FILTER);
  const i = filter.indexOf("(");
  if (i < 0) {
    context.filters.add(filter);
    return `${toValidAssetId(filter, "filter")}(${exp})`;
  } else {
    const name = filter.slice(0, i);
    const args = filter.slice(i + 1);
    context.filters.add(name);
    return `${toValidAssetId(name, "filter")}(${exp}${args !== ")" ? "," + args : args}`;
  }
}

const seen = /* @__PURE__ */ new WeakSet();
const transformMemo = (node, context) => {
  if (node.type === 1) {
    const dir = findDir(node, "memo");
    if (!dir || seen.has(node)) {
      return;
    }
    seen.add(node);
    return () => {
      const codegenNode = node.codegenNode || context.currentNode.codegenNode;
      if (codegenNode && codegenNode.type === 13) {
        if (node.tagType !== 1) {
          convertToBlock(codegenNode, context);
        }
        node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [
          dir.exp,
          createFunctionExpression(void 0, codegenNode),
          `_cache`,
          String(context.cached.length)
        ]);
        context.cached.push(null);
      }
    };
  }
};

function getBaseTransformPreset(prefixIdentifiers) {
  return [
    [
      transformOnce,
      transformIf,
      transformMemo,
      transformFor,
      ...[transformFilter] ,
      ...[],
      transformSlotOutlet,
      transformElement,
      trackSlotScopes,
      transformText
    ],
    {
      on: transformOn$1,
      bind: transformBind,
      model: transformModel$1
    }
  ];
}
function baseCompile(source, options = {}) {
  const onError = options.onError || defaultOnError;
  const isModuleMode = options.mode === "module";
  {
    if (options.prefixIdentifiers === true) {
      onError(createCompilerError(47));
    } else if (isModuleMode) {
      onError(createCompilerError(48));
    }
  }
  const prefixIdentifiers = false;
  if (options.cacheHandlers) {
    onError(createCompilerError(49));
  }
  if (options.scopeId && !isModuleMode) {
    onError(createCompilerError(50));
  }
  const resolvedOptions = extend({}, options, {
    prefixIdentifiers
  });
  const ast = isString(source) ? baseParse(source, resolvedOptions) : source;
  const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();
  transform(
    ast,
    extend({}, resolvedOptions, {
      nodeTransforms: [
        ...nodeTransforms,
        ...options.nodeTransforms || []
        // user transforms
      ],
      directiveTransforms: extend(
        {},
        directiveTransforms,
        options.directiveTransforms || {}
        // user transforms
      )
    })
  );
  return generate(ast, resolvedOptions);
}

const BindingTypes = {
  "DATA": "data",
  "PROPS": "props",
  "PROPS_ALIASED": "props-aliased",
  "SETUP_LET": "setup-let",
  "SETUP_CONST": "setup-const",
  "SETUP_REACTIVE_CONST": "setup-reactive-const",
  "SETUP_MAYBE_REF": "setup-maybe-ref",
  "SETUP_REF": "setup-ref",
  "OPTIONS": "options",
  "LITERAL_CONST": "literal-const"
};

const noopDirectiveTransform = () => ({ props: [] });

/**
* @vue/compiler-dom v3.5.10
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/

const V_MODEL_RADIO = Symbol(``);
const V_MODEL_CHECKBOX = Symbol(
  ``
);
const V_MODEL_TEXT = Symbol(``);
const V_MODEL_SELECT = Symbol(
  ``
);
const V_MODEL_DYNAMIC = Symbol(
  ``
);
const V_ON_WITH_MODIFIERS = Symbol(
  ``
);
const V_ON_WITH_KEYS = Symbol(
  ``
);
const V_SHOW = Symbol(``);
const TRANSITION$1 = Symbol(``);
const TRANSITION_GROUP = Symbol(
  ``
);
registerRuntimeHelpers({
  [V_MODEL_RADIO]: `vModelRadio`,
  [V_MODEL_CHECKBOX]: `vModelCheckbox`,
  [V_MODEL_TEXT]: `vModelText`,
  [V_MODEL_SELECT]: `vModelSelect`,
  [V_MODEL_DYNAMIC]: `vModelDynamic`,
  [V_ON_WITH_MODIFIERS]: `withModifiers`,
  [V_ON_WITH_KEYS]: `withKeys`,
  [V_SHOW]: `vShow`,
  [TRANSITION$1]: `Transition`,
  [TRANSITION_GROUP]: `TransitionGroup`
});

let decoder;
function decodeHtmlBrowser(raw, asAttr = false) {
  if (!decoder) {
    decoder = document.createElement("div");
  }
  if (asAttr) {
    decoder.innerHTML = `<div foo="${raw.replace(/"/g, "&quot;")}">`;
    return decoder.children[0].getAttribute("foo");
  } else {
    decoder.innerHTML = raw;
    return decoder.textContent;
  }
}

const parserOptions = {
  parseMode: "html",
  isVoidTag,
  isNativeTag: (tag) => isHTMLTag(tag) || isSVGTag(tag) || isMathMLTag(tag),
  isPreTag: (tag) => tag === "pre",
  isIgnoreNewlineTag: (tag) => tag === "pre" || tag === "textarea",
  decodeEntities: decodeHtmlBrowser ,
  isBuiltInComponent: (tag) => {
    if (tag === "Transition" || tag === "transition") {
      return TRANSITION$1;
    } else if (tag === "TransitionGroup" || tag === "transition-group") {
      return TRANSITION_GROUP;
    }
  },
  // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
  getNamespace(tag, parent, rootNamespace) {
    let ns = parent ? parent.ns : rootNamespace;
    if (parent && ns === 2) {
      if (parent.tag === "annotation-xml") {
        if (tag === "svg") {
          return 1;
        }
        if (parent.props.some(
          (a) => a.type === 6 && a.name === "encoding" && a.value != null && (a.value.content === "text/html" || a.value.content === "application/xhtml+xml")
        )) {
          ns = 0;
        }
      } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== "mglyph" && tag !== "malignmark") {
        ns = 0;
      }
    } else if (parent && ns === 1) {
      if (parent.tag === "foreignObject" || parent.tag === "desc" || parent.tag === "title") {
        ns = 0;
      }
    }
    if (ns === 0) {
      if (tag === "svg") {
        return 1;
      }
      if (tag === "math") {
        return 2;
      }
    }
    return ns;
  }
};

const transformStyle = (node) => {
  if (node.type === 1) {
    node.props.forEach((p, i) => {
      if (p.type === 6 && p.name === "style" && p.value) {
        node.props[i] = {
          type: 7,
          name: `bind`,
          arg: createSimpleExpression(`style`, true, p.loc),
          exp: parseInlineCSS(p.value.content, p.loc),
          modifiers: [],
          loc: p.loc
        };
      }
    });
  }
};
const parseInlineCSS = (cssText, loc) => {
  const normalized = parseStringStyle(cssText);
  return createSimpleExpression(
    JSON.stringify(normalized),
    false,
    loc,
    3
  );
};

function createDOMCompilerError(code, loc) {
  return createCompilerError(
    code,
    loc);
}
const DOMErrorCodes = {
  "X_V_HTML_NO_EXPRESSION": 53,
  "53": "X_V_HTML_NO_EXPRESSION",
  "X_V_HTML_WITH_CHILDREN": 54,
  "54": "X_V_HTML_WITH_CHILDREN",
  "X_V_TEXT_NO_EXPRESSION": 55,
  "55": "X_V_TEXT_NO_EXPRESSION",
  "X_V_TEXT_WITH_CHILDREN": 56,
  "56": "X_V_TEXT_WITH_CHILDREN",
  "X_V_MODEL_ON_INVALID_ELEMENT": 57,
  "57": "X_V_MODEL_ON_INVALID_ELEMENT",
  "X_V_MODEL_ARG_ON_ELEMENT": 58,
  "58": "X_V_MODEL_ARG_ON_ELEMENT",
  "X_V_MODEL_ON_FILE_INPUT_ELEMENT": 59,
  "59": "X_V_MODEL_ON_FILE_INPUT_ELEMENT",
  "X_V_MODEL_UNNECESSARY_VALUE": 60,
  "60": "X_V_MODEL_UNNECESSARY_VALUE",
  "X_V_SHOW_NO_EXPRESSION": 61,
  "61": "X_V_SHOW_NO_EXPRESSION",
  "X_TRANSITION_INVALID_CHILDREN": 62,
  "62": "X_TRANSITION_INVALID_CHILDREN",
  "X_IGNORED_SIDE_EFFECT_TAG": 63,
  "63": "X_IGNORED_SIDE_EFFECT_TAG",
  "__EXTEND_POINT__": 64,
  "64": "__EXTEND_POINT__"
};
const DOMErrorMessages = {
  [53]: `v-html is missing expression.`,
  [54]: `v-html will override element children.`,
  [55]: `v-text is missing expression.`,
  [56]: `v-text will override element children.`,
  [57]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
  [58]: `v-model argument is not supported on plain elements.`,
  [59]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
  [60]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
  [61]: `v-show is missing expression.`,
  [62]: `<Transition> expects exactly one child element or component.`,
  [63]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
};

const transformVHtml = (dir, node, context) => {
  const { exp, loc } = dir;
  if (!exp) {
    context.onError(
      createDOMCompilerError(53, loc)
    );
  }
  if (node.children.length) {
    context.onError(
      createDOMCompilerError(54, loc)
    );
    node.children.length = 0;
  }
  return {
    props: [
      createObjectProperty(
        createSimpleExpression(`innerHTML`, true, loc),
        exp || createSimpleExpression("", true)
      )
    ]
  };
};

const transformVText = (dir, node, context) => {
  const { exp, loc } = dir;
  if (!exp) {
    context.onError(
      createDOMCompilerError(55, loc)
    );
  }
  if (node.children.length) {
    context.onError(
      createDOMCompilerError(56, loc)
    );
    node.children.length = 0;
  }
  return {
    props: [
      createObjectProperty(
        createSimpleExpression(`textContent`, true),
        exp ? getConstantType(exp, context) > 0 ? exp : createCallExpression(
          context.helperString(TO_DISPLAY_STRING),
          [exp],
          loc
        ) : createSimpleExpression("", true)
      )
    ]
  };
};

const transformModel = (dir, node, context) => {
  const baseResult = transformModel$1(dir, node, context);
  if (!baseResult.props.length || node.tagType === 1) {
    return baseResult;
  }
  if (dir.arg) {
    context.onError(
      createDOMCompilerError(
        58,
        dir.arg.loc
      )
    );
  }
  const { tag } = node;
  const isCustomElement = context.isCustomElement(tag);
  if (tag === "input" || tag === "textarea" || tag === "select" || isCustomElement) {
    let directiveToUse = V_MODEL_TEXT;
    let isInvalidType = false;
    if (tag === "input" || isCustomElement) {
      const type = findProp(node, `type`);
      if (type) {
        if (type.type === 7) {
          directiveToUse = V_MODEL_DYNAMIC;
        } else if (type.value) {
          switch (type.value.content) {
            case "radio":
              directiveToUse = V_MODEL_RADIO;
              break;
            case "checkbox":
              directiveToUse = V_MODEL_CHECKBOX;
              break;
            case "file":
              isInvalidType = true;
              context.onError(
                createDOMCompilerError(
                  59,
                  dir.loc
                )
              );
              break;
          }
        }
      } else if (hasDynamicKeyVBind(node)) {
        directiveToUse = V_MODEL_DYNAMIC;
      } else ;
    } else if (tag === "select") {
      directiveToUse = V_MODEL_SELECT;
    } else ;
    if (!isInvalidType) {
      baseResult.needRuntime = context.helper(directiveToUse);
    }
  } else {
    context.onError(
      createDOMCompilerError(
        57,
        dir.loc
      )
    );
  }
  baseResult.props = baseResult.props.filter(
    (p) => !(p.key.type === 4 && p.key.content === "modelValue")
  );
  return baseResult;
};

const isEventOptionModifier = /* @__PURE__ */ makeMap(`passive,once,capture`);
const isNonKeyModifier = /* @__PURE__ */ makeMap(
  // event propagation management
  `stop,prevent,self,ctrl,shift,alt,meta,exact,middle`
);
const maybeKeyModifier = /* @__PURE__ */ makeMap("left,right");
const isKeyboardEvent = /* @__PURE__ */ makeMap(`onkeyup,onkeydown,onkeypress`);
const resolveModifiers = (key, modifiers, context, loc) => {
  const keyModifiers = [];
  const nonKeyModifiers = [];
  const eventOptionModifiers = [];
  for (let i = 0; i < modifiers.length; i++) {
    const modifier = modifiers[i].content;
    if (modifier === "native" && checkCompatEnabled(
      "COMPILER_V_ON_NATIVE",
      context)) {
      eventOptionModifiers.push(modifier);
    } else if (isEventOptionModifier(modifier)) {
      eventOptionModifiers.push(modifier);
    } else {
      if (maybeKeyModifier(modifier)) {
        if (isStaticExp(key)) {
          if (isKeyboardEvent(key.content.toLowerCase())) {
            keyModifiers.push(modifier);
          } else {
            nonKeyModifiers.push(modifier);
          }
        } else {
          keyModifiers.push(modifier);
          nonKeyModifiers.push(modifier);
        }
      } else {
        if (isNonKeyModifier(modifier)) {
          nonKeyModifiers.push(modifier);
        } else {
          keyModifiers.push(modifier);
        }
      }
    }
  }
  return {
    keyModifiers,
    nonKeyModifiers,
    eventOptionModifiers
  };
};
const transformClick = (key, event) => {
  const isStaticClick = isStaticExp(key) && key.content.toLowerCase() === "onclick";
  return isStaticClick ? createSimpleExpression(event, true) : key.type !== 4 ? createCompoundExpression([
    `(`,
    key,
    `) === "onClick" ? "${event}" : (`,
    key,
    `)`
  ]) : key;
};
const transformOn = (dir, node, context) => {
  return transformOn$1(dir, node, context, (baseResult) => {
    const { modifiers } = dir;
    if (!modifiers.length) return baseResult;
    let { key, value: handlerExp } = baseResult.props[0];
    const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context, dir.loc);
    if (nonKeyModifiers.includes("right")) {
      key = transformClick(key, `onContextmenu`);
    }
    if (nonKeyModifiers.includes("middle")) {
      key = transformClick(key, `onMouseup`);
    }
    if (nonKeyModifiers.length) {
      handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [
        handlerExp,
        JSON.stringify(nonKeyModifiers)
      ]);
    }
    if (keyModifiers.length && // if event name is dynamic, always wrap with keys guard
    (!isStaticExp(key) || isKeyboardEvent(key.content.toLowerCase()))) {
      handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [
        handlerExp,
        JSON.stringify(keyModifiers)
      ]);
    }
    if (eventOptionModifiers.length) {
      const modifierPostfix = eventOptionModifiers.map(capitalize$1).join("");
      key = isStaticExp(key) ? createSimpleExpression(`${key.content}${modifierPostfix}`, true) : createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`]);
    }
    return {
      props: [createObjectProperty(key, handlerExp)]
    };
  });
};

const transformShow = (dir, node, context) => {
  const { exp, loc } = dir;
  if (!exp) {
    context.onError(
      createDOMCompilerError(61, loc)
    );
  }
  return {
    props: [],
    needRuntime: context.helper(V_SHOW)
  };
};

const ignoreSideEffectTags = (node, context) => {
  if (node.type === 1 && node.tagType === 0 && (node.tag === "script" || node.tag === "style")) {
    context.removeNode();
  }
};

const DOMNodeTransforms = [
  transformStyle,
  ...[]
];
const DOMDirectiveTransforms = {
  cloak: noopDirectiveTransform,
  html: transformVHtml,
  text: transformVText,
  model: transformModel,
  // override compiler-core
  on: transformOn,
  // override compiler-core
  show: transformShow
};
function compile$1(src, options = {}) {
  return baseCompile(
    src,
    extend({}, parserOptions, options, {
      nodeTransforms: [
        // ignore <script> and <tag>
        // this is not put inside DOMNodeTransforms because that list is used
        // by compiler-ssr to generate vnode fallback branches
        ignoreSideEffectTags,
        ...DOMNodeTransforms,
        ...options.nodeTransforms || []
      ],
      directiveTransforms: extend(
        {},
        DOMDirectiveTransforms,
        options.directiveTransforms || {}
      ),
      transformHoist: null 
    })
  );
}
function parse(template, options = {}) {
  return baseParse(template, extend({}, parserOptions, options));
}

var compilerDom_esmBundler = /*#__PURE__*/Object.freeze({
  __proto__: null,
  BASE_TRANSITION: BASE_TRANSITION,
  BindingTypes: BindingTypes,
  CAMELIZE: CAMELIZE,
  CAPITALIZE: CAPITALIZE,
  CREATE_BLOCK: CREATE_BLOCK,
  CREATE_COMMENT: CREATE_COMMENT,
  CREATE_ELEMENT_BLOCK: CREATE_ELEMENT_BLOCK,
  CREATE_ELEMENT_VNODE: CREATE_ELEMENT_VNODE,
  CREATE_SLOTS: CREATE_SLOTS,
  CREATE_STATIC: CREATE_STATIC,
  CREATE_TEXT: CREATE_TEXT,
  CREATE_VNODE: CREATE_VNODE,
  CompilerDeprecationTypes: CompilerDeprecationTypes,
  ConstantTypes: ConstantTypes,
  DOMDirectiveTransforms: DOMDirectiveTransforms,
  DOMErrorCodes: DOMErrorCodes,
  DOMErrorMessages: DOMErrorMessages,
  DOMNodeTransforms: DOMNodeTransforms,
  ElementTypes: ElementTypes,
  ErrorCodes: ErrorCodes$1,
  FRAGMENT: FRAGMENT,
  GUARD_REACTIVE_PROPS: GUARD_REACTIVE_PROPS,
  IS_MEMO_SAME: IS_MEMO_SAME,
  IS_REF: IS_REF,
  KEEP_ALIVE: KEEP_ALIVE,
  MERGE_PROPS: MERGE_PROPS,
  NORMALIZE_CLASS: NORMALIZE_CLASS,
  NORMALIZE_PROPS: NORMALIZE_PROPS,
  NORMALIZE_STYLE: NORMALIZE_STYLE,
  Namespaces: Namespaces,
  NodeTypes: NodeTypes,
  OPEN_BLOCK: OPEN_BLOCK,
  POP_SCOPE_ID: POP_SCOPE_ID,
  PUSH_SCOPE_ID: PUSH_SCOPE_ID,
  RENDER_LIST: RENDER_LIST,
  RENDER_SLOT: RENDER_SLOT,
  RESOLVE_COMPONENT: RESOLVE_COMPONENT,
  RESOLVE_DIRECTIVE: RESOLVE_DIRECTIVE,
  RESOLVE_DYNAMIC_COMPONENT: RESOLVE_DYNAMIC_COMPONENT,
  RESOLVE_FILTER: RESOLVE_FILTER,
  SET_BLOCK_TRACKING: SET_BLOCK_TRACKING,
  SUSPENSE: SUSPENSE,
  TELEPORT: TELEPORT,
  TO_DISPLAY_STRING: TO_DISPLAY_STRING,
  TO_HANDLERS: TO_HANDLERS,
  TO_HANDLER_KEY: TO_HANDLER_KEY,
  TRANSITION: TRANSITION$1,
  TRANSITION_GROUP: TRANSITION_GROUP,
  TS_NODE_TYPES: TS_NODE_TYPES,
  UNREF: UNREF,
  V_MODEL_CHECKBOX: V_MODEL_CHECKBOX,
  V_MODEL_DYNAMIC: V_MODEL_DYNAMIC,
  V_MODEL_RADIO: V_MODEL_RADIO,
  V_MODEL_SELECT: V_MODEL_SELECT,
  V_MODEL_TEXT: V_MODEL_TEXT,
  V_ON_WITH_KEYS: V_ON_WITH_KEYS,
  V_ON_WITH_MODIFIERS: V_ON_WITH_MODIFIERS,
  V_SHOW: V_SHOW,
  WITH_CTX: WITH_CTX,
  WITH_DIRECTIVES: WITH_DIRECTIVES,
  WITH_MEMO: WITH_MEMO,
  advancePositionWithClone: advancePositionWithClone,
  advancePositionWithMutation: advancePositionWithMutation,
  assert: assert,
  baseCompile: baseCompile,
  baseParse: baseParse,
  buildDirectiveArgs: buildDirectiveArgs,
  buildProps: buildProps,
  buildSlots: buildSlots,
  checkCompatEnabled: checkCompatEnabled,
  compile: compile$1,
  convertToBlock: convertToBlock,
  createArrayExpression: createArrayExpression,
  createAssignmentExpression: createAssignmentExpression,
  createBlockStatement: createBlockStatement,
  createCacheExpression: createCacheExpression,
  createCallExpression: createCallExpression,
  createCompilerError: createCompilerError,
  createCompoundExpression: createCompoundExpression,
  createConditionalExpression: createConditionalExpression,
  createDOMCompilerError: createDOMCompilerError,
  createForLoopParams: createForLoopParams,
  createFunctionExpression: createFunctionExpression,
  createIfStatement: createIfStatement,
  createInterpolation: createInterpolation,
  createObjectExpression: createObjectExpression,
  createObjectProperty: createObjectProperty,
  createReturnStatement: createReturnStatement,
  createRoot: createRoot,
  createSequenceExpression: createSequenceExpression,
  createSimpleExpression: createSimpleExpression,
  createStructuralDirectiveTransform: createStructuralDirectiveTransform,
  createTemplateLiteral: createTemplateLiteral,
  createTransformContext: createTransformContext,
  createVNodeCall: createVNodeCall,
  errorMessages: errorMessages,
  extractIdentifiers: extractIdentifiers,
  findDir: findDir,
  findProp: findProp,
  forAliasRE: forAliasRE,
  generate: generate,
  generateCodeFrame: generateCodeFrame,
  getBaseTransformPreset: getBaseTransformPreset,
  getConstantType: getConstantType,
  getMemoedVNodeCall: getMemoedVNodeCall,
  getVNodeBlockHelper: getVNodeBlockHelper,
  getVNodeHelper: getVNodeHelper,
  hasDynamicKeyVBind: hasDynamicKeyVBind,
  hasScopeRef: hasScopeRef,
  helperNameMap: helperNameMap,
  injectProp: injectProp,
  isCoreComponent: isCoreComponent,
  isFnExpression: isFnExpression,
  isFnExpressionBrowser: isFnExpressionBrowser,
  isFnExpressionNode: isFnExpressionNode,
  isFunctionType: isFunctionType,
  isInDestructureAssignment: isInDestructureAssignment,
  isInNewExpression: isInNewExpression,
  isMemberExpression: isMemberExpression,
  isMemberExpressionBrowser: isMemberExpressionBrowser,
  isMemberExpressionNode: isMemberExpressionNode,
  isReferencedIdentifier: isReferencedIdentifier,
  isSimpleIdentifier: isSimpleIdentifier,
  isSlotOutlet: isSlotOutlet,
  isStaticArgOf: isStaticArgOf,
  isStaticExp: isStaticExp,
  isStaticProperty: isStaticProperty,
  isStaticPropertyKey: isStaticPropertyKey,
  isTemplateNode: isTemplateNode,
  isText: isText$1,
  isVSlot: isVSlot,
  locStub: locStub,
  noopDirectiveTransform: noopDirectiveTransform,
  parse: parse,
  parserOptions: parserOptions,
  processExpression: processExpression,
  processFor: processFor,
  processIf: processIf,
  processSlotOutlet: processSlotOutlet,
  registerRuntimeHelpers: registerRuntimeHelpers,
  resolveComponentType: resolveComponentType,
  stringifyExpression: stringifyExpression,
  toValidAssetId: toValidAssetId,
  trackSlotScopes: trackSlotScopes,
  trackVForSlotScopes: trackVForSlotScopes,
  transform: transform,
  transformBind: transformBind,
  transformElement: transformElement,
  transformExpression: transformExpression,
  transformModel: transformModel$1,
  transformOn: transformOn$1,
  transformStyle: transformStyle,
  traverseNode: traverseNode,
  unwrapTSNode: unwrapTSNode,
  walkBlockDeclarations: walkBlockDeclarations,
  walkFunctionParams: walkFunctionParams,
  walkIdentifiers: walkIdentifiers,
  warnDeprecation: warnDeprecation
});

var require$$0 = /*@__PURE__*/getAugmentedNamespace(compilerDom_esmBundler);

/**
* @vue/reactivity v3.5.10
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/

let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    /**
     * @internal
     */
    this._active = true;
    /**
     * @internal
     */
    this.effects = [];
    /**
     * @internal
     */
    this.cleanups = [];
    this._isPaused = false;
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = true;
      let i, l;
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].pause();
        }
      }
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].pause();
      }
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active) {
      if (this._isPaused) {
        this._isPaused = false;
        let i, l;
        if (this.scopes) {
          for (i = 0, l = this.scopes.length; i < l; i++) {
            this.scopes[i].resume();
          }
        }
        for (i = 0, l = this.effects.length; i < l; i++) {
          this.effects[i].resume();
        }
      }
    }
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    activeEffectScope = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this._active) {
      let i, l;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop();
      }
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
      this._active = false;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn, failSilently = false) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  }
}

let activeSub;
const pausedQueueEffects = /* @__PURE__ */ new WeakSet();
class ReactiveEffect {
  constructor(fn) {
    this.fn = fn;
    /**
     * @internal
     */
    this.deps = void 0;
    /**
     * @internal
     */
    this.depsTail = void 0;
    /**
     * @internal
     */
    this.flags = 1 | 4;
    /**
     * @internal
     */
    this.next = void 0;
    /**
     * @internal
     */
    this.cleanup = void 0;
    this.scheduler = void 0;
    if (activeEffectScope && activeEffectScope.active) {
      activeEffectScope.effects.push(this);
    }
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    if (this.flags & 64) {
      this.flags &= ~64;
      if (pausedQueueEffects.has(this)) {
        pausedQueueEffects.delete(this);
        this.trigger();
      }
    }
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags & 2 && !(this.flags & 32)) {
      return;
    }
    if (!(this.flags & 8)) {
      batch(this);
    }
  }
  run() {
    if (!(this.flags & 1)) {
      return this.fn();
    }
    this.flags |= 2;
    cleanupEffect(this);
    prepareDeps(this);
    const prevEffect = activeSub;
    const prevShouldTrack = shouldTrack;
    activeSub = this;
    shouldTrack = true;
    try {
      return this.fn();
    } finally {
      cleanupDeps(this);
      activeSub = prevEffect;
      shouldTrack = prevShouldTrack;
      this.flags &= ~2;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let link = this.deps; link; link = link.nextDep) {
        removeSub(link);
      }
      this.deps = this.depsTail = void 0;
      cleanupEffect(this);
      this.onStop && this.onStop();
      this.flags &= ~1;
    }
  }
  trigger() {
    if (this.flags & 64) {
      pausedQueueEffects.add(this);
    } else if (this.scheduler) {
      this.scheduler();
    } else {
      this.runIfDirty();
    }
  }
  /**
   * @internal
   */
  runIfDirty() {
    if (isDirty(this)) {
      this.run();
    }
  }
  get dirty() {
    return isDirty(this);
  }
}
let batchDepth = 0;
let batchedSub;
function batch(sub) {
  sub.flags |= 8;
  sub.next = batchedSub;
  batchedSub = sub;
}
function startBatch() {
  batchDepth++;
}
function endBatch() {
  if (--batchDepth > 0) {
    return;
  }
  let error;
  while (batchedSub) {
    let e = batchedSub;
    let next;
    while (e) {
      if (!(e.flags & 1)) {
        e.flags &= ~8;
      }
      e = e.next;
    }
    e = batchedSub;
    batchedSub = void 0;
    while (e) {
      next = e.next;
      e.next = void 0;
      e.flags &= ~8;
      if (e.flags & 1) {
        try {
          ;
          e.trigger();
        } catch (err) {
          if (!error) error = err;
        }
      }
      e = next;
    }
  }
  if (error) throw error;
}
function prepareDeps(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    link.version = -1;
    link.prevActiveLink = link.dep.activeLink;
    link.dep.activeLink = link;
  }
}
function cleanupDeps(sub) {
  let head;
  let tail = sub.depsTail;
  let link = tail;
  while (link) {
    const prev = link.prevDep;
    if (link.version === -1) {
      if (link === tail) tail = prev;
      removeSub(link);
      removeDep(link);
    } else {
      head = link;
    }
    link.dep.activeLink = link.prevActiveLink;
    link.prevActiveLink = void 0;
    link = prev;
  }
  sub.deps = head;
  sub.depsTail = tail;
}
function isDirty(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {
      return true;
    }
  }
  if (sub._dirty) {
    return true;
  }
  return false;
}
function refreshComputed(computed) {
  if (computed.flags & 4 && !(computed.flags & 16)) {
    return;
  }
  computed.flags &= ~16;
  if (computed.globalVersion === globalVersion) {
    return;
  }
  computed.globalVersion = globalVersion;
  const dep = computed.dep;
  computed.flags |= 2;
  if (dep.version > 0 && !computed.isSSR && computed.deps && !isDirty(computed)) {
    computed.flags &= ~2;
    return;
  }
  const prevSub = activeSub;
  const prevShouldTrack = shouldTrack;
  activeSub = computed;
  shouldTrack = true;
  try {
    prepareDeps(computed);
    const value = computed.fn(computed._value);
    if (dep.version === 0 || hasChanged(value, computed._value)) {
      computed._value = value;
      dep.version++;
    }
  } catch (err) {
    dep.version++;
    throw err;
  } finally {
    activeSub = prevSub;
    shouldTrack = prevShouldTrack;
    cleanupDeps(computed);
    computed.flags &= ~2;
  }
}
function removeSub(link, soft = false) {
  const { dep, prevSub, nextSub } = link;
  if (prevSub) {
    prevSub.nextSub = nextSub;
    link.prevSub = void 0;
  }
  if (nextSub) {
    nextSub.prevSub = prevSub;
    link.nextSub = void 0;
  }
  if (dep.subs === link) {
    dep.subs = prevSub;
  }
  if (!dep.subs && dep.computed) {
    dep.computed.flags &= ~4;
    for (let l = dep.computed.deps; l; l = l.nextDep) {
      removeSub(l, true);
    }
  }
  if (!soft && !--dep.sc && dep.map) {
    dep.map.delete(dep.key);
  }
}
function removeDep(link) {
  const { prevDep, nextDep } = link;
  if (prevDep) {
    prevDep.nextDep = nextDep;
    link.prevDep = void 0;
  }
  if (nextDep) {
    nextDep.prevDep = prevDep;
    link.nextDep = void 0;
  }
}
function effect(fn, options) {
  if (fn.effect instanceof ReactiveEffect) {
    fn = fn.effect.fn;
  }
  const e = new ReactiveEffect(fn);
  if (options) {
    extend(e, options);
  }
  try {
    e.run();
  } catch (err) {
    e.stop();
    throw err;
  }
  const runner = e.run.bind(e);
  runner.effect = e;
  return runner;
}
function stop(runner) {
  runner.effect.stop();
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function cleanupEffect(e) {
  const { cleanup } = e;
  e.cleanup = void 0;
  if (cleanup) {
    const prevSub = activeSub;
    activeSub = void 0;
    try {
      cleanup();
    } finally {
      activeSub = prevSub;
    }
  }
}

let globalVersion = 0;
class Link {
  constructor(sub, dep) {
    this.sub = sub;
    this.dep = dep;
    this.version = dep.version;
    this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class Dep {
  constructor(computed) {
    this.computed = computed;
    this.version = 0;
    /**
     * Link between this dep and the current active effect
     */
    this.activeLink = void 0;
    /**
     * Doubly linked list representing the subscribing effects (tail)
     */
    this.subs = void 0;
    /**
     * For object property deps cleanup
     */
    this.target = void 0;
    this.map = void 0;
    this.key = void 0;
    /**
     * Subscriber counter
     */
    this.sc = 0;
  }
  track(debugInfo) {
    if (!activeSub || !shouldTrack || activeSub === this.computed) {
      return;
    }
    let link = this.activeLink;
    if (link === void 0 || link.sub !== activeSub) {
      link = this.activeLink = new Link(activeSub, this);
      if (!activeSub.deps) {
        activeSub.deps = activeSub.depsTail = link;
      } else {
        link.prevDep = activeSub.depsTail;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
      }
      addSub(link);
    } else if (link.version === -1) {
      link.version = this.version;
      if (link.nextDep) {
        const next = link.nextDep;
        next.prevDep = link.prevDep;
        if (link.prevDep) {
          link.prevDep.nextDep = next;
        }
        link.prevDep = activeSub.depsTail;
        link.nextDep = void 0;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
        if (activeSub.deps === link) {
          activeSub.deps = next;
        }
      }
    }
    return link;
  }
  trigger(debugInfo) {
    this.version++;
    globalVersion++;
    this.notify(debugInfo);
  }
  notify(debugInfo) {
    startBatch();
    try {
      if (!!("production" !== "production")) ;
      for (let link = this.subs; link; link = link.prevSub) {
        if (link.sub.notify()) {
          ;
          link.sub.dep.notify();
        }
      }
    } finally {
      endBatch();
    }
  }
}
function addSub(link) {
  link.dep.sc++;
  if (link.sub.flags & 4) {
    const computed = link.dep.computed;
    if (computed && !link.dep.subs) {
      computed.flags |= 4 | 16;
      for (let l = computed.deps; l; l = l.nextDep) {
        addSub(l);
      }
    }
    const currentTail = link.dep.subs;
    if (currentTail !== link) {
      link.prevSub = currentTail;
      if (currentTail) currentTail.nextSub = link;
    }
    link.dep.subs = link;
  }
}
const targetMap = /* @__PURE__ */ new WeakMap();
const ITERATE_KEY = Symbol(
  ""
);
const MAP_KEY_ITERATE_KEY = Symbol(
  ""
);
const ARRAY_ITERATE_KEY = Symbol(
  ""
);
function track(target, type, key) {
  if (shouldTrack && activeSub) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = new Dep());
      dep.target = target;
      dep.map = depsMap;
      dep.key = key;
    }
    {
      dep.track();
    }
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    globalVersion++;
    return;
  }
  const run = (dep) => {
    if (dep) {
      {
        dep.trigger();
      }
    }
  };
  startBatch();
  if (type === "clear") {
    depsMap.forEach(run);
  } else {
    const targetIsArray = isArray(target);
    const isArrayIndex = targetIsArray && isIntegerKey(key);
    if (targetIsArray && key === "length") {
      const newLength = Number(newValue);
      depsMap.forEach((dep, key2) => {
        if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !isSymbol(key2) && key2 >= newLength) {
          run(dep);
        }
      });
    } else {
      if (key !== void 0) {
        run(depsMap.get(key));
      }
      if (isArrayIndex) {
        run(depsMap.get(ARRAY_ITERATE_KEY));
      }
      switch (type) {
        case "add":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isArrayIndex) {
            run(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if (isMap(target)) {
            run(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
  }
  endBatch();
}
function getDepFromReactive(object, key) {
  const depMap = targetMap.get(object);
  return depMap && depMap.get(key);
}

function reactiveReadArray(array) {
  const raw = toRaw(array);
  if (raw === array) return raw;
  track(raw, "iterate", ARRAY_ITERATE_KEY);
  return isShallow(array) ? raw : raw.map(toReactive);
}
function shallowReadArray(arr) {
  track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
  return arr;
}
const arrayInstrumentations = {
  __proto__: null,
  [Symbol.iterator]() {
    return iterator(this, Symbol.iterator, toReactive);
  },
  concat(...args) {
    return reactiveReadArray(this).concat(
      ...args.map((x) => isArray(x) ? reactiveReadArray(x) : x)
    );
  },
  entries() {
    return iterator(this, "entries", (value) => {
      value[1] = toReactive(value[1]);
      return value;
    });
  },
  every(fn, thisArg) {
    return apply(this, "every", fn, thisArg, void 0, arguments);
  },
  filter(fn, thisArg) {
    return apply(this, "filter", fn, thisArg, (v) => v.map(toReactive), arguments);
  },
  find(fn, thisArg) {
    return apply(this, "find", fn, thisArg, toReactive, arguments);
  },
  findIndex(fn, thisArg) {
    return apply(this, "findIndex", fn, thisArg, void 0, arguments);
  },
  findLast(fn, thisArg) {
    return apply(this, "findLast", fn, thisArg, toReactive, arguments);
  },
  findLastIndex(fn, thisArg) {
    return apply(this, "findLastIndex", fn, thisArg, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(fn, thisArg) {
    return apply(this, "forEach", fn, thisArg, void 0, arguments);
  },
  includes(...args) {
    return searchProxy(this, "includes", args);
  },
  indexOf(...args) {
    return searchProxy(this, "indexOf", args);
  },
  join(separator) {
    return reactiveReadArray(this).join(separator);
  },
  // keys() iterator only reads `length`, no optimisation required
  lastIndexOf(...args) {
    return searchProxy(this, "lastIndexOf", args);
  },
  map(fn, thisArg) {
    return apply(this, "map", fn, thisArg, void 0, arguments);
  },
  pop() {
    return noTracking(this, "pop");
  },
  push(...args) {
    return noTracking(this, "push", args);
  },
  reduce(fn, ...args) {
    return reduce(this, "reduce", fn, args);
  },
  reduceRight(fn, ...args) {
    return reduce(this, "reduceRight", fn, args);
  },
  shift() {
    return noTracking(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(fn, thisArg) {
    return apply(this, "some", fn, thisArg, void 0, arguments);
  },
  splice(...args) {
    return noTracking(this, "splice", args);
  },
  toReversed() {
    return reactiveReadArray(this).toReversed();
  },
  toSorted(comparer) {
    return reactiveReadArray(this).toSorted(comparer);
  },
  toSpliced(...args) {
    return reactiveReadArray(this).toSpliced(...args);
  },
  unshift(...args) {
    return noTracking(this, "unshift", args);
  },
  values() {
    return iterator(this, "values", toReactive);
  }
};
function iterator(self, method, wrapValue) {
  const arr = shallowReadArray(self);
  const iter = arr[method]();
  if (arr !== self && !isShallow(self)) {
    iter._next = iter.next;
    iter.next = () => {
      const result = iter._next();
      if (result.value) {
        result.value = wrapValue(result.value);
      }
      return result;
    };
  }
  return iter;
}
const arrayProto = Array.prototype;
function apply(self, method, fn, thisArg, wrappedRetFn, args) {
  const arr = shallowReadArray(self);
  const needsWrap = arr !== self && !isShallow(self);
  const methodFn = arr[method];
  if (methodFn !== arrayProto[method]) {
    const result2 = methodFn.apply(self, args);
    return needsWrap ? toReactive(result2) : result2;
  }
  let wrappedFn = fn;
  if (arr !== self) {
    if (needsWrap) {
      wrappedFn = function(item, index) {
        return fn.call(this, toReactive(item), index, self);
      };
    } else if (fn.length > 2) {
      wrappedFn = function(item, index) {
        return fn.call(this, item, index, self);
      };
    }
  }
  const result = methodFn.call(arr, wrappedFn, thisArg);
  return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
}
function reduce(self, method, fn, args) {
  const arr = shallowReadArray(self);
  let wrappedFn = fn;
  if (arr !== self) {
    if (!isShallow(self)) {
      wrappedFn = function(acc, item, index) {
        return fn.call(this, acc, toReactive(item), index, self);
      };
    } else if (fn.length > 3) {
      wrappedFn = function(acc, item, index) {
        return fn.call(this, acc, item, index, self);
      };
    }
  }
  return arr[method](wrappedFn, ...args);
}
function searchProxy(self, method, args) {
  const arr = toRaw(self);
  track(arr, "iterate", ARRAY_ITERATE_KEY);
  const res = arr[method](...args);
  if ((res === -1 || res === false) && isProxy(args[0])) {
    args[0] = toRaw(args[0]);
    return arr[method](...args);
  }
  return res;
}
function noTracking(self, method, args = []) {
  pauseTracking();
  startBatch();
  const res = toRaw(self)[method].apply(self, args);
  endBatch();
  resetTracking();
  return res;
}

const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
);
function hasOwnProperty(key) {
  if (!isSymbol(key)) key = String(key);
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
class BaseReactiveHandler {
  constructor(_isReadonly = false, _isShallow = false) {
    this._isReadonly = _isReadonly;
    this._isShallow = _isShallow;
  }
  get(target, key, receiver) {
    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return isShallow2;
    } else if (key === "__v_raw") {
      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
        return target;
      }
      return;
    }
    const targetIsArray = isArray(target);
    if (!isReadonly2) {
      let fn;
      if (targetIsArray && (fn = arrayInstrumentations[key])) {
        return fn;
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty;
      }
    }
    const res = Reflect.get(
      target,
      key,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      isRef(target) ? target : receiver
    );
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (isShallow2) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject$1(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  }
}
class MutableReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(false, isShallow2);
  }
  set(target, key, value, receiver) {
    let oldValue = target[key];
    if (!this._isShallow) {
      const isOldValueReadonly = isReadonly(oldValue);
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
        if (isOldValueReadonly) {
          return false;
        } else {
          oldValue.value = value;
          return true;
        }
      }
    }
    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(
      target,
      key,
      value,
      isRef(target) ? target : receiver
    );
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value);
      }
    }
    return result;
  }
  deleteProperty(target, key) {
    const hadKey = hasOwn(target, key);
    target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0);
    }
    return result;
  }
  has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  ownKeys(target) {
    track(
      target,
      "iterate",
      isArray(target) ? "length" : ITERATE_KEY
    );
    return Reflect.ownKeys(target);
  }
}
class ReadonlyReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(true, isShallow2);
  }
  set(target, key) {
    return true;
  }
  deleteProperty(target, key) {
    return true;
  }
}
const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);

const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);
function get(target, key, isReadonly2 = false, isShallow2 = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (hasChanged(key, rawKey)) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has2 } = getProto(rawTarget);
  const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has(key, isReadonly2 = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (hasChanged(key, rawKey)) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly2 = false) {
  target = target["__v_raw"];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add(value, _isShallow = false) {
  if (!_isShallow && !isShallow(value) && !isReadonly(value)) {
    value = toRaw(value);
  }
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set(key, value, _isShallow = false) {
  if (!_isShallow && !isShallow(value) && !isReadonly(value)) {
    value = toRaw(value);
  }
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  const oldValue = get2.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger(target, "add", key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target, "set", key, value);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  get2 ? get2.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      // iterator protocol
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    return type === "delete" ? false : type === "clear" ? void 0 : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get(this, key);
    },
    get size() {
      return size(this);
    },
    has,
    add,
    set,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has,
    add(value) {
      return add.call(this, value, true);
    },
    set(key, value) {
      return set.call(this, key, value, true);
    },
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
    shallowInstrumentations2[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations2[method] = createIterableMethod(
      method,
      true,
      true
    );
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [
  mutableInstrumentations,
  readonlyInstrumentations,
  shallowInstrumentations,
  shallowReadonlyInstrumentations
] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
      hasOwn(instrumentations, key) && key in target ? instrumentations : target,
      key,
      receiver
    );
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};

const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1 /* COMMON */;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2 /* COLLECTION */;
    default:
      return 0 /* INVALID */;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 /* INVALID */ : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
function shallowReactive(target) {
  return createReactiveObject(
    target,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  );
}
function readonly(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
function shallowReadonly(target) {
  return createReactiveObject(
    target,
    true,
    shallowReadonlyHandlers,
    shallowReadonlyCollectionHandlers,
    shallowReadonlyMap
  );
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$1(target)) {
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0 /* INVALID */) {
    return target;
  }
  const proxy = new Proxy(
    target,
    targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return value ? !!value["__v_raw"] : false;
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  if (!hasOwn(value, "__v_skip") && Object.isExtensible(value)) {
    def(value, "__v_skip", true);
  }
  return value;
}
const toReactive = (value) => isObject$1(value) ? reactive(value) : value;
const toReadonly = (value) => isObject$1(value) ? readonly(value) : value;

function isRef(r) {
  return r ? r["__v_isRef"] === true : false;
}
function ref(value) {
  return createRef(value, false);
}
function shallowRef(value) {
  return createRef(value, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, isShallow2) {
    this.dep = new Dep();
    this["__v_isRef"] = true;
    this["__v_isShallow"] = false;
    this._rawValue = isShallow2 ? value : toRaw(value);
    this._value = isShallow2 ? value : toReactive(value);
    this["__v_isShallow"] = isShallow2;
  }
  get value() {
    {
      this.dep.track();
    }
    return this._value;
  }
  set value(newValue) {
    const oldValue = this._rawValue;
    const useDirectValue = this["__v_isShallow"] || isShallow(newValue) || isReadonly(newValue);
    newValue = useDirectValue ? newValue : toRaw(newValue);
    if (hasChanged(newValue, oldValue)) {
      this._rawValue = newValue;
      this._value = useDirectValue ? newValue : toReactive(newValue);
      {
        this.dep.trigger();
      }
    }
  }
}
function triggerRef(ref2) {
  if (ref2.dep) {
    {
      ref2.dep.trigger();
    }
  }
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
function toValue(source) {
  return isFunction(source) ? source() : unref(source);
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => key === "__v_raw" ? target : unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class CustomRefImpl {
  constructor(factory) {
    this["__v_isRef"] = true;
    this._value = void 0;
    const dep = this.dep = new Dep();
    const { get, set } = factory(dep.track.bind(dep), dep.trigger.bind(dep));
    this._get = get;
    this._set = set;
  }
  get value() {
    return this._value = this._get();
  }
  set value(newVal) {
    this._set(newVal);
  }
}
function customRef(factory) {
  return new CustomRefImpl(factory);
}
function toRefs(object) {
  const ret = isArray(object) ? new Array(object.length) : {};
  for (const key in object) {
    ret[key] = propertyToRef(object, key);
  }
  return ret;
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this["__v_isRef"] = true;
    this._value = void 0;
  }
  get value() {
    const val = this._object[this._key];
    return this._value = val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
  get dep() {
    return getDepFromReactive(toRaw(this._object), this._key);
  }
}
class GetterRefImpl {
  constructor(_getter) {
    this._getter = _getter;
    this["__v_isRef"] = true;
    this["__v_isReadonly"] = true;
    this._value = void 0;
  }
  get value() {
    return this._value = this._getter();
  }
}
function toRef(source, key, defaultValue) {
  if (isRef(source)) {
    return source;
  } else if (isFunction(source)) {
    return new GetterRefImpl(source);
  } else if (isObject$1(source) && arguments.length > 1) {
    return propertyToRef(source, key, defaultValue);
  } else {
    return ref(source);
  }
}
function propertyToRef(source, key, defaultValue) {
  const val = source[key];
  return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
}

class ComputedRefImpl {
  constructor(fn, setter, isSSR) {
    this.fn = fn;
    this.setter = setter;
    /**
     * @internal
     */
    this._value = void 0;
    /**
     * @internal
     */
    this.dep = new Dep(this);
    /**
     * @internal
     */
    this.__v_isRef = true;
    // TODO isolatedDeclarations "__v_isReadonly"
    // A computed is also a subscriber that tracks other deps
    /**
     * @internal
     */
    this.deps = void 0;
    /**
     * @internal
     */
    this.depsTail = void 0;
    /**
     * @internal
     */
    this.flags = 16;
    /**
     * @internal
     */
    this.globalVersion = globalVersion - 1;
    /**
     * @internal
     */
    this.next = void 0;
    // for backwards compat
    this.effect = this;
    this["__v_isReadonly"] = !setter;
    this.isSSR = isSSR;
  }
  /**
   * @internal
   */
  notify() {
    this.flags |= 16;
    if (!(this.flags & 8) && // avoid infinite self recursion
    activeSub !== this) {
      batch(this);
      return true;
    }
  }
  get value() {
    const link = this.dep.track();
    refreshComputed(this);
    if (link) {
      link.version = this.dep.version;
    }
    return this._value;
  }
  set value(newValue) {
    if (this.setter) {
      this.setter(newValue);
    }
  }
}
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  if (isFunction(getterOrOptions)) {
    getter = getterOrOptions;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, isSSR);
  return cRef;
}

const TrackOpTypes = {
  "GET": "get",
  "HAS": "has",
  "ITERATE": "iterate"
};
const TriggerOpTypes = {
  "SET": "set",
  "ADD": "add",
  "DELETE": "delete",
  "CLEAR": "clear"
};
const INITIAL_WATCHER_VALUE = {};
const cleanupMap = /* @__PURE__ */ new WeakMap();
let activeWatcher = void 0;
function getCurrentWatcher() {
  return activeWatcher;
}
function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
  if (owner) {
    let cleanups = cleanupMap.get(owner);
    if (!cleanups) cleanupMap.set(owner, cleanups = []);
    cleanups.push(cleanupFn);
  }
}
function watch$1(source, cb, options = EMPTY_OBJ) {
  const { immediate, deep, once, scheduler, augmentJob, call } = options;
  const reactiveGetter = (source2) => {
    if (deep) return source2;
    if (isShallow(source2) || deep === false || deep === 0)
      return traverse(source2, 1);
    return traverse(source2);
  };
  let effect;
  let getter;
  let cleanup;
  let boundCleanup;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => reactiveGetter(source);
    forceTrigger = true;
  } else if (isArray(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return reactiveGetter(s);
      } else if (isFunction(s)) {
        return call ? call(s, 2) : s();
      } else ;
    });
  } else if (isFunction(source)) {
    if (cb) {
      getter = call ? () => call(source, 2) : source;
    } else {
      getter = () => {
        if (cleanup) {
          pauseTracking();
          try {
            cleanup();
          } finally {
            resetTracking();
          }
        }
        const currentEffect = activeWatcher;
        activeWatcher = effect;
        try {
          return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);
        } finally {
          activeWatcher = currentEffect;
        }
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    const depth = deep === true ? Infinity : deep;
    getter = () => traverse(baseGetter(), depth);
  }
  const scope = getCurrentScope();
  const watchHandle = () => {
    effect.stop();
    if (scope) {
      remove(scope.effects, effect);
    }
  };
  if (once && cb) {
    const _cb = cb;
    cb = (...args) => {
      _cb(...args);
      watchHandle();
    };
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = (immediateFirstRun) => {
    if (!(effect.flags & 1) || !effect.dirty && !immediateFirstRun) {
      return;
    }
    if (cb) {
      const newValue = effect.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {
        if (cleanup) {
          cleanup();
        }
        const currentWatcher = activeWatcher;
        activeWatcher = effect;
        try {
          const args = [
            newValue,
            // pass undefined as the old value when it's changed for the first time
            oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
            boundCleanup
          ];
          call ? call(cb, 3, args) : (
            // @ts-expect-error
            cb(...args)
          );
          oldValue = newValue;
        } finally {
          activeWatcher = currentWatcher;
        }
      }
    } else {
      effect.run();
    }
  };
  if (augmentJob) {
    augmentJob(job);
  }
  effect = new ReactiveEffect(getter);
  effect.scheduler = scheduler ? () => scheduler(job, false) : job;
  boundCleanup = (fn) => onWatcherCleanup(fn, false, effect);
  cleanup = effect.onStop = () => {
    const cleanups = cleanupMap.get(effect);
    if (cleanups) {
      if (call) {
        call(cleanups, 4);
      } else {
        for (const cleanup2 of cleanups) cleanup2();
      }
      cleanupMap.delete(effect);
    }
  };
  if (cb) {
    if (immediate) {
      job(true);
    } else {
      oldValue = effect.run();
    }
  } else if (scheduler) {
    scheduler(job.bind(null, true), true);
  } else {
    effect.run();
  }
  watchHandle.pause = effect.pause.bind(effect);
  watchHandle.resume = effect.resume.bind(effect);
  watchHandle.stop = watchHandle;
  return watchHandle;
}
function traverse(value, depth = Infinity, seen) {
  if (depth <= 0 || !isObject$1(value) || value["__v_skip"]) {
    return value;
  }
  seen = seen || /* @__PURE__ */ new Set();
  if (seen.has(value)) {
    return value;
  }
  seen.add(value);
  depth--;
  if (isRef(value)) {
    traverse(value.value, depth, seen);
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], depth, seen);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v) => {
      traverse(v, depth, seen);
    });
  } else if (isPlainObject(value)) {
    for (const key in value) {
      traverse(value[key], depth, seen);
    }
    for (const key of Object.getOwnPropertySymbols(value)) {
      if (Object.prototype.propertyIsEnumerable.call(value, key)) {
        traverse(value[key], depth, seen);
      }
    }
  }
  return value;
}

/**
* @vue/runtime-core v3.5.10
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/

const stack = [];
function pushWarningContext(vnode) {
  stack.push(vnode);
}
function popWarningContext() {
  stack.pop();
}
let isWarning = false;
function warn$1(msg, ...args) {
  if (isWarning) return;
  isWarning = true;
  pauseTracking();
  const instance = stack.length ? stack[stack.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(
      appWarnHandler,
      instance,
      11,
      [
        // eslint-disable-next-line no-restricted-syntax
        msg + args.map((a) => {
          var _a, _b;
          return (_b = (_a = a.toString) == null ? void 0 : _a.call(a)) != null ? _b : JSON.stringify(a);
        }).join(""),
        instance && instance.proxy,
        trace.map(
          ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
        ).join("\n"),
        trace
      ]
    );
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length && // avoid spamming console during tests
    true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  resetTracking();
  isWarning = false;
}
function getComponentTrace() {
  let currentVNode = stack[stack.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last = normalizedStack[0];
    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i) => {
    logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open = ` at <${formatComponentName(
    vnode.component,
    vnode.type,
    isRoot
  )}`;
  const close = `>` + postfix;
  return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
}
function formatProps(props) {
  const res = [];
  const keys = Object.keys(props);
  keys.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props[key]));
  });
  if (keys.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value, raw) {
  if (isString(value)) {
    value = JSON.stringify(value);
    return raw ? value : [`${key}=${value}`];
  } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
    return raw ? value : [`${key}=${value}`];
  } else if (isRef(value)) {
    value = formatProp(key, toRaw(value.value), true);
    return raw ? value : [`${key}=Ref<`, value, `>`];
  } else if (isFunction(value)) {
    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
  } else {
    value = toRaw(value);
    return raw ? value : [`${key}=`, value];
  }
}
function assertNumber(val, type) {
  return;
}

const ErrorCodes = {
  "SETUP_FUNCTION": 0,
  "0": "SETUP_FUNCTION",
  "RENDER_FUNCTION": 1,
  "1": "RENDER_FUNCTION",
  "NATIVE_EVENT_HANDLER": 5,
  "5": "NATIVE_EVENT_HANDLER",
  "COMPONENT_EVENT_HANDLER": 6,
  "6": "COMPONENT_EVENT_HANDLER",
  "VNODE_HOOK": 7,
  "7": "VNODE_HOOK",
  "DIRECTIVE_HOOK": 8,
  "8": "DIRECTIVE_HOOK",
  "TRANSITION_HOOK": 9,
  "9": "TRANSITION_HOOK",
  "APP_ERROR_HANDLER": 10,
  "10": "APP_ERROR_HANDLER",
  "APP_WARN_HANDLER": 11,
  "11": "APP_WARN_HANDLER",
  "FUNCTION_REF": 12,
  "12": "FUNCTION_REF",
  "ASYNC_COMPONENT_LOADER": 13,
  "13": "ASYNC_COMPONENT_LOADER",
  "SCHEDULER": 14,
  "14": "SCHEDULER",
  "COMPONENT_UPDATE": 15,
  "15": "COMPONENT_UPDATE",
  "APP_UNMOUNT_CLEANUP": 16,
  "16": "APP_UNMOUNT_CLEANUP"
};
const ErrorTypeStrings$1 = {
  ["sp"]: "serverPrefetch hook",
  ["bc"]: "beforeCreate hook",
  ["c"]: "created hook",
  ["bm"]: "beforeMount hook",
  ["m"]: "mounted hook",
  ["bu"]: "beforeUpdate hook",
  ["u"]: "updated",
  ["bum"]: "beforeUnmount hook",
  ["um"]: "unmounted hook",
  ["a"]: "activated hook",
  ["da"]: "deactivated hook",
  ["ec"]: "errorCaptured hook",
  ["rtc"]: "renderTracked hook",
  ["rtg"]: "renderTriggered hook",
  [0]: "setup function",
  [1]: "render function",
  [2]: "watcher getter",
  [3]: "watcher callback",
  [4]: "watcher cleanup function",
  [5]: "native event handler",
  [6]: "component event handler",
  [7]: "vnode hook",
  [8]: "directive hook",
  [9]: "transition hook",
  [10]: "app errorHandler",
  [11]: "app warnHandler",
  [12]: "ref function",
  [13]: "async component loader",
  [14]: "scheduler flush",
  [15]: "component update",
  [16]: "app unmount cleanup function"
};
function callWithErrorHandling(fn, instance, type, args) {
  try {
    return args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  if (isArray(fn)) {
    const values = [];
    for (let i = 0; i < fn.length; i++) {
      values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
    }
    return values;
  }
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || EMPTY_OBJ;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = `https://vuejs.org/error-reference/#runtime-${type}`;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    if (errorHandler) {
      pauseTracking();
      callWithErrorHandling(errorHandler, null, 10, [
        err,
        exposedInstance,
        errorInfo
      ]);
      resetTracking();
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev, throwUnhandledErrorInProduction);
}
function logError(err, type, contextVNode, throwInDev = true, throwInProd = false) {
  if (throwInProd) {
    throw err;
  } else {
    console.error(err);
  }
}

let isFlushing = false;
let isFlushPending = false;
const queue$1 = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
function nextTick(fn) {
  const p = currentFlushPromise || resolvedPromise;
  return fn ? p.then(this ? fn.bind(this) : fn) : p;
}
function findInsertionIndex(id) {
  let start = isFlushing ? flushIndex + 1 : 0;
  let end = queue$1.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJob = queue$1[middle];
    const middleJobId = getId(middleJob);
    if (middleJobId < id || middleJobId === id && middleJob.flags & 2) {
      start = middle + 1;
    } else {
      end = middle;
    }
  }
  return start;
}
function queueJob(job) {
  if (!(job.flags & 1)) {
    const jobId = getId(job);
    const lastJob = queue$1[queue$1.length - 1];
    if (!lastJob || // fast path when the job id is larger than the tail
    !(job.flags & 2) && jobId >= getId(lastJob)) {
      queue$1.push(job);
    } else {
      queue$1.splice(findInsertionIndex(jobId), 0, job);
    }
    job.flags |= 1;
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray(cb)) {
    if (activePostFlushCbs && cb.id === -1) {
      activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);
    } else if (!(cb.flags & 1)) {
      pendingPostFlushCbs.push(cb);
      cb.flags |= 1;
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(instance, seen, i = isFlushing ? flushIndex + 1 : 0) {
  for (; i < queue$1.length; i++) {
    const cb = queue$1[i];
    if (cb && cb.flags & 2) {
      if (instance && cb.id !== instance.uid) {
        continue;
      }
      queue$1.splice(i, 1);
      i--;
      if (cb.flags & 4) {
        cb.flags &= ~1;
      }
      cb();
      if (!(cb.flags & 4)) {
        cb.flags &= ~1;
      }
    }
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)].sort(
      (a, b) => getId(a) - getId(b)
    );
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      const cb = activePostFlushCbs[postFlushIndex];
      if (cb.flags & 4) {
        cb.flags &= ~1;
      }
      if (!(cb.flags & 8)) cb();
      cb.flags &= ~1;
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
function flushJobs(seen) {
  isFlushPending = false;
  isFlushing = true;
  const check = NOOP;
  try {
    for (flushIndex = 0; flushIndex < queue$1.length; flushIndex++) {
      const job = queue$1[flushIndex];
      if (job && !(job.flags & 8)) {
        if (!!("production" !== "production") && check(job)) ;
        if (job.flags & 4) {
          job.flags &= ~1;
        }
        callWithErrorHandling(
          job,
          job.i,
          job.i ? 15 : 14
        );
        if (!(job.flags & 4)) {
          job.flags &= ~1;
        }
      }
    }
  } finally {
    for (; flushIndex < queue$1.length; flushIndex++) {
      const job = queue$1[flushIndex];
      if (job) {
        job.flags &= ~1;
      }
    }
    flushIndex = 0;
    queue$1.length = 0;
    flushPostFlushCbs();
    isFlushing = false;
    currentFlushPromise = null;
    if (queue$1.length || pendingPostFlushCbs.length) {
      flushJobs();
    }
  }
}

let devtools$1;
let buffer = [];
let devtoolsNotInstalled = false;
function emit$1(event, ...args) {
  if (devtools$1) {
    devtools$1.emit(event, ...args);
  } else if (!devtoolsNotInstalled) {
    buffer.push({ event, args });
  }
}
function setDevtoolsHook$1(hook, target) {
  var _a, _b;
  devtools$1 = hook;
  if (devtools$1) {
    devtools$1.enabled = true;
    buffer.forEach(({ event, args }) => devtools$1.emit(event, ...args));
    buffer = [];
  } else if (
    // handle late devtools injection - only do this if we are in an actual
    // browser environment to avoid the timer handle stalling test runner exit
    // (#4815)
    typeof window !== "undefined" && // some envs mock window but not fully
    window.HTMLElement && // also exclude jsdom
    // eslint-disable-next-line no-restricted-syntax
    !((_b = (_a = window.navigator) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.includes("jsdom"))
  ) {
    const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
    replay.push((newHook) => {
      setDevtoolsHook$1(newHook, target);
    });
    setTimeout(() => {
      if (!devtools$1) {
        target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
        devtoolsNotInstalled = true;
        buffer = [];
      }
    }, 3e3);
  } else {
    devtoolsNotInstalled = true;
    buffer = [];
  }
}
function devtoolsInitApp(app, version) {
  emit$1("app:init" /* APP_INIT */, app, version, {
    Fragment,
    Text,
    Comment,
    Static
  });
}
function devtoolsUnmountApp(app) {
  emit$1("app:unmount" /* APP_UNMOUNT */, app);
}
const devtoolsComponentAdded = /* @__PURE__ */ createDevtoolsComponentHook("component:added" /* COMPONENT_ADDED */);
const devtoolsComponentUpdated = /* @__PURE__ */ createDevtoolsComponentHook("component:updated" /* COMPONENT_UPDATED */);
const _devtoolsComponentRemoved = /* @__PURE__ */ createDevtoolsComponentHook(
  "component:removed" /* COMPONENT_REMOVED */
);
const devtoolsComponentRemoved = (component) => {
  if (devtools$1 && typeof devtools$1.cleanupBuffer === "function" && // remove the component if it wasn't buffered
  !devtools$1.cleanupBuffer(component)) {
    _devtoolsComponentRemoved(component);
  }
};
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function createDevtoolsComponentHook(hook) {
  return (component) => {
    emit$1(
      hook,
      component.appContext.app,
      component.uid,
      component.parent ? component.parent.uid : void 0,
      component
    );
  };
}
function devtoolsComponentEmit(component, event, params) {
  emit$1(
    "component:emit" /* COMPONENT_EMIT */,
    component.appContext.app,
    component,
    event,
    params
  );
}

let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function pushScopeId(id) {
  currentScopeId = id;
}
function popScopeId() {
  currentScopeId = null;
}
const withScopeId = (_id) => withCtx;
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx) return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    if (__VUE_PROD_DEVTOOLS__) {
      devtoolsComponentUpdated(ctx);
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function withDirectives(vnode, directives) {
  if (currentRenderingInstance === null) {
    return vnode;
  }
  const instance = getComponentPublicInstance(currentRenderingInstance);
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i = 0; i < directives.length; i++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
    if (dir) {
      if (isFunction(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse(value);
      }
      bindings.push({
        dir,
        instance,
        value,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];
    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}

const TeleportEndKey = Symbol("_vte");
const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
const isTeleportDeferred = (props) => props && (props.defer || props.defer === "");
const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
const isTargetMathML = (target) => typeof MathMLElement === "function" && target instanceof MathMLElement;
const resolveTarget = (props, select) => {
  const targetSelector = props && props.to;
  if (isString(targetSelector)) {
    if (!select) {
      return null;
    } else {
      const target = select(targetSelector);
      return target;
    }
  } else {
    return targetSelector;
  }
};
const TeleportImpl = {
  name: "Teleport",
  __isTeleport: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
    const {
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      o: { insert, querySelector, createText, createComment }
    } = internals;
    const disabled = isTeleportDisabled(n2.props);
    let { shapeFlag, children, dynamicChildren } = n2;
    if (n1 == null) {
      const placeholder = n2.el = createText("");
      const mainAnchor = n2.anchor = createText("");
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      const mount = (container2, anchor2) => {
        if (shapeFlag & 16) {
          if (parentComponent && parentComponent.isCE) {
            parentComponent.ce._teleportTarget = container2;
          }
          mountChildren(
            children,
            container2,
            anchor2,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      };
      const mountToTarget = () => {
        const target = n2.target = resolveTarget(n2.props, querySelector);
        const targetAnchor = prepareAnchor(target, n2, createText, insert);
        if (target) {
          if (namespace !== "svg" && isTargetSVG(target)) {
            namespace = "svg";
          } else if (namespace !== "mathml" && isTargetMathML(target)) {
            namespace = "mathml";
          }
          if (!disabled) {
            mount(target, targetAnchor);
            updateCssVars(n2);
          }
        }
      };
      if (disabled) {
        mount(container, mainAnchor);
        updateCssVars(n2);
      }
      if (isTeleportDeferred(n2.props)) {
        queuePostRenderEffect(mountToTarget, parentSuspense);
      } else {
        mountToTarget();
      }
    } else {
      n2.el = n1.el;
      n2.targetStart = n1.targetStart;
      const mainAnchor = n2.anchor = n1.anchor;
      const target = n2.target = n1.target;
      const targetAnchor = n2.targetAnchor = n1.targetAnchor;
      const wasDisabled = isTeleportDisabled(n1.props);
      const currentContainer = wasDisabled ? container : target;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      if (namespace === "svg" || isTargetSVG(target)) {
        namespace = "svg";
      } else if (namespace === "mathml" || isTargetMathML(target)) {
        namespace = "mathml";
      }
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          currentContainer,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(
          n1,
          n2,
          currentContainer,
          currentAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          false
        );
      }
      if (disabled) {
        if (!wasDisabled) {
          moveTeleport(
            n2,
            container,
            mainAnchor,
            internals,
            1
          );
        } else {
          if (n2.props && n1.props && n2.props.to !== n1.props.to) {
            n2.props.to = n1.props.to;
          }
        }
      } else {
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          const nextTarget = n2.target = resolveTarget(
            n2.props,
            querySelector
          );
          if (nextTarget) {
            moveTeleport(
              n2,
              nextTarget,
              null,
              internals,
              0
            );
          }
        } else if (wasDisabled) {
          moveTeleport(
            n2,
            target,
            targetAnchor,
            internals,
            1
          );
        }
      }
      updateCssVars(n2);
    }
  },
  remove(vnode, parentComponent, parentSuspense, { um: unmount, o: { remove: hostRemove } }, doRemove) {
    const {
      shapeFlag,
      children,
      anchor,
      targetStart,
      targetAnchor,
      target,
      props
    } = vnode;
    if (target) {
      hostRemove(targetStart);
      hostRemove(targetAnchor);
    }
    doRemove && hostRemove(anchor);
    if (shapeFlag & 16) {
      const shouldRemove = doRemove || !isTeleportDisabled(props);
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        unmount(
          child,
          parentComponent,
          parentSuspense,
          shouldRemove,
          !!child.dynamicChildren
        );
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
  if (moveType === 0) {
    insert(vnode.targetAnchor, container, parentAnchor);
  }
  const { el, anchor, shapeFlag, children, props } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert(el, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props)) {
    if (shapeFlag & 16) {
      for (let i = 0; i < children.length; i++) {
        move(
          children[i],
          container,
          parentAnchor,
          2
        );
      }
    }
  }
  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
  o: { nextSibling, parentNode, querySelector, insert, createText }
}, hydrateChildren) {
  const target = vnode.target = resolveTarget(
    vnode.props,
    querySelector
  );
  if (target) {
    const targetNode = target._lpa || target.firstChild;
    if (vnode.shapeFlag & 16) {
      if (isTeleportDisabled(vnode.props)) {
        vnode.anchor = hydrateChildren(
          nextSibling(node),
          vnode,
          parentNode(node),
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
        vnode.targetStart = targetNode;
        vnode.targetAnchor = targetNode && nextSibling(targetNode);
      } else {
        vnode.anchor = nextSibling(node);
        let targetAnchor = targetNode;
        while (targetAnchor) {
          if (targetAnchor && targetAnchor.nodeType === 8) {
            if (targetAnchor.data === "teleport start anchor") {
              vnode.targetStart = targetAnchor;
            } else if (targetAnchor.data === "teleport anchor") {
              vnode.targetAnchor = targetAnchor;
              target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
              break;
            }
          }
          targetAnchor = nextSibling(targetAnchor);
        }
        if (!vnode.targetAnchor) {
          prepareAnchor(target, vnode, createText, insert);
        }
        hydrateChildren(
          targetNode && nextSibling(targetNode),
          vnode,
          target,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      }
    }
    updateCssVars(vnode);
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
function updateCssVars(vnode) {
  const ctx = vnode.ctx;
  if (ctx && ctx.ut) {
    let node = vnode.targetStart;
    while (node && node !== vnode.targetAnchor) {
      if (node.nodeType === 1) node.setAttribute("data-v-owner", ctx.uid);
      node = node.nextSibling;
    }
    ctx.ut();
  }
}
function prepareAnchor(target, vnode, createText, insert) {
  const targetStart = vnode.targetStart = createText("");
  const targetAnchor = vnode.targetAnchor = createText("");
  targetStart[TeleportEndKey] = targetAnchor;
  if (target) {
    insert(targetStart, target);
    insert(targetAnchor, target);
  }
  return targetAnchor;
}

const leaveCbKey = Symbol("_leaveCb");
const enterCbKey$1 = Symbol("_enterCb");
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionPropsValidators = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: TransitionHookValidator,
  onEnter: TransitionHookValidator,
  onAfterEnter: TransitionHookValidator,
  onEnterCancelled: TransitionHookValidator,
  // leave
  onBeforeLeave: TransitionHookValidator,
  onLeave: TransitionHookValidator,
  onAfterLeave: TransitionHookValidator,
  onLeaveCancelled: TransitionHookValidator,
  // appear
  onBeforeAppear: TransitionHookValidator,
  onAppear: TransitionHookValidator,
  onAfterAppear: TransitionHookValidator,
  onAppearCancelled: TransitionHookValidator
};
const recursiveGetSubtree = (instance) => {
  const subTree = instance.subTree;
  return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
};
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: BaseTransitionPropsValidators,
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      const child = findNonCommentChild(children);
      const rawProps = toRaw(props);
      const { mode } = rawProps;
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getInnerChild$1(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      let enterHooks = resolveTransitionHooks(
        innerChild,
        rawProps,
        state,
        instance,
        // #11061, ensure enterHooks is fresh after clone
        (hooks) => enterHooks = hooks
      );
      if (innerChild.type !== Comment) {
        setTransitionHooks(innerChild, enterHooks);
      }
      const oldChild = instance.subTree;
      const oldInnerChild = oldChild && getInnerChild$1(oldChild);
      if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild) && recursiveGetSubtree(instance).type !== Comment) {
        const leavingHooks = resolveTransitionHooks(
          oldInnerChild,
          rawProps,
          state,
          instance
        );
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in" && innerChild.type !== Comment) {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            if (!(instance.job.flags & 8)) {
              instance.update();
            }
            delete leavingHooks.afterLeave;
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(
              state,
              oldInnerChild
            );
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el[leaveCbKey] = () => {
              earlyRemove();
              el[leaveCbKey] = void 0;
              delete enterHooks.delayedLeave;
            };
            enterHooks.delayedLeave = delayedLeave;
          };
        }
      }
      return child;
    };
  }
};
function findNonCommentChild(children) {
  let child = children[0];
  if (children.length > 1) {
    for (const c of children) {
      if (c.type !== Comment) {
        child = c;
        break;
      }
    }
  }
  return child;
}
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance, postClone) {
  const {
    appear,
    mode,
    persisted = false,
    onBeforeEnter,
    onEnter,
    onAfterEnter,
    onEnterCancelled,
    onBeforeLeave,
    onLeave,
    onAfterLeave,
    onLeaveCancelled,
    onBeforeAppear,
    onAppear,
    onAfterAppear,
    onAppearCancelled
  } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook = (hook, args) => {
    hook && callWithAsyncErrorHandling(
      hook,
      instance,
      9,
      args
    );
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook(hook, args);
    if (isArray(hook)) {
      if (hook.every((hook2) => hook2.length <= 1)) done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el[leaveCbKey]) {
        el[leaveCbKey](
          true
          /* cancelled */
        );
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
        leavingVNode.el[leaveCbKey]();
      }
      callHook(hook, [el]);
    },
    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el[enterCbKey$1] = (cancelled) => {
        if (called) return;
        called = true;
        if (cancelled) {
          callHook(cancelHook, [el]);
        } else {
          callHook(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el[enterCbKey$1] = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el, done]);
      } else {
        done();
      }
    },
    leave(el, remove) {
      const key2 = String(vnode.key);
      if (el[enterCbKey$1]) {
        el[enterCbKey$1](
          true
          /* cancelled */
        );
      }
      if (state.isUnmounting) {
        return remove();
      }
      callHook(onBeforeLeave, [el]);
      let called = false;
      const done = el[leaveCbKey] = (cancelled) => {
        if (called) return;
        called = true;
        remove();
        if (cancelled) {
          callHook(onLeaveCancelled, [el]);
        } else {
          callHook(onAfterLeave, [el]);
        }
        el[leaveCbKey] = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      const hooks2 = resolveTransitionHooks(
        vnode2,
        props,
        state,
        instance,
        postClone
      );
      if (postClone) postClone(hooks2);
      return hooks2;
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getInnerChild$1(vnode) {
  if (!isKeepAlive(vnode)) {
    if (isTeleport(vnode.type) && vnode.children) {
      return findNonCommentChild(vnode.children);
    }
    return vnode;
  }
  const { shapeFlag, children } = vnode;
  if (children) {
    if (shapeFlag & 16) {
      return children[0];
    }
    if (shapeFlag & 32 && isFunction(children.default)) {
      return children.default();
    }
  }
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    vnode.transition = hooks;
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i = 0; i < children.length; i++) {
    let child = children[i];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
    if (child.type === Fragment) {
      if (child.patchFlag & 128) keyedFragmentCount++;
      ret = ret.concat(
        getTransitionRawChildren(child.children, keepComment, key)
      );
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i = 0; i < ret.length; i++) {
      ret[i].patchFlag = -2;
    }
  }
  return ret;
}

/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineComponent(options, extraOptions) {
  return isFunction(options) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))()
  ) : options;
}

function useId() {
  const i = getCurrentInstance();
  if (i) {
    return (i.appContext.config.idPrefix || "v") + "-" + i.ids[0] + i.ids[1]++;
  }
  return "";
}
function markAsyncBoundary(instance) {
  instance.ids = [instance.ids[0] + instance.ids[2]++ + "-", 0, 0];
}
function useTemplateRef(key) {
  const i = getCurrentInstance();
  const r = shallowRef(null);
  if (i) {
    const refs = i.refs === EMPTY_OBJ ? i.refs = {} : i.refs;
    {
      Object.defineProperty(refs, key, {
        enumerable: true,
        get: () => r.value,
        set: (val) => r.value = val
      });
    }
  }
  const ret = r;
  return ret;
}

function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray(rawRef)) {
    rawRef.forEach(
      (r, i) => setRef(
        r,
        oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef),
        parentSuspense,
        vnode,
        isUnmount
      )
    );
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  const rawSetupState = toRaw(setupState);
  const canSetSetupRef = setupState === EMPTY_OBJ ? () => false : (key) => {
    return hasOwn(rawSetupState, key);
  };
  if (oldRef != null && oldRef !== ref) {
    if (isString(oldRef)) {
      refs[oldRef] = null;
      if (canSetSetupRef(oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction(ref)) {
    callWithErrorHandling(ref, owner, 12, [value, refs]);
  } else {
    const _isString = isString(ref);
    const _isRef = isRef(ref);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? canSetSetupRef(ref) ? setupState[ref] : refs[ref] : ref.value;
          if (isUnmount) {
            isArray(existing) && remove(existing, refValue);
          } else {
            if (!isArray(existing)) {
              if (_isString) {
                refs[ref] = [refValue];
                if (canSetSetupRef(ref)) {
                  setupState[ref] = refs[ref];
                }
              } else {
                ref.value = [refValue];
                if (rawRef.k) refs[rawRef.k] = ref.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref] = value;
          if (canSetSetupRef(ref)) {
            setupState[ref] = value;
          }
        } else if (_isRef) {
          ref.value = value;
          if (rawRef.k) refs[rawRef.k] = value;
        } else ;
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    }
  }
}

let hasLoggedMismatchError = false;
const logMismatchError = () => {
  if (hasLoggedMismatchError) {
    return;
  }
  console.error("Hydration completed but contains mismatches.");
  hasLoggedMismatchError = true;
};
const isSVGContainer = (container) => container.namespaceURI.includes("svg") && container.tagName !== "foreignObject";
const isMathMLContainer = (container) => container.namespaceURI.includes("MathML");
const getContainerType = (container) => {
  if (container.nodeType !== 1) return void 0;
  if (isSVGContainer(container)) return "svg";
  if (isMathMLContainer(container)) return "mathml";
  return void 0;
};
const isComment = (node) => node.nodeType === 8;
function createHydrationFunctions(rendererInternals) {
  const {
    mt: mountComponent,
    p: patch,
    o: {
      patchProp,
      createText,
      nextSibling,
      parentNode,
      remove,
      insert,
      createComment
    }
  } = rendererInternals;
  const hydrate = (vnode, container) => {
    if (!container.hasChildNodes()) {
      (__VUE_PROD_HYDRATION_MISMATCH_DETAILS__) && warn$1(
        `Attempting to hydrate existing markup but container is empty. Performing full mount instead.`
      );
      patch(null, vnode, container);
      flushPostFlushCbs();
      container._vnode = vnode;
      return;
    }
    hydrateNode(container.firstChild, vnode, null, null, null);
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
    optimized = optimized || !!vnode.dynamicChildren;
    const isFragmentStart = isComment(node) && node.data === "[";
    const onMismatch = () => handleMismatch(
      node,
      vnode,
      parentComponent,
      parentSuspense,
      slotScopeIds,
      isFragmentStart
    );
    const { type, ref, shapeFlag, patchFlag } = vnode;
    let domType = node.nodeType;
    vnode.el = node;
    if (__VUE_PROD_DEVTOOLS__) {
      def(node, "__vnode", vnode, true);
      def(node, "__vueParentComponent", parentComponent, true);
    }
    if (patchFlag === -2) {
      optimized = false;
      vnode.dynamicChildren = null;
    }
    let nextNode = null;
    switch (type) {
      case Text:
        if (domType !== 3) {
          if (vnode.children === "") {
            insert(vnode.el = createText(""), parentNode(node), node);
            nextNode = node;
          } else {
            nextNode = onMismatch();
          }
        } else {
          if (node.data !== vnode.children) {
            (__VUE_PROD_HYDRATION_MISMATCH_DETAILS__) && warn$1(
              `Hydration text mismatch in`,
              node.parentNode,
              `
  - rendered on server: ${JSON.stringify(
                node.data
              )}
  - expected on client: ${JSON.stringify(vnode.children)}`
            );
            logMismatchError();
            node.data = vnode.children;
          }
          nextNode = nextSibling(node);
        }
        break;
      case Comment:
        if (isTemplateNode(node)) {
          nextNode = nextSibling(node);
          replaceNode(
            vnode.el = node.content.firstChild,
            node,
            parentComponent
          );
        } else if (domType !== 8 || isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = nextSibling(node);
        }
        break;
      case Static:
        if (isFragmentStart) {
          node = nextSibling(node);
          domType = node.nodeType;
        }
        if (domType === 1 || domType === 3) {
          nextNode = node;
          const needToAdoptContent = !vnode.children.length;
          for (let i = 0; i < vnode.staticCount; i++) {
            if (needToAdoptContent)
              vnode.children += nextNode.nodeType === 1 ? nextNode.outerHTML : nextNode.data;
            if (i === vnode.staticCount - 1) {
              vnode.anchor = nextNode;
            }
            nextNode = nextSibling(nextNode);
          }
          return isFragmentStart ? nextSibling(nextNode) : nextNode;
        } else {
          onMismatch();
        }
        break;
      case Fragment:
        if (!isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = hydrateFragment(
            node,
            vnode,
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
        }
        break;
      default:
        if (shapeFlag & 1) {
          if ((domType !== 1 || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) && !isTemplateNode(node)) {
            nextNode = onMismatch();
          } else {
            nextNode = hydrateElement(
              node,
              vnode,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
          }
        } else if (shapeFlag & 6) {
          vnode.slotScopeIds = slotScopeIds;
          const container = parentNode(node);
          if (isFragmentStart) {
            nextNode = locateClosingAnchor(node);
          } else if (isComment(node) && node.data === "teleport start") {
            nextNode = locateClosingAnchor(node, node.data, "teleport end");
          } else {
            nextNode = nextSibling(node);
          }
          mountComponent(
            vnode,
            container,
            null,
            parentComponent,
            parentSuspense,
            getContainerType(container),
            optimized
          );
          if (isAsyncWrapper(vnode)) {
            let subTree;
            if (isFragmentStart) {
              subTree = createVNode(Fragment);
              subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
            } else {
              subTree = node.nodeType === 3 ? createTextVNode("") : createVNode("div");
            }
            subTree.el = node;
            vnode.component.subTree = subTree;
          }
        } else if (shapeFlag & 64) {
          if (domType !== 8) {
            nextNode = onMismatch();
          } else {
            nextNode = vnode.type.hydrate(
              node,
              vnode,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized,
              rendererInternals,
              hydrateChildren
            );
          }
        } else if (shapeFlag & 128) {
          nextNode = vnode.type.hydrate(
            node,
            vnode,
            parentComponent,
            parentSuspense,
            getContainerType(parentNode(node)),
            slotScopeIds,
            optimized,
            rendererInternals,
            hydrateNode
          );
        } else if (__VUE_PROD_HYDRATION_MISMATCH_DETAILS__) {
          warn$1("Invalid HostVNode type:", type, `(${typeof type})`);
        }
    }
    if (ref != null) {
      setRef(ref, null, parentSuspense, vnode);
    }
    return nextNode;
  };
  const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!vnode.dynamicChildren;
    const { type, props, patchFlag, shapeFlag, dirs, transition } = vnode;
    const forcePatch = type === "input" || type === "option";
    if (forcePatch || patchFlag !== -1) {
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      let needCallTransitionHooks = false;
      if (isTemplateNode(el)) {
        needCallTransitionHooks = needTransition(parentSuspense, transition) && parentComponent && parentComponent.vnode.props && parentComponent.vnode.props.appear;
        const content = el.content.firstChild;
        if (needCallTransitionHooks) {
          transition.beforeEnter(content);
        }
        replaceNode(content, el, parentComponent);
        vnode.el = el = content;
      }
      if (shapeFlag & 16 && // skip if element has innerHTML / textContent
      !(props && (props.innerHTML || props.textContent))) {
        let next = hydrateChildren(
          el.firstChild,
          vnode,
          el,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
        let hasWarned = false;
        while (next) {
          if (!isMismatchAllowed(el, 1 /* CHILDREN */)) {
            if ((__VUE_PROD_HYDRATION_MISMATCH_DETAILS__) && !hasWarned) {
              warn$1(
                `Hydration children mismatch on`,
                el,
                `
Server rendered element contains more child nodes than client vdom.`
              );
              hasWarned = true;
            }
            logMismatchError();
          }
          const cur = next;
          next = next.nextSibling;
          remove(cur);
        }
      } else if (shapeFlag & 8) {
        let clientText = vnode.children;
        if (clientText[0] === "\n" && (el.tagName === "PRE" || el.tagName === "TEXTAREA")) {
          clientText = clientText.slice(1);
        }
        if (el.textContent !== clientText) {
          if (!isMismatchAllowed(el, 0 /* TEXT */)) {
            (__VUE_PROD_HYDRATION_MISMATCH_DETAILS__) && warn$1(
              `Hydration text content mismatch on`,
              el,
              `
  - rendered on server: ${el.textContent}
  - expected on client: ${vnode.children}`
            );
            logMismatchError();
          }
          el.textContent = vnode.children;
        }
      }
      if (props) {
        if (__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ || forcePatch || !optimized || patchFlag & (16 | 32)) {
          const isCustomElement = el.tagName.includes("-");
          for (const key in props) {
            if ((__VUE_PROD_HYDRATION_MISMATCH_DETAILS__) && // #11189 skip if this node has directives that have created hooks
            // as it could have mutated the DOM in any possible way
            !(dirs && dirs.some((d) => d.dir.created)) && propHasMismatch(el, key, props[key], vnode, parentComponent)) {
              logMismatchError();
            }
            if (forcePatch && (key.endsWith("value") || key === "indeterminate") || isOn(key) && !isReservedProp(key) || // force hydrate v-bind with .prop modifiers
            key[0] === "." || isCustomElement) {
              patchProp(el, key, null, props[key], void 0, parentComponent);
            }
          }
        } else if (props.onClick) {
          patchProp(
            el,
            "onClick",
            null,
            props.onClick,
            void 0,
            parentComponent
          );
        } else if (patchFlag & 4 && isReactive(props.style)) {
          for (const key in props.style) props.style[key];
        }
      }
      let vnodeHooks;
      if (vnodeHooks = props && props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHooks, parentComponent, vnode);
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      if ((vnodeHooks = props && props.onVnodeMounted) || dirs || needCallTransitionHooks) {
        queueEffectWithSuspense(() => {
          vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
          needCallTransitionHooks && transition.enter(el);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
    }
    return el.nextSibling;
  };
  const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!parentVNode.dynamicChildren;
    const children = parentVNode.children;
    const l = children.length;
    let hasWarned = false;
    for (let i = 0; i < l; i++) {
      const vnode = optimized ? children[i] : children[i] = normalizeVNode(children[i]);
      const isText = vnode.type === Text;
      if (node) {
        if (isText && !optimized) {
          if (i + 1 < l && normalizeVNode(children[i + 1]).type === Text) {
            insert(
              createText(
                node.data.slice(vnode.children.length)
              ),
              container,
              nextSibling(node)
            );
            node.data = vnode.children;
          }
        }
        node = hydrateNode(
          node,
          vnode,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      } else if (isText && !vnode.children) {
        insert(vnode.el = createText(""), container);
      } else {
        if (!isMismatchAllowed(container, 1 /* CHILDREN */)) {
          if ((__VUE_PROD_HYDRATION_MISMATCH_DETAILS__) && !hasWarned) {
            warn$1(
              `Hydration children mismatch on`,
              container,
              `
Server rendered element contains fewer child nodes than client vdom.`
            );
            hasWarned = true;
          }
          logMismatchError();
        }
        patch(
          null,
          vnode,
          container,
          null,
          parentComponent,
          parentSuspense,
          getContainerType(container),
          slotScopeIds
        );
      }
    }
    return node;
  };
  const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    const { slotScopeIds: fragmentSlotScopeIds } = vnode;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    const container = parentNode(node);
    const next = hydrateChildren(
      nextSibling(node),
      vnode,
      container,
      parentComponent,
      parentSuspense,
      slotScopeIds,
      optimized
    );
    if (next && isComment(next) && next.data === "]") {
      return nextSibling(vnode.anchor = next);
    } else {
      logMismatchError();
      insert(vnode.anchor = createComment(`]`), container, next);
      return next;
    }
  };
  const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {
    if (!isMismatchAllowed(node.parentElement, 1 /* CHILDREN */)) {
      (__VUE_PROD_HYDRATION_MISMATCH_DETAILS__) && warn$1(
        `Hydration node mismatch:
- rendered on server:`,
        node,
        node.nodeType === 3 ? `(text)` : isComment(node) && node.data === "[" ? `(start of fragment)` : ``,
        `
- expected on client:`,
        vnode.type
      );
      logMismatchError();
    }
    vnode.el = null;
    if (isFragment) {
      const end = locateClosingAnchor(node);
      while (true) {
        const next2 = nextSibling(node);
        if (next2 && next2 !== end) {
          remove(next2);
        } else {
          break;
        }
      }
    }
    const next = nextSibling(node);
    const container = parentNode(node);
    remove(node);
    patch(
      null,
      vnode,
      container,
      next,
      parentComponent,
      parentSuspense,
      getContainerType(container),
      slotScopeIds
    );
    return next;
  };
  const locateClosingAnchor = (node, open = "[", close = "]") => {
    let match = 0;
    while (node) {
      node = nextSibling(node);
      if (node && isComment(node)) {
        if (node.data === open) match++;
        if (node.data === close) {
          if (match === 0) {
            return nextSibling(node);
          } else {
            match--;
          }
        }
      }
    }
    return node;
  };
  const replaceNode = (newNode, oldNode, parentComponent) => {
    const parentNode2 = oldNode.parentNode;
    if (parentNode2) {
      parentNode2.replaceChild(newNode, oldNode);
    }
    let parent = parentComponent;
    while (parent) {
      if (parent.vnode.el === oldNode) {
        parent.vnode.el = parent.subTree.el = newNode;
      }
      parent = parent.parent;
    }
  };
  const isTemplateNode = (node) => {
    return node.nodeType === 1 && node.tagName === "TEMPLATE";
  };
  return [hydrate, hydrateNode];
}
function propHasMismatch(el, key, clientValue, vnode, instance) {
  let mismatchType;
  let mismatchKey;
  let actual;
  let expected;
  if (key === "class") {
    actual = el.getAttribute("class");
    expected = normalizeClass(clientValue);
    if (!isSetEqual(toClassSet(actual || ""), toClassSet(expected))) {
      mismatchType = 2 /* CLASS */;
      mismatchKey = `class`;
    }
  } else if (key === "style") {
    actual = el.getAttribute("style") || "";
    expected = isString(clientValue) ? clientValue : stringifyStyle(normalizeStyle(clientValue));
    const actualMap = toStyleMap(actual);
    const expectedMap = toStyleMap(expected);
    if (vnode.dirs) {
      for (const { dir, value } of vnode.dirs) {
        if (dir.name === "show" && !value) {
          expectedMap.set("display", "none");
        }
      }
    }
    if (instance) {
      resolveCssVars(instance, vnode, expectedMap);
    }
    if (!isMapEqual(actualMap, expectedMap)) {
      mismatchType = 3 /* STYLE */;
      mismatchKey = "style";
    }
  } else if (el instanceof SVGElement && isKnownSvgAttr(key) || el instanceof HTMLElement && (isBooleanAttr(key) || isKnownHtmlAttr(key))) {
    if (isBooleanAttr(key)) {
      actual = el.hasAttribute(key);
      expected = includeBooleanAttr(clientValue);
    } else if (clientValue == null) {
      actual = el.hasAttribute(key);
      expected = false;
    } else {
      if (el.hasAttribute(key)) {
        actual = el.getAttribute(key);
      } else if (key === "value" && el.tagName === "TEXTAREA") {
        actual = el.value;
      } else {
        actual = false;
      }
      expected = isRenderableAttrValue(clientValue) ? String(clientValue) : false;
    }
    if (actual !== expected) {
      mismatchType = 4 /* ATTRIBUTE */;
      mismatchKey = key;
    }
  }
  if (mismatchType != null && !isMismatchAllowed(el, mismatchType)) {
    const format = (v) => v === false ? `(not rendered)` : `${mismatchKey}="${v}"`;
    const preSegment = `Hydration ${MismatchTypeString[mismatchType]} mismatch on`;
    const postSegment = `
  - rendered on server: ${format(actual)}
  - expected on client: ${format(expected)}
  Note: this mismatch is check-only. The DOM will not be rectified in production due to performance overhead.
  You should fix the source of the mismatch.`;
    {
      warn$1(preSegment, el, postSegment);
    }
    return true;
  }
  return false;
}
function toClassSet(str) {
  return new Set(str.trim().split(/\s+/));
}
function isSetEqual(a, b) {
  if (a.size !== b.size) {
    return false;
  }
  for (const s of a) {
    if (!b.has(s)) {
      return false;
    }
  }
  return true;
}
function toStyleMap(str) {
  const styleMap = /* @__PURE__ */ new Map();
  for (const item of str.split(";")) {
    let [key, value] = item.split(":");
    key = key.trim();
    value = value && value.trim();
    if (key && value) {
      styleMap.set(key, value);
    }
  }
  return styleMap;
}
function isMapEqual(a, b) {
  if (a.size !== b.size) {
    return false;
  }
  for (const [key, value] of a) {
    if (value !== b.get(key)) {
      return false;
    }
  }
  return true;
}
function resolveCssVars(instance, vnode, expectedMap) {
  const root = instance.subTree;
  if (instance.getCssVars && (vnode === root || root && root.type === Fragment && root.children.includes(vnode))) {
    const cssVars = instance.getCssVars();
    for (const key in cssVars) {
      expectedMap.set(
        `--${getEscapedCssVarName(key, false)}`,
        String(cssVars[key])
      );
    }
  }
  if (vnode === root && instance.parent) {
    resolveCssVars(instance.parent, instance.vnode, expectedMap);
  }
}
const allowMismatchAttr = "data-allow-mismatch";
const MismatchTypeString = {
  [0 /* TEXT */]: "text",
  [1 /* CHILDREN */]: "children",
  [2 /* CLASS */]: "class",
  [3 /* STYLE */]: "style",
  [4 /* ATTRIBUTE */]: "attribute"
};
function isMismatchAllowed(el, allowedType) {
  if (allowedType === 0 /* TEXT */ || allowedType === 1 /* CHILDREN */) {
    while (el && !el.hasAttribute(allowMismatchAttr)) {
      el = el.parentElement;
    }
  }
  const allowedAttr = el && el.getAttribute(allowMismatchAttr);
  if (allowedAttr == null) {
    return false;
  } else if (allowedAttr === "") {
    return true;
  } else {
    const list = allowedAttr.split(",");
    if (allowedType === 0 /* TEXT */ && list.includes("children")) {
      return true;
    }
    return allowedAttr.split(",").includes(MismatchTypeString[allowedType]);
  }
}

const hydrateOnIdle = (timeout = 1e4) => (hydrate) => {
  const id = requestIdleCallback(hydrate, { timeout });
  return () => cancelIdleCallback(id);
};
function elementIsVisibleInViewport(el) {
  const { top, left, bottom, right } = el.getBoundingClientRect();
  const { innerHeight, innerWidth } = window;
  return (top > 0 && top < innerHeight || bottom > 0 && bottom < innerHeight) && (left > 0 && left < innerWidth || right > 0 && right < innerWidth);
}
const hydrateOnVisible = (opts) => (hydrate, forEach) => {
  const ob = new IntersectionObserver((entries) => {
    for (const e of entries) {
      if (!e.isIntersecting) continue;
      ob.disconnect();
      hydrate();
      break;
    }
  }, opts);
  forEach((el) => {
    if (!(el instanceof Element)) return;
    if (elementIsVisibleInViewport(el)) {
      hydrate();
      ob.disconnect();
      return false;
    }
    ob.observe(el);
  });
  return () => ob.disconnect();
};
const hydrateOnMediaQuery = (query) => (hydrate) => {
  if (query) {
    const mql = matchMedia(query);
    if (mql.matches) {
      hydrate();
    } else {
      mql.addEventListener("change", hydrate, { once: true });
      return () => mql.removeEventListener("change", hydrate);
    }
  }
};
const hydrateOnInteraction = (interactions = []) => (hydrate, forEach) => {
  if (isString(interactions)) interactions = [interactions];
  let hasHydrated = false;
  const doHydrate = (e) => {
    if (!hasHydrated) {
      hasHydrated = true;
      teardown();
      hydrate();
      e.target.dispatchEvent(new e.constructor(e.type, e));
    }
  };
  const teardown = () => {
    forEach((el) => {
      for (const i of interactions) {
        el.removeEventListener(i, doHydrate);
      }
    });
  };
  forEach((el) => {
    for (const i of interactions) {
      el.addEventListener(i, doHydrate, { once: true });
    }
  });
  return teardown;
};
function forEachElement(node, cb) {
  if (isComment(node) && node.data === "[") {
    let depth = 1;
    let next = node.nextSibling;
    while (next) {
      if (next.nodeType === 1) {
        const result = cb(next);
        if (result === false) {
          break;
        }
      } else if (isComment(next)) {
        if (next.data === "]") {
          if (--depth === 0) break;
        } else if (next.data === "[") {
          depth++;
        }
      }
      next = next.nextSibling;
    }
  } else {
    cb(node);
  }
}

const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineAsyncComponent(source) {
  if (isFunction(source)) {
    source = { loader: source };
  }
  const {
    loader,
    loadingComponent,
    errorComponent,
    delay = 200,
    hydrate: hydrateStrategy,
    timeout,
    // undefined = never times out
    suspensible = true,
    onError: userOnError
  } = source;
  let pendingRequest = null;
  let resolvedComp;
  let retries = 0;
  const retry = () => {
    retries++;
    pendingRequest = null;
    return load();
  };
  const load = () => {
    let thisRequest;
    return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {
      err = err instanceof Error ? err : new Error(String(err));
      if (userOnError) {
        return new Promise((resolve, reject) => {
          const userRetry = () => resolve(retry());
          const userFail = () => reject(err);
          userOnError(err, userRetry, userFail, retries + 1);
        });
      } else {
        throw err;
      }
    }).then((comp) => {
      if (thisRequest !== pendingRequest && pendingRequest) {
        return pendingRequest;
      }
      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
        comp = comp.default;
      }
      resolvedComp = comp;
      return comp;
    }));
  };
  return defineComponent({
    name: "AsyncComponentWrapper",
    __asyncLoader: load,
    __asyncHydrate(el, instance, hydrate) {
      const doHydrate = hydrateStrategy ? () => {
        const teardown = hydrateStrategy(
          hydrate,
          (cb) => forEachElement(el, cb)
        );
        if (teardown) {
          (instance.bum || (instance.bum = [])).push(teardown);
        }
      } : hydrate;
      if (resolvedComp) {
        doHydrate();
      } else {
        load().then(() => !instance.isUnmounted && doHydrate());
      }
    },
    get __asyncResolved() {
      return resolvedComp;
    },
    setup() {
      const instance = currentInstance;
      markAsyncBoundary(instance);
      if (resolvedComp) {
        return () => createInnerComp(resolvedComp, instance);
      }
      const onError = (err) => {
        pendingRequest = null;
        handleError(
          err,
          instance,
          13,
          !errorComponent
        );
      };
      if (suspensible && instance.suspense || isInSSRComponentSetup) {
        return load().then((comp) => {
          return () => createInnerComp(comp, instance);
        }).catch((err) => {
          onError(err);
          return () => errorComponent ? createVNode(errorComponent, {
            error: err
          }) : null;
        });
      }
      const loaded = ref(false);
      const error = ref();
      const delayed = ref(!!delay);
      if (delay) {
        setTimeout(() => {
          delayed.value = false;
        }, delay);
      }
      if (timeout != null) {
        setTimeout(() => {
          if (!loaded.value && !error.value) {
            const err = new Error(
              `Async component timed out after ${timeout}ms.`
            );
            onError(err);
            error.value = err;
          }
        }, timeout);
      }
      load().then(() => {
        loaded.value = true;
        if (instance.parent && isKeepAlive(instance.parent.vnode)) {
          instance.parent.update();
        }
      }).catch((err) => {
        onError(err);
        error.value = err;
      });
      return () => {
        if (loaded.value && resolvedComp) {
          return createInnerComp(resolvedComp, instance);
        } else if (error.value && errorComponent) {
          return createVNode(errorComponent, {
            error: error.value
          });
        } else if (loadingComponent && !delayed.value) {
          return createVNode(loadingComponent);
        }
      };
    }
  });
}
function createInnerComp(comp, parent) {
  const { ref: ref2, props, children, ce } = parent.vnode;
  const vnode = createVNode(comp, props, children);
  vnode.ref = ref2;
  vnode.ce = ce;
  delete parent.vnode.ce;
  return vnode;
}

const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
const KeepAliveImpl = {
  name: `KeepAlive`,
  // Marker for special handling inside the renderer. We are not using a ===
  // check directly on KeepAlive in the renderer, because importing it directly
  // would prevent it from being tree-shaken.
  __isKeepAlive: true,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const sharedContext = instance.ctx;
    if (!sharedContext.renderer) {
      return () => {
        const children = slots.default && slots.default();
        return children && children.length === 1 ? children[0] : children;
      };
    }
    const cache = /* @__PURE__ */ new Map();
    const keys = /* @__PURE__ */ new Set();
    let current = null;
    if (__VUE_PROD_DEVTOOLS__) {
      instance.__v_cache = cache;
    }
    const parentSuspense = instance.suspense;
    const {
      renderer: {
        p: patch,
        m: move,
        um: _unmount,
        o: { createElement }
      }
    } = sharedContext;
    const storageContainer = createElement("div");
    sharedContext.activate = (vnode, container, anchor, namespace, optimized) => {
      const instance2 = vnode.component;
      move(vnode, container, anchor, 0, parentSuspense);
      patch(
        instance2.vnode,
        vnode,
        container,
        anchor,
        instance2,
        parentSuspense,
        namespace,
        vnode.slotScopeIds,
        optimized
      );
      queuePostRenderEffect(() => {
        instance2.isDeactivated = false;
        if (instance2.a) {
          invokeArrayFns(instance2.a);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
      }, parentSuspense);
      if (__VUE_PROD_DEVTOOLS__) {
        devtoolsComponentAdded(instance2);
      }
    };
    sharedContext.deactivate = (vnode) => {
      const instance2 = vnode.component;
      invalidateMount(instance2.m);
      invalidateMount(instance2.a);
      move(vnode, storageContainer, null, 1, parentSuspense);
      queuePostRenderEffect(() => {
        if (instance2.da) {
          invokeArrayFns(instance2.da);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
        instance2.isDeactivated = true;
      }, parentSuspense);
      if (__VUE_PROD_DEVTOOLS__) {
        devtoolsComponentAdded(instance2);
      }
    };
    function unmount(vnode) {
      resetShapeFlag(vnode);
      _unmount(vnode, instance, parentSuspense, true);
    }
    function pruneCache(filter) {
      cache.forEach((vnode, key) => {
        const name = getComponentName(vnode.type);
        if (name && !filter(name)) {
          pruneCacheEntry(key);
        }
      });
    }
    function pruneCacheEntry(key) {
      const cached = cache.get(key);
      if (cached && (!current || !isSameVNodeType(cached, current))) {
        unmount(cached);
      } else if (current) {
        resetShapeFlag(current);
      }
      cache.delete(key);
      keys.delete(key);
    }
    watch(
      () => [props.include, props.exclude],
      ([include, exclude]) => {
        include && pruneCache((name) => matches(include, name));
        exclude && pruneCache((name) => !matches(exclude, name));
      },
      // prune post-render after `current` has been updated
      { flush: "post", deep: true }
    );
    let pendingCacheKey = null;
    const cacheSubtree = () => {
      if (pendingCacheKey != null) {
        if (isSuspense(instance.subTree.type)) {
          queuePostRenderEffect(() => {
            cache.set(pendingCacheKey, getInnerChild(instance.subTree));
          }, instance.subTree.suspense);
        } else {
          cache.set(pendingCacheKey, getInnerChild(instance.subTree));
        }
      }
    };
    onMounted(cacheSubtree);
    onUpdated(cacheSubtree);
    onBeforeUnmount(() => {
      cache.forEach((cached) => {
        const { subTree, suspense } = instance;
        const vnode = getInnerChild(subTree);
        if (cached.type === vnode.type && cached.key === vnode.key) {
          resetShapeFlag(vnode);
          const da = vnode.component.da;
          da && queuePostRenderEffect(da, suspense);
          return;
        }
        unmount(cached);
      });
    });
    return () => {
      pendingCacheKey = null;
      if (!slots.default) {
        return current = null;
      }
      const children = slots.default();
      const rawVNode = children[0];
      if (children.length > 1) {
        current = null;
        return children;
      } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
        current = null;
        return rawVNode;
      }
      let vnode = getInnerChild(rawVNode);
      if (vnode.type === Comment) {
        current = null;
        return vnode;
      }
      const comp = vnode.type;
      const name = getComponentName(
        isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp
      );
      const { include, exclude, max } = props;
      if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
        vnode.shapeFlag &= ~256;
        current = vnode;
        return rawVNode;
      }
      const key = vnode.key == null ? comp : vnode.key;
      const cachedVNode = cache.get(key);
      if (vnode.el) {
        vnode = cloneVNode(vnode);
        if (rawVNode.shapeFlag & 128) {
          rawVNode.ssContent = vnode;
        }
      }
      pendingCacheKey = key;
      if (cachedVNode) {
        vnode.el = cachedVNode.el;
        vnode.component = cachedVNode.component;
        if (vnode.transition) {
          setTransitionHooks(vnode, vnode.transition);
        }
        vnode.shapeFlag |= 512;
        keys.delete(key);
        keys.add(key);
      } else {
        keys.add(key);
        if (max && keys.size > parseInt(max, 10)) {
          pruneCacheEntry(keys.values().next().value);
        }
      }
      vnode.shapeFlag |= 256;
      current = vnode;
      return isSuspense(rawVNode.type) ? rawVNode : vnode;
    };
  }
};
const KeepAlive = KeepAliveImpl;
function matches(pattern, name) {
  if (isArray(pattern)) {
    return pattern.some((p) => matches(p, name));
  } else if (isString(pattern)) {
    return pattern.split(",").includes(name);
  } else if (isRegExp(pattern)) {
    pattern.lastIndex = 0;
    return pattern.test(name);
  }
  return false;
}
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function resetShapeFlag(vnode) {
  vnode.shapeFlag &= ~256;
  vnode.shapeFlag &= ~512;
}
function getInnerChild(vnode) {
  return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
}

function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      pauseTracking();
      const reset = setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      reset();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => {
  if (!isInSSRComponentSetup || lifecycle === "sp") {
    injectHook(lifecycle, (...args) => hook(...args), target);
  }
};
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook(
  "bu"
);
const onUpdated = createHook("u");
const onBeforeUnmount = createHook(
  "bum"
);
const onUnmounted = createHook("um");
const onServerPrefetch = createHook(
  "sp"
);
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}

const COMPONENTS = "components";
const DIRECTIVES = "directives";
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveDynamicComponent(component) {
  if (isString(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveDirective(name) {
  return resolveAsset(DIRECTIVES, name);
}
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    if (type === COMPONENTS) {
      const selfName = getComponentName(
        Component,
        false
      );
      if (selfName && (selfName === name || selfName === camelize$1(name) || selfName === capitalize$1(camelize$1(name)))) {
        return Component;
      }
    }
    const res = (
      // local registration
      // check instance[type] first which is resolved for options API
      resolve(instance[type] || Component[type], name) || // global registration
      resolve(instance.appContext[type], name)
    );
    if (!res && maybeSelfReference) {
      return Component;
    }
    return res;
  }
}
function resolve(registry, name) {
  return registry && (registry[name] || registry[camelize$1(name)] || registry[capitalize$1(camelize$1(name))]);
}

function renderList(source, renderItem, cache, index) {
  let ret;
  const cached = cache && cache[index];
  const sourceIsArray = isArray(source);
  if (sourceIsArray || isString(source)) {
    const sourceIsReactiveArray = sourceIsArray && isReactive(source);
    let needsWrap = false;
    if (sourceIsReactiveArray) {
      needsWrap = !isShallow(source);
      source = shallowReadArray(source);
    }
    ret = new Array(source.length);
    for (let i = 0, l = source.length; i < l; i++) {
      ret[i] = renderItem(
        needsWrap ? toReactive(source[i]) : source[i],
        i,
        void 0,
        cached && cached[i]
      );
    }
  } else if (typeof source === "number") {
    ret = new Array(source);
    for (let i = 0; i < source; i++) {
      ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
    }
  } else if (isObject$1(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(
        source,
        (item, i) => renderItem(item, i, void 0, cached && cached[i])
      );
    } else {
      const keys = Object.keys(source);
      ret = new Array(keys.length);
      for (let i = 0, l = keys.length; i < l; i++) {
        const key = keys[i];
        ret[i] = renderItem(source[key], key, i, cached && cached[i]);
      }
    }
  } else {
    ret = [];
  }
  if (cache) {
    cache[index] = ret;
  }
  return ret;
}

function createSlots(slots, dynamicSlots) {
  for (let i = 0; i < dynamicSlots.length; i++) {
    const slot = dynamicSlots[i];
    if (isArray(slot)) {
      for (let j = 0; j < slot.length; j++) {
        slots[slot[j].name] = slot[j].fn;
      }
    } else if (slot) {
      slots[slot.name] = slot.key ? (...args) => {
        const res = slot.fn(...args);
        if (res) res.key = slot.key;
        return res;
      } : slot.fn;
    }
  }
  return slots;
}

function renderSlot(slots, name, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.ce || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.ce) {
    if (name !== "default") props.name = name;
    return openBlock(), createBlock(
      Fragment,
      null,
      [createVNode("slot", props, fallback && fallback())],
      64
    );
  }
  let slot = slots[name];
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const rendered = createBlock(
    Fragment,
    {
      key: (props.key || // slot content array of a dynamic conditional slot may have a branch
      // key attached in the `createSlots` helper, respect that
      validSlotContent && validSlotContent.key || `_${name}`) + // #7256 force differentiate fallback content from actual content
      (!validSlotContent && fallback ? "_fb" : "")
    },
    validSlotContent || (fallback ? fallback() : []),
    validSlotContent && slots._ === 1 ? 64 : -2
  );
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode(child)) return true;
    if (child.type === Comment) return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}

function toHandlers(obj, preserveCaseIfNecessary) {
  const ret = {};
  for (const key in obj) {
    ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : toHandlerKey$1(key)] = obj[key];
  }
  return ret;
}

const getPublicInstance = (i) => {
  if (!i) return null;
  if (isStatefulComponent(i)) return getComponentPublicInstance(i);
  return getPublicInstance(i.parent);
};
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) => i.props,
    $attrs: (i) => i.attrs,
    $slots: (i) => i.slots,
    $refs: (i) => i.refs,
    $parent: (i) => getPublicInstance(i.parent),
    $root: (i) => getPublicInstance(i.root),
    $host: (i) => i.ce,
    $emit: (i) => i.emit,
    $options: (i) => __VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type,
    $forceUpdate: (i) => i.f || (i.f = () => {
      queueJob(i.update);
    }),
    $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: (i) => __VUE_OPTIONS_API__ ? instanceWatch.bind(i) : NOOP
  })
);
const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    if (key === "__v_skip") {
      return true;
    }
    const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1 /* SETUP */:
            return setupState[key];
          case 2 /* DATA */:
            return data[key];
          case 4 /* CONTEXT */:
            return ctx[key];
          case 3 /* PROPS */:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1 /* SETUP */;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        accessCache[key] = 2 /* DATA */;
        return data[key];
      } else if (
        // only cache other properties when instance has declared (thus stable)
        // props
        (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
      ) {
        accessCache[key] = 3 /* PROPS */;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4 /* CONTEXT */;
        return ctx[key];
      } else if (!__VUE_OPTIONS_API__ || shouldCacheAccess) {
        accessCache[key] = 0 /* OTHER */;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance.attrs, "get", "");
      }
      return publicGetter(instance);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
      accessCache[key] = 4 /* CONTEXT */;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else ;
  },
  set({ _: instance }, key, value) {
    const { data, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
      data[key] = value;
      return true;
    } else if (hasOwn(instance.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      return false;
    } else {
      {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({
    _: { data, setupState, accessCache, ctx, appContext, propsOptions }
  }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
const RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ extend({}, PublicInstanceProxyHandlers, {
  get(target, key) {
    if (key === Symbol.unscopables) {
      return;
    }
    return PublicInstanceProxyHandlers.get(target, key, target);
  },
  has(_, key) {
    const has = key[0] !== "_" && !isGloballyAllowed(key);
    return has;
  }
});
function defineProps() {
  return null;
}
function defineEmits() {
  return null;
}
function defineExpose(exposed) {
}
function defineOptions(options) {
}
function defineSlots() {
  return null;
}
function defineModel() {
}
function withDefaults(props, defaults) {
  return null;
}
function useSlots() {
  return getContext().slots;
}
function useAttrs() {
  return getContext().attrs;
}
function getContext() {
  const i = getCurrentInstance();
  return i.setupContext || (i.setupContext = createSetupContext(i));
}
function normalizePropsOrEmits(props) {
  return isArray(props) ? props.reduce(
    (normalized, p) => (normalized[p] = null, normalized),
    {}
  ) : props;
}
function mergeDefaults(raw, defaults) {
  const props = normalizePropsOrEmits(raw);
  for (const key in defaults) {
    if (key.startsWith("__skip")) continue;
    let opt = props[key];
    if (opt) {
      if (isArray(opt) || isFunction(opt)) {
        opt = props[key] = { type: opt, default: defaults[key] };
      } else {
        opt.default = defaults[key];
      }
    } else if (opt === null) {
      opt = props[key] = { default: defaults[key] };
    } else ;
    if (opt && defaults[`__skip_${key}`]) {
      opt.skipFactory = true;
    }
  }
  return props;
}
function mergeModels(a, b) {
  if (!a || !b) return a || b;
  if (isArray(a) && isArray(b)) return a.concat(b);
  return extend({}, normalizePropsOrEmits(a), normalizePropsOrEmits(b));
}
function createPropsRestProxy(props, excludedKeys) {
  const ret = {};
  for (const key in props) {
    if (!excludedKeys.includes(key)) {
      Object.defineProperty(ret, key, {
        enumerable: true,
        get: () => props[key]
      });
    }
  }
  return ret;
}
function withAsyncContext(getAwaitable) {
  const ctx = getCurrentInstance();
  let awaitable = getAwaitable();
  unsetCurrentInstance();
  if (isPromise(awaitable)) {
    awaitable = awaitable.catch((e) => {
      setCurrentInstance(ctx);
      throw e;
    });
  }
  return [awaitable, () => setCurrentInstance(ctx)];
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook$1(options.beforeCreate, instance, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction(methodHandler)) {
        {
          ctx[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data = dataOptions.call(publicThis, publicThis);
    if (!isObject$1(data)) ; else {
      instance.data = reactive(data);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get = isFunction(opt) ? opt.bind(publicThis, publicThis) : isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set = !isFunction(opt) && isFunction(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c = computed({
        get,
        set
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c.value,
        set: (v) => c.value = v
      });
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook$1(created, instance, "c");
  }
  function registerLifecycleHook(register, hook) {
    if (isArray(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render && instance.render === NOOP) {
    instance.render = render;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components) instance.components = components;
  if (directives) instance.directives = directives;
  if (serverPrefetch) {
    markAsyncBoundary(instance);
  }
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
  if (isArray(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject$1(opt)) {
      if ("default" in opt) {
        injected = inject(
          opt.from || key,
          opt.default,
          true
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => injected.value,
        set: (v) => injected.value = v
      });
    } else {
      ctx[key] = injected;
    }
  }
}
function callHook$1(hook, instance, type) {
  callWithAsyncErrorHandling(
    isArray(hook) ? hook.map((h) => h.bind(instance.proxy)) : hook.bind(instance.proxy),
    instance,
    type
  );
}
function createWatcher(raw, ctx, publicThis, key) {
  let getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString(raw)) {
    const handler = ctx[raw];
    if (isFunction(handler)) {
      {
        watch(getter, handler);
      }
    }
  } else if (isFunction(raw)) {
    {
      watch(getter, raw.bind(publicThis));
    }
  } else if (isObject$1(raw)) {
    if (isArray(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler = isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction(handler)) {
        watch(getter, handler, raw);
      }
    }
  } else ;
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache,
    config: { optionMergeStrategies }
  } = instance.appContext;
  const cached = cache.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(
        (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
      );
    }
    mergeOptions(resolved, base, optionMergeStrategies);
  }
  if (isObject$1(base)) {
    cache.set(base, resolved);
  }
  return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(
      (m) => mergeOptions(to, m, strats, true)
    );
  }
  for (const key in from) {
    if (asMixin && key === "expose") ; else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return (extend)(
      isFunction(to) ? to.call(this, this) : to,
      isFunction(from) ? from.call(this, this) : from
    );
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? extend(/* @__PURE__ */ Object.create(null), to, from) : from;
}
function mergeEmitsOrPropsOptions(to, from) {
  if (to) {
    if (isArray(to) && isArray(from)) {
      return [.../* @__PURE__ */ new Set([...to, ...from])];
    }
    return extend(
      /* @__PURE__ */ Object.create(null),
      normalizePropsOrEmits(to),
      normalizePropsOrEmits(from != null ? from : {})
    );
  } else {
    return from;
  }
}
function mergeWatchOptions(to, from) {
  if (!to) return from;
  if (!from) return to;
  const merged = extend(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }
  return merged;
}

function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render, hydrate) {
  return function createApp(rootComponent, rootProps = null) {
    if (!isFunction(rootComponent)) {
      rootComponent = extend({}, rootComponent);
    }
    if (rootProps != null && !isObject$1(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new WeakSet();
    const pluginCleanupFns = [];
    let isMounted = false;
    const app = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version: version$1,
      get config() {
        return context.config;
      },
      set config(v) {
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin)) ; else if (plugin && isFunction(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app, ...options);
        } else if (isFunction(plugin)) {
          installedPlugins.add(plugin);
          plugin(app, ...options);
        } else ;
        return app;
      },
      mixin(mixin) {
        if (__VUE_OPTIONS_API__) {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          }
        }
        return app;
      },
      component(name, component) {
        if (!component) {
          return context.components[name];
        }
        context.components[name] = component;
        return app;
      },
      directive(name, directive) {
        if (!directive) {
          return context.directives[name];
        }
        context.directives[name] = directive;
        return app;
      },
      mount(rootContainer, isHydrate, namespace) {
        if (!isMounted) {
          const vnode = app._ceVNode || createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (namespace === true) {
            namespace = "svg";
          } else if (namespace === false) {
            namespace = void 0;
          }
          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render(vnode, rootContainer, namespace);
          }
          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;
          if (__VUE_PROD_DEVTOOLS__) {
            app._instance = vnode.component;
            devtoolsInitApp(app, version$1);
          }
          return getComponentPublicInstance(vnode.component);
        }
      },
      onUnmount(cleanupFn) {
        pluginCleanupFns.push(cleanupFn);
      },
      unmount() {
        if (isMounted) {
          callWithAsyncErrorHandling(
            pluginCleanupFns,
            app._instance,
            16
          );
          render(null, app._container);
          if (__VUE_PROD_DEVTOOLS__) {
            app._instance = null;
            devtoolsUnmountApp(app);
          }
          delete app._container.__vue_app__;
        }
      },
      provide(key, value) {
        context.provides[key] = value;
        return app;
      },
      runWithContext(fn) {
        const lastApp = currentApp;
        currentApp = app;
        try {
          return fn();
        } finally {
          currentApp = lastApp;
        }
      }
    };
    return app;
  };
}
let currentApp = null;

function provide(key, value) {
  if (!currentInstance) ; else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance || currentApp) {
    const provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
    } else ;
  }
}
function hasInjectionContext() {
  return !!(currentInstance || currentRenderingInstance || currentApp);
}

const internalObjectProto = {};
const createInternalObject = () => Object.create(internalObjectProto);
const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;

function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = createInternalObject();
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const {
    props,
    attrs,
    vnode: { patchFlag }
  } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize$1(key);
            props[camelizedKey] = resolvePropValue(
              options,
              rawCurrentProps,
              camelizedKey,
              value,
              instance,
              false
            );
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = hyphenate$1(key)) === key || !hasOwn(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance.attrs, "set", "");
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn(options, camelKey = camelize$1(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(
        options,
        rawCurrentProps,
        key,
        castValues[key],
        instance,
        !hasOwn(castValues, key)
      );
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && !opt.skipFactory && isFunction(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          const reset = setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(
            null,
            props
          );
          reset();
        }
      } else {
        value = defaultValue;
      }
      if (instance.ce) {
        instance.ce._setProp(key, value);
      }
    }
    if (opt[0 /* shouldCast */]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[1 /* shouldCastTrue */] && (value === "" || value === hyphenate$1(key))) {
        value = true;
      }
    }
  }
  return value;
}
const mixinPropsCache = /* @__PURE__ */ new WeakMap();
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = __VUE_OPTIONS_API__ && asMixin ? mixinPropsCache : appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (__VUE_OPTIONS_API__ && !isFunction(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw2, appContext, true);
      extend(normalized, props);
      if (keys) needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$1(comp)) {
      cache.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray(raw)) {
    for (let i = 0; i < raw.length; i++) {
      const normalizedKey = camelize$1(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key in raw) {
      const normalizedKey = camelize$1(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray(opt) || isFunction(opt) ? { type: opt } : extend({}, opt);
        const propType = prop.type;
        let shouldCast = false;
        let shouldCastTrue = true;
        if (isArray(propType)) {
          for (let index = 0; index < propType.length; ++index) {
            const type = propType[index];
            const typeName = isFunction(type) && type.name;
            if (typeName === "Boolean") {
              shouldCast = true;
              break;
            } else if (typeName === "String") {
              shouldCastTrue = false;
            }
          }
        } else {
          shouldCast = isFunction(propType) && propType.name === "Boolean";
        }
        prop[0 /* shouldCast */] = shouldCast;
        prop[1 /* shouldCastTrue */] = shouldCastTrue;
        if (shouldCast || hasOwn(prop, "default")) {
          needCastKeys.push(normalizedKey);
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject$1(comp)) {
    cache.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$" && !isReservedProp(key)) {
    return true;
  }
  return false;
}

const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value) => isArray(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (!!("production" !== "production") && currentInstance && (!ctx || ctx.root === currentInstance.root)) ;
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key)) continue;
    const value = rawSlots[key];
    if (isFunction(value)) {
      slots[key] = normalizeSlot(key, value, ctx);
    } else if (value != null) {
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const assignSlots = (slots, children, optimized) => {
  for (const key in children) {
    if (optimized || key !== "_") {
      slots[key] = children[key];
    }
  }
};
const initSlots = (instance, children, optimized) => {
  const slots = instance.slots = createInternalObject();
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      assignSlots(slots, children, optimized);
      if (optimized) {
        def(slots, "_", type, true);
      }
    } else {
      normalizeObjectSlots(children, slots);
    }
  } else if (children) {
    normalizeVNodeSlots(instance, children);
  }
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        assignSlots(slots, children, optimized);
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
        delete slots[key];
      }
    }
  }
};

function initFeatureFlags() {
  if (typeof __VUE_OPTIONS_API__ !== "boolean") {
    getGlobalThis().__VUE_OPTIONS_API__ = true;
  }
  if (typeof __VUE_PROD_DEVTOOLS__ !== "boolean") {
    getGlobalThis().__VUE_PROD_DEVTOOLS__ = false;
  }
  if (typeof __VUE_PROD_HYDRATION_MISMATCH_DETAILS__ !== "boolean") {
    getGlobalThis().__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ = false;
  }
}

const queuePostRenderEffect = queueEffectWithSuspense ;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function createHydrationRenderer(options) {
  return baseCreateRenderer(options, createHydrationFunctions);
}
function baseCreateRenderer(options, createHydrationFns) {
  {
    initFeatureFlags();
  }
  const target = getGlobalThis();
  target.__VUE__ = true;
  if (__VUE_PROD_DEVTOOLS__) {
    setDevtoolsHook$1(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
  }
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = NOOP,
    insertStaticContent: hostInsertStaticContent
  } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, namespace);
        }
        break;
      case Fragment:
        processFragment(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        break;
      default:
        if (shapeFlag & 1) {
          processElement(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 6) {
          processComponent(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 64) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (shapeFlag & 128) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else ;
    }
    if (ref != null && parentComponent) {
      setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateText(n2.children),
        container,
        anchor
      );
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateComment(n2.children || ""),
        container,
        anchor
      );
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, namespace) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(
      n2.children,
      container,
      anchor,
      namespace,
      n2.el,
      n2.anchor
    );
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    if (n2.type === "svg") {
      namespace = "svg";
    } else if (n2.type === "math") {
      namespace = "mathml";
    }
    if (n1 == null) {
      mountElement(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      patchElement(
        n1,
        n2,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { props, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(
      vnode.type,
      namespace,
      props && props.is,
      props
    );
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(
        vnode.children,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(vnode, namespace),
        slotScopeIds,
        optimized
      );
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(el, key, null, props[key], namespace, parentComponent);
        }
      }
      if ("value" in props) {
        hostPatchProp(el, "value", null, props.value, namespace);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (__VUE_PROD_DEVTOOLS__) {
      def(el, "__vnode", vnode, true);
      def(el, "__vueParentComponent", parentComponent, true);
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = needTransition(parentSuspense, transition);
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el, slotScopeIds[i]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
        const parentVNode = parentComponent.vnode;
        setScopeId(
          el,
          parentVNode,
          parentVNode.scopeId,
          parentVNode.slotScopeIds,
          parentComponent.parent
        );
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
    for (let i = start; i < children.length; i++) {
      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(
        null,
        child,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    if (__VUE_PROD_DEVTOOLS__) {
      el.__vnode = n2;
    }
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
      hostSetElementText(el, "");
    }
    if (dynamicChildren) {
      patchBlockChildren(
        n1.dynamicChildren,
        dynamicChildren,
        el,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds
      );
    } else if (!optimized) {
      patchChildren(
        n1,
        n2,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds,
        false
      );
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el, oldProps, newProps, parentComponent, namespace);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, namespace);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key = propsToUpdate[i];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(el, key, prev, next, namespace, parentComponent);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el, oldProps, newProps, parentComponent, namespace);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch(
        oldVNode,
        newVNode,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        true
      );
    }
  };
  const patchProps = (el, oldProps, newProps, parentComponent, namespace) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(
              el,
              key,
              oldProps[key],
              null,
              namespace,
              parentComponent
            );
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key)) continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(el, key, prev, next, namespace, parentComponent);
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(
        // #10007
        // such fragment like `<></>` will be compiled into
        // a fragment which doesn't have a children.
        // In this case fallback to an empty array
        n2.children || [],
        container,
        fragmentEndAnchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          container,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n2.key != null || parentComponent && n2 === parentComponent.subTree
        ) {
          traverseStaticChildren(
            n1,
            n2,
            true
            /* shallow */
          );
        }
      } else {
        patchChildren(
          n1,
          n2,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(
          n2,
          container,
          anchor,
          namespace,
          optimized
        );
      } else {
        mountComponent(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          optimized
        );
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
    const instance = (initialVNode.component = createComponentInstance(
      initialVNode,
      parentComponent,
      parentSuspense
    ));
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent(instance, false, optimized);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
    } else {
      setupRenderEffect(
        instance,
        initialVNode,
        container,
        anchor,
        parentSuspense,
        namespace,
        optimized
      );
    }
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n2, optimized);
        return;
      } else {
        instance.next = n2;
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m, parent, root, type } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            instance.subTree = renderComponentRoot(instance);
            hydrateNode(
              el,
              instance.subTree,
              instance,
              parentSuspense,
              null
            );
          };
          if (isAsyncWrapperVNode && type.__asyncHydrate) {
            type.__asyncHydrate(
              el,
              instance,
              hydrateSubTree
            );
          } else {
            hydrateSubTree();
          }
        } else {
          if (root.ce) {
            root.ce._injectChildStyle(type);
          }
          const subTree = instance.subTree = renderComponentRoot(instance);
          patch(
            null,
            subTree,
            container,
            anchor,
            instance,
            parentSuspense,
            namespace
          );
          initialVNode.el = subTree.el;
        }
        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
            parentSuspense
          );
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        if (__VUE_PROD_DEVTOOLS__) {
          devtoolsComponentAdded(instance);
        }
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u, parent, vnode } = instance;
        {
          const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
          if (nonHydratedAsyncRoot) {
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance, next, optimized);
            }
            nonHydratedAsyncRoot.asyncDep.then(() => {
              if (!instance.isUnmounted) {
                componentUpdateFn();
              }
            });
            return;
          }
        }
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        const nextTree = renderComponentRoot(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          namespace
        );
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, next, vnode),
            parentSuspense
          );
        }
        if (__VUE_PROD_DEVTOOLS__) {
          devtoolsComponentUpdated(instance);
        }
      }
    };
    instance.scope.on();
    const effect = instance.effect = new ReactiveEffect(componentUpdateFn);
    instance.scope.off();
    const update = instance.update = effect.run.bind(effect);
    const job = instance.job = effect.runIfDirty.bind(effect);
    job.i = instance;
    job.id = instance.uid;
    effect.scheduler = () => queueJob(job);
    toggleRecurse(instance, true);
    update();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs(instance);
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;
    for (i = 0; i < commonLength; i++) {
      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(
        c1[i],
        nextChild,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
    if (oldLength > newLength) {
      unmountChildren(
        c1,
        parentComponent,
        parentSuspense,
        true,
        false,
        commonLength
      );
    } else {
      mountChildren(
        c2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized,
        commonLength
      );
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i <= e1 && i <= e2) {
      const n1 = c1[i];
      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      i++;
    }
    while (i <= e1 && i <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i <= e2) {
          patch(
            null,
            c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          i++;
        }
      }
    } else if (i > e2) {
      while (i <= e1) {
        unmount(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } else {
      const s1 = i;
      const s2 = i;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i = s2; i <= e2; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(
            prevChild,
            c2[newIndex],
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i] === 0) {
          patch(
            null,
            nextChild,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (moved) {
          if (j < 0 || i !== increasingNewIndexSequence[j]) {
            move(nextChild, container, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition2) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove2 = () => hostInsert(el, container, anchor);
        const performLeave = () => {
          leave(el, () => {
            remove2();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove2, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type,
      props,
      ref,
      children,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs,
      cacheIndex
    } = vnode;
    if (patchFlag === -2) {
      optimized = false;
    }
    if (ref != null) {
      setRef(ref, null, parentSuspense, vnode, true);
    }
    if (cacheIndex != null) {
      parentComponent.renderCache[cacheIndex] = void 0;
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(
          vnode,
          parentComponent,
          parentSuspense,
          internals,
          doRemove
        );
      } else if (dynamicChildren && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(
          dynamicChildren,
          parentComponent,
          parentSuspense,
          false,
          true
        );
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const { bum, scope, job, subTree, um, m, a } = instance;
    invalidateMount(m);
    invalidateMount(a);
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (job) {
      job.flags |= 8;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
    if (__VUE_PROD_DEVTOOLS__) {
      devtoolsComponentRemoved(instance);
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i = start; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    const el = hostNextSibling(vnode.anchor || vnode.el);
    const teleportEnd = el && el[TeleportEndKey];
    return teleportEnd ? hostNextSibling(teleportEnd) : el;
  };
  let isFlushing = false;
  const render = (vnode, container, namespace) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(
        container._vnode || null,
        vnode,
        container,
        null,
        null,
        null,
        namespace
      );
    }
    container._vnode = vnode;
    if (!isFlushing) {
      isFlushing = true;
      flushPreFlushCbs();
      flushPostFlushCbs();
      isFlushing = false;
    }
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate, hydrateNode] = createHydrationFns(
      internals
    );
  }
  return {
    render,
    hydrate,
    createApp: createAppAPI(render, hydrate)
  };
}
function resolveChildrenNamespace({ type, props }, currentNamespace) {
  return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
}
function toggleRecurse({ effect, job }, allowed) {
  if (allowed) {
    effect.flags |= 32;
    job.flags |= 4;
  } else {
    effect.flags &= ~32;
    job.flags &= ~4;
  }
}
function needTransition(parentSuspense, transition) {
  return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray(ch1) && isArray(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      const c1 = ch1[i];
      let c2 = ch2[i];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }
        if (!shallow && c2.patchFlag !== -2)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p = arr.slice();
  const result = [0];
  let i, j, u, v, c;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p[i] = j;
        result.push(i);
        continue;
      }
      u = 0;
      v = result.length - 1;
      while (u < v) {
        c = u + v >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = result.length;
  v = result[u - 1];
  while (u-- > 0) {
    result[u] = v;
    v = p[v];
  }
  return result;
}
function locateNonHydratedAsyncRoot(instance) {
  const subComponent = instance.subTree.component;
  if (subComponent) {
    if (subComponent.asyncDep && !subComponent.asyncResolved) {
      return subComponent;
    } else {
      return locateNonHydratedAsyncRoot(subComponent);
    }
  }
}
function invalidateMount(hooks) {
  if (hooks) {
    for (let i = 0; i < hooks.length; i++)
      hooks[i].flags |= 8;
  }
}

const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    return ctx;
  }
};

function watchEffect(effect, options) {
  return doWatch(effect, null, options);
}
function watchPostEffect(effect, options) {
  return doWatch(
    effect,
    null,
    { flush: "post" }
  );
}
function watchSyncEffect(effect, options) {
  return doWatch(
    effect,
    null,
    { flush: "sync" }
  );
}
function watch(source, cb, options) {
  return doWatch(source, cb, options);
}
function doWatch(source, cb, options = EMPTY_OBJ) {
  const { immediate, deep, flush, once } = options;
  const baseWatchOptions = extend({}, options);
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else if (!cb || immediate) {
      baseWatchOptions.once = true;
    } else {
      const watchStopHandle = () => {
      };
      watchStopHandle.stop = NOOP;
      watchStopHandle.resume = NOOP;
      watchStopHandle.pause = NOOP;
      return watchStopHandle;
    }
  }
  const instance = currentInstance;
  baseWatchOptions.call = (fn, type, args) => callWithAsyncErrorHandling(fn, instance, type, args);
  let isPre = false;
  if (flush === "post") {
    baseWatchOptions.scheduler = (job) => {
      queuePostRenderEffect(job, instance && instance.suspense);
    };
  } else if (flush !== "sync") {
    isPre = true;
    baseWatchOptions.scheduler = (job, isFirstRun) => {
      if (isFirstRun) {
        job();
      } else {
        queueJob(job);
      }
    };
  }
  baseWatchOptions.augmentJob = (job) => {
    if (cb) {
      job.flags |= 4;
    }
    if (isPre) {
      job.flags |= 2;
      if (instance) {
        job.id = instance.uid;
        job.i = instance;
      }
    }
  };
  const watchHandle = watch$1(source, cb, baseWatchOptions);
  if (ssrCleanup) ssrCleanup.push(watchHandle);
  return watchHandle;
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const reset = setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  reset();
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}

function useModel(props, name, options = EMPTY_OBJ) {
  const i = getCurrentInstance();
  const camelizedName = camelize$1(name);
  const hyphenatedName = hyphenate$1(name);
  const modifiers = getModelModifiers(props, name);
  const res = customRef((track, trigger) => {
    let localValue;
    let prevSetValue = EMPTY_OBJ;
    let prevEmittedValue;
    watchSyncEffect(() => {
      const propValue = props[name];
      if (hasChanged(localValue, propValue)) {
        localValue = propValue;
        trigger();
      }
    });
    return {
      get() {
        track();
        return options.get ? options.get(localValue) : localValue;
      },
      set(value) {
        const emittedValue = options.set ? options.set(value) : value;
        if (!hasChanged(emittedValue, localValue) && !(prevSetValue !== EMPTY_OBJ && hasChanged(value, prevSetValue))) {
          return;
        }
        const rawProps = i.vnode.props;
        if (!(rawProps && // check if parent has passed v-model
        (name in rawProps || camelizedName in rawProps || hyphenatedName in rawProps) && (`onUpdate:${name}` in rawProps || `onUpdate:${camelizedName}` in rawProps || `onUpdate:${hyphenatedName}` in rawProps))) {
          localValue = value;
          trigger();
        }
        i.emit(`update:${name}`, emittedValue);
        if (hasChanged(value, emittedValue) && hasChanged(value, prevSetValue) && !hasChanged(emittedValue, prevEmittedValue)) {
          trigger();
        }
        prevSetValue = value;
        prevEmittedValue = emittedValue;
      }
    };
  });
  res[Symbol.iterator] = () => {
    let i2 = 0;
    return {
      next() {
        if (i2 < 2) {
          return { value: i2++ ? modifiers || EMPTY_OBJ : res, done: false };
        } else {
          return { done: true };
        }
      }
    };
  };
  return res;
}
const getModelModifiers = (props, modelName) => {
  return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${camelize$1(modelName)}Modifiers`] || props[`${hyphenate$1(modelName)}Modifiers`];
};

function emit(instance, event, ...rawArgs) {
  if (instance.isUnmounted) return;
  const props = instance.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener = event.startsWith("update:");
  const modifiers = isModelListener && getModelModifiers(props, event.slice(7));
  if (modifiers) {
    if (modifiers.trim) {
      args = rawArgs.map((a) => isString(a) ? a.trim() : a);
    }
    if (modifiers.number) {
      args = rawArgs.map(looseToNumber);
    }
  }
  if (__VUE_PROD_DEVTOOLS__) {
    devtoolsComponentEmit(instance, event, args);
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey$1(event)] || // also try camelCase event handler (#2249)
  props[handlerName = toHandlerKey$1(camelize$1(event))];
  if (!handler && isModelListener) {
    handler = props[handlerName = toHandlerKey$1(hyphenate$1(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(
      handler,
      instance,
      6,
      args
    );
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(
      onceHandler,
      instance,
      6,
      args
    );
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (__VUE_OPTIONS_API__ && !isFunction(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$1(comp)) {
      cache.set(comp, null);
    }
    return null;
  }
  if (isArray(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend(normalized, raw);
  }
  if (isObject$1(comp)) {
    cache.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate$1(key)) || hasOwn(options, key);
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    propsOptions: [propsOptions],
    slots,
    attrs,
    emit,
    render,
    renderCache,
    props,
    data,
    setupState,
    ctx,
    inheritAttrs
  } = instance;
  const prev = setCurrentRenderingInstance(instance);
  let result;
  let fallthroughAttrs;
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      const thisProxy = !!("production" !== "production") && setupState.__isScriptSetup ? new Proxy(proxyToUse, {
        get(target, key, receiver) {
          warn$1(
            `Property '${String(
              key
            )}' was accessed via 'this'. Avoid using 'this' in templates.`
          );
          return Reflect.get(target, key, receiver);
        }
      }) : proxyToUse;
      result = normalizeVNode(
        render.call(
          thisProxy,
          proxyToUse,
          renderCache,
          !!("production" !== "production") ? shallowReadonly(props) : props,
          setupState,
          data,
          ctx
        )
      );
      fallthroughAttrs = attrs;
    } else {
      const render2 = Component;
      if (!!("production" !== "production") && attrs === props) ;
      result = normalizeVNode(
        render2.length > 1 ? render2(
          !!("production" !== "production") ? shallowReadonly(props) : props,
          !!("production" !== "production") ? {
            get attrs() {
              markAttrsAccessed();
              return shallowReadonly(attrs);
            },
            slots,
            emit
          } : { attrs, slots, emit }
        ) : render2(
          !!("production" !== "production") ? shallowReadonly(props) : props,
          null
        )
      );
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(
            fallthroughAttrs,
            propsOptions
          );
        }
        root = cloneVNode(root, fallthroughAttrs, false, true);
      }
    }
  }
  if (vnode.dirs) {
    root = cloneVNode(root, null, false, true);
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    setTransitionHooks(root, vnode.transition);
  }
  {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
function filterSingleRoot(children, recurse = true) {
  let singleRoot;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (isVNode(child)) {
      if (child.type !== Comment || child.children === "v-if") {
        if (singleRoot) {
          return;
        } else {
          singleRoot = child;
        }
      }
    } else {
      return;
    }
  }
  return singleRoot;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i = 0; i < dynamicProps.length; i++) {
        const key = dynamicProps[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent) {
    const root = parent.subTree;
    if (root.suspense && root.suspense.activeBranch === vnode) {
      root.el = vnode.el;
    }
    if (root === vnode) {
      (vnode = parent.vnode).el = el;
      parent = parent.parent;
    } else {
      break;
    }
  }
}

const isSuspense = (type) => type.__isSuspense;
let suspenseId = 0;
const SuspenseImpl = {
  name: "Suspense",
  // In order to make Suspense tree-shakable, we need to avoid importing it
  // directly in the renderer. The renderer checks for the __isSuspense flag
  // on a vnode's type and calls the `process` method, passing in renderer
  // internals.
  __isSuspense: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
    if (n1 == null) {
      mountSuspense(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized,
        rendererInternals
      );
    } else {
      if (parentSuspense && parentSuspense.deps > 0 && !n1.suspense.isInFallback) {
        n2.suspense = n1.suspense;
        n2.suspense.vnode = n2;
        n2.el = n1.el;
        return;
      }
      patchSuspense(
        n1,
        n2,
        container,
        anchor,
        parentComponent,
        namespace,
        slotScopeIds,
        optimized,
        rendererInternals
      );
    }
  },
  hydrate: hydrateSuspense,
  normalize: normalizeSuspenseChildren
};
const Suspense = SuspenseImpl ;
function triggerEvent(vnode, name) {
  const eventListener = vnode.props && vnode.props[name];
  if (isFunction(eventListener)) {
    eventListener();
  }
}
function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
  const {
    p: patch,
    o: { createElement }
  } = rendererInternals;
  const hiddenContainer = createElement("div");
  const suspense = vnode.suspense = createSuspenseBoundary(
    vnode,
    parentSuspense,
    parentComponent,
    container,
    hiddenContainer,
    anchor,
    namespace,
    slotScopeIds,
    optimized,
    rendererInternals
  );
  patch(
    null,
    suspense.pendingBranch = vnode.ssContent,
    hiddenContainer,
    null,
    parentComponent,
    suspense,
    namespace,
    slotScopeIds
  );
  if (suspense.deps > 0) {
    triggerEvent(vnode, "onPending");
    triggerEvent(vnode, "onFallback");
    patch(
      null,
      vnode.ssFallback,
      container,
      anchor,
      parentComponent,
      null,
      // fallback tree will not have suspense context
      namespace,
      slotScopeIds
    );
    setActiveBranch(suspense, vnode.ssFallback);
  } else {
    suspense.resolve(false, true);
  }
}
function patchSuspense(n1, n2, container, anchor, parentComponent, namespace, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {
  const suspense = n2.suspense = n1.suspense;
  suspense.vnode = n2;
  n2.el = n1.el;
  const newBranch = n2.ssContent;
  const newFallback = n2.ssFallback;
  const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
  if (pendingBranch) {
    suspense.pendingBranch = newBranch;
    if (isSameVNodeType(newBranch, pendingBranch)) {
      patch(
        pendingBranch,
        newBranch,
        suspense.hiddenContainer,
        null,
        parentComponent,
        suspense,
        namespace,
        slotScopeIds,
        optimized
      );
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else if (isInFallback) {
        if (!isHydrating) {
          patch(
            activeBranch,
            newFallback,
            container,
            anchor,
            parentComponent,
            null,
            // fallback tree will not have suspense context
            namespace,
            slotScopeIds,
            optimized
          );
          setActiveBranch(suspense, newFallback);
        }
      }
    } else {
      suspense.pendingId = suspenseId++;
      if (isHydrating) {
        suspense.isHydrating = false;
        suspense.activeBranch = pendingBranch;
      } else {
        unmount(pendingBranch, parentComponent, suspense);
      }
      suspense.deps = 0;
      suspense.effects.length = 0;
      suspense.hiddenContainer = createElement("div");
      if (isInFallback) {
        patch(
          null,
          newBranch,
          suspense.hiddenContainer,
          null,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        if (suspense.deps <= 0) {
          suspense.resolve();
        } else {
          patch(
            activeBranch,
            newFallback,
            container,
            anchor,
            parentComponent,
            null,
            // fallback tree will not have suspense context
            namespace,
            slotScopeIds,
            optimized
          );
          setActiveBranch(suspense, newFallback);
        }
      } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
        patch(
          activeBranch,
          newBranch,
          container,
          anchor,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        suspense.resolve(true);
      } else {
        patch(
          null,
          newBranch,
          suspense.hiddenContainer,
          null,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        if (suspense.deps <= 0) {
          suspense.resolve();
        }
      }
    }
  } else {
    if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
      patch(
        activeBranch,
        newBranch,
        container,
        anchor,
        parentComponent,
        suspense,
        namespace,
        slotScopeIds,
        optimized
      );
      setActiveBranch(suspense, newBranch);
    } else {
      triggerEvent(n2, "onPending");
      suspense.pendingBranch = newBranch;
      if (newBranch.shapeFlag & 512) {
        suspense.pendingId = newBranch.component.suspenseId;
      } else {
        suspense.pendingId = suspenseId++;
      }
      patch(
        null,
        newBranch,
        suspense.hiddenContainer,
        null,
        parentComponent,
        suspense,
        namespace,
        slotScopeIds,
        optimized
      );
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else {
        const { timeout, pendingId } = suspense;
        if (timeout > 0) {
          setTimeout(() => {
            if (suspense.pendingId === pendingId) {
              suspense.fallback(newFallback);
            }
          }, timeout);
        } else if (timeout === 0) {
          suspense.fallback(newFallback);
        }
      }
    }
  }
}
function createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, namespace, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
  const {
    p: patch,
    m: move,
    um: unmount,
    n: next,
    o: { parentNode, remove }
  } = rendererInternals;
  let parentSuspenseId;
  const isSuspensible = isVNodeSuspensible(vnode);
  if (isSuspensible) {
    if (parentSuspense && parentSuspense.pendingBranch) {
      parentSuspenseId = parentSuspense.pendingId;
      parentSuspense.deps++;
    }
  }
  const timeout = vnode.props ? toNumber(vnode.props.timeout) : void 0;
  const initialAnchor = anchor;
  const suspense = {
    vnode,
    parent: parentSuspense,
    parentComponent,
    namespace,
    container,
    hiddenContainer,
    deps: 0,
    pendingId: suspenseId++,
    timeout: typeof timeout === "number" ? timeout : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: !isHydrating,
    isHydrating,
    isUnmounted: false,
    effects: [],
    resolve(resume = false, sync = false) {
      const {
        vnode: vnode2,
        activeBranch,
        pendingBranch,
        pendingId,
        effects,
        parentComponent: parentComponent2,
        container: container2
      } = suspense;
      let delayEnter = false;
      if (suspense.isHydrating) {
        suspense.isHydrating = false;
      } else if (!resume) {
        delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
        if (delayEnter) {
          activeBranch.transition.afterLeave = () => {
            if (pendingId === suspense.pendingId) {
              move(
                pendingBranch,
                container2,
                anchor === initialAnchor ? next(activeBranch) : anchor,
                0
              );
              queuePostFlushCb(effects);
            }
          };
        }
        if (activeBranch) {
          if (parentNode(activeBranch.el) === container2) {
            anchor = next(activeBranch);
          }
          unmount(activeBranch, parentComponent2, suspense, true);
        }
        if (!delayEnter) {
          move(pendingBranch, container2, anchor, 0);
        }
      }
      setActiveBranch(suspense, pendingBranch);
      suspense.pendingBranch = null;
      suspense.isInFallback = false;
      let parent = suspense.parent;
      let hasUnresolvedAncestor = false;
      while (parent) {
        if (parent.pendingBranch) {
          parent.effects.push(...effects);
          hasUnresolvedAncestor = true;
          break;
        }
        parent = parent.parent;
      }
      if (!hasUnresolvedAncestor && !delayEnter) {
        queuePostFlushCb(effects);
      }
      suspense.effects = [];
      if (isSuspensible) {
        if (parentSuspense && parentSuspense.pendingBranch && parentSuspenseId === parentSuspense.pendingId) {
          parentSuspense.deps--;
          if (parentSuspense.deps === 0 && !sync) {
            parentSuspense.resolve();
          }
        }
      }
      triggerEvent(vnode2, "onResolve");
    },
    fallback(fallbackVNode) {
      if (!suspense.pendingBranch) {
        return;
      }
      const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, namespace: namespace2 } = suspense;
      triggerEvent(vnode2, "onFallback");
      const anchor2 = next(activeBranch);
      const mountFallback = () => {
        if (!suspense.isInFallback) {
          return;
        }
        patch(
          null,
          fallbackVNode,
          container2,
          anchor2,
          parentComponent2,
          null,
          // fallback tree will not have suspense context
          namespace2,
          slotScopeIds,
          optimized
        );
        setActiveBranch(suspense, fallbackVNode);
      };
      const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
      if (delayEnter) {
        activeBranch.transition.afterLeave = mountFallback;
      }
      suspense.isInFallback = true;
      unmount(
        activeBranch,
        parentComponent2,
        null,
        // no suspense so unmount hooks fire now
        true
        // shouldRemove
      );
      if (!delayEnter) {
        mountFallback();
      }
    },
    move(container2, anchor2, type) {
      suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);
      suspense.container = container2;
    },
    next() {
      return suspense.activeBranch && next(suspense.activeBranch);
    },
    registerDep(instance, setupRenderEffect, optimized2) {
      const isInPendingSuspense = !!suspense.pendingBranch;
      if (isInPendingSuspense) {
        suspense.deps++;
      }
      const hydratedEl = instance.vnode.el;
      instance.asyncDep.catch((err) => {
        handleError(err, instance, 0);
      }).then((asyncSetupResult) => {
        if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
          return;
        }
        instance.asyncResolved = true;
        const { vnode: vnode2 } = instance;
        handleSetupResult(instance, asyncSetupResult, false);
        if (hydratedEl) {
          vnode2.el = hydratedEl;
        }
        const placeholder = !hydratedEl && instance.subTree.el;
        setupRenderEffect(
          instance,
          vnode2,
          // component may have been moved before resolve.
          // if this is not a hydration, instance.subTree will be the comment
          // placeholder.
          parentNode(hydratedEl || instance.subTree.el),
          // anchor will not be used if this is hydration, so only need to
          // consider the comment placeholder case.
          hydratedEl ? null : next(instance.subTree),
          suspense,
          namespace,
          optimized2
        );
        if (placeholder) {
          remove(placeholder);
        }
        updateHOCHostEl(instance, vnode2.el);
        if (isInPendingSuspense && --suspense.deps === 0) {
          suspense.resolve();
        }
      });
    },
    unmount(parentSuspense2, doRemove) {
      suspense.isUnmounted = true;
      if (suspense.activeBranch) {
        unmount(
          suspense.activeBranch,
          parentComponent,
          parentSuspense2,
          doRemove
        );
      }
      if (suspense.pendingBranch) {
        unmount(
          suspense.pendingBranch,
          parentComponent,
          parentSuspense2,
          doRemove
        );
      }
    }
  };
  return suspense;
}
function hydrateSuspense(node, vnode, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals, hydrateNode) {
  const suspense = vnode.suspense = createSuspenseBoundary(
    vnode,
    parentSuspense,
    parentComponent,
    node.parentNode,
    // eslint-disable-next-line no-restricted-globals
    document.createElement("div"),
    null,
    namespace,
    slotScopeIds,
    optimized,
    rendererInternals,
    true
  );
  const result = hydrateNode(
    node,
    suspense.pendingBranch = vnode.ssContent,
    parentComponent,
    suspense,
    slotScopeIds,
    optimized
  );
  if (suspense.deps === 0) {
    suspense.resolve(false, true);
  }
  return result;
}
function normalizeSuspenseChildren(vnode) {
  const { shapeFlag, children } = vnode;
  const isSlotChildren = shapeFlag & 32;
  vnode.ssContent = normalizeSuspenseSlot(
    isSlotChildren ? children.default : children
  );
  vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
}
function normalizeSuspenseSlot(s) {
  let block;
  if (isFunction(s)) {
    const trackBlock = isBlockTreeEnabled && s._c;
    if (trackBlock) {
      s._d = false;
      openBlock();
    }
    s = s();
    if (trackBlock) {
      s._d = true;
      block = currentBlock;
      closeBlock();
    }
  }
  if (isArray(s)) {
    const singleChild = filterSingleRoot(s);
    s = singleChild;
  }
  s = normalizeVNode(s);
  if (block && !s.dynamicChildren) {
    s.dynamicChildren = block.filter((c) => c !== s);
  }
  return s;
}
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
function setActiveBranch(suspense, branch) {
  suspense.activeBranch = branch;
  const { vnode, parentComponent } = suspense;
  let el = branch.el;
  while (!el && branch.component) {
    branch = branch.component.subTree;
    el = branch.el;
  }
  vnode.el = el;
  if (parentComponent && parentComponent.subTree === vnode) {
    parentComponent.vnode.el = el;
    updateHOCHostEl(parentComponent, el);
  }
}
function isVNodeSuspensible(vnode) {
  const suspensible = vnode.props && vnode.props.suspensible;
  return suspensible != null && suspensible !== false;
}

const Fragment = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value) {
  isBlockTreeEnabled += value;
  if (value < 0 && currentBlock) {
    currentBlock.hasOnce = true;
  }
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(
    createBaseVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      true
    )
  );
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(
    createVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      true
    )
  );
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
function transformVNodeArgs(transformer) {
}
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({
  ref,
  ref_key,
  ref_for
}) => {
  if (typeof ref === "number") {
    ref = "" + ref;
  }
  return ref != null ? isString(ref) || isRef(ref) || isFunction(ref) ? { i: currentRenderingInstance, r: ref, k: ref_key, f: !!ref_for } : ref : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(
      type,
      props,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag = -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style } = props;
    if (klass && !isString(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject$1(style)) {
      if (isProxy(style) && !isArray(style)) {
        style = extend({}, style);
      }
      props.style = normalizeStyle(style);
    }
  }
  const shapeFlag = isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$1(type) ? 4 : isFunction(type) ? 2 : 0;
  return createBaseVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  );
}
function guardReactiveProps(props) {
  if (!props) return null;
  return isProxy(props) || isInternalObject(props) ? extend({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
  const { props, ref, patchFlag, children, transition } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref ? isArray(ref) ? ref.concat(normalizeRef(extraProps)) : [ref, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children: children,
    target: vnode.target,
    targetStart: vnode.targetStart,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  if (transition && cloneTransition) {
    setTransitionHooks(
      cloned,
      transition.clone(cloned)
    );
  }
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createStaticVNode(content, numberOfNodes) {
  const vnode = createVNode(Static, null, content);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (isVNode(child)) {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !isInternalObject(children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}

const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    ids: parent ? parent.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let setInSSRSetupState;
{
  const g = getGlobalThis();
  const registerGlobalSetter = (key, setter) => {
    let setters;
    if (!(setters = g[key])) setters = g[key] = [];
    setters.push(setter);
    return (v) => {
      if (setters.length > 1) setters.forEach((set) => set(v));
      else setters[0](v);
    };
  };
  internalSetCurrentInstance = registerGlobalSetter(
    `__VUE_INSTANCE_SETTERS__`,
    (v) => currentInstance = v
  );
  setInSSRSetupState = registerGlobalSetter(
    `__VUE_SSR_SETTERS__`,
    (v) => isInSSRComponentSetup = v
  );
}
const setCurrentInstance = (instance) => {
  const prev = currentInstance;
  internalSetCurrentInstance(instance);
  instance.scope.on();
  return () => {
    instance.scope.off();
    internalSetCurrentInstance(prev);
  };
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false, optimized = false) {
  isSSR && setInSSRSetupState(isSSR);
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children, optimized);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isSSR && setInSSRSetupState(false);
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
  const { setup } = Component;
  if (setup) {
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    const reset = setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling(
      setup,
      instance,
      0,
      [
        instance.props,
        setupContext
      ]
    );
    resetTracking();
    reset();
    if (isPromise(setupResult)) {
      if (!isAsyncWrapper(instance)) markAsyncBoundary(instance);
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e) => {
          handleError(e, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject$1(setupResult)) {
    if (__VUE_PROD_DEVTOOLS__) {
      instance.devtoolsRawSetupState = setupResult;
    }
    instance.setupState = proxyRefs(setupResult);
  } else ;
  finishComponentSetup(instance, isSSR);
}
let compile;
let installWithProxy;
function registerRuntimeCompiler(_compile) {
  compile = _compile;
  installWithProxy = (i) => {
    if (i.render._rc) {
      i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
    }
  };
}
const isRuntimeOnly = () => !compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile && !Component.render) {
      const template = Component.template || resolveMergedOptions(instance).template;
      if (template) {
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend(
          extend(
            {
              isCustomElement,
              delimiters
            },
            compilerOptions
          ),
          componentCompilerOptions
        );
        Component.render = compile(template, finalCompilerOptions);
      }
    }
    instance.render = Component.render || NOOP;
    if (installWithProxy) {
      installWithProxy(instance);
    }
  }
  if (__VUE_OPTIONS_API__ && true) {
    const reset = setCurrentInstance(instance);
    pauseTracking();
    try {
      applyOptions(instance);
    } finally {
      resetTracking();
      reset();
    }
  }
}
const attrsProxyHandlers = {
  get(target, key) {
    track(target, "get", "");
    return target[key];
  }
};
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  {
    return {
      attrs: new Proxy(instance.attrs, attrsProxyHandlers),
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getComponentPublicInstance(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  } else {
    return instance.proxy;
  }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component, includeInferred = true) {
  return isFunction(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance, Component, isRoot = false) {
  let name = getComponentName(Component);
  if (!name && Component.__file) {
    const match = Component.__file.match(/([^/\\]+)\.\w+$/);
    if (match) {
      name = match[1];
    }
  }
  if (!name && instance && instance.parent) {
    const inferFromRegistry = (registry) => {
      for (const key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    };
    name = inferFromRegistry(
      instance.components || instance.parent.type.components
    ) || inferFromRegistry(instance.appContext.components);
  }
  return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
  return isFunction(value) && "__vccOpts" in value;
}

const computed = (getterOrOptions, debugOptions) => {
  const c = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
  return c;
};

function h(type, propsOrChildren, children) {
  const l = arguments.length;
  if (l === 2) {
    if (isObject$1(propsOrChildren) && !isArray(propsOrChildren)) {
      if (isVNode(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildren, children);
  }
}

function initCustomFormatter() {
  {
    return;
  }
}

function withMemo(memo, render, cache, index) {
  const cached = cache[index];
  if (cached && isMemoSame(cached, memo)) {
    return cached;
  }
  const ret = render();
  ret.memo = memo.slice();
  ret.cacheIndex = index;
  return cache[index] = ret;
}
function isMemoSame(cached, memo) {
  const prev = cached.memo;
  if (prev.length != memo.length) {
    return false;
  }
  for (let i = 0; i < prev.length; i++) {
    if (hasChanged(prev[i], memo[i])) {
      return false;
    }
  }
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(cached);
  }
  return true;
}

const version$1 = "3.5.10";
const warn = NOOP;
const ErrorTypeStrings = ErrorTypeStrings$1 ;
const devtools = devtools$1 ;
const setDevtoolsHook = setDevtoolsHook$1 ;
const _ssrUtils = {
  createComponentInstance,
  setupComponent,
  renderComponentRoot,
  setCurrentRenderingInstance,
  isVNode: isVNode,
  normalizeVNode,
  getComponentPublicInstance,
  ensureValidVNode,
  pushWarningContext,
  popWarningContext
};
const ssrUtils = _ssrUtils ;
const resolveFilter = null;
const compatUtils = null;
const DeprecationTypes = null;

/**
* @vue/runtime-dom v3.5.10
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/

let policy = void 0;
const tt = typeof window !== "undefined" && window.trustedTypes;
if (tt) {
  try {
    policy = /* @__PURE__ */ tt.createPolicy("vue", {
      createHTML: (val) => val
    });
  } catch (e) {
  }
}
const unsafeToTrustedHTML = policy ? (val) => policy.createHTML(val) : (val) => val;
const svgNS = "http://www.w3.org/2000/svg";
const mathmlNS = "http://www.w3.org/1998/Math/MathML";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, namespace, is, props) => {
    const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, { is }) : doc.createElement(tag);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id) {
    el.setAttribute(id, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent, anchor, namespace, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling)) break;
      }
    } else {
      templateContainer.innerHTML = unsafeToTrustedHTML(
        namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content
      );
      const template = templateContainer.content;
      if (namespace === "svg" || namespace === "mathml") {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      // first
      before ? before.nextSibling : parent.firstChild,
      // last
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};

const TRANSITION = "transition";
const ANIMATION = "animation";
const vtcKey = Symbol("_vtc");
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
const TransitionPropsValidators = /* @__PURE__ */ extend(
  {},
  BaseTransitionPropsValidators,
  DOMTransitionPropsValidators
);
const decorate$1 = (t) => {
  t.displayName = "Transition";
  t.props = TransitionPropsValidators;
  return t;
};
const Transition = /* @__PURE__ */ decorate$1(
  (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots)
);
const callHook = (hook, args = []) => {
  if (isArray(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? isArray(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const {
    name = "v",
    type,
    duration,
    enterFromClass = `${name}-enter-from`,
    enterActiveClass = `${name}-enter-active`,
    enterToClass = `${name}-enter-to`,
    appearFromClass = enterFromClass,
    appearActiveClass = enterActiveClass,
    appearToClass = enterToClass,
    leaveFromClass = `${name}-leave-from`,
    leaveActiveClass = `${name}-leave-active`,
    leaveToClass = `${name}-leave-to`
  } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const {
    onBeforeEnter,
    onEnter,
    onEnterCancelled,
    onLeave,
    onLeaveCancelled,
    onBeforeAppear = onBeforeEnter,
    onAppear = onEnter,
    onAppearCancelled = onEnterCancelled
  } = baseProps;
  const finishEnter = (el, isAppear, done) => {
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el, done) => {
    el._isLeaving = false;
    removeTransitionClass(el, leaveFromClass);
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve = () => finishEnter(el, isAppear, done);
      callHook(hook, [el, resolve]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type, enterDuration, resolve);
        }
      });
    };
  };
  return extend(baseProps, {
    onBeforeEnter(el) {
      callHook(onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done) {
      el._isLeaving = true;
      const resolve = () => finishLeave(el, done);
      addTransitionClass(el, leaveFromClass);
      addTransitionClass(el, leaveActiveClass);
      forceReflow();
      nextFrame(() => {
        if (!el._isLeaving) {
          return;
        }
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el, type, leaveDuration, resolve);
        }
      });
      callHook(onLeave, [el, resolve]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false);
      callHook(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true);
      callHook(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook(onLeaveCancelled, [el]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject$1(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n = NumberOf(duration);
    return [n, n];
  }
}
function NumberOf(val) {
  const res = toNumber(val);
  return res;
}
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
  (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el[vtcKey] = void 0;
    }
  }
}
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
  const id = el._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id === el._endId) {
      resolve();
    }
  };
  if (explicitTimeout != null) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
  if (!type) {
    return resolve();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end = () => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e) => {
    if (e.target === el && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el);
  const getStyleProperties = (key) => (styles[key] || "").split(", ");
  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
    getStyleProperties(`${TRANSITION}Property`).toString()
  );
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
}
function toMs(s) {
  if (s === "auto") return 0;
  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}

function patchClass(el, value, isSVG) {
  const transitionClasses = el[vtcKey];
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}

const vShowOriginalDisplay = Symbol("_vod");
const vShowHidden = Symbol("_vsh");
const vShow = {
  beforeMount(el, { value }, { transition }) {
    el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
    if (transition && value) {
      transition.beforeEnter(el);
    } else {
      setDisplay(el, value);
    }
  },
  mounted(el, { value }, { transition }) {
    if (transition && value) {
      transition.enter(el);
    }
  },
  updated(el, { value, oldValue }, { transition }) {
    if (!value === !oldValue) return;
    if (transition) {
      if (value) {
        transition.beforeEnter(el);
        setDisplay(el, true);
        transition.enter(el);
      } else {
        transition.leave(el, () => {
          setDisplay(el, false);
        });
      }
    } else {
      setDisplay(el, value);
    }
  },
  beforeUnmount(el, { value }) {
    setDisplay(el, value);
  }
};
function setDisplay(el, value) {
  el.style.display = value ? el[vShowOriginalDisplay] : "none";
  el[vShowHidden] = !value;
}
function initVShowForSSR() {
  vShow.getSSRProps = ({ value }) => {
    if (!value) {
      return { style: { display: "none" } };
    }
  };
}

const CSS_VAR_TEXT = Symbol("");
function useCssVars(getter) {
  const instance = getCurrentInstance();
  if (!instance) {
    return;
  }
  const updateTeleports = instance.ut = (vars = getter(instance.proxy)) => {
    Array.from(
      document.querySelectorAll(`[data-v-owner="${instance.uid}"]`)
    ).forEach((node) => setVarsOnNode(node, vars));
  };
  const setVars = () => {
    const vars = getter(instance.proxy);
    if (instance.ce) {
      setVarsOnNode(instance.ce, vars);
    } else {
      setVarsOnVNode(instance.subTree, vars);
    }
    updateTeleports(vars);
  };
  onBeforeMount(() => {
    watchPostEffect(setVars);
  });
  onMounted(() => {
    const ob = new MutationObserver(setVars);
    ob.observe(instance.subTree.el.parentNode, { childList: true });
    onUnmounted(() => ob.disconnect());
  });
}
function setVarsOnVNode(vnode, vars) {
  if (vnode.shapeFlag & 128) {
    const suspense = vnode.suspense;
    vnode = suspense.activeBranch;
    if (suspense.pendingBranch && !suspense.isHydrating) {
      suspense.effects.push(() => {
        setVarsOnVNode(suspense.activeBranch, vars);
      });
    }
  }
  while (vnode.component) {
    vnode = vnode.component.subTree;
  }
  if (vnode.shapeFlag & 1 && vnode.el) {
    setVarsOnNode(vnode.el, vars);
  } else if (vnode.type === Fragment) {
    vnode.children.forEach((c) => setVarsOnVNode(c, vars));
  } else if (vnode.type === Static) {
    let { el, anchor } = vnode;
    while (el) {
      setVarsOnNode(el, vars);
      if (el === anchor) break;
      el = el.nextSibling;
    }
  }
}
function setVarsOnNode(el, vars) {
  if (el.nodeType === 1) {
    const style = el.style;
    let cssText = "";
    for (const key in vars) {
      style.setProperty(`--${key}`, vars[key]);
      cssText += `--${key}: ${vars[key]};`;
    }
    style[CSS_VAR_TEXT] = cssText;
  }
}

const displayRE = /(^|;)\s*display\s*:/;
function patchStyle(el, prev, next) {
  const style = el.style;
  const isCssString = isString(next);
  let hasControlledDisplay = false;
  if (next && !isCssString) {
    if (prev) {
      if (!isString(prev)) {
        for (const key in prev) {
          if (next[key] == null) {
            setStyle(style, key, "");
          }
        }
      } else {
        for (const prevStyle of prev.split(";")) {
          const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
          if (next[key] == null) {
            setStyle(style, key, "");
          }
        }
      }
    }
    for (const key in next) {
      if (key === "display") {
        hasControlledDisplay = true;
      }
      setStyle(style, key, next[key]);
    }
  } else {
    if (isCssString) {
      if (prev !== next) {
        const cssVarText = style[CSS_VAR_TEXT];
        if (cssVarText) {
          next += ";" + cssVarText;
        }
        style.cssText = next;
        hasControlledDisplay = displayRE.test(next);
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
  }
  if (vShowOriginalDisplay in el) {
    el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
    if (el[vShowHidden]) {
      style.display = "none";
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
  if (isArray(val)) {
    val.forEach((v) => setStyle(style, name, v));
  } else {
    if (val == null) val = "";
    if (name.startsWith("--")) {
      style.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style, name);
      if (importantRE.test(val)) {
        style.setProperty(
          hyphenate$1(prefixed),
          val.replace(importantRE, ""),
          "important"
        );
      } else {
        style[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize$1(rawName);
  if (name !== "filter" && name in style) {
    return prefixCache[rawName] = name;
  }
  name = capitalize$1(name);
  for (let i = 0; i < prefixes.length; i++) {
    const prefixed = prefixes[i] + name;
    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}

const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance, isBoolean = isSpecialBooleanAttr(key)) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    if (value == null || isBoolean && !includeBooleanAttr(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(
        key,
        isBoolean ? "" : isSymbol(value) ? String(value) : value
      );
    }
  }
}

function patchDOMProp(el, key, value, parentComponent) {
  if (key === "innerHTML" || key === "textContent") {
    if (value != null) {
      el[key] = key === "innerHTML" ? unsafeToTrustedHTML(value) : value;
    }
    return;
  }
  const tag = el.tagName;
  if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
  !tag.includes("-")) {
    const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
    const newValue = value == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      el.type === "checkbox" ? "on" : ""
    ) : String(value);
    if (oldValue !== newValue || !("_value" in el)) {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key);
    }
    el._value = value;
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type === "string") {
      value = "";
      needRemove = true;
    } else if (type === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value;
  } catch (e) {
  }
  needRemove && el.removeAttribute(key);
}

function addEventListener(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
const veiKey = Symbol("_vei");
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el[veiKey] || (el[veiKey] = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(
        nextValue,
        instance
      );
      addEventListener(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m;
    while (m = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m[0].length);
      options[m[0].toLowerCase()] = true;
    }
  }
  const event = name[2] === ":" ? name.slice(3) : hyphenate$1(name.slice(2));
  return [event, options];
}
let cachedNow = 0;
const p = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = (e) => {
    if (!e._vts) {
      e._vts = Date.now();
    } else if (e._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(
      patchStopImmediatePropagation(e, invoker.value),
      instance,
      5,
      [e]
    );
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e, value) {
  if (isArray(value)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value.map(
      (fn) => (e2) => !e2._stopped && fn && fn(e2)
    );
  } else {
    return value;
  }
}

const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
const patchProp = (el, key, prevValue, nextValue, namespace, parentComponent) => {
  const isSVG = namespace === "svg";
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(el, key, nextValue);
    if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
      patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
    }
  } else if (
    // #11081 force set props for possible async custom element
    el._isVueCE && (/[A-Z]/.test(key) || !isString(nextValue))
  ) {
    patchDOMProp(el, camelize$1(key), nextValue);
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && isNativeOn(key) && isFunction(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (key === "width" || key === "height") {
    const tag = el.tagName;
    if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
      return false;
    }
  }
  if (isNativeOn(key) && isString(value)) {
    return false;
  }
  return key in el;
}

const REMOVAL = {};
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineCustomElement(options, extraOptions, _createApp) {
  const Comp = defineComponent(options, extraOptions);
  if (isPlainObject(Comp)) extend(Comp, extraOptions);
  class VueCustomElement extends VueElement {
    constructor(initialProps) {
      super(Comp, initialProps, _createApp);
    }
  }
  VueCustomElement.def = Comp;
  return VueCustomElement;
}
/*! #__NO_SIDE_EFFECTS__ */
const defineSSRCustomElement = /* @__NO_SIDE_EFFECTS__ */ (options, extraOptions) => {
  return /* @__PURE__ */ defineCustomElement(options, extraOptions, createSSRApp);
};
const BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
};
class VueElement extends BaseClass {
  constructor(_def, _props = {}, _createApp = createApp) {
    super();
    this._def = _def;
    this._props = _props;
    this._createApp = _createApp;
    this._isVueCE = true;
    /**
     * @internal
     */
    this._instance = null;
    /**
     * @internal
     */
    this._app = null;
    /**
     * @internal
     */
    this._nonce = this._def.nonce;
    this._connected = false;
    this._resolved = false;
    this._numberProps = null;
    this._styleChildren = /* @__PURE__ */ new WeakSet();
    this._ob = null;
    if (this.shadowRoot && _createApp !== createApp) {
      this._root = this.shadowRoot;
    } else {
      if (_def.shadowRoot !== false) {
        this.attachShadow({ mode: "open" });
        this._root = this.shadowRoot;
      } else {
        this._root = this;
      }
    }
    if (!this._def.__asyncLoader) {
      this._resolveProps(this._def);
    }
  }
  connectedCallback() {
    if (!this.isConnected) return;
    if (!this.shadowRoot) {
      this._parseSlots();
    }
    this._connected = true;
    let parent = this;
    while (parent = parent && (parent.parentNode || parent.host)) {
      if (parent instanceof VueElement) {
        this._parent = parent;
        break;
      }
    }
    if (!this._instance) {
      if (this._resolved) {
        this._setParent();
        this._update();
      } else {
        if (parent && parent._pendingResolve) {
          this._pendingResolve = parent._pendingResolve.then(() => {
            this._pendingResolve = void 0;
            this._resolveDef();
          });
        } else {
          this._resolveDef();
        }
      }
    }
  }
  _setParent(parent = this._parent) {
    if (parent) {
      this._instance.parent = parent._instance;
      this._instance.provides = parent._instance.provides;
    }
  }
  disconnectedCallback() {
    this._connected = false;
    nextTick(() => {
      if (!this._connected) {
        if (this._ob) {
          this._ob.disconnect();
          this._ob = null;
        }
        this._app && this._app.unmount();
        if (this._instance) this._instance.ce = void 0;
        this._app = this._instance = null;
      }
    });
  }
  /**
   * resolve inner component definition (handle possible async component)
   */
  _resolveDef() {
    if (this._pendingResolve) {
      return;
    }
    for (let i = 0; i < this.attributes.length; i++) {
      this._setAttr(this.attributes[i].name);
    }
    this._ob = new MutationObserver((mutations) => {
      for (const m of mutations) {
        this._setAttr(m.attributeName);
      }
    });
    this._ob.observe(this, { attributes: true });
    const resolve = (def, isAsync = false) => {
      this._resolved = true;
      this._pendingResolve = void 0;
      const { props, styles } = def;
      let numberProps;
      if (props && !isArray(props)) {
        for (const key in props) {
          const opt = props[key];
          if (opt === Number || opt && opt.type === Number) {
            if (key in this._props) {
              this._props[key] = toNumber(this._props[key]);
            }
            (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[camelize$1(key)] = true;
          }
        }
      }
      this._numberProps = numberProps;
      if (isAsync) {
        this._resolveProps(def);
      }
      if (this.shadowRoot) {
        this._applyStyles(styles);
      }
      this._mount(def);
    };
    const asyncDef = this._def.__asyncLoader;
    if (asyncDef) {
      this._pendingResolve = asyncDef().then(
        (def) => resolve(this._def = def, true)
      );
    } else {
      resolve(this._def);
    }
  }
  _mount(def) {
    if ((__VUE_PROD_DEVTOOLS__) && !def.name) {
      def.name = "VueElement";
    }
    this._app = this._createApp(def);
    if (def.configureApp) {
      def.configureApp(this._app);
    }
    this._app._ceVNode = this._createVNode();
    this._app.mount(this._root);
    const exposed = this._instance && this._instance.exposed;
    if (!exposed) return;
    for (const key in exposed) {
      if (!hasOwn(this, key)) {
        Object.defineProperty(this, key, {
          // unwrap ref to be consistent with public instance behavior
          get: () => unref(exposed[key])
        });
      }
    }
  }
  _resolveProps(def) {
    const { props } = def;
    const declaredPropKeys = isArray(props) ? props : Object.keys(props || {});
    for (const key of Object.keys(this)) {
      if (key[0] !== "_" && declaredPropKeys.includes(key)) {
        this._setProp(key, this[key]);
      }
    }
    for (const key of declaredPropKeys.map(camelize$1)) {
      Object.defineProperty(this, key, {
        get() {
          return this._getProp(key);
        },
        set(val) {
          this._setProp(key, val, true, true);
        }
      });
    }
  }
  _setAttr(key) {
    if (key.startsWith("data-v-")) return;
    const has = this.hasAttribute(key);
    let value = has ? this.getAttribute(key) : REMOVAL;
    const camelKey = camelize$1(key);
    if (has && this._numberProps && this._numberProps[camelKey]) {
      value = toNumber(value);
    }
    this._setProp(camelKey, value, false, true);
  }
  /**
   * @internal
   */
  _getProp(key) {
    return this._props[key];
  }
  /**
   * @internal
   */
  _setProp(key, val, shouldReflect = true, shouldUpdate = false) {
    if (val !== this._props[key]) {
      if (val === REMOVAL) {
        delete this._props[key];
      } else {
        this._props[key] = val;
        if (key === "key" && this._app) {
          this._app._ceVNode.key = val;
        }
      }
      if (shouldUpdate && this._instance) {
        this._update();
      }
      if (shouldReflect) {
        if (val === true) {
          this.setAttribute(hyphenate$1(key), "");
        } else if (typeof val === "string" || typeof val === "number") {
          this.setAttribute(hyphenate$1(key), val + "");
        } else if (!val) {
          this.removeAttribute(hyphenate$1(key));
        }
      }
    }
  }
  _update() {
    render$H(this._createVNode(), this._root);
  }
  _createVNode() {
    const baseProps = {};
    if (!this.shadowRoot) {
      baseProps.onVnodeMounted = baseProps.onVnodeUpdated = this._renderSlots.bind(this);
    }
    const vnode = createVNode(this._def, extend(baseProps, this._props));
    if (!this._instance) {
      vnode.ce = (instance) => {
        this._instance = instance;
        instance.ce = this;
        instance.isCE = true;
        const dispatch = (event, args) => {
          this.dispatchEvent(
            new CustomEvent(
              event,
              isPlainObject(args[0]) ? extend({ detail: args }, args[0]) : { detail: args }
            )
          );
        };
        instance.emit = (event, ...args) => {
          dispatch(event, args);
          if (hyphenate$1(event) !== event) {
            dispatch(hyphenate$1(event), args);
          }
        };
        this._setParent();
      };
    }
    return vnode;
  }
  _applyStyles(styles, owner) {
    if (!styles) return;
    if (owner) {
      if (owner === this._def || this._styleChildren.has(owner)) {
        return;
      }
      this._styleChildren.add(owner);
    }
    const nonce = this._nonce;
    for (let i = styles.length - 1; i >= 0; i--) {
      const s = document.createElement("style");
      if (nonce) s.setAttribute("nonce", nonce);
      s.textContent = styles[i];
      this.shadowRoot.prepend(s);
    }
  }
  /**
   * Only called when shadowRoot is false
   */
  _parseSlots() {
    const slots = this._slots = {};
    let n;
    while (n = this.firstChild) {
      const slotName = n.nodeType === 1 && n.getAttribute("slot") || "default";
      (slots[slotName] || (slots[slotName] = [])).push(n);
      this.removeChild(n);
    }
  }
  /**
   * Only called when shadowRoot is false
   */
  _renderSlots() {
    const outlets = (this._teleportTarget || this).querySelectorAll("slot");
    const scopeId = this._instance.type.__scopeId;
    for (let i = 0; i < outlets.length; i++) {
      const o = outlets[i];
      const slotName = o.getAttribute("name") || "default";
      const content = this._slots[slotName];
      const parent = o.parentNode;
      if (content) {
        for (const n of content) {
          if (scopeId && n.nodeType === 1) {
            const id = scopeId + "-s";
            const walker = document.createTreeWalker(n, 1);
            n.setAttribute(id, "");
            let child;
            while (child = walker.nextNode()) {
              child.setAttribute(id, "");
            }
          }
          parent.insertBefore(n, o);
        }
      } else {
        while (o.firstChild) parent.insertBefore(o.firstChild, o);
      }
      parent.removeChild(o);
    }
  }
  /**
   * @internal
   */
  _injectChildStyle(comp) {
    this._applyStyles(comp.styles, comp);
  }
  /**
   * @internal
   */
  _removeChildStyle(comp) {
  }
}
function useHost(caller) {
  const instance = getCurrentInstance();
  const el = instance && instance.ce;
  if (el) {
    return el;
  }
  return null;
}
function useShadowRoot() {
  const el = useHost();
  return el && el.shadowRoot;
}

function useCssModule(name = "$style") {
  {
    const instance = getCurrentInstance();
    if (!instance) {
      return EMPTY_OBJ;
    }
    const modules = instance.type.__cssModules;
    if (!modules) {
      return EMPTY_OBJ;
    }
    const mod = modules[name];
    if (!mod) {
      return EMPTY_OBJ;
    }
    return mod;
  }
}

const positionMap = /* @__PURE__ */ new WeakMap();
const newPositionMap = /* @__PURE__ */ new WeakMap();
const moveCbKey = Symbol("_moveCb");
const enterCbKey = Symbol("_enterCb");
const decorate = (t) => {
  delete t.props.mode;
  return t;
};
const TransitionGroupImpl = /* @__PURE__ */ decorate({
  name: "TransitionGroup",
  props: /* @__PURE__ */ extend({}, TransitionPropsValidators, {
    tag: String,
    moveClass: String
  }),
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevChildren;
    let children;
    onUpdated(() => {
      if (!prevChildren.length) {
        return;
      }
      const moveClass = props.moveClass || `${props.name || "v"}-move`;
      if (!hasCSSTransform(
        prevChildren[0].el,
        instance.vnode.el,
        moveClass
      )) {
        return;
      }
      prevChildren.forEach(callPendingCbs);
      prevChildren.forEach(recordPosition);
      const movedChildren = prevChildren.filter(applyTranslation);
      forceReflow();
      movedChildren.forEach((c) => {
        const el = c.el;
        const style = el.style;
        addTransitionClass(el, moveClass);
        style.transform = style.webkitTransform = style.transitionDuration = "";
        const cb = el[moveCbKey] = (e) => {
          if (e && e.target !== el) {
            return;
          }
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener("transitionend", cb);
            el[moveCbKey] = null;
            removeTransitionClass(el, moveClass);
          }
        };
        el.addEventListener("transitionend", cb);
      });
    });
    return () => {
      const rawProps = toRaw(props);
      const cssTransitionProps = resolveTransitionProps(rawProps);
      let tag = rawProps.tag || Fragment;
      prevChildren = [];
      if (children) {
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if (child.el && child.el instanceof Element) {
            prevChildren.push(child);
            setTransitionHooks(
              child,
              resolveTransitionHooks(
                child,
                cssTransitionProps,
                state,
                instance
              )
            );
            positionMap.set(
              child,
              child.el.getBoundingClientRect()
            );
          }
        }
      }
      children = slots.default ? getTransitionRawChildren(slots.default()) : [];
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (child.key != null) {
          setTransitionHooks(
            child,
            resolveTransitionHooks(child, cssTransitionProps, state, instance)
          );
        }
      }
      return createVNode(tag, null, children);
    };
  }
});
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c) {
  const el = c.el;
  if (el[moveCbKey]) {
    el[moveCbKey]();
  }
  if (el[enterCbKey]) {
    el[enterCbKey]();
  }
}
function recordPosition(c) {
  newPositionMap.set(c, c.el.getBoundingClientRect());
}
function applyTranslation(c) {
  const oldPos = positionMap.get(c);
  const newPos = newPositionMap.get(c);
  const dx = oldPos.left - newPos.left;
  const dy = oldPos.top - newPos.top;
  if (dx || dy) {
    const s = c.el.style;
    s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
    s.transitionDuration = "0s";
    return c;
  }
}
function hasCSSTransform(el, root, moveClass) {
  const clone = el.cloneNode();
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.forEach((cls) => {
      cls.split(/\s+/).forEach((c) => c && clone.classList.remove(c));
    });
  }
  moveClass.split(/\s+/).forEach((c) => c && clone.classList.add(c));
  clone.style.display = "none";
  const container = root.nodeType === 1 ? root : root.parentNode;
  container.appendChild(clone);
  const { hasTransform } = getTransitionInfo(clone);
  container.removeChild(clone);
  return hasTransform;
}

const getModelAssigner = (vnode) => {
  const fn = vnode.props["onUpdate:modelValue"] || false;
  return isArray(fn) ? (value) => invokeArrayFns(fn, value) : fn;
};
function onCompositionStart(e) {
  e.target.composing = true;
}
function onCompositionEnd(e) {
  const target = e.target;
  if (target.composing) {
    target.composing = false;
    target.dispatchEvent(new Event("input"));
  }
}
const assignKey = Symbol("_assign");
const vModelText = {
  created(el, { modifiers: { lazy, trim, number } }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    const castToNumber = number || vnode.props && vnode.props.type === "number";
    addEventListener(el, lazy ? "change" : "input", (e) => {
      if (e.target.composing) return;
      let domValue = el.value;
      if (trim) {
        domValue = domValue.trim();
      }
      if (castToNumber) {
        domValue = looseToNumber(domValue);
      }
      el[assignKey](domValue);
    });
    if (trim) {
      addEventListener(el, "change", () => {
        el.value = el.value.trim();
      });
    }
    if (!lazy) {
      addEventListener(el, "compositionstart", onCompositionStart);
      addEventListener(el, "compositionend", onCompositionEnd);
      addEventListener(el, "change", onCompositionEnd);
    }
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(el, { value }) {
    el.value = value == null ? "" : value;
  },
  beforeUpdate(el, { value, oldValue, modifiers: { lazy, trim, number } }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    if (el.composing) return;
    const elValue = (number || el.type === "number") && !/^0\d/.test(el.value) ? looseToNumber(el.value) : el.value;
    const newValue = value == null ? "" : value;
    if (elValue === newValue) {
      return;
    }
    if (document.activeElement === el && el.type !== "range") {
      if (lazy && value === oldValue) {
        return;
      }
      if (trim && el.value.trim() === newValue) {
        return;
      }
    }
    el.value = newValue;
  }
};
const vModelCheckbox = {
  // #4096 array checkboxes need to be deep traversed
  deep: true,
  created(el, _, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    addEventListener(el, "change", () => {
      const modelValue = el._modelValue;
      const elementValue = getValue(el);
      const checked = el.checked;
      const assign = el[assignKey];
      if (isArray(modelValue)) {
        const index = looseIndexOf(modelValue, elementValue);
        const found = index !== -1;
        if (checked && !found) {
          assign(modelValue.concat(elementValue));
        } else if (!checked && found) {
          const filtered = [...modelValue];
          filtered.splice(index, 1);
          assign(filtered);
        }
      } else if (isSet(modelValue)) {
        const cloned = new Set(modelValue);
        if (checked) {
          cloned.add(elementValue);
        } else {
          cloned.delete(elementValue);
        }
        assign(cloned);
      } else {
        assign(getCheckboxValue(el, checked));
      }
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: setChecked,
  beforeUpdate(el, binding, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    setChecked(el, binding, vnode);
  }
};
function setChecked(el, { value }, vnode) {
  el._modelValue = value;
  let checked;
  if (isArray(value)) {
    checked = looseIndexOf(value, vnode.props.value) > -1;
  } else if (isSet(value)) {
    checked = value.has(vnode.props.value);
  } else {
    checked = looseEqual(value, getCheckboxValue(el, true));
  }
  if (el.checked !== checked) {
    el.checked = checked;
  }
}
const vModelRadio = {
  created(el, { value }, vnode) {
    el.checked = looseEqual(value, vnode.props.value);
    el[assignKey] = getModelAssigner(vnode);
    addEventListener(el, "change", () => {
      el[assignKey](getValue(el));
    });
  },
  beforeUpdate(el, { value, oldValue }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    if (value !== oldValue) {
      el.checked = looseEqual(value, vnode.props.value);
    }
  }
};
const vModelSelect = {
  // <select multiple> value need to be deep traversed
  deep: true,
  created(el, { value, modifiers: { number } }, vnode) {
    const isSetModel = isSet(value);
    addEventListener(el, "change", () => {
      const selectedVal = Array.prototype.filter.call(el.options, (o) => o.selected).map(
        (o) => number ? looseToNumber(getValue(o)) : getValue(o)
      );
      el[assignKey](
        el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]
      );
      el._assigning = true;
      nextTick(() => {
        el._assigning = false;
      });
    });
    el[assignKey] = getModelAssigner(vnode);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(el, { value }) {
    setSelected(el, value);
  },
  beforeUpdate(el, _binding, vnode) {
    el[assignKey] = getModelAssigner(vnode);
  },
  updated(el, { value }) {
    if (!el._assigning) {
      setSelected(el, value);
    }
  }
};
function setSelected(el, value) {
  const isMultiple = el.multiple;
  const isArrayValue = isArray(value);
  if (isMultiple && !isArrayValue && !isSet(value)) {
    return;
  }
  for (let i = 0, l = el.options.length; i < l; i++) {
    const option = el.options[i];
    const optionValue = getValue(option);
    if (isMultiple) {
      if (isArrayValue) {
        const optionType = typeof optionValue;
        if (optionType === "string" || optionType === "number") {
          option.selected = value.some((v) => String(v) === String(optionValue));
        } else {
          option.selected = looseIndexOf(value, optionValue) > -1;
        }
      } else {
        option.selected = value.has(optionValue);
      }
    } else if (looseEqual(getValue(option), value)) {
      if (el.selectedIndex !== i) el.selectedIndex = i;
      return;
    }
  }
  if (!isMultiple && el.selectedIndex !== -1) {
    el.selectedIndex = -1;
  }
}
function getValue(el) {
  return "_value" in el ? el._value : el.value;
}
function getCheckboxValue(el, checked) {
  const key = checked ? "_trueValue" : "_falseValue";
  return key in el ? el[key] : checked;
}
const vModelDynamic = {
  created(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "created");
  },
  mounted(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "mounted");
  },
  beforeUpdate(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
  },
  updated(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "updated");
  }
};
function resolveDynamicModel(tagName, type) {
  switch (tagName) {
    case "SELECT":
      return vModelSelect;
    case "TEXTAREA":
      return vModelText;
    default:
      switch (type) {
        case "checkbox":
          return vModelCheckbox;
        case "radio":
          return vModelRadio;
        default:
          return vModelText;
      }
  }
}
function callModelHook(el, binding, vnode, prevVNode, hook) {
  const modelToUse = resolveDynamicModel(
    el.tagName,
    vnode.props && vnode.props.type
  );
  const fn = modelToUse[hook];
  fn && fn(el, binding, vnode, prevVNode);
}
function initVModelForSSR() {
  vModelText.getSSRProps = ({ value }) => ({ value });
  vModelRadio.getSSRProps = ({ value }, vnode) => {
    if (vnode.props && looseEqual(vnode.props.value, value)) {
      return { checked: true };
    }
  };
  vModelCheckbox.getSSRProps = ({ value }, vnode) => {
    if (isArray(value)) {
      if (vnode.props && looseIndexOf(value, vnode.props.value) > -1) {
        return { checked: true };
      }
    } else if (isSet(value)) {
      if (vnode.props && value.has(vnode.props.value)) {
        return { checked: true };
      }
    } else if (value) {
      return { checked: true };
    }
  };
  vModelDynamic.getSSRProps = (binding, vnode) => {
    if (typeof vnode.type !== "string") {
      return;
    }
    const modelToUse = resolveDynamicModel(
      // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
      vnode.type.toUpperCase(),
      vnode.props && vnode.props.type
    );
    if (modelToUse.getSSRProps) {
      return modelToUse.getSSRProps(binding, vnode);
    }
  };
}

const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: (e) => e.stopPropagation(),
  prevent: (e) => e.preventDefault(),
  self: (e) => e.target !== e.currentTarget,
  ctrl: (e) => !e.ctrlKey,
  shift: (e) => !e.shiftKey,
  alt: (e) => !e.altKey,
  meta: (e) => !e.metaKey,
  left: (e) => "button" in e && e.button !== 0,
  middle: (e) => "button" in e && e.button !== 1,
  right: (e) => "button" in e && e.button !== 2,
  exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
};
const withModifiers = (fn, modifiers) => {
  const cache = fn._withMods || (fn._withMods = {});
  const cacheKey = modifiers.join(".");
  return cache[cacheKey] || (cache[cacheKey] = (event, ...args) => {
    for (let i = 0; i < modifiers.length; i++) {
      const guard = modifierGuards[modifiers[i]];
      if (guard && guard(event, modifiers)) return;
    }
    return fn(event, ...args);
  });
};
const keyNames = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
};
const withKeys = (fn, modifiers) => {
  const cache = fn._withKeys || (fn._withKeys = {});
  const cacheKey = modifiers.join(".");
  return cache[cacheKey] || (cache[cacheKey] = (event) => {
    if (!("key" in event)) {
      return;
    }
    const eventKey = hyphenate$1(event.key);
    if (modifiers.some(
      (k) => k === eventKey || keyNames[k] === eventKey
    )) {
      return fn(event);
    }
  });
};

const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
let renderer;
let enabledHydration = false;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
function ensureHydrationRenderer() {
  renderer = enabledHydration ? renderer : createHydrationRenderer(rendererOptions);
  enabledHydration = true;
  return renderer;
}
const render$H = (...args) => {
  ensureRenderer().render(...args);
};
const hydrate = (...args) => {
  ensureHydrationRenderer().hydrate(...args);
};
const createApp = (...args) => {
  const app = ensureRenderer().createApp(...args);
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container) return;
    const component = app._component;
    if (!isFunction(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    if (container.nodeType === 1) {
      container.textContent = "";
    }
    const proxy = mount(container, false, resolveRootNamespace(container));
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app;
};
const createSSRApp = (...args) => {
  const app = ensureHydrationRenderer().createApp(...args);
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (container) {
      return mount(container, true, resolveRootNamespace(container));
    }
  };
  return app;
};
function resolveRootNamespace(container) {
  if (container instanceof SVGElement) {
    return "svg";
  }
  if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
    return "mathml";
  }
}
function normalizeContainer(container) {
  if (isString(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}
let ssrDirectiveInitialized = false;
const initDirectivesForSSR = () => {
  if (!ssrDirectiveInitialized) {
    ssrDirectiveInitialized = true;
    initVModelForSSR();
    initVShowForSSR();
  }
} ;

var runtimeDom_esmBundler = /*#__PURE__*/Object.freeze({
  __proto__: null,
  BaseTransition: BaseTransition,
  BaseTransitionPropsValidators: BaseTransitionPropsValidators,
  Comment: Comment,
  DeprecationTypes: DeprecationTypes,
  EffectScope: EffectScope,
  ErrorCodes: ErrorCodes,
  ErrorTypeStrings: ErrorTypeStrings,
  Fragment: Fragment,
  KeepAlive: KeepAlive,
  ReactiveEffect: ReactiveEffect,
  Static: Static,
  Suspense: Suspense,
  Teleport: Teleport,
  Text: Text,
  TrackOpTypes: TrackOpTypes,
  Transition: Transition,
  TransitionGroup: TransitionGroup,
  TriggerOpTypes: TriggerOpTypes,
  VueElement: VueElement,
  assertNumber: assertNumber,
  callWithAsyncErrorHandling: callWithAsyncErrorHandling,
  callWithErrorHandling: callWithErrorHandling,
  camelize: camelize$1,
  capitalize: capitalize$1,
  cloneVNode: cloneVNode,
  compatUtils: compatUtils,
  computed: computed,
  createApp: createApp,
  createBlock: createBlock,
  createCommentVNode: createCommentVNode,
  createElementBlock: createElementBlock,
  createElementVNode: createBaseVNode,
  createHydrationRenderer: createHydrationRenderer,
  createPropsRestProxy: createPropsRestProxy,
  createRenderer: createRenderer,
  createSSRApp: createSSRApp,
  createSlots: createSlots,
  createStaticVNode: createStaticVNode,
  createTextVNode: createTextVNode,
  createVNode: createVNode,
  customRef: customRef,
  defineAsyncComponent: defineAsyncComponent,
  defineComponent: defineComponent,
  defineCustomElement: defineCustomElement,
  defineEmits: defineEmits,
  defineExpose: defineExpose,
  defineModel: defineModel,
  defineOptions: defineOptions,
  defineProps: defineProps,
  defineSSRCustomElement: defineSSRCustomElement,
  defineSlots: defineSlots,
  devtools: devtools,
  effect: effect,
  effectScope: effectScope,
  getCurrentInstance: getCurrentInstance,
  getCurrentScope: getCurrentScope,
  getCurrentWatcher: getCurrentWatcher,
  getTransitionRawChildren: getTransitionRawChildren,
  guardReactiveProps: guardReactiveProps,
  h: h,
  handleError: handleError,
  hasInjectionContext: hasInjectionContext,
  hydrate: hydrate,
  hydrateOnIdle: hydrateOnIdle,
  hydrateOnInteraction: hydrateOnInteraction,
  hydrateOnMediaQuery: hydrateOnMediaQuery,
  hydrateOnVisible: hydrateOnVisible,
  initCustomFormatter: initCustomFormatter,
  initDirectivesForSSR: initDirectivesForSSR,
  inject: inject,
  isMemoSame: isMemoSame,
  isProxy: isProxy,
  isReactive: isReactive,
  isReadonly: isReadonly,
  isRef: isRef,
  isRuntimeOnly: isRuntimeOnly,
  isShallow: isShallow,
  isVNode: isVNode,
  markRaw: markRaw,
  mergeDefaults: mergeDefaults,
  mergeModels: mergeModels,
  mergeProps: mergeProps,
  nextTick: nextTick,
  normalizeClass: normalizeClass,
  normalizeProps: normalizeProps,
  normalizeStyle: normalizeStyle,
  onActivated: onActivated,
  onBeforeMount: onBeforeMount,
  onBeforeUnmount: onBeforeUnmount,
  onBeforeUpdate: onBeforeUpdate,
  onDeactivated: onDeactivated,
  onErrorCaptured: onErrorCaptured,
  onMounted: onMounted,
  onRenderTracked: onRenderTracked,
  onRenderTriggered: onRenderTriggered,
  onScopeDispose: onScopeDispose,
  onServerPrefetch: onServerPrefetch,
  onUnmounted: onUnmounted,
  onUpdated: onUpdated,
  onWatcherCleanup: onWatcherCleanup,
  openBlock: openBlock,
  popScopeId: popScopeId,
  provide: provide,
  proxyRefs: proxyRefs,
  pushScopeId: pushScopeId,
  queuePostFlushCb: queuePostFlushCb,
  reactive: reactive,
  readonly: readonly,
  ref: ref,
  registerRuntimeCompiler: registerRuntimeCompiler,
  render: render$H,
  renderList: renderList,
  renderSlot: renderSlot,
  resolveComponent: resolveComponent,
  resolveDirective: resolveDirective,
  resolveDynamicComponent: resolveDynamicComponent,
  resolveFilter: resolveFilter,
  resolveTransitionHooks: resolveTransitionHooks,
  setBlockTracking: setBlockTracking,
  setDevtoolsHook: setDevtoolsHook,
  setTransitionHooks: setTransitionHooks,
  shallowReactive: shallowReactive,
  shallowReadonly: shallowReadonly,
  shallowRef: shallowRef,
  ssrContextKey: ssrContextKey,
  ssrUtils: ssrUtils,
  stop: stop,
  toDisplayString: toDisplayString,
  toHandlerKey: toHandlerKey$1,
  toHandlers: toHandlers,
  toRaw: toRaw,
  toRef: toRef,
  toRefs: toRefs,
  toValue: toValue,
  transformVNodeArgs: transformVNodeArgs,
  triggerRef: triggerRef,
  unref: unref,
  useAttrs: useAttrs,
  useCssModule: useCssModule,
  useCssVars: useCssVars,
  useHost: useHost,
  useId: useId,
  useModel: useModel,
  useSSRContext: useSSRContext,
  useShadowRoot: useShadowRoot,
  useSlots: useSlots,
  useTemplateRef: useTemplateRef,
  useTransitionState: useTransitionState,
  vModelCheckbox: vModelCheckbox,
  vModelDynamic: vModelDynamic,
  vModelRadio: vModelRadio,
  vModelSelect: vModelSelect,
  vModelText: vModelText,
  vShow: vShow,
  version: version$1,
  warn: warn,
  watch: watch,
  watchEffect: watchEffect,
  watchPostEffect: watchPostEffect,
  watchSyncEffect: watchSyncEffect,
  withAsyncContext: withAsyncContext,
  withCtx: withCtx,
  withDefaults: withDefaults,
  withDirectives: withDirectives,
  withKeys: withKeys,
  withMemo: withMemo,
  withModifiers: withModifiers,
  withScopeId: withScopeId
});

var require$$1 = /*@__PURE__*/getAugmentedNamespace(runtimeDom_esmBundler);

var require$$2 = /*@__PURE__*/getAugmentedNamespace(shared_esmBundler);

/**
* vue v3.5.10
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/

(function (exports) {

	Object.defineProperty(exports, '__esModule', { value: true });

	var compilerDom = require$$0;
	var runtimeDom = require$$1;
	var shared = require$$2;

	function _interopNamespaceDefault(e) {
	  var n = Object.create(null);
	  if (e) {
	    for (var k in e) {
	      n[k] = e[k];
	    }
	  }
	  n.default = e;
	  return Object.freeze(n);
	}

	var runtimeDom__namespace = /*#__PURE__*/_interopNamespaceDefault(runtimeDom);

	const compileCache = /* @__PURE__ */ Object.create(null);
	function compileToFunction(template, options) {
	  if (!shared.isString(template)) {
	    if (template.nodeType) {
	      template = template.innerHTML;
	    } else {
	      runtimeDom.warn(`invalid template option: `, template);
	      return shared.NOOP;
	    }
	  }
	  const key = shared.genCacheKey(template, options);
	  const cached = compileCache[key];
	  if (cached) {
	    return cached;
	  }
	  if (template[0] === "#") {
	    const el = document.querySelector(template);
	    if (!el) {
	      runtimeDom.warn(`Template element not found or is empty: ${template}`);
	    }
	    template = el ? el.innerHTML : ``;
	  }
	  const opts = shared.extend(
	    {
	      hoistStatic: true,
	      onError: onError ,
	      onWarn: (e) => onError(e, true) 
	    },
	    options
	  );
	  if (!opts.isCustomElement && typeof customElements !== "undefined") {
	    opts.isCustomElement = (tag) => !!customElements.get(tag);
	  }
	  const { code } = compilerDom.compile(template, opts);
	  function onError(err, asWarning = false) {
	    const message = asWarning ? err.message : `Template compilation error: ${err.message}`;
	    const codeFrame = err.loc && shared.generateCodeFrame(
	      template,
	      err.loc.start.offset,
	      err.loc.end.offset
	    );
	    runtimeDom.warn(codeFrame ? `${message}
${codeFrame}` : message);
	  }
	  const render = new Function("Vue", code)(runtimeDom__namespace);
	  render._rc = true;
	  return compileCache[key] = render;
	}
	runtimeDom.registerRuntimeCompiler(compileToFunction);

	exports.compile = compileToFunction;
	Object.keys(runtimeDom).forEach(function (k) {
	  if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) exports[k] = runtimeDom[k];
	}); 
} (vue_cjs));

function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}

function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}

function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}

function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

function ownKeys$8(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$8(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$8(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$8(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }

/**
 * +/- function to native math sign
 */
function signPoly(value) {
  if (value < 0) return -1;
  return value > 0 ? 1 : 0;
}
var sign = Math.sign || signPoly;

/**
 * Checks if the flag is set
 * @param val
 * @param flag
 * @returns {boolean}
 */
function hasFlag(val, flag) {
  return (val & flag) === flag;
}

/**
 * Native modulo bug with negative numbers
 * @param n
 * @param mod
 * @returns {number}
 */
function mod(n, mod) {
  return (n % mod + mod) % mod;
}

/**
 * Asserts a value is beetween min and max
 * @param val
 * @param min
 * @param max
 * @returns {number}
 */
function bound(val, min, max) {
  return Math.max(min, Math.min(max, val));
}

/**
 * Get value of an object property/path even if it's nested
 */
function getValueByPath(obj, path) {
  return path.split('.').reduce(function (o, i) {
    return o ? o[i] : null;
  }, obj);
}

/**
 * Extension of indexOf method by equality function if specified
 */
function indexOf(array, obj, fn) {
  if (!array) return -1;
  if (!fn || typeof fn !== 'function') return array.indexOf(obj);
  for (var i = 0; i < array.length; i++) {
    if (fn(array[i], obj)) {
      return i;
    }
  }
  return -1;
}

/**
 * Merge function to replace Object.assign with deep merging possibility
 */
var isObject = function isObject(item) {
  return _typeof(item) === 'object' && !Array.isArray(item);
};
var mergeFn = function mergeFn(target, source) {
  var deep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  if (deep || !Object.assign) {
    var isDeep = function isDeep(prop) {
      return isObject(source[prop]) && target !== null && Object.prototype.hasOwnProperty.call(target, prop) && isObject(target[prop]);
    };
    var replaced = Object.getOwnPropertyNames(source).map(function (prop) {
      return _defineProperty({}, prop, isDeep(prop) ? mergeFn(target[prop], source[prop], deep) : source[prop]);
    }).reduce(function (a, b) {
      return _objectSpread$8(_objectSpread$8({}, a), b);
    }, {});
    return _objectSpread$8(_objectSpread$8({}, target), replaced);
  } else {
    return Object.assign(target, source);
  }
};
var merge = mergeFn;

/**
 * Mobile detection
 * https://www.abeautifulsite.net/detecting-mobile-devices-with-javascript
 */
var isMobile = {
  Android: function Android() {
    return typeof window !== 'undefined' && window.navigator.userAgent.match(/Android/i);
  },
  BlackBerry: function BlackBerry() {
    return typeof window !== 'undefined' && window.navigator.userAgent.match(/BlackBerry/i);
  },
  iOS: function iOS() {
    return typeof window !== 'undefined' && (window.navigator.userAgent.match(/iPhone|iPad|iPod/i) || window.navigator.platform === 'MacIntel' && window.navigator.maxTouchPoints > 1);
  },
  Opera: function Opera() {
    return typeof window !== 'undefined' && window.navigator.userAgent.match(/Opera Mini/i);
  },
  Windows: function Windows() {
    return typeof window !== 'undefined' && window.navigator.userAgent.match(/IEMobile/i);
  },
  any: function any() {
    return isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows();
  }
};
function removeElement(el) {
  if (typeof el.remove !== 'undefined') {
    el.remove();
  } else if (typeof el.parentNode !== 'undefined' && el.parentNode !== null) {
    el.parentNode.removeChild(el);
  }
}
function createAbsoluteElement(el) {
  var root = document.createElement('div');
  root.style.position = 'absolute';
  root.style.left = '0px';
  root.style.top = '0px';
  root.style.width = '100%';
  var wrapper = document.createElement('div');
  root.appendChild(wrapper);
  wrapper.appendChild(el);
  document.body.appendChild(root);
  return root;
}
function isVueComponent(c) {
  return c && c.$ != null && c.$.vnode != null;
}

/**
 * Escape regex characters
 * http://stackoverflow.com/a/6969486
 */
function escapeRegExpChars(value) {
  if (!value) return value;

  // eslint-disable-next-line
  return value.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
}
/**
 * Remove accents/diacritics in a string in JavaScript
 * https://stackoverflow.com/a/37511463
 */
function removeDiacriticsFromString(value) {
  if (!value) return value;
  return value.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
}
function multiColumnSort(inputArray, sortingPriority) {
  // NOTE: this function is intended to be used by BTable
  // clone it to prevent the any watchers from triggering every sorting iteration
  var array = JSON.parse(JSON.stringify(inputArray));
  var fieldSorter = function fieldSorter(fields) {
    return function (a, b) {
      return fields.map(function (o) {
        var field = o.field,
          order = o.order,
          customSort = o.customSort;
        if (typeof customSort === 'function') {
          return customSort(a, b, order !== 'desc');
        } else {
          var aValue = getValueByPath(a, field);
          var bValue = getValueByPath(b, field);
          var ord = aValue > bValue ? 1 : aValue < bValue ? -1 : 0;
          return order === 'desc' ? -ord : ord;
        }
      }).reduce(function (p, n) {
        return p || n;
      }, 0);
    };
  };
  return array.sort(fieldSorter(sortingPriority));
}
function toCssWidth(width) {
  return width === undefined ? null : isNaN(width) ? width : width + 'px';
}

/**
 * Return month names according to a specified locale
 * @param  {String} locale A bcp47 localerouter. undefined will use the user browser locale
 * @param  {String} format long (ex. March), short (ex. Mar) or narrow (M)
 * @return {Array<String>} An array of month names
 */
function getMonthNames() {
  var locale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
  var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'long';
  var dates = [];
  for (var i = 0; i < 12; i++) {
    dates.push(new Date(2000, i, 15));
  }
  var dtf = new Intl.DateTimeFormat(locale, {
    month: format
  });
  return dates.map(function (d) {
    return dtf.format(d);
  });
}

/**
 * Return weekday names according to a specified locale
 * @param  {String} locale A bcp47 localerouter. undefined will use the user browser locale
 * @param  {String} format long (ex. Thursday), short (ex. Thu) or narrow (T)
 * @return {Array<String>} An array of weekday names
 */
function getWeekdayNames() {
  var locale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
  var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'narrow';
  var dates = [];
  for (var i = 0; i < 7; i++) {
    var dt = new Date(2000, 0, i + 1);
    dates[dt.getDay()] = dt;
  }
  var dtf = new Intl.DateTimeFormat(locale, {
    weekday: format
  });
  return dates.map(function (d) {
    return dtf.format(d);
  });
}

/**
 * Accept a regex with group names and return an object
 * ex. matchWithGroups(/((?!=<year>)\d+)\/((?!=<month>)\d+)\/((?!=<day>)\d+)/, '2000/12/25')
 * will return { year: 2000, month: 12, day: 25 }
 * @param  {String} includes injections of (?!={groupname}) for each group
 * @param  {String} the string to run regex
 * @return {Object} an object with a property for each group having the group's match as the value
 */
function matchWithGroups(pattern, str) {
  var matches = str.match(pattern);
  return pattern
  // get the pattern as a string
  .toString()
  // suss out the groups
  .match(/<(.+?)>/g)
  // remove the braces
  .map(function (group) {
    var groupMatches = group.match(/<(.+)>/);
    if (!groupMatches || groupMatches.length <= 0) {
      return null;
    }
    return group.match(/<(.+)>/)[1];
  })
  // create an object with a property for each group having the group's match as the value
  .reduce(function (acc, curr, index, arr) {
    if (matches && matches.length > index) {
      acc[curr] = matches[index + 1];
    } else {
      acc[curr] = null;
    }
    return acc;
  }, {});
}

/**
 * Based on
 * https://github.com/fregante/supports-webp
 */
function isWebpSupported() {
  return new Promise(function (resolve) {
    var image = new Image();
    image.onerror = function () {
      return resolve(false);
    };
    image.onload = function () {
      return resolve(image.width === 1);
    };
    image.src = 'data:image/webp;base64,UklGRiQAAABXRUJQVlA4IBgAAAAwAQCdASoBAAEAAwA0JaQAA3AA/vuUAAA=';
  })["catch"](function () {
    return false;
  });
}
function isCustomElement(vm) {
  return 'shadowRoot' in vm.$root.$options;
}
var isDefined = function isDefined(d) {
  return d !== undefined;
};

/**
 * Checks if a value is null or undefined.
 * Based on
 * https://github.com/lodash/lodash/blob/master/isNil.js
 */
var isNil = function isNil(value) {
  return value === null || value === undefined;
};
function isFragment(vnode) {
  return vnode.type === Fragment;
}

// TODO: replacement of vnode.tag test
function isTag(vnode) {
  return vnode.type !== Comment && vnode.type !== Text && vnode.type !== Static;
}

// references
// - https://github.com/vuejs/core/blob/1c525f75a3d17a6356d5f66765623c0ae7c0ebcc/packages/runtime-core/src/apiCreateApp.ts#L361
// - https://github.com/vuejs/core/blob/1c525f75a3d17a6356d5f66765623c0ae7c0ebcc/packages/runtime-core/src/component.ts#L1036-L1054
//
// we cannot access getExposeProxy since it is not exported from `vue`, though,
// its purpose seems to be one-time initialization of component.exposeProxy,
// which should have been done by this function call
function getComponentFromVNode(vnode) {
  if (!vnode) {
    return undefined;
  }
  var component = vnode.component;
  if (!component) {
    return undefined;
  }
  return component.exposed && component.exposeProxy || component.proxy;
}

// Copies the context from a given app to another app.
//
// This function is necessary to programmatically mount a component; e.g.,
// Modal.
// Since Vue 3's app can mount only one component, we have to create a new app
// to mount another new component.
// If we create a new app with `createApp` API, no context (e.g., installed
// components, directives) is available on the new app.
// This function can copy the context from the host app to the new app.
//
// Depends on what Vue internally does: https://github.com/vuejs/core/blob/b775b71c788499ec7ee58bc2cf4cd04ed388e072/packages/runtime-core/src/apiCreateApp.ts#L170-L190
//
// This function also should take care of compatiblity with other plugins.
// We need a generic solution, though, it fixes compatiblity issues of
// individual plugins for now.
function copyAppContext(src, dest) {
  // replacing _context won't work because methods of app bypasses app._context
  var srcContext = src._context;
  var destContext = dest._context;
  destContext.config = srcContext.config;
  destContext.mixins = srcContext.mixins;
  destContext.components = srcContext.components;
  destContext.directives = srcContext.directives;
  destContext.provides = srcContext.provides;
  destContext.optionsCache = srcContext.optionsCache;
  destContext.propsCache = srcContext.propsCache;
  destContext.emitsCache = srcContext.emitsCache;
  // vue-i18n support: https://github.com/ntohq/buefy-next/issues/153
  if ('__VUE_I18N_SYMBOL__' in src) {
    dest.__VUE_I18N_SYMBOL__ = src.__VUE_I18N_SYMBOL__;
  }
}

/**
 * Translates a touch event as a drag event.
 *
 * `event` must be a touch event.
 *
 * `options` must be an object with the following properties:
 * - `type`: new event type (required). must be one of the following:
 *     - `"dragstart"`
 *     - `"dragend"`
 *     - `"drop"`
 *     - `"dragover"`
 *     - `"dragleave"`
 * - `target`: new target element (optional). `clientX` and `clientY` will be
 *   translated if `target` is different from `event.target`.
 *
 * This function only works with single-touch events for now.
 */
var translateTouchAsDragEvent = function translateTouchAsDragEvent(event, options) {
  var type = options.type,
    target = options.target;
  var translateX = 0;
  var translateY = 0;
  if (target != null && target !== event.target) {
    var baseRect = event.target.getBoundingClientRect();
    var targetRect = target.getBoundingClientRect();
    translateX = targetRect.left - baseRect.left;
    translateY = targetRect.top - baseRect.top;
  }
  var touch = event.touches[0] || event.changedTouches[0];
  return new DragEvent(type, {
    dataTransfer: new DataTransfer(),
    bubbles: true,
    screenX: touch.screenX,
    screenY: touch.screenY,
    clientX: touch.clientX + translateX,
    clientY: touch.clientY + translateY,
    ctrlKey: event.ctrlKey,
    shiftKey: event.shiftKey,
    altKey: event.altKey,
    metaKey: event.metaKey
  });
};

var config = {
  defaultContainerElement: null,
  defaultIconPack: 'mdi',
  defaultIconComponent: null,
  defaultIconPrev: 'chevron-left',
  defaultIconNext: 'chevron-right',
  defaultLocale: undefined,
  defaultDialogConfirmText: null,
  defaultDialogCancelText: null,
  defaultSnackbarDuration: 3500,
  defaultSnackbarPosition: null,
  defaultToastDuration: 2000,
  defaultToastPosition: null,
  defaultNotificationDuration: 2000,
  defaultNotificationPosition: null,
  defaultTooltipType: 'is-primary',
  defaultTooltipDelay: null,
  defaultTooltipCloseDelay: null,
  defaultSidebarDelay: null,
  defaultInputAutocomplete: 'on',
  defaultDateFormatter: null,
  defaultDateParser: null,
  defaultDateCreator: null,
  defaultTimeCreator: null,
  defaultDayNames: null,
  defaultMonthNames: null,
  defaultFirstDayOfWeek: null,
  defaultUnselectableDaysOfWeek: null,
  defaultTimeFormatter: null,
  defaultTimeParser: null,
  defaultModalCanCancel: ['escape', 'x', 'outside', 'button'],
  defaultModalScroll: null,
  defaultDatepickerMobileNative: true,
  defaultTimepickerMobileNative: true,
  defaultTimepickerMobileModal: true,
  defaultNoticeQueue: true,
  defaultInputHasCounter: true,
  /**
   * Whether `class`, `style`, and `id` are applied to the root element in
   * components that are affected by Vue 3 change in fallthgourh beahvior.
   * See: https://github.com/ntohq/buefy-next/issues/16
   */
  defaultCompatFallthrough: true,
  defaultTaginputHasCounter: true,
  defaultUseHtml5Validation: true,
  defaultDropdownMobileModal: true,
  defaultFieldLabelPosition: null,
  defaultDatepickerYearsRange: [-100, 10],
  defaultDatepickerNearbyMonthDays: true,
  defaultDatepickerNearbySelectableMonthDays: false,
  defaultDatepickerShowWeekNumber: false,
  defaultDatepickerWeekNumberClickable: false,
  defaultDatepickerMobileModal: true,
  defaultTrapFocus: true,
  defaultAutoFocus: true,
  defaultButtonRounded: false,
  defaultSwitchRounded: true,
  defaultCarouselInterval: 3500,
  defaultTabsExpanded: false,
  defaultTabsAnimated: true,
  defaultTabsType: null,
  defaultStatusIcon: true,
  defaultProgrammaticPromise: false,
  defaultLinkTags: ['a', 'button', 'input', 'router-link', 'nuxt-link', 'n-link', 'RouterLink', 'NuxtLink', 'NLink'],
  defaultImageWebpFallback: null,
  defaultImageLazy: true,
  defaultImageResponsive: true,
  defaultImageRatio: null,
  defaultImageSrcsetFormatter: null,
  defaultBreadcrumbTag: 'a',
  defaultBreadcrumbAlign: 'is-left',
  defaultBreadcrumbSeparator: '',
  defaultBreadcrumbSize: 'is-medium',
  customIconPacks: null
};
var setOptions = function setOptions(options) {
  config = options;
};

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}

var _excluded = ["style", "class", "id"];
var CompatFallthroughMixin = {
  inheritAttrs: false,
  props: {
    compatFallthrough: {
      type: Boolean,
      "default": function _default() {
        return config.defaultCompatFallthrough;
      }
    }
  },
  computed: {
    rootAttrs: function rootAttrs() {
      return this.compatFallthrough ? {
        "class": this.$attrs["class"],
        style: this.$attrs.style,
        id: this.$attrs.id
      } : {};
    },
    fallthroughAttrs: function fallthroughAttrs() {
      if (this.compatFallthrough) {
        var _this$$attrs = this.$attrs;
          _this$$attrs.style;
          _this$$attrs["class"];
          _this$$attrs.id;
          var rest = _objectWithoutProperties(_this$$attrs, _excluded);
        return rest;
      } else {
        return this.$attrs;
      }
    }
  }
};

var FormElementMixin = {
  props: {
    size: String,
    expanded: Boolean,
    loading: Boolean,
    rounded: Boolean,
    icon: String,
    iconPack: String,
    // Native options to use in HTML5 validation
    autocomplete: String,
    maxlength: [Number, String],
    useHtml5Validation: {
      type: Boolean,
      "default": function _default() {
        return config.defaultUseHtml5Validation;
      }
    },
    validationMessage: String,
    locale: {
      type: [String, Array],
      "default": function _default() {
        return config.defaultLocale;
      }
    },
    statusIcon: {
      type: Boolean,
      "default": function _default() {
        return config.defaultStatusIcon;
      }
    }
  },
  emits: ['blur', 'focus'],
  data: function data() {
    return {
      isValid: true,
      isFocused: false,
      newIconPack: this.iconPack || config.defaultIconPack
    };
  },
  computed: {
    /**
     * Find parent Field, max 3 levels deep.
     */
    parentField: function parentField() {
      var parent = this.$parent;
      for (var i = 0; i < 3; i++) {
        if (parent && !parent.$data._isField) {
          parent = parent.$parent;
        }
      }
      return parent;
    },
    /**
     * Get the type prop from parent if it's a Field.
     */
    statusType: function statusType() {
      var _ref = this.parentField || {},
        newType = _ref.newType;
      if (!newType) return;
      if (typeof newType === 'string') {
        return newType;
      } else {
        for (var key in newType) {
          if (newType[key]) {
            return key;
          }
        }
      }
    },
    /**
     * Get the message prop from parent if it's a Field.
     */
    statusMessage: function statusMessage() {
      if (!this.parentField) return;
      return this.parentField.newMessage || this.parentField.$slots.message;
    },
    /**
     * Fix icon size for inputs, large was too big
     */
    iconSize: function iconSize() {
      switch (this.size) {
        case 'is-small':
          return this.size;
        case 'is-medium':
          return;
        case 'is-large':
          return this.newIconPack === 'mdi' ? 'is-medium' : '';
      }
    }
  },
  methods: {
    /**
     * Focus method that work dynamically depending on the component.
     */
    focus: function focus() {
      var el = this.getElement();
      if (el === undefined) return;
      this.$nextTick(function () {
        if (el) el.focus();
      });
    },
    onBlur: function onBlur($event) {
      this.isFocused = false;
      this.$emit('blur', $event);
      this.checkHtml5Validity();
    },
    onFocus: function onFocus($event) {
      this.isFocused = true;
      this.$emit('focus', $event);
    },
    getElement: function getElement() {
      var el = this.$refs[this.$data._elementRef];
      while (el != null && '$refs' in el) {
        el = el.$refs[el.$data._elementRef];
      }
      return el;
    },
    setInvalid: function setInvalid() {
      var type = 'is-danger';
      var message = this.validationMessage || this.getElement().validationMessage;
      this.setValidity(type, message);
    },
    setValidity: function setValidity(type, message) {
      var _this = this;
      this.$nextTick(function () {
        if (_this.parentField) {
          // Set type only if not defined
          if (!_this.parentField.type) {
            _this.parentField.newType = type;
          }
          // Set message only if not defined
          if (!_this.parentField.message) {
            _this.parentField.newMessage = message;
          }
        }
      });
    },
    /**
     * Check HTML5 validation, set isValid property.
     * If validation fail, send 'is-danger' type,
     * and error message to parent if it's a Field.
     */
    checkHtml5Validity: function checkHtml5Validity() {
      if (!this.useHtml5Validation) return;
      var el = this.getElement();
      if (el == null) return;
      if (!el.checkValidity()) {
        this.setInvalid();
        this.isValid = false;
      } else {
        this.setValidity(null, null);
        this.isValid = true;
      }
      return this.isValid;
    }
  }
};

var mdiIcons = {
  sizes: {
    "default": 'mdi-24px',
    'is-small': null,
    'is-medium': 'mdi-36px',
    'is-large': 'mdi-48px'
  },
  iconPrefix: 'mdi-'
};
var faIcons = function faIcons() {
  var faIconPrefix = config && config.defaultIconComponent ? '' : 'fa-';
  return {
    sizes: {
      "default": null,
      'is-small': null,
      'is-medium': faIconPrefix + 'lg',
      'is-large': faIconPrefix + '2x'
    },
    iconPrefix: faIconPrefix,
    internalIcons: {
      information: 'info-circle',
      alert: 'exclamation-triangle',
      'alert-circle': 'exclamation-circle',
      'chevron-right': 'angle-right',
      'chevron-left': 'angle-left',
      'chevron-down': 'angle-down',
      'eye-off': 'eye-slash',
      'menu-down': 'caret-down',
      'menu-up': 'caret-up',
      'close-circle': 'times-circle'
    }
  };
};
var getIcons = function getIcons() {
  var icons = {
    mdi: mdiIcons,
    fa: faIcons(),
    fas: faIcons(),
    far: faIcons(),
    fad: faIcons(),
    fab: faIcons(),
    fal: faIcons(),
    'fa-solid': faIcons(),
    'fa-regular': faIcons(),
    'fa-light': faIcons(),
    'fa-thin': faIcons(),
    'fa-duotone': faIcons(),
    'fa-brands': faIcons()
  };
  if (config && config.customIconPacks) {
    icons = merge(icons, config.customIconPacks, true);
  }
  return icons;
};
var getIcons$1 = getIcons;

var script$I = {
    name: 'BIcon',
    props: {
        type: [String, Object],
        component: String,
        pack: String,
        icon: String,
        size: String,
        customSize: String,
        customClass: String,
        both: Boolean // This is used internally to show both MDI and FA icon
    },
    computed: {
        iconConfig() {
            const allIcons = getIcons$1();
            return allIcons[this.newPack]
        },
        iconPrefix() {
            if (this.iconConfig && this.iconConfig.iconPrefix) {
                return this.iconConfig.iconPrefix
            }
            return ''
        },
        /**
        * Internal icon name based on the pack.
        * If pack is 'fa', gets the equivalent FA icon name of the MDI,
        * internal icons are always MDI.
        */
        newIcon() {
            return `${this.iconPrefix}${this.getEquivalentIconOf(this.icon)}`
        },
        newPack() {
            return this.pack || config.defaultIconPack
        },
        newType() {
            if (!this.type) return

            let splitType = [];
            if (typeof this.type === 'string') {
                splitType = this.type.split('-');
            } else {
                for (const key in this.type) {
                    if (this.type[key]) {
                        splitType = key.split('-');
                        break
                    }
                }
            }
            if (splitType.length <= 1) return

            const [, ...type] = splitType;
            return `has-text-${type.join('-')}`
        },
        newCustomSize() {
            return this.customSize || this.customSizeByPack
        },
        customSizeByPack() {
            if (this.iconConfig && this.iconConfig.sizes) {
                if (this.size && this.iconConfig.sizes[this.size] !== undefined) {
                    return this.iconConfig.sizes[this.size]
                } else if (this.iconConfig.sizes.default) {
                    return this.iconConfig.sizes.default
                }
            }
            return null
        },
        useIconComponent() {
            return this.component || config.defaultIconComponent
        }
    },
    methods: {
        /**
        * Equivalent icon name of the MDI.
        */
        getEquivalentIconOf(value) {
            // Only transform the class if the both prop is set to true
            if (!this.both) {
                return value
            }

            if (this.iconConfig &&
                this.iconConfig.internalIcons &&
                this.iconConfig.internalIcons[value]) {
                return this.iconConfig.internalIcons[value]
            }
            return value
        }
    }
};

function render$G(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createElementBlock("span", {
    class: normalizeClass(["icon", [$options.newType, $props.size]])
  }, [
    (!$options.useIconComponent)
      ? (openBlock(), createElementBlock("i", {
          key: 0,
          class: normalizeClass([$options.newPack, $options.newIcon, $options.newCustomSize, $props.customClass])
        }, null, 2 /* CLASS */))
      : (openBlock(), createBlock(resolveDynamicComponent($options.useIconComponent), {
          key: 1,
          icon: [$options.newPack, $options.newIcon],
          size: $options.newCustomSize,
          class: normalizeClass([$props.customClass])
        }, null, 8 /* PROPS */, ["icon", "size", "class"]))
  ], 2 /* CLASS */))
}

script$I.render = render$G;
script$I.__file = "src/components/icon/Icon.vue";

var script$H = {
    name: 'BInput',
    components: {
        [script$I.name]: script$I
    },
    mixins: [CompatFallthroughMixin, FormElementMixin],
    props: {
        modelValue: [Number, String],
        type: {
            type: String,
            default: 'text'
        },
        lazy: {
            type: Boolean,
            default: false
        },
        passwordReveal: Boolean,
        iconClickable: Boolean,
        hasCounter: {
            type: Boolean,
            default: () => config.defaultInputHasCounter
        },
        customClass: {
            type: String,
            default: ''
        },
        iconRight: String,
        iconRightClickable: Boolean,
        iconRightType: String
    },
    emits: [
        'icon-click',
        'icon-right-click',
        'update:modelValue'
    ],
    data() {
        return {
            newValue: this.modelValue,
            newType: this.type,
            newAutocomplete: this.autocomplete || config.defaultInputAutocomplete,
            isPasswordVisible: false,
            _elementRef: this.type === 'textarea'
                ? 'textarea'
                : 'input'
        }
    },
    computed: {
        computedValue: {
            get() {
                return this.newValue
            },
            set(value) {
                this.newValue = value;
                this.$emit('update:modelValue', value);
            }
        },
        rootClasses() {
            return [
                this.iconPosition,
                this.size,
                {
                    'is-expanded': this.expanded,
                    'is-loading': this.loading,
                    'is-clearfix': !this.hasMessage
                }
            ]
        },
        inputClasses() {
            return [
                this.statusType,
                this.size,
                { 'is-rounded': this.rounded }
            ]
        },
        hasIconRight() {
            return this.passwordReveal ||
                this.loading || (this.statusIcon && this.statusTypeIcon) || this.iconRight
        },
        rightIcon() {
            if (this.passwordReveal) {
                return this.passwordVisibleIcon
            } else if (this.iconRight) {
                return this.iconRight
            }
            return this.statusTypeIcon
        },
        rightIconType() {
            if (this.passwordReveal) {
                return 'is-primary'
            } else if (this.iconRight) {
                return this.iconRightType || null
            }
            return this.statusType
        },

        /**
        * Position of the icon or if it's both sides.
        */
        iconPosition() {
            let iconClasses = '';

            if (this.icon) {
                iconClasses += 'has-icons-left ';
            }

            if (this.hasIconRight) {
                iconClasses += 'has-icons-right';
            }

            return iconClasses
        },

        /**
        * Icon name (MDI) based on the type.
        */
        statusTypeIcon() {
            switch (this.statusType) {
                case 'is-success': return 'check'
                case 'is-danger': return 'alert-circle'
                case 'is-info': return 'information'
                case 'is-warning': return 'alert'
                default: return undefined
            }
        },

        /**
        * Check if have any message prop from parent if it's a Field.
        */
        hasMessage() {
            return !!this.statusMessage
        },

        /**
        * Current password-reveal icon name.
        */
        passwordVisibleIcon() {
            return !this.isPasswordVisible ? 'eye' : 'eye-off'
        },
        /**
        * Get value length
        */
        valueLength() {
            if (typeof this.computedValue === 'string') {
                return Array.from(this.computedValue).length
            } else if (typeof this.computedValue === 'number') {
                return this.computedValue.toString().length
            }
            return 0
        }
    },
    watch: {
        /**
        * When v-model is changed:
        *   1. Set internal value.
        *   2. Validate it if the value came from outside;
        *      i.e., not equal to computedValue
        */
        modelValue(value) {
            const fromOutside = this.computedValue != value; // eslint-disable-line eqeqeq
            this.newValue = value;
            if (fromOutside) {
                // validation must wait for DOM updated
                this.$nextTick(() => {
                    !this.isValid && this.checkHtml5Validity();
                });
            }
        },
        type(type) {
            this.newType = type;
        }
    },
    methods: {
        /**
        * Toggle the visibility of a password-reveal input
        * by changing the type and focus the input right away.
        */
        togglePasswordVisibility() {
            this.isPasswordVisible = !this.isPasswordVisible;
            this.newType = this.isPasswordVisible ? 'text' : 'password';

            this.$nextTick(() => {
                this.focus();
            });
        },

        iconClick(emit, event) {
            this.$emit(emit, event);
            this.$nextTick(() => {
                this.focus();
            });
        },

        rightIconClick(event) {
            if (this.passwordReveal) {
                this.togglePasswordVisibility();
            } else if (this.iconRightClickable) {
                this.iconClick('icon-right-click', event);
            }
        },

        onInput(event) {
            if (!this.lazy) {
                const value = event.target.value;
                this.updateValue(value);
            }
        },

        onChange(event) {
            if (this.lazy) {
                const value = event.target.value;
                this.updateValue(value);
            }
        },

        updateValue(value) {
            this.computedValue = value;
            !this.isValid && this.checkHtml5Validity();
        }
    }
};

const _hoisted_1$C = ["type", "autocomplete", "maxlength", "value"];
const _hoisted_2$A = ["maxlength", "value"];

function render$F(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_b_icon = resolveComponent("b-icon");

  return (openBlock(), createElementBlock("div", mergeProps({
    class: ["control", $options.rootClasses]
  }, _ctx.rootAttrs), [
    ($props.type !== 'textarea')
      ? (openBlock(), createElementBlock("input", mergeProps({
          key: 0,
          ref: "input",
          class: ["input", [$options.inputClasses, $props.customClass]],
          type: $data.newType,
          autocomplete: $data.newAutocomplete,
          maxlength: _ctx.maxlength,
          value: $options.computedValue
        }, _ctx.fallthroughAttrs, {
          onInput: _cache[0] || (_cache[0] = (...args) => ($options.onInput && $options.onInput(...args))),
          onChange: _cache[1] || (_cache[1] = (...args) => ($options.onChange && $options.onChange(...args))),
          onBlur: _cache[2] || (_cache[2] = (...args) => (_ctx.onBlur && _ctx.onBlur(...args))),
          onFocus: _cache[3] || (_cache[3] = (...args) => (_ctx.onFocus && _ctx.onFocus(...args)))
        }), null, 16 /* FULL_PROPS */, _hoisted_1$C))
      : (openBlock(), createElementBlock("textarea", mergeProps({
          key: 1,
          ref: "textarea",
          class: ["textarea", [$options.inputClasses, $props.customClass]],
          maxlength: _ctx.maxlength,
          value: $options.computedValue
        }, _ctx.fallthroughAttrs, {
          onInput: _cache[4] || (_cache[4] = (...args) => ($options.onInput && $options.onInput(...args))),
          onChange: _cache[5] || (_cache[5] = (...args) => ($options.onChange && $options.onChange(...args))),
          onBlur: _cache[6] || (_cache[6] = (...args) => (_ctx.onBlur && _ctx.onBlur(...args))),
          onFocus: _cache[7] || (_cache[7] = (...args) => (_ctx.onFocus && _ctx.onFocus(...args)))
        }), null, 16 /* FULL_PROPS */, _hoisted_2$A)),
    (_ctx.icon)
      ? (openBlock(), createBlock(_component_b_icon, {
          key: 2,
          class: normalizeClass(["is-left", {'is-clickable': $props.iconClickable}]),
          icon: _ctx.icon,
          pack: _ctx.iconPack,
          size: _ctx.iconSize,
          onClick: _cache[8] || (_cache[8] = $event => ($options.iconClick('icon-click', $event)))
        }, null, 8 /* PROPS */, ["class", "icon", "pack", "size"]))
      : createCommentVNode("v-if", true),
    (!_ctx.loading && $options.hasIconRight)
      ? (openBlock(), createBlock(_component_b_icon, {
          key: 3,
          class: normalizeClass(["is-right", { 'is-clickable': $props.passwordReveal || $props.iconRightClickable }]),
          icon: $options.rightIcon,
          pack: _ctx.iconPack,
          size: _ctx.iconSize,
          type: $options.rightIconType,
          both: "",
          onClick: $options.rightIconClick
        }, null, 8 /* PROPS */, ["class", "icon", "pack", "size", "type", "onClick"]))
      : createCommentVNode("v-if", true),
    (_ctx.maxlength && $props.hasCounter && $props.type !== 'number')
      ? (openBlock(), createElementBlock("small", {
          key: 4,
          class: normalizeClass(["help counter", { 'is-invisible': !_ctx.isFocused }])
        }, toDisplayString($options.valueLength) + " / " + toDisplayString(_ctx.maxlength), 3 /* TEXT, CLASS */))
      : createCommentVNode("v-if", true)
  ], 16 /* FULL_PROPS */))
}

script$H.render = render$F;
script$H.__file = "src/components/input/Input.vue";

var script$G = {
    name: 'BAutocomplete',
    components: {
        [script$H.name]: script$H
    },
    mixins: [CompatFallthroughMixin, FormElementMixin],
    props: {
        modelValue: [Number, String],
        data: {
            type: Array,
            default: () => []
        },
        field: {
            type: String,
            default: 'value'
        },
        keepFirst: Boolean,
        clearOnSelect: Boolean,
        openOnFocus: Boolean,
        customFormatter: Function,
        checkInfiniteScroll: Boolean,
        keepOpen: Boolean,
        selectOnClickOutside: Boolean,
        clearable: Boolean,
        maxHeight: [String, Number],
        dropdownPosition: {
            type: String,
            default: 'auto'
        },
        groupField: String,
        groupOptions: String,
        iconRight: String,
        iconRightClickable: Boolean,
        appendToBody: Boolean,
        type: {
            type: String,
            default: 'text'
        },
        confirmKeys: {
            type: Array,
            default: () => ['Tab', 'Enter']
        },
        selectableHeader: Boolean,
        selectableFooter: Boolean
    },
    emits: [
        'active',
        'blur',
        'focus',
        'icon-click',
        'icon-right-click',
        'infinite-scroll',
        'select',
        'select-footer',
        'select-header',
        'typing',
        'update:modelValue'
    ],
    data() {
        return {
            selected: null,
            hovered: null,
            headerHovered: null,
            footerHovered: null,
            isActive: false,
            newValue: this.modelValue,
            newAutocomplete: this.autocomplete || 'off',
            ariaAutocomplete: this.keepFirst ? 'both' : 'list',
            isListInViewportVertically: true,
            hasFocus: false,
            style: {},
            _isAutocomplete: true,
            _elementRef: 'input',
            _bodyEl: undefined, // Used to append to body
            timeOutID: null
        }
    },
    computed: {
        computedData() {
            if (this.groupField) {
                if (this.groupOptions) {
                    const newData = [];
                    this.data.forEach((option) => {
                        const group = getValueByPath(option, this.groupField);
                        const items = getValueByPath(option, this.groupOptions);
                        newData.push({ group, items });
                    });
                    return newData
                } else {
                    const tmp = {};
                    this.data.forEach((option) => {
                        const group = getValueByPath(option, this.groupField);
                        if (!tmp[group]) tmp[group] = [];
                        tmp[group].push(option);
                    });
                    const newData = [];
                    Object.keys(tmp).forEach((group) => {
                        newData.push({ group, items: tmp[group] });
                    });
                    return newData
                }
            }
            return [{ items: this.data }]
        },
        isEmpty() {
            if (!this.computedData) return true
            return !this.computedData.some((element) => element.items && element.items.length)
        },
        /**
         * White-listed items to not close when clicked.
         * Add input, dropdown and all children.
         */
        whiteList() {
            const whiteList = [];
            whiteList.push(this.$refs.input.$el.querySelector('input'));
            whiteList.push(this.$refs.dropdown);
            // Add all children from dropdown
            if (this.$refs.dropdown != null) {
                const children = this.$refs.dropdown.querySelectorAll('*');
                for (const child of children) {
                    whiteList.push(child);
                }
            }
            if (this.$parent.$data._isTaginput) {
                // Add taginput container
                whiteList.push(this.$parent.$el);
                // Add .tag and .delete
                const tagInputChildren = this.$parent.$el.querySelectorAll('*');
                for (const tagInputChild of tagInputChildren) {
                    whiteList.push(tagInputChild);
                }
            }

            return whiteList
        },

        /**
         * Check if exists default slot
         */
        hasDefaultSlot() {
            return !!this.$slots.default
        },

        /**
         * Check if exists group slot
         */
        hasGroupSlot() {
            return !!this.$slots.group
        },

        /**
         * Check if exists "empty" slot
         */
        hasEmptySlot() {
            return !!this.$slots.empty
        },

        /**
         * Check if exists "header" slot
         */
        hasHeaderSlot() {
            return !!this.$slots.header
        },

        /**
         * Check if exists "footer" slot
         */
        hasFooterSlot() {
            return !!this.$slots.footer
        },

        /**
         * Apply dropdownPosition property
         */
        isOpenedTop() {
            return (
                this.dropdownPosition === 'top' ||
                    (this.dropdownPosition === 'auto' && !this.isListInViewportVertically)
            )
        },

        newIconRight() {
            if (this.clearable && this.newValue) {
                return 'close-circle'
            }
            return this.iconRight
        },

        newIconRightClickable() {
            if (this.clearable) {
                return true
            }
            return this.iconRightClickable
        },

        contentStyle() {
            return {
                maxHeight: toCssWidth(this.maxHeight)
            }
        }
    },
    watch: {
        /**
         * When dropdown is toggled, check the visibility to know when
         * to open upwards.
         */
        isActive(active) {
            if (this.dropdownPosition === 'auto') {
                if (active) {
                    this.calcDropdownInViewportVertical();
                } else {
                    // Timeout to wait for the animation to finish before recalculating
                    this.timeOutID = setTimeout(() => {
                        this.calcDropdownInViewportVertical();
                    }, 100);
                }
            }

            this.$nextTick(() => {
                this.$emit('active', active);
            });
        },

        /**
         * When checkInfiniteScroll property changes scroll event should be removed or added
         */
        checkInfiniteScroll(checkInfiniteScroll) {
            if ((this.$refs.dropdown && this.$refs.dropdown.querySelector('.dropdown-content')) === false) return

            const list = this.$refs.dropdown.querySelector('.dropdown-content');

            if (checkInfiniteScroll === true) {
                list.addEventListener('scroll', this.checkIfReachedTheEndOfScroll);

                return
            }

            list.removeEventListener('scroll', this.checkIfReachedTheEndOfScroll);
        },

        /**
         * When updating input's value
         *   1. Emit changes
         *   2. If value isn't the same as selected, set null
         *   3. Close dropdown if value is clear or else open it
         */
        newValue(value) {
            this.$emit('update:modelValue', value);
            // Check if selected is invalid
            const currentValue = this.getValue(this.selected);
            if (currentValue && currentValue !== value) {
                this.setSelected(null, false);
            }
            // Close dropdown if input is clear or else open it
            if (this.hasFocus && (!this.openOnFocus || value)) {
                this.isActive = !!value;
            }
        },

        /**
         * When v-model is changed:
         *   1. Update internal value.
         *   2. If it's invalid, validate again.
         */
        modelValue(value) {
            this.newValue = value;
        },

        /**
         * Select first option if "keep-first
         */
        data() {
            // Keep first option always pre-selected
            if (this.keepFirst) {
                this.$nextTick(() => {
                    if (this.isActive) {
                        this.selectFirstOption(this.computedData);
                    } else {
                        this.setHovered(null);
                    }
                });
            } else {
                if (this.hovered) {
                    // reset hovered if list doesn't contain it
                    const hoveredValue = this.getValue(this.hovered);
                    const data = this.computedData.map((d) => d.items)
                        .reduce((a, b) => ([...a, ...b]), []);
                    if (!data.some((d) => this.getValue(d) === hoveredValue)) {
                        this.setHovered(null);
                    }
                }
            }
        }
    },
    methods: {
        /**
         * Set which option is currently hovered.
         */
        setHovered(option) {
            if (option === undefined) return

            this.hovered = option;
        },

        /**
         * Set which option is currently selected, update v-model,
         * update input value and close dropdown.
         */
        setSelected(option, closeDropdown = true, event = undefined) {
            if (option === undefined) return
            this.selected = option;
            this.$emit('select', this.selected, event);
            if (this.selected !== null) {
                if (this.clearOnSelect) {
                    const input = this.$refs.input;
                    input.newValue = '';
                    input.$refs.input.value = '';
                } else {
                    this.newValue = this.getValue(this.selected);
                }
                this.setHovered(null);
            }
            closeDropdown && this.$nextTick(() => {
                this.isActive = false;
            });
            this.checkValidity();
        },

        /**
         * Select first option
         */
        selectFirstOption(computedData) {
            this.$nextTick(() => {
                const nonEmptyElements = computedData.filter(
                    (element) => element.items && element.items.length
                );
                if (nonEmptyElements.length) {
                    const option = nonEmptyElements[0].items[0];
                    this.setHovered(option);
                } else {
                    this.setHovered(null);
                }
            });
        },

        keydown(event) {
            const { key } = event; // cannot destructure preventDefault (https://stackoverflow.com/a/49616808/2774496)
            // prevent emit submit event
            if (key === 'Enter') event.preventDefault();
            // Close dropdown on Tab & no hovered
            if (key === 'Escape' || key === 'Tab') {
                this.isActive = false;
            }

            if (this.confirmKeys.indexOf(key) >= 0) {
                // If adding by comma, don't add the comma to the input
                if (key === ',') event.preventDefault();
                // Close dropdown on select by Tab
                const closeDropdown = !this.keepOpen || key === 'Tab';
                if (this.hovered === null) {
                    // header and footer uses headerHovered && footerHovered. If header or footer
                    // was selected then fire event otherwise just return so a value isn't selected
                    this.checkIfHeaderOrFooterSelected(event, null, closeDropdown);
                    return
                }
                this.setSelected(this.hovered, closeDropdown, event);
            }
        },

        selectHeaderOrFoterByClick(event, origin) {
            this.checkIfHeaderOrFooterSelected(event, { origin });
        },

        /**
         * Check if header or footer was selected.
         */
        checkIfHeaderOrFooterSelected(event, triggerClick, closeDropdown = true) {
            if (this.selectableHeader && (this.headerHovered || (triggerClick && triggerClick.origin === 'header'))) {
                this.$emit('select-header', event);
                this.headerHovered = false;
                if (triggerClick) this.setHovered(null);
                if (closeDropdown) this.isActive = false;
            }
            if (this.selectableFooter && (this.footerHovered || (triggerClick && triggerClick.origin === 'footer'))) {
                this.$emit('select-footer', event);
                this.footerHovered = false;
                if (triggerClick) this.setHovered(null);
                if (closeDropdown) this.isActive = false;
            }
        },

        /**
         * Close dropdown if clicked outside.
         */
        clickedOutside(event) {
            const target = isCustomElement(this) ? event.composedPath()[0] : event.target;
            if (!this.hasFocus && this.whiteList.indexOf(target) < 0) {
                if (this.keepFirst && this.hovered && this.selectOnClickOutside) {
                    this.setSelected(this.hovered, true);
                } else {
                    this.isActive = false;
                }
            }
        },

        /**
         * Return display text for the input.
         * If object, get value from path, or else just the value.
         */
        getValue(option) {
            if (option === null) return

            if (typeof this.customFormatter !== 'undefined') {
                return this.customFormatter(option)
            }
            return typeof option === 'object' ? getValueByPath(option, this.field) : option
        },

        /**
         * Check if the scroll list inside the dropdown
         * reached it's end.
         */
        checkIfReachedTheEndOfScroll() {
            const list = this.$refs.dropdown.querySelector('.dropdown-content');
            const footerHeight = this.hasFooterSlot ? list.querySelectorAll('div.dropdown-footer')[0].clientHeight : 0;
            if (list.clientHeight !== list.scrollHeight &&
                list.scrollTop + list.parentElement.clientHeight + footerHeight >= list.scrollHeight
            ) {
                this.$emit('infinite-scroll');
            }
        },

        /**
         * Calculate if the dropdown is vertically visible when activated,
         * otherwise it is openened upwards.
         */
        calcDropdownInViewportVertical() {
            this.$nextTick(() => {
                /**
                 * this.$refs.dropdown may be undefined
                 * when Autocomplete is conditional rendered
                 */
                if (this.$refs.dropdown == null) return

                const rect = this.$refs.dropdown.getBoundingClientRect();

                this.isListInViewportVertically = rect.top >= 0 &&
                    rect.bottom <= (window.innerHeight || document.documentElement.clientHeight);
                if (this.appendToBody) {
                    this.updateAppendToBody();
                }
            });
        },

        /**
         * Arrows keys listener.
         * If dropdown is active, set hovered option, or else just open.
         */
        keyArrows(direction) {
            const sum = direction === 'down' ? 1 : -1;
            if (this.isActive) {
                const data = this.computedData.map(
                    (d) => d.items).reduce((a, b) => ([...a, ...b]), []);
                if (this.hasHeaderSlot && this.selectableHeader) {
                    data.unshift(undefined);
                }
                if (this.hasFooterSlot && this.selectableFooter) {
                    data.push(undefined);
                }

                let index;
                if (this.headerHovered) {
                    index = 0 + sum;
                } else if (this.footerHovered) {
                    index = (data.length - 1) + sum;
                } else {
                    index = data.indexOf(this.hovered) + sum;
                }

                index = index > data.length - 1 ? data.length - 1 : index;
                index = index < 0 ? 0 : index;

                this.footerHovered = false;
                this.headerHovered = false;
                this.setHovered(data[index] !== undefined ? data[index] : null);
                if (this.hasFooterSlot && this.selectableFooter && index === data.length - 1) {
                    this.footerHovered = true;
                }
                if (this.hasHeaderSlot && this.selectableHeader && index === 0) {
                    this.headerHovered = true;
                }

                const list = this.$refs.dropdown.querySelector('.dropdown-content');
                let querySelectorText = 'a.dropdown-item:not(.is-disabled)';
                if (this.hasHeaderSlot && this.selectableHeader) {
                    querySelectorText += ',div.dropdown-header';
                }
                if (this.hasFooterSlot && this.selectableFooter) {
                    querySelectorText += ',div.dropdown-footer';
                }
                const element = list.querySelectorAll(querySelectorText)[index];

                if (!element) return

                const visMin = list.scrollTop;
                const visMax = list.scrollTop + list.clientHeight - element.clientHeight;

                if (element.offsetTop < visMin) {
                    list.scrollTop = element.offsetTop;
                } else if (element.offsetTop >= visMax) {
                    list.scrollTop = element.offsetTop - list.clientHeight + element.clientHeight;
                }
            } else {
                this.isActive = true;
            }
        },

        /**
         * Focus listener.
         * If value is the same as selected, select all text.
         */
        focused(event) {
            if (this.getValue(this.selected) === this.newValue) {
                this.$el.querySelector('input').select();
            }
            if (this.openOnFocus) {
                this.isActive = true;
                if (this.keepFirst) {
                    // If open on focus, update the hovered
                    this.selectFirstOption(this.computedData);
                }
            }
            this.hasFocus = true;
            this.$emit('focus', event);
        },

        /**
         * Blur listener.
         */
        onBlur(event) {
            this.hasFocus = false;
            this.$emit('blur', event);
        },
        onInput() {
            const currentValue = this.getValue(this.selected);
            if (currentValue && currentValue === this.newValue) return
            this.$emit('typing', this.newValue);
            this.checkValidity();
        },
        rightIconClick(event) {
            if (this.clearable) {
                this.newValue = '';
                this.setSelected(null, false);
                if (this.openOnFocus) {
                    this.$refs.input.$el.focus();
                }
            } else {
                this.$emit('icon-right-click', event);
            }
        },
        checkValidity() {
            if (this.useHtml5Validation) {
                this.$nextTick(() => {
                    this.checkHtml5Validity();
                });
            }
        },
        updateAppendToBody() {
            const dropdownMenu = this.$refs.dropdown;
            const trigger = this.$parent.$data._isTaginput ? this.$parent.$el : this.$refs.input.$el;
            if (dropdownMenu && trigger) {
                // update wrapper dropdown
                const root = this.$data._bodyEl;
                root.classList.forEach((item) => root.classList.remove(item));
                root.classList.add('autocomplete');
                root.classList.add('control');
                if (this.expandend) {
                    root.classList.add('is-expandend');
                }
                const rect = trigger.getBoundingClientRect();
                let top = rect.top + window.scrollY;
                const left = rect.left + window.scrollX;
                if (!this.isOpenedTop) {
                    top += trigger.clientHeight;
                } else {
                    top -= dropdownMenu.clientHeight;
                }
                this.style = {
                    position: 'absolute',
                    top: `${top}px`,
                    left: `${left}px`,
                    width: `${trigger.clientWidth}px`,
                    maxWidth: `${trigger.clientWidth}px`,
                    zIndex: '99'
                };
            }
        }
    },
    created() {
        if (typeof window !== 'undefined') {
            document.addEventListener('click', this.clickedOutside);
            if (this.dropdownPosition === 'auto') { window.addEventListener('resize', this.calcDropdownInViewportVertical); }
        }
    },
    mounted() {
        if (this.checkInfiniteScroll &&
            this.$refs.dropdown && this.$refs.dropdown.querySelector('.dropdown-content')
        ) {
            const list = this.$refs.dropdown.querySelector('.dropdown-content');
            list.addEventListener('scroll', this.checkIfReachedTheEndOfScroll);
        }
        if (this.appendToBody) {
            this.$data._bodyEl = createAbsoluteElement(this.$refs.dropdown);
            this.updateAppendToBody();
        }
    },
    beforeUnmount() {
        if (typeof window !== 'undefined') {
            document.removeEventListener('click', this.clickedOutside);
            if (this.dropdownPosition === 'auto') { window.removeEventListener('resize', this.calcDropdownInViewportVertical); }
        }
        if (this.checkInfiniteScroll &&
            this.$refs.dropdown && this.$refs.dropdown.querySelector('.dropdown-content')
        ) {
            const list = this.$refs.dropdown.querySelector('.dropdown-content');
            list.removeEventListener('scroll', this.checkIfReachedTheEndOfScroll);
        }
        if (this.appendToBody) {
            removeElement(this.$data._bodyEl);
        }
        clearTimeout(this.timeOutID);
    }
};

const _hoisted_1$B = {
  key: 1,
  class: "has-text-weight-bold"
};
const _hoisted_2$z = ["onClick"];
const _hoisted_3$o = { key: 1 };
const _hoisted_4$h = {
  key: 1,
  class: "dropdown-item is-disabled"
};

function render$E(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_b_input = resolveComponent("b-input");

  return (openBlock(), createElementBlock("div", mergeProps({
    class: ["autocomplete control", { 'is-expanded': _ctx.expanded }]
  }, _ctx.rootAttrs), [
    createVNode(_component_b_input, mergeProps({
      modelValue: $data.newValue,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => (($data.newValue) = $event)),
      ref: "input",
      type: $props.type,
      size: _ctx.size,
      loading: _ctx.loading,
      rounded: _ctx.rounded,
      icon: _ctx.icon,
      "icon-right": $options.newIconRight,
      "icon-right-clickable": $options.newIconRightClickable,
      "icon-pack": _ctx.iconPack,
      maxlength: _ctx.maxlength,
      autocomplete: $data.newAutocomplete,
      "use-html5-validation": false,
      "aria-autocomplete": $data.ariaAutocomplete
    }, _ctx.fallthroughAttrs, {
      "onUpdate:modelValue": $options.onInput,
      onFocus: $options.focused,
      onBlur: $options.onBlur,
      onKeydown: [
        $options.keydown,
        _cache[1] || (_cache[1] = withKeys(withModifiers($event => ($options.keyArrows('up')), ["prevent"]), ["up"])),
        _cache[2] || (_cache[2] = withKeys(withModifiers($event => ($options.keyArrows('down')), ["prevent"]), ["down"]))
      ],
      onIconRightClick: $options.rightIconClick,
      onIconClick: _cache[3] || (_cache[3] = (event) => _ctx.$emit('icon-click', event))
    }), null, 16 /* FULL_PROPS */, ["modelValue", "type", "size", "loading", "rounded", "icon", "icon-right", "icon-right-clickable", "icon-pack", "maxlength", "autocomplete", "aria-autocomplete", "onUpdate:modelValue", "onFocus", "onBlur", "onKeydown", "onIconRightClick"]),
    createVNode(Transition, {
      name: "fade",
      persisted: ""
    }, {
      default: withCtx(() => [
        withDirectives(createBaseVNode("div", {
          class: normalizeClass(["dropdown-menu", { 'is-opened-top': $options.isOpenedTop && !$props.appendToBody }]),
          style: normalizeStyle($data.style),
          ref: "dropdown"
        }, [
          withDirectives(createBaseVNode("div", {
            class: "dropdown-content",
            style: normalizeStyle($options.contentStyle)
          }, [
            ($options.hasHeaderSlot)
              ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(["dropdown-item dropdown-header", { 'is-hovered': $data.headerHovered }]),
                  role: "button",
                  tabindex: "0",
                  onClick: _cache[4] || (_cache[4] = $event => ($options.selectHeaderOrFoterByClick($event, 'header')))
                }, [
                  renderSlot(_ctx.$slots, "header")
                ], 2 /* CLASS */))
              : createCommentVNode("v-if", true),
            (openBlock(true), createElementBlock(Fragment, null, renderList($options.computedData, (element, groupindex) => {
              return (openBlock(), createElementBlock(Fragment, null, [
                (element.group)
                  ? (openBlock(), createElementBlock("div", {
                      key: groupindex + 'group',
                      class: "dropdown-item"
                    }, [
                      ($options.hasGroupSlot)
                        ? renderSlot(_ctx.$slots, "group", {
                            key: 0,
                            group: element.group,
                            index: groupindex
                          })
                        : (openBlock(), createElementBlock("span", _hoisted_1$B, toDisplayString(element.group), 1 /* TEXT */))
                    ]))
                  : createCommentVNode("v-if", true),
                (openBlock(true), createElementBlock(Fragment, null, renderList(element.items, (option, index) => {
                  return (openBlock(), createElementBlock("a", {
                    key: groupindex + ':' + index,
                    class: normalizeClass(["dropdown-item", { 'is-hovered': option === $data.hovered }]),
                    role: "button",
                    tabindex: "0",
                    onClick: withModifiers($event => ($options.setSelected(option, !$props.keepOpen, $event)), ["stop"])
                  }, [
                    ($options.hasDefaultSlot)
                      ? renderSlot(_ctx.$slots, "default", {
                          key: 0,
                          option: option,
                          index: index
                        })
                      : (openBlock(), createElementBlock("span", _hoisted_3$o, toDisplayString($options.getValue(option, true)), 1 /* TEXT */))
                  ], 10 /* CLASS, PROPS */, _hoisted_2$z))
                }), 128 /* KEYED_FRAGMENT */))
              ], 64 /* STABLE_FRAGMENT */))
            }), 256 /* UNKEYED_FRAGMENT */)),
            ($options.isEmpty && $options.hasEmptySlot)
              ? (openBlock(), createElementBlock("div", _hoisted_4$h, [
                  renderSlot(_ctx.$slots, "empty")
                ]))
              : createCommentVNode("v-if", true),
            ($options.hasFooterSlot)
              ? (openBlock(), createElementBlock("div", {
                  key: 2,
                  class: normalizeClass(["dropdown-item dropdown-footer", { 'is-hovered': $data.footerHovered }]),
                  role: "button",
                  tabindex: "0",
                  onClick: _cache[5] || (_cache[5] = $event => ($options.selectHeaderOrFoterByClick($event, 'footer')))
                }, [
                  renderSlot(_ctx.$slots, "footer")
                ], 2 /* CLASS */))
              : createCommentVNode("v-if", true)
          ], 4 /* STYLE */), [
            [vShow, $data.isActive]
          ])
        ], 6 /* CLASS, STYLE */), [
          [vShow, $data.isActive && (!$options.isEmpty || $options.hasEmptySlot || $options.hasHeaderSlot || $options.hasFooterSlot)]
        ])
      ]),
      _: 3 /* FORWARDED */
    })
  ], 16 /* FULL_PROPS */))
}

script$G.render = render$E;
script$G.__file = "src/components/autocomplete/Autocomplete.vue";

// use `name` to register a Functional Component which will become unresolvable
// in production build due to name mangling.
var registerComponent = function registerComponent(Vue, component, name) {
  Vue.component(name || component.name, component);
};
var registerComponentProgrammatic = function registerComponentProgrammatic(Vue, property, component) {
  if (!Vue.config.globalProperties.$buefy) Vue.config.globalProperties.$buefy = {};
  Vue.config.globalProperties.$buefy[property] = component;
};

var Plugin$F = {
  install: function install(Vue) {
    registerComponent(Vue, script$G);
  }
};

var script$1$g = {
    name: 'BBreadcrumb',
    props: {
        align: {
            type: String,
            default: () => {
                return config.defaultBreadcrumbAlign
            }
        },
        separator: {
            type: String,
            default: () => {
                return config.defaultBreadcrumbSeparator
            }
        },
        size: {
            type: String,
            default: () => {
                return config.defaultBreadcrumbSize
            }
        }
    },

    computed: {
        breadcrumbClasses() {
            return ['breadcrumb', this.align, this.separator, this.size]
        }
    }
};

function render$1$d(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createElementBlock("nav", {
    class: normalizeClass($options.breadcrumbClasses)
  }, [
    createBaseVNode("ul", null, [
      renderSlot(_ctx.$slots, "default")
    ])
  ], 2 /* CLASS */))
}

script$1$g.render = render$1$d;
script$1$g.__file = "src/components/breadcrumb/Breadcrumb.vue";

var script$F = {
    name: 'BBreadcrumbItem',
    mixins: [CompatFallthroughMixin],
    props: {
        tag: {
            type: String,
            default: () => {
                return config.defaultBreadcrumbTag
            }
        },
        active: Boolean
    }
};

function render$D(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createElementBlock("li", mergeProps({
    class: { 'is-active': $props.active }
  }, _ctx.rootAttrs), [
    (openBlock(), createBlock(resolveDynamicComponent($props.tag), normalizeProps(guardReactiveProps(_ctx.fallthroughAttrs)), {
      default: withCtx(() => [
        renderSlot(_ctx.$slots, "default")
      ]),
      _: 3 /* FORWARDED */
    }, 16 /* FULL_PROPS */))
  ], 16 /* FULL_PROPS */))
}

script$F.render = render$D;
script$F.__file = "src/components/breadcrumb/BreadcrumbItem.vue";

var Plugin$E = {
  install: function install(Vue) {
    registerComponent(Vue, script$1$g);
    registerComponent(Vue, script$F);
  }
};

var script$E = {
    name: 'BButton',
    components: {
        [script$I.name]: script$I
    },
    inheritAttrs: false,
    props: {
        type: [String, Object],
        size: String,
        label: String,
        iconPack: String,
        iconLeft: String,
        iconRight: String,
        rounded: {
            type: Boolean,
            default: () => {
                return config.defaultButtonRounded
            }
        },
        loading: Boolean,
        outlined: Boolean,
        expanded: Boolean,
        inverted: Boolean,
        focused: Boolean,
        active: Boolean,
        hovered: Boolean,
        selected: Boolean,
        nativeType: {
            type: String,
            default: 'button',
            validator: (value) => {
                return [
                    'button',
                    'submit',
                    'reset'
                ].indexOf(value) >= 0
            }
        },
        tag: {
            type: String,
            default: 'button',
            validator: (value) => {
                return config.defaultLinkTags.indexOf(value) >= 0
            }
        }
    },
    computed: {
        computedTag() {
            if (this.$attrs.disabled !== undefined && this.$attrs.disabled !== false) {
                return 'button'
            }
            return this.tag
        },
        iconSize() {
            if (!this.size || this.size === 'is-medium') {
                return 'is-small'
            } else if (this.size === 'is-large') {
                return 'is-medium'
            }
            return this.size
        }
    }
};

const _hoisted_1$A = { key: 1 };
const _hoisted_2$y = { key: 2 };

function render$C(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_b_icon = resolveComponent("b-icon");

  return (openBlock(), createBlock(resolveDynamicComponent($options.computedTag), mergeProps({ class: "button" }, _ctx.$attrs, {
    type: ['button', 'input'].includes($options.computedTag) ? $props.nativeType : undefined,
    class: [$props.size, $props.type, {
            'is-rounded': $props.rounded,
            'is-loading': $props.loading,
            'is-outlined': $props.outlined,
            'is-fullwidth': $props.expanded,
            'is-inverted': $props.inverted,
            'is-focused': $props.focused,
            'is-active': $props.active,
            'is-hovered': $props.hovered,
            'is-selected': $props.selected
        }]
  }), {
    default: withCtx(() => [
      ($props.iconLeft)
        ? (openBlock(), createBlock(_component_b_icon, {
            key: 0,
            pack: $props.iconPack,
            icon: $props.iconLeft,
            size: $options.iconSize
          }, null, 8 /* PROPS */, ["pack", "icon", "size"]))
        : createCommentVNode("v-if", true),
      ($props.label)
        ? (openBlock(), createElementBlock("span", _hoisted_1$A, toDisplayString($props.label), 1 /* TEXT */))
        : (_ctx.$slots.default)
          ? (openBlock(), createElementBlock("span", _hoisted_2$y, [
              renderSlot(_ctx.$slots, "default")
            ]))
          : createCommentVNode("v-if", true),
      ($props.iconRight)
        ? (openBlock(), createBlock(_component_b_icon, {
            key: 3,
            pack: $props.iconPack,
            icon: $props.iconRight,
            size: $options.iconSize
          }, null, 8 /* PROPS */, ["pack", "icon", "size"]))
        : createCommentVNode("v-if", true)
    ]),
    _: 3 /* FORWARDED */
  }, 16 /* FULL_PROPS */, ["type", "class"]))
}

script$E.render = render$C;
script$E.__file = "src/components/button/Button.vue";

var Plugin$D = {
  install: function install(Vue) {
    registerComponent(Vue, script$E);
  }
};

function ownKeys$1$2(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$1$2(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$1$2(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1$2(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var items = 1;
var sorted$1 = 3;
var Sorted$1 = sorted$1;
var ProviderParentMixin = (function (itemName) {
  var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var mixin = {
    provide: function provide() {
      return _defineProperty({}, 'b' + itemName, this);
    }
  };
  if (hasFlag(flags, items)) {
    mixin.data = function () {
      return _objectSpread$1$2({
        childItems: []
      }, hasFlag(flags, sorted$1) ? {
        nextIndex: 0
      } : {});
    };
    mixin.methods = {
      _registerItem: function _registerItem(item) {
        if (hasFlag(flags, sorted$1)) {
          // assigns a dynamic index.
          // dynamic indices will be messed up if any child is
          // unmounted.
          // use the new `order` prop to maintain the ordering.
          item.dynamicIndex = this.nextIndex;
          ++this.nextIndex;
        }
        this.childItems.push(item);
      },
      _unregisterItem: function _unregisterItem(item) {
        this.childItems = this.childItems.filter(function (i) {
          return i.uniqueValue !== item.uniqueValue;
        });
      }
    };
    if (hasFlag(flags, sorted$1)) {
      mixin.computed = {
        /**
         * When items are added/removed sort them according to their position
         */
        sortedItems: function sortedItems() {
          return this.childItems.slice().sort(function (i1, i2) {
            return i1.index - i2.index;
          });
        }
      };
    }
  }
  return mixin;
});

function ownKeys$7(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$7(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$7(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$7(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var sorted = 1;
var optional = 2;
var Sorted = sorted;
var InjectedChildMixin = (function (parentItemName) {
  var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var mixin = {
    inject: {
      parent: {
        from: 'b' + parentItemName,
        "default": false
      }
    },
    props: {
      // if `value` is non-null, it must be unique among all the siblings.
      // see `uniqueValue`
      value: {
        type: String,
        "default": null
      }
    },
    computed: {
      // `ProviderParentMixin` uses `uniqueValue` computed value to
      // identify the child in its `childItems` collection.
      // so the value must be unique among all the siblings.
      // falls back to the `uid` internal field to ensure uniqueness.
      uniqueValue: function uniqueValue() {
        return this.value != null ? this.value : this.$.uid;
      }
    },
    created: function created() {
      if (!this.parent) {
        if (!hasFlag(flags, optional)) {
          throw new Error('You should wrap ' + this.$options.name + ' in a ' + parentItemName);
        }
      } else if (this.parent._registerItem) {
        this.parent._registerItem(this);
      }
    },
    beforeUnmount: function beforeUnmount() {
      if (this.parent && this.parent._unregisterItem) {
        this.parent._unregisterItem(this);
      }
    }
  };
  if (hasFlag(flags, sorted)) {
    // a user can explicitly specify the `order` prop to keep the order of
    // children.
    // I can no longer rely on automatic indexing of children, because I
    // could not figure out how to calculate the index of a child in its
    // parent on Vue 3.
    // incomplete dynamic indexing is still available if any child is never
    // unmounted; e.g., not switched with `v-if`
    mixin.props = _objectSpread$7(_objectSpread$7({}, mixin.props), {}, {
      order: {
        type: Number,
        required: false
      }
    });
    mixin.data = function () {
      return {
        dynamicIndex: null
      };
    };
    mixin.computed = _objectSpread$7(_objectSpread$7({}, mixin.computed), {}, {
      index: function index() {
        return this.order != null ? this.order : this.dynamicIndex;
      }
    });
  }
  return mixin;
});

var script$D = {
    name: 'BImage',
    props: {
        src: String,
        alt: String,
        srcFallback: String,
        webpFallback: {
            type: String,
            default: () => {
                return config.defaultImageWebpFallback
            }
        },
        lazy: {
            type: Boolean,
            default: () => {
                return config.defaultImageLazy
            }
        },
        responsive: {
            type: Boolean,
            default: () => {
                return config.defaultImageResponsive
            }
        },
        ratio: {
            type: String,
            default: () => {
                return config.defaultImageRatio
            }
        },
        placeholder: String,
        srcset: String,
        srcsetSizes: Array,
        srcsetFormatter: {
            type: Function,
            default: (src, size, vm) => {
                if (typeof config.defaultImageSrcsetFormatter === 'function') {
                    return config.defaultImageSrcsetFormatter(src, size)
                } else {
                    return vm.formatSrcset(src, size)
                }
            }
        },
        rounded: {
            type: Boolean,
            default: false
        },
        captionFirst: {
            type: Boolean,
            default: false
        },
        customClass: String
    },
    emits: ['load', 'error'],
    data() {
        return {
            clientWidth: 0,
            webpSupportVerified: false,
            webpSupported: false,
            useNativeLazy: false,
            observer: null,
            inViewPort: false,
            bulmaKnownRatio: ['square', '1by1', '5by4', '4by3', '3by2', '5by3', '16by9', 'b2y1', '3by1', '4by5', '3by4', '2by3', '3by5', '9by16', '1by2', '1by3'],
            loaded: false,
            failed: false
        }
    },
    computed: {
        ratioPattern() {
            return /([0-9]+)by([0-9]+)/
        },
        hasRatio() {
            return this.ratio && this.ratioPattern.test(this.ratio)
        },
        figureClasses() {
            const classes = { image: this.responsive };
            if (this.hasRatio && this.bulmaKnownRatio.indexOf(this.ratio) >= 0) {
                classes[`is-${this.ratio}`] = true;
            }
            return classes
        },
        figureStyles() {
            if (
                this.hasRatio &&
                this.bulmaKnownRatio.indexOf(this.ratio) < 0
            ) {
                const ratioValues = this.ratioPattern.exec(this.ratio);
                return {
                    paddingTop: `${(ratioValues[2] / ratioValues[1]) * 100}%`
                }
            }
            return undefined
        },
        imgClasses() {
            return {
                'is-rounded': this.rounded,
                'has-ratio': this.hasRatio,
                [this.customClass]: !!this.customClass
            }
        },
        srcExt() {
            return this.getExt(this.src)
        },
        isWepb() {
            return this.srcExt === 'webp'
        },
        computedSrc() {
            let src = this.src;
            if (this.failed && this.srcFallback) {
                src = this.srcFallback;
            }
            if (!this.webpSupported && this.isWepb && this.webpFallback) {
                if (this.webpFallback.startsWith('.')) {
                    return src.replace(/\.webp/gi, `${this.webpFallback}`)
                }
                return this.webpFallback
            }
            return src
        },
        computedWidth() {
            if (this.responsive && this.clientWidth > 0) {
                return this.clientWidth
            }
            return undefined
        },
        computedNativeLazy() {
            if (this.lazy && this.useNativeLazy) {
                return 'lazy'
            }
            return undefined
        },
        isDisplayed() {
            return (
                (this.webpSupportVerified || !this.isWepb) &&
                (!this.lazy || this.useNativeLazy || this.inViewPort)
            )
        },
        placeholderExt() {
            if (this.placeholder) {
                return this.getExt(this.placeholder)
            }
            return undefined
        },
        isPlaceholderWepb() {
            if (this.placeholder) {
                return this.placeholderExt === 'webp'
            }
            return false
        },
        computedPlaceholder() {
            if (!this.webpSupported && this.isPlaceholderWepb && this.webpFallback && this.webpFallback.startsWith('.')) {
                return this.placeholder.replace(/\.webp/gi, `${this.webpFallback}`)
            }
            return this.placeholder
        },
        isPlaceholderDisplayed() {
            return (
                !this.loaded &&
                (
                    this.$slots.placeholder || (
                        this.placeholder &&
                        (this.webpSupportVerified || !this.isPlaceholderWepb)
                    )
                )
            )
        },
        computedSrcset() {
            if (this.srcset) {
                if (!this.webpSupported && this.isWepb && this.webpFallback && this.webpFallback.startsWith('.')) {
                    return this.srcset.replace(/\.webp/gi, `${this.webpFallback}`)
                }
                return this.srcset
            }
            if (
                this.srcsetSizes && Array.isArray(this.srcsetSizes) && this.srcsetSizes.length > 0
            ) {
                return this.srcsetSizes.map((size) => {
                    return `${this.srcsetFormatter(this.computedSrc, size, this)} ${size}w`
                }).join(',')
            }
            return undefined
        },
        computedSizes() {
            if (this.computedSrcset && this.computedWidth) {
                return `${this.computedWidth}px`
            }
            return undefined
        },
        isCaptionFirst() {
            return this.$slots.caption && this.captionFirst
        },
        isCaptionLast() {
            return this.$slots.caption && !this.captionFirst
        }
    },
    methods: {
        getExt(filename, clean = true) {
            if (filename) {
                const noParam = clean ? filename.split('?')[0] : filename;
                return noParam.split('.').pop()
            }
            return ''
        },
        setWidth() {
            this.clientWidth = this.$el.clientWidth;
        },
        formatSrcset(src, size) {
            const ext = this.getExt(src, false);
            const name = src.split('.').slice(0, -1).join('.');
            return `${name}-${size}.${ext}`
        },
        onLoad(event) {
            this.loaded = true;
            this.emit('load', event);
        },
        onError(event) {
            this.emit('error', event);
            if (!this.failed) {
                this.failed = true;
            }
        },
        emit(eventName, event) {
            const { target } = event;
            this.$emit(eventName, event, target.currentSrc || target.src || this.computedSrc);
        }
    },
    created() {
        if (this.isWepb) {
            isWebpSupported().then((supported) => {
                this.webpSupportVerified = true;
                this.webpSupported = supported;
            });
        }
        if (this.lazy) {
            // We use native lazy loading if supported
            // We try to use Intersection Observer if native lazy loading is not supported
            // We use the lazy attribute anyway if we cannot detect support (SSR for example).
            const nativeLazySupported = typeof window !== 'undefined' && 'HTMLImageElement' in window && 'loading' in HTMLImageElement.prototype;
            const intersectionObserverSupported = typeof window !== 'undefined' && 'IntersectionObserver' in window;
            if (!nativeLazySupported && intersectionObserverSupported) {
                this.observer = new IntersectionObserver((events) => {
                    const { target, isIntersecting } = events[0];
                    if (isIntersecting && !this.inViewPort) {
                        this.inViewPort = true;
                        this.observer.unobserve(target);
                    }
                });
            } else {
                this.useNativeLazy = true;
            }
        }
    },
    mounted() {
        if (this.lazy && this.observer) {
            this.observer.observe(this.$el);
        }
        this.setWidth();
        if (typeof window !== 'undefined') {
            window.addEventListener('resize', this.setWidth);
        }
    },
    beforeUnmount() {
        if (this.observer) {
            this.observer.disconnect();
        }
        if (typeof window !== 'undefined') {
            window.removeEventListener('resize', this.setWidth);
        }
    }
};

const _hoisted_1$z = { key: 0 };
const _hoisted_2$x = ["srcset", "src", "alt", "width", "sizes", "loading"];
const _hoisted_3$n = ["src", "alt"];
const _hoisted_4$g = { key: 1 };

function render$B(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createElementBlock("figure", {
    class: normalizeClass(["b-image-wrapper", $options.figureClasses]),
    style: normalizeStyle($options.figureStyles)
  }, [
    ($options.isCaptionFirst)
      ? (openBlock(), createElementBlock("figcaption", _hoisted_1$z, [
          renderSlot(_ctx.$slots, "caption")
        ]))
      : createCommentVNode("v-if", true),
    createVNode(Transition, { name: "fade" }, {
      default: withCtx(() => [
        ($options.isDisplayed)
          ? (openBlock(), createElementBlock("img", {
              key: 0,
              srcset: $options.computedSrcset,
              src: $options.computedSrc,
              alt: $props.alt,
              class: normalizeClass($options.imgClasses),
              width: $options.computedWidth,
              sizes: $options.computedSizes,
              loading: $options.computedNativeLazy,
              onLoad: _cache[0] || (_cache[0] = (...args) => ($options.onLoad && $options.onLoad(...args))),
              onError: _cache[1] || (_cache[1] = (...args) => ($options.onError && $options.onError(...args)))
            }, null, 42 /* CLASS, PROPS, HYDRATE_EVENTS */, _hoisted_2$x))
          : createCommentVNode("v-if", true)
      ]),
      _: 1 /* STABLE */
    }),
    createVNode(Transition, { name: "fade" }, {
      default: withCtx(() => [
        ($options.isPlaceholderDisplayed)
          ? renderSlot(_ctx.$slots, "placeholder", { key: 0 }, () => [
              createBaseVNode("img", {
                src: $options.computedPlaceholder,
                alt: $props.alt,
                class: normalizeClass([$options.imgClasses, "placeholder"])
              }, null, 10 /* CLASS, PROPS */, _hoisted_3$n)
            ])
          : createCommentVNode("v-if", true)
      ]),
      _: 3 /* FORWARDED */
    }),
    ($options.isCaptionLast)
      ? (openBlock(), createElementBlock("figcaption", _hoisted_4$g, [
          renderSlot(_ctx.$slots, "caption")
        ]))
      : createCommentVNode("v-if", true)
  ], 6 /* CLASS, STYLE */))
}

script$D.render = render$B;
script$D.__file = "src/components/image/Image.vue";

var script$2$7 = {
    name: 'BCarousel',
    components: {
        [script$I.name]: script$I
    },
    mixins: [ProviderParentMixin('carousel', Sorted$1)],
    props: {
        modelValue: {
            type: Number,
            default: 0
        },
        animated: {
            type: String,
            default: 'slide'
        },
        interval: Number,
        hasDrag: {
            type: Boolean,
            default: true
        },
        autoplay: {
            type: Boolean,
            default: true
        },
        pauseHover: {
            type: Boolean,
            default: true
        },
        pauseInfo: {
            type: Boolean,
            default: true
        },
        pauseInfoType: {
            type: String,
            default: 'is-white'
        },
        pauseText: {
            type: String,
            default: 'Pause'
        },
        arrow: {
            type: Boolean,
            default: true
        },
        arrowHover: {
            type: Boolean,
            default: true
        },
        repeat: {
            type: Boolean,
            default: true
        },
        iconPack: String,
        iconSize: String,
        iconPrev: {
            type: String,
            default: () => {
                return config.defaultIconPrev
            }
        },
        iconNext: {
            type: String,
            default: () => {
                return config.defaultIconNext
            }
        },
        indicator: {
            type: Boolean,
            default: true
        },
        indicatorBackground: Boolean,
        indicatorCustom: Boolean,
        indicatorCustomSize: {
            type: String,
            default: 'is-small'
        },
        indicatorInside: {
            type: Boolean,
            default: true
        },
        indicatorMode: {
            type: String,
            default: 'click'
        },
        indicatorPosition: {
            type: String,
            default: 'is-bottom'
        },
        indicatorStyle: {
            type: String,
            default: 'is-dots'
        },
        overlay: Boolean,
        progress: Boolean,
        progressType: {
            type: String,
            default: 'is-primary'
        },
        withCarouselList: Boolean
    },
    emits: ['change', 'click', 'update:modelValue'],
    data() {
        return {
            transition: 'next',
            activeChild: this.modelValue || 0,
            isPause: false,
            dragX: false,
            timer: null
        }
    },
    computed: {
        indicatorClasses() {
            return [
                {
                    'has-background': this.indicatorBackground,
                    'has-custom': this.indicatorCustom,
                    'is-inside': this.indicatorInside
                },
                this.indicatorCustom && this.indicatorCustomSize,
                this.indicatorInside && this.indicatorPosition
            ]
        },

        // checking arrows
        hasPrev() {
            return this.repeat || this.activeChild !== 0
        },
        hasNext() {
            return this.repeat || this.activeChild < this.childItems.length - 1
        },

        activeChildIndex() {
            const item = this.sortedItems[this.activeChild];
            return item != null ? item.index : undefined
        }
    },
    watch: {
        /**
         * When v-model is changed set the new active item.
         */
        modelValue(value) {
            this.changeActive(value);
        },
        /**
         * When carousel-items are updated, set active one.
         */
        sortedItems(items) {
            if (this.activeChild >= items.length && this.activeChild > 0) {
                this.changeActive(this.activeChild - 1);
            }
        },
        /**
         *  When autoplay is changed, start or pause timer accordingly
         */
        autoplay(status) {
            status ? this.startTimer() : this.pauseTimer();
        },
        /**
         *  Since the timer can get paused at the end, if repeat is changed we need to restart it
         */
        repeat(status) {
            if (status) { this.startTimer(); }
        }
    },

    methods: {
        startTimer() {
            if (!this.autoplay || this.timer) return
            this.isPause = false;
            this.timer = setInterval(() => {
                if (!this.repeat && this.activeChild >= this.childItems.length - 1) {
                    this.pauseTimer();
                } else {
                    this.next();
                }
            }, (this.interval || config.defaultCarouselInterval));
        },
        pauseTimer() {
            this.isPause = true;
            if (this.timer) {
                clearInterval(this.timer);
                this.timer = null;
            }
        },
        restartTimer() {
            this.pauseTimer();
            this.startTimer();
        },
        checkPause() {
            if (this.pauseHover && this.autoplay) {
                this.pauseTimer();
            }
        },
        /**
         * Change the active item and emit change event.
         * action only for animated slide, there true = next, false = prev
         */
        changeActive(newIndex, direction = 0) {
            if (this.activeChild === newIndex || isNaN(newIndex)) return

            direction = direction || (newIndex - this.activeChild);

            newIndex = this.repeat
                ? mod(newIndex, this.childItems.length)
                : bound(newIndex, 0, this.childItems.length - 1);

            this.transition = direction > 0 ? 'prev' : 'next';
            // Transition names are reversed from the actual direction for correct effect

            this.activeChild = newIndex;
            if (newIndex !== this.modelValue) {
                this.$emit('update:modelValue', newIndex);
            }
            this.restartTimer();
            this.$emit('change', newIndex); // BC
        },
        // Indicator trigger when change active item.
        modeChange(trigger, value) {
            if (this.indicatorMode === trigger) {
                return this.changeActive(value)
            }
        },
        prev() {
            this.changeActive(this.activeChild - 1, -1);
        },
        next() {
            this.changeActive(this.activeChild + 1, 1);
        },
        // handle drag event
        dragStart(event) {
            if (!this.hasDrag ||
                !event.target.draggable) return
            this.dragX = event.touches ? event.changedTouches[0].pageX : event.pageX;
            if (event.touches) {
                this.pauseTimer();
            } else {
                event.preventDefault();
            }
        },
        dragEnd(event) {
            if (this.dragX === false) return
            const detected = event.touches ? event.changedTouches[0].pageX : event.pageX;
            const diffX = detected - this.dragX;
            if (Math.abs(diffX) > 30) {
                if (diffX < 0) {
                    this.next();
                } else {
                    this.prev();
                }
            } else {
                event.target.click();
                this.sortedItems[this.activeChild].$emit('click');
                this.$emit('click');
            }
            if (event.touches) {
                this.startTimer();
            }
            this.dragX = false;
        }
    },
    mounted() {
        this.startTimer();
    },
    beforeUnmount() {
        this.pauseTimer();
    }
};

const _hoisted_1$2$6 = ["value", "max"];
const _hoisted_2$w = {
  key: 1,
  class: "carousel-pause"
};
const _hoisted_3$m = ["onMouseover", "onClick"];

function render$2$7(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_b_icon = resolveComponent("b-icon");

  return (openBlock(), createElementBlock("div", {
    class: normalizeClass(["carousel", {'is-overlay': $props.overlay}]),
    onMouseenter: _cache[4] || (_cache[4] = (...args) => ($options.checkPause && $options.checkPause(...args))),
    onMouseleave: _cache[5] || (_cache[5] = (...args) => ($options.startTimer && $options.startTimer(...args)))
  }, [
    ($props.progress)
      ? (openBlock(), createElementBlock("progress", {
          key: 0,
          class: normalizeClass(["progress", $props.progressType]),
          value: $data.activeChild,
          max: _ctx.childItems.length - 1
        }, toDisplayString(_ctx.childItems.length - 1), 11 /* TEXT, CLASS, PROPS */, _hoisted_1$2$6))
      : createCommentVNode("v-if", true),
    createBaseVNode("div", {
      class: "carousel-items",
      onMousedown: _cache[0] || (_cache[0] = (...args) => ($options.dragStart && $options.dragStart(...args))),
      onMouseup: _cache[1] || (_cache[1] = (...args) => ($options.dragEnd && $options.dragEnd(...args))),
      onTouchstart: _cache[2] || (_cache[2] = withModifiers((...args) => ($options.dragStart && $options.dragStart(...args)), ["stop"])),
      onTouchend: _cache[3] || (_cache[3] = withModifiers((...args) => ($options.dragEnd && $options.dragEnd(...args)), ["stop"]))
    }, [
      renderSlot(_ctx.$slots, "default"),
      ($props.arrow)
        ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(["carousel-arrow", {'is-hovered': $props.arrowHover}])
          }, [
            withDirectives(createVNode(_component_b_icon, {
              class: "has-icons-left",
              onClick: $options.prev,
              pack: $props.iconPack,
              icon: $props.iconPrev,
              size: $props.iconSize,
              both: ""
            }, null, 8 /* PROPS */, ["onClick", "pack", "icon", "size"]), [
              [vShow, $options.hasPrev]
            ]),
            withDirectives(createVNode(_component_b_icon, {
              class: "has-icons-right",
              onClick: $options.next,
              pack: $props.iconPack,
              icon: $props.iconNext,
              size: $props.iconSize,
              both: ""
            }, null, 8 /* PROPS */, ["onClick", "pack", "icon", "size"]), [
              [vShow, $options.hasNext]
            ])
          ], 2 /* CLASS */))
        : createCommentVNode("v-if", true)
    ], 32 /* HYDRATE_EVENTS */),
    ($props.autoplay && $props.pauseHover && $props.pauseInfo && $data.isPause)
      ? (openBlock(), createElementBlock("div", _hoisted_2$w, [
          createBaseVNode("span", {
            class: normalizeClass(["tag", $props.pauseInfoType])
          }, toDisplayString($props.pauseText), 3 /* TEXT, CLASS */)
        ]))
      : createCommentVNode("v-if", true),
    ($props.withCarouselList && !$props.indicator)
      ? renderSlot(_ctx.$slots, "list", {
          key: 2,
          active: $data.activeChild,
          switch: $options.changeActive
        })
      : createCommentVNode("v-if", true),
    ($props.indicator)
      ? (openBlock(), createElementBlock("div", {
          key: 3,
          class: normalizeClass(["carousel-indicator", $options.indicatorClasses])
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.sortedItems, (item, index) => {
            return (openBlock(), createElementBlock("a", {
              class: normalizeClass(["indicator-item", {'is-active': item.isActive}]),
              onMouseover: $event => ($options.modeChange('hover', index)),
              onClick: $event => ($options.modeChange('click', index)),
              key: item._uid
            }, [
              renderSlot(_ctx.$slots, "indicators", { i: index }, () => [
                createBaseVNode("span", {
                  class: normalizeClass(["indicator-style", $props.indicatorStyle])
                }, null, 2 /* CLASS */)
              ])
            ], 42 /* CLASS, PROPS, HYDRATE_EVENTS */, _hoisted_3$m))
          }), 128 /* KEYED_FRAGMENT */))
        ], 2 /* CLASS */))
      : createCommentVNode("v-if", true),
    ($props.overlay)
      ? renderSlot(_ctx.$slots, "overlay", { key: 4 })
      : createCommentVNode("v-if", true)
  ], 34 /* CLASS, HYDRATE_EVENTS */))
}

script$2$7.render = render$2$7;
script$2$7.__file = "src/components/carousel/Carousel.vue";

var script$1$f = {
    name: 'BCarouselItem',
    mixins: [InjectedChildMixin('carousel', Sorted)],
    data() {
        return {
            transitionName: null
        }
    },
    computed: {
        transition() {
            if (this.parent.animated === 'fade') {
                return 'fade'
            } else if (this.parent.transition) {
                return 'slide-' + this.parent.transition
            } else {
                return undefined
            }
        },
        isActive() {
            return this.parent.activeChildIndex === this.index
        }
    }
};

const _hoisted_1$1$9 = { class: "carousel-item" };

function render$1$c(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock(Transition, {
    name: $options.transition,
    persisted: ""
  }, {
    default: withCtx(() => [
      withDirectives(createBaseVNode("div", _hoisted_1$1$9, [
        renderSlot(_ctx.$slots, "default")
      ], 512 /* NEED_PATCH */), [
        [vShow, $options.isActive]
      ])
    ]),
    _: 3 /* FORWARDED */
  }, 8 /* PROPS */, ["name"]))
}

script$1$f.render = render$1$c;
script$1$f.__file = "src/components/carousel/CarouselItem.vue";

var script$C = {
    name: 'BCarouselList',
    components: {
        [script$I.name]: script$I,
        [script$D.name]: script$D
    },
    props: {
        data: {
            type: Array,
            default: () => []
        },
        modelValue: {
            type: Number,
            default: 0
        },
        scrollValue: {
            type: Number,
            default: 0
        },
        hasDrag: {
            type: Boolean,
            default: true
        },
        hasGrayscale: Boolean,
        hasOpacity: Boolean,
        repeat: Boolean,
        itemsToShow: {
            type: Number,
            default: 4
        },
        itemsToList: {
            type: Number,
            default: 1
        },
        asIndicator: Boolean,
        arrow: {
            type: Boolean,
            default: true
        },
        arrowHover: {
            type: Boolean,
            default: true
        },
        iconPack: String,
        iconSize: String,
        iconPrev: {
            type: String,
            default: () => {
                return config.defaultIconPrev
            }
        },
        iconNext: {
            type: String,
            default: () => {
                return config.defaultIconNext
            }
        },
        breakpoints: {
            type: Object,
            default: () => ({})
        }
    },
    emits: ['switch', 'update:modelValue', 'updated:scroll'],
    data() {
        return {
            activeItem: this.modelValue,
            scrollIndex: this.asIndicator ? this.scrollValue : this.modelValue,
            delta: 0,
            dragX: false,
            hold: 0,
            windowWidth: 0,
            touch: false,
            observer: null,
            refresh_: 0
        }
    },
    computed: {
        dragging() {
            return this.dragX !== false
        },
        listClass() {
            return [
                {
                    'has-grayscale': this.settings.hasGrayscale,
                    'has-opacity': this.settings.hasOpacity,
                    'is-dragging': this.dragging
                }
            ]
        },
        itemStyle() {
            return `width: ${this.itemWidth}px;`
        },
        translation() {
            return -bound(
                this.delta + (this.scrollIndex * this.itemWidth), 0,
                (this.data.length - this.settings.itemsToShow) * this.itemWidth
            )
        },
        total() {
            return this.data.length - this.settings.itemsToShow
        },
        hasPrev() {
            return (this.settings.repeat || this.scrollIndex > 0)
        },
        hasNext() {
            return (this.settings.repeat || this.scrollIndex < this.total)
        },
        breakpointKeys() {
            return Object.keys(this.breakpoints).sort((a, b) => b - a)
        },
        settings() {
            const breakpoint = this.breakpointKeys.filter((breakpoint) => {
                if (this.windowWidth >= breakpoint) {
                    return true
                } else {
                    return false
                }
            })[0];
            if (breakpoint) {
                return { ...this.$props, ...this.breakpoints[breakpoint] }
            }
            return this.$props
        },
        itemWidth() {
            if (this.windowWidth) { // Ensure component is mounted
                /* eslint-disable-next-line */
                this.refresh_; // We force the computed property to refresh if this prop is changed

                const rect = this.$el.getBoundingClientRect();
                return rect.width / this.settings.itemsToShow
            }
            return 0
        }
    },
    watch: {
        /**
         * When v-model is changed set the new active item.
         */
        modelValue(value) {
            this.switchTo(this.asIndicator ? value - (this.itemsToShow - 3) / 2 : value);
            if (this.activeItem !== value) {
                this.activeItem = bound(value, 0, this.data.length - 1);
            }
        },
        scrollValue(value) {
            this.switchTo(value);
        }
    },
    methods: {
        resized() {
            this.windowWidth = window.innerWidth;
        },
        switchTo(newIndex) {
            if (newIndex === this.scrollIndex || isNaN(newIndex)) { return }

            if (this.settings.repeat) {
                newIndex = mod(newIndex, this.total + 1);
            }
            newIndex = bound(newIndex, 0, this.total);
            this.scrollIndex = newIndex;
            if (!this.asIndicator && this.modelValue !== newIndex) {
                this.$emit('update:modelValue', newIndex);
            } else if (this.scrollIndex !== newIndex) {
                this.$emit('updated:scroll', newIndex);
            }
        },
        next() {
            this.switchTo(this.scrollIndex + this.settings.itemsToList);
        },
        prev() {
            this.switchTo(this.scrollIndex - this.settings.itemsToList);
        },
        checkAsIndicator(value, event) {
            if (!this.asIndicator) return

            const dragEndX = event.changedTouches ? event.changedTouches[0].clientX : event.clientX;
            if (this.hold - Date.now() > 2000 || Math.abs(this.dragX - dragEndX) > 10) return

            this.dragX = false;
            this.hold = 0;
            event.preventDefault();

            // Make the item appear in the middle
            this.activeItem = value;

            this.$emit('switch', value);
        },
        // handle drag event
        dragStart(event) {
            if (this.dragging || !this.settings.hasDrag || (event.button !== 0 && event.type !== 'touchstart')) return
            this.hold = Date.now();
            this.touch = !!event.touches;
            this.dragX = this.touch ? event.touches[0].clientX : event.clientX;
            window.addEventListener(this.touch ? 'touchmove' : 'mousemove', this.dragMove);
            window.addEventListener(this.touch ? 'touchend' : 'mouseup', this.dragEnd);
        },
        dragMove(event) {
            if (!this.dragging) return
            const dragEndX = event.touches
                ? (event.changedTouches[0] || event.touches[0]).clientX
                : event.clientX;
            this.delta = this.dragX - dragEndX;
            if (!event.touches) {
                event.preventDefault();
            }
        },
        dragEnd() {
            if (!this.dragging && !this.hold) return
            if (this.hold) {
                const signCheck = sign(this.delta);
                const results = Math.round(Math.abs(this.delta / this.itemWidth) + 0.15);// Hack
                this.switchTo(this.scrollIndex + signCheck * results);
            }
            this.delta = 0;
            this.dragX = false;
            window.removeEventListener(this.touch ? 'touchmove' : 'mousemove', this.dragMove);
            window.removeEventListener(this.touch ? 'touchend' : 'mouseup', this.dragEnd);
        },
        refresh() {
            this.$nextTick(() => {
                this.refresh_++;
            });
        }
    },
    mounted() {
        if (typeof window !== 'undefined') {
            if (window.ResizeObserver) {
                this.observer = new ResizeObserver(this.refresh);
                this.observer.observe(this.$el);
            }
            window.addEventListener('resize', this.resized);
            document.addEventListener('animationend', this.refresh);
            document.addEventListener('transitionend', this.refresh);
            document.addEventListener('transitionstart', this.refresh);
            this.resized();
        }
        if (this.$attrs.config) {
            throw new Error('The config prop was removed, you need to use v-bind instead')
        }
    },
    beforeUnmount() {
        if (typeof window !== 'undefined') {
            if (window.ResizeObserver) {
                this.observer.disconnect();
            }
            window.removeEventListener('resize', this.resized);
            document.removeEventListener('animationend', this.refresh);
            document.removeEventListener('transitionend', this.refresh);
            document.removeEventListener('transitionstart', this.refresh);
            this.dragEnd();
        }
    }
};

const _hoisted_1$y = ["onMouseup", "onTouchend"];

function render$A(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_b_image = resolveComponent("b-image");
  const _component_b_icon = resolveComponent("b-icon");

  return (openBlock(), createElementBlock("div", {
    class: normalizeClass(["carousel-list", {'has-shadow': $data.scrollIndex > 0}]),
    onMousedown: _cache[0] || (_cache[0] = withModifiers((...args) => ($options.dragStart && $options.dragStart(...args)), ["prevent"])),
    onTouchstart: _cache[1] || (_cache[1] = (...args) => ($options.dragStart && $options.dragStart(...args)))
  }, [
    createBaseVNode("div", {
      class: normalizeClass(["carousel-slides", $options.listClass]),
      style: normalizeStyle('transform:translateX('+$options.translation+'px)')
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList($props.data, (list, index) => {
        return (openBlock(), createElementBlock("div", {
          class: normalizeClass(["carousel-slide", {'is-active': $props.asIndicator ? $data.activeItem === index : $data.scrollIndex === index}]),
          onMouseup: $event => ($options.checkAsIndicator(index, $event)),
          onTouchend: $event => ($options.checkAsIndicator(index, $event)),
          key: index,
          style: normalizeStyle($options.itemStyle)
        }, [
          renderSlot(_ctx.$slots, "item", mergeProps({
            index: index,
            active: $data.activeItem,
            scroll: $data.scrollIndex
          }, list, { list: list }), () => [
            createVNode(_component_b_image, mergeProps({
              src: list.image
            }, list), null, 16 /* FULL_PROPS */, ["src"])
          ])
        ], 46 /* CLASS, STYLE, PROPS, HYDRATE_EVENTS */, _hoisted_1$y))
      }), 128 /* KEYED_FRAGMENT */))
    ], 6 /* CLASS, STYLE */),
    ($props.arrow)
      ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(["carousel-arrow", {'is-hovered': $options.settings.arrowHover}])
        }, [
          withDirectives(createVNode(_component_b_icon, {
            class: "has-icons-left",
            onClick: withModifiers($options.prev, ["prevent"]),
            pack: $options.settings.iconPack,
            icon: $options.settings.iconPrev,
            size: $options.settings.iconSize,
            both: ""
          }, null, 8 /* PROPS */, ["onClick", "pack", "icon", "size"]), [
            [vShow, $options.hasPrev]
          ]),
          withDirectives(createVNode(_component_b_icon, {
            class: "has-icons-right",
            onClick: withModifiers($options.next, ["prevent"]),
            pack: $options.settings.iconPack,
            icon: $options.settings.iconNext,
            size: $options.settings.iconSize,
            both: ""
          }, null, 8 /* PROPS */, ["onClick", "pack", "icon", "size"]), [
            [vShow, $options.hasNext]
          ])
        ], 2 /* CLASS */))
      : createCommentVNode("v-if", true)
  ], 34 /* CLASS, HYDRATE_EVENTS */))
}

script$C.render = render$A;
script$C.__file = "src/components/carousel/CarouselList.vue";

var Plugin$C = {
  install: function install(Vue) {
    registerComponent(Vue, script$2$7);
    registerComponent(Vue, script$1$f);
    registerComponent(Vue, script$C);
  }
};

var CheckRadioMixin = {
  props: {
    modelValue: [String, Number, Boolean, Function, Object, Array],
    nativeValue: [String, Number, Boolean, Function, Object, Array],
    type: String,
    disabled: Boolean,
    required: Boolean,
    name: String,
    size: String
  },
  emits: ['update:modelValue'],
  data: function data() {
    return {
      newValue: this.modelValue
    };
  },
  computed: {
    computedValue: {
      get: function get() {
        return this.newValue;
      },
      set: function set(value) {
        this.newValue = value;
        this.$emit('update:modelValue', value);
      }
    },
    disabledOrUndefined: function disabledOrUndefined() {
      // On Vue 3, setting a boolean attribute `false` does not remove it.
      // To remove it, `null` or `undefined` has to be given.
      // Setting `false` ends up with a grayed out component.
      return this.disabled || undefined;
    },
    requiredOrUndefined: function requiredOrUndefined() {
      // On Vue 3, setting a boolean attribute `false` does not remove it,
      // `null` or `undefined` has to be given to remove it.
      return this.required || undefined;
    }
  },
  watch: {
    /**
    * When v-model change, set internal value.
    */
    modelValue: function modelValue(value) {
      this.newValue = value;
    }
  },
  methods: {
    focus: function focus() {
      // MacOS FireFox and Safari do not focus when clicked
      this.$refs.input.focus();
    }
  }
};

var script$B = {
    name: 'BCheckbox',
    mixins: [CheckRadioMixin],
    props: {
        indeterminate: Boolean,
        ariaLabelledby: String,
        trueValue: {
            type: [String, Number, Boolean, Function, Object, Array],
            default: true
        },
        falseValue: {
            type: [String, Number, Boolean, Function, Object, Array],
            default: false
        },
        autocomplete: {
            type: String,
            default: 'on'
        },
        inputId: {
            type: String,
            default: ''
        }
    }
};

const _hoisted_1$x = ["disabled"];
const _hoisted_2$v = ["id", ".indeterminate", "autocomplete", "disabled", "required", "name", "value", "true-value", "false-value", "aria-labelledby"];
const _hoisted_3$l = ["id"];

function render$z(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createElementBlock("label", {
    class: normalizeClass(["b-checkbox checkbox", [_ctx.size, { 'is-disabled': _ctx.disabled }]]),
    ref: "label",
    disabled: _ctx.disabledOrUndefined,
    onClick: _cache[2] || (_cache[2] = (...args) => (_ctx.focus && _ctx.focus(...args))),
    onKeydown: [
      _cache[3] || (_cache[3] = withKeys(withModifiers($event => (_ctx.$refs.label.click()), ["prevent"]), ["enter"])),
      _cache[4] || (_cache[4] = withKeys(withModifiers($event => (_ctx.$refs.label.click()), ["prevent"]), ["space"]))
    ]
  }, [
    createCommentVNode(" Checkbox needs to listen for a space event instead of a just a\n             click and enter event so that that using the keyboard spacebar will also\n             trigger the checkbox change in the b-table "),
    withDirectives(createBaseVNode("input", {
      "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => ((_ctx.computedValue) = $event)),
      id: $props.inputId,
      ".indeterminate": $props.indeterminate,
      type: "checkbox",
      ref: "input",
      onClick: _cache[1] || (_cache[1] = withModifiers(() => {}, ["stop"])),
      autocomplete: $props.autocomplete,
      disabled: _ctx.disabledOrUndefined,
      required: _ctx.requiredOrUndefined,
      name: _ctx.name,
      value: _ctx.nativeValue,
      "true-value": $props.trueValue,
      "false-value": $props.falseValue,
      "aria-labelledby": $props.ariaLabelledby
    }, null, 8 /* PROPS */, _hoisted_2$v), [
      [vModelCheckbox, _ctx.computedValue]
    ]),
    createBaseVNode("span", {
      class: normalizeClass(["check", _ctx.type])
    }, null, 2 /* CLASS */),
    createBaseVNode("span", {
      id: $props.ariaLabelledby,
      class: "control-label"
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 8 /* PROPS */, _hoisted_3$l)
  ], 42 /* CLASS, PROPS, HYDRATE_EVENTS */, _hoisted_1$x))
}

script$B.render = render$z;
script$B.__file = "src/components/checkbox/Checkbox.vue";

var script$A = {
    name: 'BCheckboxButton',
    mixins: [CheckRadioMixin],
    props: {
        type: {
            type: String,
            default: 'is-primary'
        },
        expanded: Boolean
    },
    data() {
        return {
            isFocused: false
        }
    },
    computed: {
        checked() {
            if (Array.isArray(this.newValue)) {
                return this.newValue.indexOf(this.nativeValue) >= 0
            }
            return this.newValue === this.nativeValue
        }
    }
};

const _hoisted_1$w = ["disabled"];
const _hoisted_2$u = ["disabled", "required", "name", "value"];

function render$y(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createElementBlock("div", {
    class: normalizeClass(["control", { 'is-expanded': $props.expanded }])
  }, [
    createBaseVNode("label", {
      class: normalizeClass(["b-checkbox checkbox button", [$options.checked ? $props.type : null, _ctx.size, {
                'is-disabled': _ctx.disabled,
                'is-focused': $data.isFocused
            }]]),
      ref: "label",
      disabled: _ctx.disabledOrUndefined,
      onClick: _cache[4] || (_cache[4] = (...args) => (_ctx.focus && _ctx.focus(...args))),
      onKeydown: _cache[5] || (_cache[5] = withKeys(withModifiers($event => (_ctx.$refs.label.click()), ["prevent"]), ["enter"]))
    }, [
      renderSlot(_ctx.$slots, "default"),
      withDirectives(createBaseVNode("input", {
        "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => ((_ctx.computedValue) = $event)),
        type: "checkbox",
        ref: "input",
        onClick: _cache[1] || (_cache[1] = withModifiers(() => {}, ["stop"])),
        disabled: _ctx.disabledOrUndefined,
        required: _ctx.requiredOrUndefined,
        name: _ctx.name,
        value: _ctx.nativeValue,
        onFocus: _cache[2] || (_cache[2] = $event => ($data.isFocused = true)),
        onBlur: _cache[3] || (_cache[3] = $event => ($data.isFocused = false))
      }, null, 40 /* PROPS, HYDRATE_EVENTS */, _hoisted_2$u), [
        [vModelCheckbox, _ctx.computedValue]
      ])
    ], 42 /* CLASS, PROPS, HYDRATE_EVENTS */, _hoisted_1$w)
  ], 2 /* CLASS */))
}

script$A.render = render$y;
script$A.__file = "src/components/checkbox/CheckboxButton.vue";

var Plugin$B = {
  install: function install(Vue) {
    registerComponent(Vue, script$B);
    registerComponent(Vue, script$A);
  }
};

var script$z = {
    name: 'BCollapse',
    props: {
        modelValue: {
            type: Boolean,
            default: true
        },
        animation: {
            type: String,
            default: 'fade'
        },
        ariaId: {
            type: String,
            default: ''
        },
        position: {
            type: String,
            default: 'is-top',
            validator(value) {
                return [
                    'is-top',
                    'is-bottom'
                ].indexOf(value) > -1
            }
        }
    },
    emits: ['close', 'open', 'update:modelValue'],
    data() {
        return {
            isOpen: this.modelValue
        }
    },
    watch: {
        modelValue(value) {
            this.isOpen = value;
        }
    },
    methods: {
        /**
        * Toggle and emit events
        */
        toggle() {
            this.isOpen = !this.isOpen;
            this.$emit('update:modelValue', this.isOpen);
            this.$emit(this.isOpen ? 'open' : 'close');
        }
    },
    render() {
        const trigger = h(
            'div',
            {
                class: 'collapse-trigger',
                onClick: this.toggle
            },
            this.$slots.trigger
                ? this.$slots.trigger({ open: this.isOpen })
                : undefined
        );
        const content = withDirectives(
            h(
                Transition,
                { name: this.animation },
                () => [
                    h(
                        'div',
                        {
                            class: 'collapse-content',
                            id: this.ariaId
                        },
                        this.$slots
                    )
                ]
            ),
            [[vShow, this.isOpen]]
        );
        return h(
            'div',
            { class: 'collapse' },
            this.position === 'is-top' ? [trigger, content] : [content, trigger]
        )
    }
};

script$z.__file = "src/components/collapse/Collapse.vue";

var Plugin$A = {
  install: function install(Vue) {
    registerComponent(Vue, script$z);
  }
};

var AM$1 = 'AM';
var PM$1 = 'PM';
var HOUR_FORMAT_24 = '24';
var HOUR_FORMAT_12 = '12';
var defaultTimeFormatter = function defaultTimeFormatter(date, vm) {
  return vm.dtf.format(date);
};
var defaultTimeParser = function defaultTimeParser(timeString, vm) {
  if (timeString) {
    var d = null;
    if (vm.computedValue && !isNaN(vm.computedValue)) {
      d = new Date(vm.computedValue);
    } else {
      d = vm.timeCreator();
      d.setMilliseconds(0);
    }
    if (vm.dtf.formatToParts && typeof vm.dtf.formatToParts === 'function') {
      var formatRegex = vm.dtf.formatToParts(d).map(function (part) {
        if (part.type === 'literal') {
          return part.value.replace(/ /g, '\\s?');
        } else if (part.type === 'dayPeriod') {
          return "((?!=<".concat(part.type, ">)(").concat(vm.amString, "|").concat(vm.pmString, "|").concat(AM$1, "|").concat(PM$1, "|").concat(AM$1.toLowerCase(), "|").concat(PM$1.toLowerCase(), ")?)");
        }
        return "((?!=<".concat(part.type, ">)\\d+)");
      }).join('');
      var timeGroups = matchWithGroups(formatRegex, timeString);

      // We do a simple validation for the group.
      // If it is not valid, it will fallback to Date.parse below
      timeGroups.hour = timeGroups.hour ? parseInt(timeGroups.hour, 10) : null;
      timeGroups.minute = timeGroups.minute ? parseInt(timeGroups.minute, 10) : null;
      timeGroups.second = timeGroups.second ? parseInt(timeGroups.second, 10) : null;
      if (timeGroups.hour && timeGroups.hour >= 0 && timeGroups.hour < 24 && timeGroups.minute && timeGroups.minute >= 0 && timeGroups.minute < 59) {
        if (timeGroups.dayPeriod && (timeGroups.dayPeriod.toLowerCase() === vm.pmString.toLowerCase() || timeGroups.dayPeriod.toLowerCase() === PM$1.toLowerCase()) && timeGroups.hour < 12) {
          timeGroups.hour += 12;
        }
        d.setHours(timeGroups.hour);
        d.setMinutes(timeGroups.minute);
        d.setSeconds(timeGroups.second || 0);
        return d;
      }
    }

    // Fallback if formatToParts is not supported or if we were not able to parse a valid date
    var am = false;
    if (vm.hourFormat === HOUR_FORMAT_12) {
      var dateString12 = timeString.split(' ');
      timeString = dateString12[0];
      am = dateString12[1] === vm.amString || dateString12[1] === AM$1;
    }
    var time = timeString.split(':');
    var hours = parseInt(time[0], 10);
    var minutes = parseInt(time[1], 10);
    var seconds = vm.enableSeconds ? parseInt(time[2], 10) : 0;
    if (isNaN(hours) || hours < 0 || hours > 23 || vm.hourFormat === HOUR_FORMAT_12 && (hours < 1 || hours > 12) || isNaN(minutes) || minutes < 0 || minutes > 59) {
      return null;
    }
    d.setSeconds(seconds);
    d.setMinutes(minutes);
    if (vm.hourFormat === HOUR_FORMAT_12) {
      if (am && hours === 12) {
        hours = 0;
      } else if (!am && hours !== 12) {
        hours += 12;
      }
    }
    d.setHours(hours);
    return new Date(d.getTime());
  }
  return null;
};
var TimepickerMixin = {
  mixins: [CompatFallthroughMixin, FormElementMixin],
  props: {
    modelValue: Date,
    inline: Boolean,
    minTime: Date,
    maxTime: Date,
    placeholder: String,
    editable: Boolean,
    disabled: Boolean,
    hourFormat: {
      type: String,
      validator: function validator(value) {
        return value === HOUR_FORMAT_24 || value === HOUR_FORMAT_12;
      }
    },
    incrementHours: {
      type: Number,
      "default": 1
    },
    incrementMinutes: {
      type: Number,
      "default": 1
    },
    incrementSeconds: {
      type: Number,
      "default": 1
    },
    timeFormatter: {
      type: Function,
      "default": function _default(date, vm) {
        if (typeof config.defaultTimeFormatter === 'function') {
          return config.defaultTimeFormatter(date);
        } else {
          return defaultTimeFormatter(date, vm);
        }
      }
    },
    timeParser: {
      type: Function,
      "default": function _default(date, vm) {
        if (typeof config.defaultTimeParser === 'function') {
          return config.defaultTimeParser(date);
        } else {
          return defaultTimeParser(date, vm);
        }
      }
    },
    mobileNative: {
      type: Boolean,
      "default": function _default() {
        return config.defaultTimepickerMobileNative;
      }
    },
    mobileModal: {
      type: Boolean,
      "default": function _default() {
        return config.defaultTimepickerMobileModal;
      }
    },
    timeCreator: {
      type: Function,
      "default": function _default() {
        if (typeof config.defaultTimeCreator === 'function') {
          return config.defaultTimeCreator();
        } else {
          return new Date();
        }
      }
    },
    position: String,
    unselectableTimes: Array,
    openOnFocus: Boolean,
    enableSeconds: Boolean,
    defaultMinutes: Number,
    defaultSeconds: Number,
    focusable: {
      type: Boolean,
      "default": true
    },
    tzOffset: {
      type: Number,
      "default": 0
    },
    appendToBody: Boolean,
    resetOnMeridianChange: {
      type: Boolean,
      "default": false
    }
  },
  emits: ['update:modelValue'],
  data: function data() {
    return {
      dateSelected: this.modelValue,
      hoursSelected: null,
      minutesSelected: null,
      secondsSelected: null,
      meridienSelected: null,
      _elementRef: 'input',
      AM: AM$1,
      PM: PM$1,
      HOUR_FORMAT_24: HOUR_FORMAT_24,
      HOUR_FORMAT_12: HOUR_FORMAT_12
    };
  },
  computed: {
    computedValue: {
      get: function get() {
        return this.dateSelected;
      },
      set: function set(value) {
        this.dateSelected = value;
        this.$emit('update:modelValue', this.dateSelected);
      }
    },
    localeOptions: function localeOptions() {
      return new Intl.DateTimeFormat(this.locale, {
        hour: 'numeric',
        minute: 'numeric',
        second: this.enableSeconds ? 'numeric' : undefined
      }).resolvedOptions();
    },
    dtf: function dtf() {
      return new Intl.DateTimeFormat(this.locale, {
        hour: this.localeOptions.hour || 'numeric',
        minute: this.localeOptions.minute || 'numeric',
        second: this.enableSeconds ? this.localeOptions.second || 'numeric' : undefined,
        // Fixes 12 hour display github.com/buefy/buefy/issues/3418
        hourCycle: !this.isHourFormat24 ? 'h12' : 'h23'
      });
    },
    newHourFormat: function newHourFormat() {
      return this.hourFormat || (this.localeOptions.hour12 ? HOUR_FORMAT_12 : HOUR_FORMAT_24);
    },
    sampleTime: function sampleTime() {
      var d = this.timeCreator();
      d.setHours(10);
      d.setSeconds(0);
      d.setMinutes(0);
      d.setMilliseconds(0);
      return d;
    },
    hourLiteral: function hourLiteral() {
      if (this.dtf.formatToParts && typeof this.dtf.formatToParts === 'function') {
        var d = this.sampleTime;
        var parts = this.dtf.formatToParts(d);
        var literal = parts.find(function (part, idx) {
          return idx > 0 && parts[idx - 1].type === 'hour';
        });
        if (literal) {
          return literal.value;
        }
      }
      return ':';
    },
    minuteLiteral: function minuteLiteral() {
      if (this.dtf.formatToParts && typeof this.dtf.formatToParts === 'function') {
        var d = this.sampleTime;
        var parts = this.dtf.formatToParts(d);
        var literal = parts.find(function (part, idx) {
          return idx > 0 && parts[idx - 1].type === 'minute';
        });
        if (literal) {
          return literal.value;
        }
      }
      return ':';
    },
    secondLiteral: function secondLiteral() {
      if (this.dtf.formatToParts && typeof this.dtf.formatToParts === 'function') {
        var d = this.sampleTime;
        var parts = this.dtf.formatToParts(d);
        var literal = parts.find(function (part, idx) {
          return idx > 0 && parts[idx - 1].type === 'second';
        });
        if (literal) {
          return literal.value;
        }
      }
    },
    amString: function amString() {
      if (this.dtf.formatToParts && typeof this.dtf.formatToParts === 'function') {
        var d = this.sampleTime;
        d.setHours(10);
        var dayPeriod = this.dtf.formatToParts(d).find(function (part) {
          return part.type === 'dayPeriod';
        });
        if (dayPeriod) {
          return dayPeriod.value;
        }
      }
      return AM$1;
    },
    pmString: function pmString() {
      if (this.dtf.formatToParts && typeof this.dtf.formatToParts === 'function') {
        var d = this.sampleTime;
        d.setHours(20);
        var dayPeriod = this.dtf.formatToParts(d).find(function (part) {
          return part.type === 'dayPeriod';
        });
        if (dayPeriod) {
          return dayPeriod.value;
        }
      }
      return PM$1;
    },
    hours: function hours() {
      if (!this.incrementHours || this.incrementHours < 1) throw new Error('Hour increment cannot be null or less than 1.');
      var hours = [];
      var numberOfHours = this.isHourFormat24 ? 24 : 12;
      for (var i = 0; i < numberOfHours; i += this.incrementHours) {
        var value = i;
        var label = value;
        if (!this.isHourFormat24) {
          value = i + 1;
          label = value;
          if (this.meridienSelected === this.amString) {
            if (value === 12) {
              value = 0;
            }
          } else if (this.meridienSelected === this.pmString) {
            if (value !== 12) {
              value += 12;
            }
          }
        }
        hours.push({
          label: this.formatNumber(label),
          value: value
        });
      }
      return hours;
    },
    minutes: function minutes() {
      if (!this.incrementMinutes || this.incrementMinutes < 1) throw new Error('Minute increment cannot be null or less than 1.');
      var minutes = [];
      for (var i = 0; i < 60; i += this.incrementMinutes) {
        minutes.push({
          label: this.formatNumber(i, true),
          value: i
        });
      }
      return minutes;
    },
    seconds: function seconds() {
      if (!this.incrementSeconds || this.incrementSeconds < 1) throw new Error('Second increment cannot be null or less than 1.');
      var seconds = [];
      for (var i = 0; i < 60; i += this.incrementSeconds) {
        seconds.push({
          label: this.formatNumber(i, true),
          value: i
        });
      }
      return seconds;
    },
    meridiens: function meridiens() {
      return [this.amString, this.pmString];
    },
    isMobile: function isMobile$1() {
      return this.mobileNative && isMobile.any();
    },
    isHourFormat24: function isHourFormat24() {
      return this.newHourFormat === HOUR_FORMAT_24;
    },
    disabledOrUndefined: function disabledOrUndefined() {
      return this.disabled || undefined;
    }
  },
  watch: {
    hourFormat: function hourFormat() {
      if (this.hoursSelected !== null) {
        this.meridienSelected = this.hoursSelected >= 12 ? this.pmString : this.amString;
      }
    },
    locale: function locale() {
      // see updateInternalState default
      if (!this.value) {
        this.meridienSelected = this.amString;
      }
    },
    /**
     * When v-model is changed:
     *   1. Update internal value.
     *   2. If it's invalid, validate again.
     */
    modelValue: {
      handler: function handler(value) {
        this.updateInternalState(value);
        !this.isValid && this.$refs.input.checkHtml5Validity();
      },
      immediate: true
    }
  },
  methods: {
    onMeridienChange: function onMeridienChange(value) {
      if (this.hoursSelected !== null && this.resetOnMeridianChange) {
        this.hoursSelected = null;
        this.minutesSelected = null;
        this.secondsSelected = null;
        this.computedValue = null;
      } else if (this.hoursSelected !== null) {
        if (value === this.pmString) {
          this.hoursSelected += 12;
        } else if (value === this.amString) {
          this.hoursSelected -= 12;
        }
      }
      this.updateDateSelected(this.hoursSelected, this.minutesSelected, this.enableSeconds ? this.secondsSelected : 0, value);
    },
    onHoursChange: function onHoursChange(value) {
      if (!this.minutesSelected && typeof this.defaultMinutes !== 'undefined') {
        this.minutesSelected = this.defaultMinutes;
      }
      if (!this.secondsSelected && typeof this.defaultSeconds !== 'undefined') {
        this.secondsSelected = this.defaultSeconds;
      }
      this.updateDateSelected(parseInt(value, 10), this.minutesSelected, this.enableSeconds ? this.secondsSelected : 0, this.meridienSelected);
    },
    onMinutesChange: function onMinutesChange(value) {
      if (!this.secondsSelected && this.defaultSeconds) {
        this.secondsSelected = this.defaultSeconds;
      }
      this.updateDateSelected(this.hoursSelected, parseInt(value, 10), this.enableSeconds ? this.secondsSelected : 0, this.meridienSelected);
    },
    onSecondsChange: function onSecondsChange(value) {
      this.updateDateSelected(this.hoursSelected, this.minutesSelected, parseInt(value, 10), this.meridienSelected);
    },
    updateDateSelected: function updateDateSelected(hours, minutes, seconds, meridiens) {
      if (hours != null && minutes != null && (!this.isHourFormat24 && meridiens !== null || this.isHourFormat24)) {
        var time = null;
        if (this.computedValue && !isNaN(this.computedValue)) {
          time = new Date(this.computedValue);
        } else {
          time = this.timeCreator();
          time.setMilliseconds(0);
        }
        time.setHours(hours);
        time.setMinutes(minutes);
        time.setSeconds(seconds);
        if (!isNaN(time.getTime())) this.computedValue = new Date(time.getTime());
      }
    },
    updateInternalState: function updateInternalState(value) {
      if (value) {
        this.hoursSelected = value.getHours();
        this.minutesSelected = value.getMinutes();
        this.secondsSelected = value.getSeconds();
        this.meridienSelected = value.getHours() >= 12 ? this.pmString : this.amString;
      } else {
        this.hoursSelected = null;
        this.minutesSelected = null;
        this.secondsSelected = null;
        this.meridienSelected = this.amString;
      }
      this.dateSelected = value;
    },
    isHourDisabled: function isHourDisabled(hour) {
      var _this = this;
      var disabled = false;
      if (this.minTime) {
        var minHours = this.minTime.getHours();
        var noMinutesAvailable = this.minutes.every(function (minute) {
          return _this.isMinuteDisabledForHour(hour, minute.value);
        });
        disabled = hour < minHours || noMinutesAvailable;
      }
      if (this.maxTime) {
        if (!disabled) {
          var maxHours = this.maxTime.getHours();
          disabled = hour > maxHours;
        }
      }
      if (this.unselectableTimes) {
        if (!disabled) {
          var unselectable = this.unselectableTimes.filter(function (time) {
            if (_this.enableSeconds && _this.secondsSelected !== null) {
              return time.getHours() === hour && time.getMinutes() === _this.minutesSelected && time.getSeconds() === _this.secondsSelected;
            } else if (_this.minutesSelected !== null) {
              return time.getHours() === hour && time.getMinutes() === _this.minutesSelected;
            }
            return false;
          });
          if (unselectable.length > 0) {
            disabled = true;
          } else {
            disabled = this.minutes.every(function (minute) {
              return _this.unselectableTimes.filter(function (time) {
                return time.getHours() === hour && time.getMinutes() === minute.value;
              }).length > 0;
            });
          }
        }
      }
      return disabled;
    },
    isMinuteDisabledForHour: function isMinuteDisabledForHour(hour, minute) {
      var disabled = false;
      if (this.minTime) {
        var minHours = this.minTime.getHours();
        var minMinutes = this.minTime.getMinutes();
        disabled = hour === minHours && minute < minMinutes;
      }
      if (this.maxTime) {
        if (!disabled) {
          var maxHours = this.maxTime.getHours();
          var maxMinutes = this.maxTime.getMinutes();
          disabled = hour === maxHours && minute > maxMinutes;
        }
      }
      return disabled;
    },
    isMinuteDisabled: function isMinuteDisabled(minute) {
      var _this2 = this;
      var disabled = false;
      if (this.hoursSelected !== null) {
        if (this.isHourDisabled(this.hoursSelected)) {
          disabled = true;
        } else {
          disabled = this.isMinuteDisabledForHour(this.hoursSelected, minute);
        }
        if (this.unselectableTimes) {
          if (!disabled) {
            var unselectable = this.unselectableTimes.filter(function (time) {
              if (_this2.enableSeconds && _this2.secondsSelected !== null) {
                return time.getHours() === _this2.hoursSelected && time.getMinutes() === minute && time.getSeconds() === _this2.secondsSelected;
              } else {
                return time.getHours() === _this2.hoursSelected && time.getMinutes() === minute;
              }
            });
            disabled = unselectable.length > 0;
          }
        }
      }
      return disabled;
    },
    isSecondDisabled: function isSecondDisabled(second) {
      var _this3 = this;
      var disabled = false;
      if (this.minutesSelected !== null) {
        if (this.isMinuteDisabled(this.minutesSelected)) {
          disabled = true;
        } else {
          if (this.minTime) {
            var minHours = this.minTime.getHours();
            var minMinutes = this.minTime.getMinutes();
            var minSeconds = this.minTime.getSeconds();
            disabled = this.hoursSelected === minHours && this.minutesSelected === minMinutes && second < minSeconds;
          }
          if (this.maxTime) {
            if (!disabled) {
              var maxHours = this.maxTime.getHours();
              var maxMinutes = this.maxTime.getMinutes();
              var maxSeconds = this.maxTime.getSeconds();
              disabled = this.hoursSelected === maxHours && this.minutesSelected === maxMinutes && second > maxSeconds;
            }
          }
        }
        if (this.unselectableTimes) {
          if (!disabled) {
            var unselectable = this.unselectableTimes.filter(function (time) {
              return time.getHours() === _this3.hoursSelected && time.getMinutes() === _this3.minutesSelected && time.getSeconds() === second;
            });
            disabled = unselectable.length > 0;
          }
        }
      }
      return disabled;
    },
    /*
     * Parse string into date
     */
    onChange: function onChange(value) {
      var date = this.timeParser(value, this);
      this.updateInternalState(date);
      if (date && !isNaN(date)) {
        this.computedValue = date;
      } else {
        // Force refresh input value when not valid date
        this.computedValue = null;
        this.$refs.input.newValue = this.computedValue;
      }
    },
    /*
     * Toggle timepicker
     */
    toggle: function toggle(active) {
      if (this.$refs.dropdown) {
        this.$refs.dropdown.isActive = typeof active === 'boolean' ? active : !this.$refs.dropdown.isActive;
      }
    },
    /*
     * Close timepicker
     */
    close: function close() {
      this.toggle(false);
    },
    /*
     * Call default onFocus method and show timepicker
     */
    handleOnFocus: function handleOnFocus() {
      this.onFocus();
      if (this.openOnFocus) {
        this.toggle(true);
      }
    },
    /*
     * Format date into string 'HH-MM-SS'
     */
    formatHHMMSS: function formatHHMMSS(value) {
      var date = new Date(value);
      if (value && !isNaN(date)) {
        var hours = date.getHours();
        var minutes = date.getMinutes();
        var seconds = date.getSeconds();
        return this.formatNumber(hours, true) + ':' + this.formatNumber(minutes, true) + ':' + this.formatNumber(seconds, true);
      }
      return '';
    },
    /*
     * Parse time from string
     */
    onChangeNativePicker: function onChangeNativePicker(event) {
      var date = event.target.value;
      if (date) {
        var time = null;
        if (this.computedValue && !isNaN(this.computedValue)) {
          time = new Date(this.computedValue);
        } else {
          time = new Date();
          time.setMilliseconds(0);
        }
        var t = date.split(':');
        time.setHours(parseInt(t[0], 10));
        time.setMinutes(parseInt(t[1], 10));
        time.setSeconds(t[2] ? parseInt(t[2], 10) : 0);
        this.computedValue = new Date(time.getTime());
      } else {
        this.computedValue = null;
      }
    },
    formatNumber: function formatNumber(value, prependZero) {
      return this.isHourFormat24 || prependZero ? this.pad(value) : value;
    },
    pad: function pad(value) {
      return (value < 10 ? '0' : '') + value;
    },
    /*
     * Format date into string
     */
    formatValue: function formatValue(date) {
      if (date && !isNaN(date)) {
        return this.timeFormatter(date, this);
      } else {
        return null;
      }
    },
    /**
     * Keypress event that is bound to the document.
     */
    keyPress: function keyPress(_ref) {
      var key = _ref.key;
      if (this.$refs.dropdown && this.$refs.dropdown.isActive && (key === 'Escape' || key === 'Esc')) {
        this.toggle(false);
      }
    },
    /**
     * Emit 'blur' event on dropdown is not active (closed)
     */
    onActiveChange: function onActiveChange(value) {
      if (!value) {
        this.onBlur();
      }
    }
  },
  created: function created() {
    if (typeof window !== 'undefined') {
      document.addEventListener('keyup', this.keyPress);
    }
  },
  beforeUnmounted: function beforeUnmounted() {
    if (typeof window !== 'undefined') {
      document.removeEventListener('keyup', this.keyPress);
    }
  }
};

var findFocusable = function findFocusable(element) {
  var programmatic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  if (!element) {
    return null;
  }
  if (programmatic) {
    return element.querySelectorAll('*[tabindex="-1"]');
  }
  return element.querySelectorAll("a[href]:not([tabindex=\"-1\"]),\n                                     area[href],\n                                     input:not([disabled]),\n                                     select:not([disabled]),\n                                     textarea:not([disabled]),\n                                     button:not([disabled]),\n                                     iframe,\n                                     object,\n                                     embed,\n                                     *[tabindex]:not([tabindex=\"-1\"]),\n                                     *[contenteditable]");
};
var onKeyDown;
var beforeMount$1 = function beforeMount(el, _ref) {
  var _ref$value = _ref.value,
    value = _ref$value === void 0 ? true : _ref$value;
  if (value) {
    var focusable = findFocusable(el);
    var focusableProg = findFocusable(el, true);
    if (focusable && focusable.length > 0) {
      onKeyDown = function onKeyDown(event) {
        // Need to get focusable each time since it can change between key events
        // ex. changing month in a datepicker
        focusable = findFocusable(el);
        focusableProg = findFocusable(el, true);
        var firstFocusable = focusable[0];
        var lastFocusable = focusable[focusable.length - 1];
        if (event.target === firstFocusable && event.shiftKey && event.key === 'Tab') {
          event.preventDefault();
          lastFocusable.focus();
        } else if ((event.target === lastFocusable || Array.from(focusableProg).indexOf(event.target) >= 0) && !event.shiftKey && event.key === 'Tab') {
          event.preventDefault();
          firstFocusable.focus();
        }
      };
      el.addEventListener('keydown', onKeyDown);
    }
  }
};
var unmounted$1 = function unmounted(el) {
  el.removeEventListener('keydown', onKeyDown);
};
var directive$1 = {
  beforeMount: beforeMount$1,
  unmounted: unmounted$1
};
var trapFocus = directive$1;

const DEFAULT_CLOSE_OPTIONS = ['escape', 'outside'];

const DROPDOWN_INJECTION_KEY = Symbol('bdropdown');

var script$1$e = {
    name: 'BDropdown',
    directives: {
        trapFocus
    },
    provide() {
        return {
            [DROPDOWN_INJECTION_KEY]: this
        }
    },
    props: {
        modelValue: {
            type: [String, Number, Boolean, Object, Array, Function],
            default: null
        },
        disabled: Boolean,
        inline: Boolean,
        scrollable: Boolean,
        maxHeight: {
            type: [String, Number],
            default: 200
        },
        position: {
            type: String,
            validator(value) {
                return [
                    'is-top-right',
                    'is-top-left',
                    'is-bottom-left',
                    'is-bottom-right'
                ].indexOf(value) > -1
            }
        },
        triggers: {
            type: Array,
            default: () => ['click']
        },
        mobileModal: {
            type: Boolean,
            default: () => {
                return config.defaultDropdownMobileModal
            }
        },
        ariaRole: {
            type: String,
            validator(value) {
                return [
                    'menu',
                    'list',
                    'dialog'
                ].indexOf(value) > -1
            },
            default: null
        },
        animation: {
            type: String,
            default: 'fade'
        },
        multiple: Boolean,
        trapFocus: {
            type: Boolean,
            default: () => {
                return config.defaultTrapFocus
            }
        },
        closeOnClick: {
            type: Boolean,
            default: true
        },
        canClose: {
            type: [Array, Boolean],
            default: true
        },
        expanded: Boolean,
        appendToBody: Boolean,
        appendToBodyCopyParent: Boolean,
        triggerTabindex: {
            type: Number,
            default: 0
        }
    },
    emits: ['active-change', 'change', 'update:modelValue'],
    data() {
        return {
            selected: this.modelValue,
            style: {},
            isActive: false,
            isHoverable: false,
            maybeTap: false,
            isTouchEnabled: false,
            _bodyEl: undefined, // Used to append to body
            timeOutID: null,
            timeOutID2: null
        }
    },
    computed: {
        rootClasses() {
            return [this.position, {
                'is-disabled': this.disabled,
                'is-hoverable': this.hoverable,
                'is-inline': this.inline,
                'is-active': this.isActive || this.inline,
                'is-mobile-modal': this.isMobileModal,
                'is-expanded': this.expanded,
                'is-touch-enabled': this.isTouchEnabled
            }]
        },
        isMobileModal() {
            return this.mobileModal && !this.inline
        },
        cancelOptions() {
            return typeof this.canClose === 'boolean'
                ? this.canClose
                    ? DEFAULT_CLOSE_OPTIONS
                    : []
                : this.canClose
        },
        contentStyle() {
            return {
                maxHeight: this.scrollable ? toCssWidth(this.maxHeight) : null,
                overflow: this.scrollable ? 'auto' : null
            }
        },
        hoverable() {
            return this.triggers.indexOf('hover') >= 0
        }
    },
    watch: {
        /**
        * When v-model is changed set the new selected item.
        */
        modelValue(value) {
            this.selected = value;
        },

        /**
        * Emit event when isActive value is changed.
        *
        * Also resets `isTouchEnabled` when it turns inactive.
        */
        isActive(value) {
            this.$emit('active-change', value);
            if (!value) {
                // delays to reset the touch enabled flag until the dropdown
                // menu disappears to avoid glitches
                // also takes care of chattering, e.g., repeated quick taps,
                // otherwise the flag may become inconsistent with the actual
                // state of the dropdown menu
                this.timeOutID = setTimeout(() => {
                    if (!this.isActive) {
                        this.isTouchEnabled = false;
                    }
                }, 250);
            }
            this.handleScroll();
            if (this.appendToBody) {
                this.$nextTick(() => {
                    this.updateAppendToBody();
                });
            }
        },

        isHoverable(value) {
            if (this.hoverable) {
                this.$emit('active-change', value);
            }
        }
    },
    methods: {
        handleScroll() {
            if (typeof window === 'undefined') return

            if (this.isMobileModal) {
                if (this.isActive) {
                    document.documentElement.classList.add('is-clipped-touch');
                } else {
                    document.documentElement.classList.remove('is-clipped-touch');
                }
            }
        },

        /**
         * Click listener from DropdownItem.
         *   1. Set new selected item.
         *   2. Emit input event to update the user v-model.
         *   3. Close the dropdown.
         */
        selectItem(value) {
            if (this.multiple) {
                if (this.selected) {
                    if (this.selected.indexOf(value) === -1) {
                        // Add value
                        this.selected = [...this.selected, value];
                    } else {
                        // Remove value
                        this.selected = this.selected.filter((val) => val !== value);
                    }
                } else {
                    this.selected = [value];
                }
                this.$emit('change', this.selected);
            } else {
                if (this.selected !== value) {
                    this.selected = value;
                    this.$emit('change', this.selected);
                }
            }
            this.$emit('update:modelValue', this.selected);
            if (!this.multiple) {
                this.isActive = !this.closeOnClick;
                if (this.hoverable && this.closeOnClick) {
                    this.isHoverable = false;
                }
            }
        },

        /**
        * White-listed items to not close when clicked.
        */
        isInWhiteList(el) {
            if (el === this.$refs.dropdownMenu) return true
            if (el === this.$refs.trigger) return true
            // All chidren from dropdown
            if (this.$refs.dropdownMenu != null) {
                const children = this.$refs.dropdownMenu.querySelectorAll('*');
                for (const child of children) {
                    if (el === child) {
                        return true
                    }
                }
            }
            // All children from trigger
            if (this.$refs.trigger != null) {
                const children = this.$refs.trigger.querySelectorAll('*');
                for (const child of children) {
                    if (el === child) {
                        return true
                    }
                }
            }
            return false
        },

        /**
        * Close dropdown if clicked outside.
        */
        clickedOutside(event) {
            if (this.cancelOptions.indexOf('outside') < 0) return
            if (this.inline) return

            const target = isCustomElement(this) ? event.composedPath()[0] : event.target;
            if (!this.isInWhiteList(target)) this.isActive = false;
        },

        /**
         * Keypress event that is bound to the document
         */
        keyPress({ key }) {
            if (this.isActive && (key === 'Escape' || key === 'Esc')) {
                if (this.cancelOptions.indexOf('escape') < 0) return
                this.isActive = false;
            }
        },

        onClick() {
            // hover precedes
            if (this.triggers.indexOf('hover') !== -1) return
            if (this.triggers.indexOf('click') < 0) return
            this.toggle();
        },
        onContextMenu() {
            if (this.triggers.indexOf('contextmenu') < 0) return
            this.toggle();
        },
        onHover() {
            if (this.triggers.indexOf('hover') < 0) return
            // touch precedes
            if (this.isTouchEnabled) return
            this.isHoverable = true;
        },
        // takes care of touch-enabled devices
        // - does nothing if hover trigger is disabled
        // - suppresses hover trigger by setting isTouchEnabled
        // - handles only a tap; i.e., touchstart on the trigger immediately
        //   folowed by touchend
        onTouchStart() {
            this.maybeTap = true;
        },
        onTouchMove() {
            this.maybeTap = false;
        },
        onTouchEnd(e) {
            if (this.triggers.indexOf('hover') === -1) return
            if (!this.maybeTap) return
            // tap on dropdown contents may happen without preventDefault
            e.preventDefault();
            this.maybeTap = false;
            this.isTouchEnabled = true;
            this.toggle();
        },
        onFocus() {
            if (this.triggers.indexOf('focus') < 0) return
            this.toggle();
        },

        /**
        * Toggle dropdown if it's not disabled.
        */
        toggle() {
            if (this.disabled) return

            if (!this.isActive) {
                // if not active, toggle after clickOutside event
                // this fixes toggling programmatic
                // $nextTick may not wait for other events since Vue 3.
                this.timeOutID2 = setTimeout(() => {
                    const value = !this.isActive;
                    this.isActive = value;
                });
            } else {
                this.isActive = !this.isActive;
            }
        },

        updateAppendToBody() {
            const dropdown = this.$refs.dropdown;
            const dropdownMenu = this.$refs.dropdownMenu;
            const trigger = this.$refs.trigger;
            if (dropdownMenu && trigger) {
                // update wrapper dropdown
                const dropdownWrapper = this.$data._bodyEl.children[0];
                dropdownWrapper.classList.forEach((item) => dropdownWrapper.classList.remove(item));
                dropdownWrapper.classList.add('dropdown');
                dropdownWrapper.classList.add('dropdown-menu-animation');
                // TODO: the following test never becomes true on Vue 3.
                //       I have no idea about the intention of it.
                if (this.$vnode && this.$vnode.data && this.$vnode.data.staticClass) {
                    dropdownWrapper.classList.add(this.$vnode.data.staticClass);
                }
                this.rootClasses.forEach((item) => {
                    // skip position prop
                    if (item && typeof item === 'object') {
                        for (const key in item) {
                            if (item[key]) {
                                dropdownWrapper.classList.add(key);
                            }
                        }
                    }
                });
                if (this.appendToBodyCopyParent) {
                    const parentNode = this.$refs.dropdown.parentNode;
                    const parent = this.$data._bodyEl;
                    parent.classList.forEach((item) => parent.classList.remove(item));
                    parentNode.classList.forEach((item) => {
                        parent.classList.add(item);
                    });
                }
                const rect = trigger.getBoundingClientRect();
                let top = rect.top + window.scrollY;
                let left = rect.left + window.scrollX;
                if (!this.position || this.position.indexOf('bottom') >= 0) {
                    top += trigger.clientHeight;
                } else {
                    top -= dropdownMenu.clientHeight;
                }
                if (this.position && this.position.indexOf('left') >= 0) {
                    left -= (dropdownMenu.clientWidth - trigger.clientWidth);
                }
                this.style = {
                    position: 'absolute',
                    top: `${top}px`,
                    left: `${left}px`,
                    zIndex: '99',
                    width: this.expanded ? `${dropdown.offsetWidth}px` : undefined
                };
            }
        }
    },
    mounted() {
        if (this.appendToBody) {
            this.$data._bodyEl = createAbsoluteElement(this.$refs.dropdownMenu);
            this.updateAppendToBody();
        }
    },
    created() {
        if (typeof window !== 'undefined') {
            document.addEventListener('click', this.clickedOutside);
            document.addEventListener('keyup', this.keyPress);
        }
    },
    beforeUnmount() {
        if (typeof window !== 'undefined') {
            document.removeEventListener('click', this.clickedOutside);
            document.removeEventListener('keyup', this.keyPress);
        }
        if (this.appendToBody) {
            removeElement(this.$data._bodyEl);
        }
        clearTimeout(this.timeOutID);
        clearTimeout(this.timeOutID2);
    }
};

const _hoisted_1$1$8 = ["tabindex"];
const _hoisted_2$1$6 = ["aria-hidden"];
const _hoisted_3$1$4 = ["aria-hidden"];
const _hoisted_4$f = ["role", "aria-modal"];

function render$1$b(_ctx, _cache, $props, $setup, $data, $options) {
  const _directive_trap_focus = resolveDirective("trap-focus");

  return (openBlock(), createElementBlock("div", {
    class: normalizeClass(["dropdown dropdown-menu-animation", $options.rootClasses]),
    ref: "dropdown",
    onMouseleave: _cache[7] || (_cache[7] = $event => ($data.isHoverable = false))
  }, [
    (!$props.inline)
      ? (openBlock(), createElementBlock("div", {
          key: 0,
          tabindex: $props.disabled ? false : $props.triggerTabindex,
          ref: "trigger",
          class: "dropdown-trigger",
          onClick: _cache[0] || (_cache[0] = (...args) => ($options.onClick && $options.onClick(...args))),
          onContextmenu: _cache[1] || (_cache[1] = withModifiers((...args) => ($options.onContextMenu && $options.onContextMenu(...args)), ["prevent"])),
          onMouseenter: _cache[2] || (_cache[2] = (...args) => ($options.onHover && $options.onHover(...args))),
          onFocusCapture: _cache[3] || (_cache[3] = (...args) => ($options.onFocus && $options.onFocus(...args))),
          onTouchstart: _cache[4] || (_cache[4] = (...args) => ($options.onTouchStart && $options.onTouchStart(...args))),
          onTouchmove: _cache[5] || (_cache[5] = (...args) => ($options.onTouchMove && $options.onTouchMove(...args))),
          onTouchend: _cache[6] || (_cache[6] = (...args) => ($options.onTouchEnd && $options.onTouchEnd(...args))),
          "aria-haspopup": "true"
        }, [
          renderSlot(_ctx.$slots, "trigger", { active: $data.isActive })
        ], 40 /* PROPS, HYDRATE_EVENTS */, _hoisted_1$1$8))
      : createCommentVNode("v-if", true),
    createVNode(Transition, { name: $props.animation }, {
      default: withCtx(() => [
        ($options.isMobileModal)
          ? withDirectives((openBlock(), createElementBlock("div", {
              key: 0,
              class: "background",
              "aria-hidden": !$data.isActive
            }, null, 8 /* PROPS */, _hoisted_2$1$6)), [
              [vShow, $data.isActive]
            ])
          : createCommentVNode("v-if", true)
      ]),
      _: 1 /* STABLE */
    }, 8 /* PROPS */, ["name"]),
    createVNode(Transition, {
      name: $props.animation,
      persisted: ""
    }, {
      default: withCtx(() => [
        withDirectives((openBlock(), createElementBlock("div", {
          ref: "dropdownMenu",
          class: "dropdown-menu",
          style: normalizeStyle($data.style),
          "aria-hidden": !$data.isActive
        }, [
          createBaseVNode("div", {
            class: "dropdown-content",
            role: $props.ariaRole,
            "aria-modal": !$props.inline,
            style: normalizeStyle($options.contentStyle)
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 12 /* STYLE, PROPS */, _hoisted_4$f)
        ], 12 /* STYLE, PROPS */, _hoisted_3$1$4)), [
          [vShow, (!$props.disabled && ($data.isActive || $data.isHoverable)) || $props.inline],
          [_directive_trap_focus, $props.trapFocus]
        ])
      ]),
      _: 3 /* FORWARDED */
    }, 8 /* PROPS */, ["name"])
  ], 34 /* CLASS, HYDRATE_EVENTS */))
}

script$1$e.render = render$1$b;
script$1$e.__file = "src/components/dropdown/Dropdown.vue";

var script$y = {
    name: 'BDropdownItem',
    inject: {
        parent: {
            from: DROPDOWN_INJECTION_KEY,
            default: undefined
        }
    },
    props: {
        value: {
            type: [String, Number, Boolean, Object, Array, Function],
            default: null
        },
        separator: Boolean,
        disabled: Boolean,
        custom: Boolean,
        focusable: {
            type: Boolean,
            default: true
        },
        paddingless: Boolean,
        hasLink: Boolean,
        ariaRole: {
            type: String,
            default: ''
        }
    },
    emits: ['click'],
    computed: {
        anchorClasses() {
            return {
                'is-disabled': this.parent.disabled || this.disabled,
                'is-paddingless': this.paddingless,
                'is-active': this.isActive
            }
        },
        itemClasses() {
            return {
                'dropdown-item': !this.hasLink,
                'is-disabled': this.disabled,
                'is-paddingless': this.paddingless,
                'is-active': this.isActive,
                'has-link': this.hasLink
            }
        },
        ariaRoleItem() {
            return this.ariaRole === 'menuitem' || this.ariaRole === 'listitem' ? this.ariaRole : null
        },
        isClickable() {
            return !this.parent.disabled && !this.separator && !this.disabled && !this.custom
        },
        isActive() {
            if (this.parent.selected === null) return false
            if (this.parent.multiple) return this.parent.selected.indexOf(this.value) >= 0
            return this.value === this.parent.selected
        },
        isFocusable() {
            return this.hasLink ? false : this.focusable
        }
    },
    methods: {
        /**
        * Click listener, select the item.
        */
        selectItem() {
            if (!this.isClickable) return

            this.parent.selectItem(this.value);
            this.$emit('click');
        }
    }
};

const _hoisted_1$v = {
  key: 0,
  class: "dropdown-divider"
};
const _hoisted_2$t = ["role", "tabindex"];
const _hoisted_3$k = ["role", "tabindex"];

function render$x(_ctx, _cache, $props, $setup, $data, $options) {
  return ($props.separator)
    ? (openBlock(), createElementBlock("hr", _hoisted_1$v))
    : (!$props.custom && !$props.hasLink)
      ? (openBlock(), createElementBlock("a", {
          key: 1,
          class: normalizeClass(["dropdown-item", $options.anchorClasses]),
          onClick: _cache[0] || (_cache[0] = (...args) => ($options.selectItem && $options.selectItem(...args))),
          role: $options.ariaRoleItem,
          tabindex: $options.isFocusable ? 0 : null
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 10 /* CLASS, PROPS */, _hoisted_2$t))
      : (openBlock(), createElementBlock("div", {
          key: 2,
          class: normalizeClass($options.itemClasses),
          onClick: _cache[1] || (_cache[1] = (...args) => ($options.selectItem && $options.selectItem(...args))),
          role: $options.ariaRoleItem,
          tabindex: $options.isFocusable ? 0 : null
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 10 /* CLASS, PROPS */, _hoisted_3$k))
}

script$y.render = render$x;
script$y.__file = "src/components/dropdown/DropdownItem.vue";

var script$1$d = {
    name: 'BFieldBody',
    inject: {
        parent: {
            from: 'BField',
            default: null
        }
    },
    props: {
        message: {
            type: [String, Array]
        },
        type: {
            type: [String, Object]
        }
    },
    render() {
        let first = true;
        // wraps the default slot (children) with `b-field`.
        // children may be given in a fragment and should be extracted.
        let children = typeof this.$slots.default === 'function'
            ? this.$slots.default()
            : this.$slots.default;
        if (children != null && children.length === 1 && children[0].type === Fragment) {
            children = children[0].children;
        }
        return h(
            'div',
            { class: 'field-body' },
            {
                default: () => {
                    return children != null && children.map((element) => {
                        // skip returns(?) and comments
                        if (element.type === Comment || element.type === Text) {
                            return element
                        }
                        let message;
                        if (first) {
                            message = this.message;
                            first = false;
                        }
                        return h(
                            this.parent ? this.parent.$.type : resolveComponent('b-field'),
                            {
                                type: this.type,
                                message
                            },
                            () => element
                        )
                    })
                }
            }
        )
    }
};

script$1$d.__file = "src/components/field/FieldBody.vue";

var script$x = {
    name: 'BField',
    components: {
        [script$1$d.name]: script$1$d
    },
    provide() {
        return {
            BField: this
        }
    },
    inject: {
        parent: {
            from: 'BField',
            default: false
        }
    }, // Used internally only when using Field in Field
    props: {
        type: [String, Object],
        label: String,
        labelFor: String,
        message: [String, Array, Object],
        grouped: Boolean,
        groupMultiline: Boolean,
        position: String,
        expanded: Boolean,
        horizontal: Boolean,
        addons: {
            type: Boolean,
            default: true
        },
        customClass: String,
        labelPosition: {
            type: String,
            default: () => { return config.defaultFieldLabelPosition }
        }
    },
    data() {
        return {
            newType: this.type,
            newMessage: this.message,
            fieldLabelSize: null,
            numberInputClasses: [],
            _isField: true // Used internally by Input and Select
        }
    },
    computed: {
        rootClasses() {
            return [{
                'is-expanded': this.expanded,
                'is-horizontal': this.horizontal,
                'is-floating-in-label': this.hasLabel && !this.horizontal &&
                    this.labelPosition === 'inside',
                'is-floating-label': this.hasLabel && !this.horizontal &&
                    this.labelPosition === 'on-border'
            },
            this.numberInputClasses]
        },
        innerFieldClasses() {
            return [
                this.fieldType(),
                this.newPosition,
                {
                    'is-grouped-multiline': this.groupMultiline
                }
            ]
        },
        hasInnerField() {
            return this.grouped || this.groupMultiline || this.hasAddons()
        },
        /**
        * Correct Bulma class for the side of the addon or group.
        *
        * This is not kept like the others (is-small, etc.),
        * because since 'has-addons' is set automatically it
        * doesn't make sense to teach users what addons are exactly.
        */
        newPosition() {
            if (this.position === undefined) return

            const position = this.position.split('-');
            if (position.length < 1) return

            const prefix = this.grouped
                ? 'is-grouped-'
                : 'has-addons-';

            if (this.position) return prefix + position[1]
            return undefined
        },
        /**
        * Formatted message in case it's an array
        * (each element is separated by <br> tag)
        */
        formattedMessage() {
            if (this.parent && this.parent.hasInnerField) {
                return '' // Message will be displayed in parent field
            }
            if (typeof this.newMessage === 'string') {
                return [this.newMessage]
            }
            const messages = [];
            if (Array.isArray(this.newMessage)) {
                this.newMessage.forEach((message) => {
                    if (typeof message === 'string') {
                        messages.push(message);
                    } else {
                        for (const key in message) {
                            if (message[key]) {
                                messages.push(key);
                            }
                        }
                    }
                });
            } else {
                for (const key in this.newMessage) {
                    if (this.newMessage[key]) {
                        messages.push(key);
                    }
                }
            }
            return messages.filter((m) => !!m)
        },
        hasLabel() {
            return this.label || this.$slots.label
        },
        hasMessage() {
            return ((!this.parent || !this.parent.hasInnerField) && this.newMessage) ||
                this.$slots.message
        }
    },
    watch: {
        /**
        * Set internal type when prop change.
        */
        type(value) {
            this.newType = value;
        },

        /**
        * Set internal message when prop change.
        */
        message(value) {
            // we deep comparison here becase an innner Field of another Field
            // receives the message as a brand new array every time, so simple
            // identity check won't work and will end up with infinite
            // recursions
            // https://github.com/buefy/buefy/issues/4018#issuecomment-1985026234
            if (JSON.stringify(value) !== JSON.stringify(this.newMessage)) {
                this.newMessage = value;
            }
        },

        /**
        * Set parent message if we use Field in Field.
        */
        newMessage(value) {
            if (this.parent && this.parent.hasInnerField) {
                if (!this.parent.type) {
                    this.parent.newType = this.newType;
                }
                if (!this.parent.message) {
                    this.parent.newMessage = value;
                }
            }
        }
    },
    methods: {
        /**
        * Field has addons if there are more than one slot
        * (element / component) in the Field.
        * Or is grouped when prop is set.
        * Is a method to be called when component re-render.
        */
        fieldType() {
            if (this.grouped) return 'is-grouped'
            if (this.hasAddons()) return 'has-addons'
        },
        hasAddons() {
            let renderedNode = 0;
            if (this.$slots.default) {
                renderedNode = this.$slots.default().reduce((i, node) => isTag(node) ? i + 1 : i, 0);
            }
            return (
                renderedNode > 1 &&
                this.addons &&
                !this.horizontal
            )
        },
        // called by a number input if it is a direct child.
        wrapNumberinput({ controlsPosition, size }) {
            const classes = ['has-numberinput'];
            if (controlsPosition) {
                classes.push(`has-numberinput-${controlsPosition}`);
            }
            if (size) {
                classes.push(`has-numberinput-${size}`);
            }
            this.numberInputClasses = classes;
        }
    },
    mounted() {
        if (this.horizontal) {
            // Bulma docs: .is-normal for any .input or .button
            const elements = this.$el.querySelectorAll('.input, .select, .button, .textarea, .b-slider');
            if (elements.length > 0) {
                this.fieldLabelSize = 'is-normal';
            }
        }
    }
};

const _hoisted_1$u = ["for"];
const _hoisted_2$s = ["for"];
const _hoisted_3$j = {
  key: 3,
  class: "field-body"
};

function render$w(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_b_field_body = resolveComponent("b-field-body");
  const _component_b_field = resolveComponent("b-field");

  return (openBlock(), createElementBlock("div", {
    class: normalizeClass(["field", $options.rootClasses])
  }, [
    ($props.horizontal)
      ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(["field-label", [$props.customClass, $data.fieldLabelSize]])
        }, [
          ($options.hasLabel)
            ? (openBlock(), createElementBlock("label", {
                key: 0,
                for: $props.labelFor,
                class: normalizeClass([$props.customClass, "label"])
              }, [
                (_ctx.$slots.label)
                  ? renderSlot(_ctx.$slots, "label", { key: 0 })
                  : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                      createTextVNode(toDisplayString($props.label), 1 /* TEXT */)
                    ], 64 /* STABLE_FRAGMENT */))
              ], 10 /* CLASS, PROPS */, _hoisted_1$u))
            : createCommentVNode("v-if", true)
        ], 2 /* CLASS */))
      : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          ($options.hasLabel)
            ? (openBlock(), createElementBlock("label", {
                key: 0,
                for: $props.labelFor,
                class: normalizeClass([$props.customClass, "label"])
              }, [
                (_ctx.$slots.label)
                  ? renderSlot(_ctx.$slots, "label", { key: 0 })
                  : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                      createTextVNode(toDisplayString($props.label), 1 /* TEXT */)
                    ], 64 /* STABLE_FRAGMENT */))
              ], 10 /* CLASS, PROPS */, _hoisted_2$s))
            : createCommentVNode("v-if", true)
        ], 64 /* STABLE_FRAGMENT */)),
    ($props.horizontal)
      ? (openBlock(), createBlock(_component_b_field_body, {
          key: 2,
          message: $data.newMessage ? $options.formattedMessage : '',
          type: $data.newType
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3 /* FORWARDED */
        }, 8 /* PROPS */, ["message", "type"]))
      : ($options.hasInnerField)
        ? (openBlock(), createElementBlock("div", _hoisted_3$j, [
            createVNode(_component_b_field, {
              addons: false,
              type: $props.type,
              class: normalizeClass($options.innerFieldClasses)
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3 /* FORWARDED */
            }, 8 /* PROPS */, ["type", "class"])
          ]))
        : renderSlot(_ctx.$slots, "default", { key: 4 }),
    ($options.hasMessage && !$props.horizontal)
      ? (openBlock(), createElementBlock("p", {
          key: 5,
          class: normalizeClass(["help", $data.newType])
        }, [
          (_ctx.$slots.message)
            ? renderSlot(_ctx.$slots, "message", {
                key: 0,
                messages: $options.formattedMessage
              })
            : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList($options.formattedMessage, (mess, i) => {
                return (openBlock(), createElementBlock(Fragment, null, [
                  createTextVNode(toDisplayString(mess) + " ", 1 /* TEXT */),
                  ((i + 1) < $options.formattedMessage.length)
                    ? (openBlock(), createElementBlock("br", { key: i }))
                    : createCommentVNode("v-if", true)
                ], 64 /* STABLE_FRAGMENT */))
              }), 256 /* UNKEYED_FRAGMENT */))
        ], 2 /* CLASS */))
      : createCommentVNode("v-if", true)
  ], 2 /* CLASS */))
}

script$x.render = render$w;
script$x.__file = "src/components/field/Field.vue";

// These should match the variables in clockpicker.scss
const indicatorSize = 40;
const paddingInner = 5;

var script$1$c = {
    name: 'BClockpickerFace',
    props: {
        pickerSize: Number,
        min: Number,
        max: Number,
        double: Boolean,
        value: Number,
        faceNumbers: Array,
        disabledValues: Function
    },
    emits: ['change', 'input'],
    data() {
        return {
            isDragging: false,
            inputValue: this.value,
            prevAngle: 720
        }
    },
    computed: {
        /**
        * How many number indicators are shown on the face
        */
        count() {
            return this.max - this.min + 1
        },
        /**
        * How many number indicators are shown per ring on the face
        */
        countPerRing() {
            return this.double ? (this.count / 2) : this.count
        },
        /**
        * Radius of the clock face
        */
        radius() {
            return this.pickerSize / 2
        },
        /**
        * Radius of the outer ring of number indicators
        */
        outerRadius() {
            return this.radius -
                paddingInner -
                indicatorSize / 2
        },
        /**
        * Radius of the inner ring of number indicators
        */
        innerRadius() {
            return Math.max(this.outerRadius * 0.6,
                this.outerRadius - paddingInner - indicatorSize)
            // 48px gives enough room for the outer ring of numbers
        },
        /**
        * The angle for each selectable value
        * For hours this ends up being 30 degrees, for minutes 6 degrees
        */
        degreesPerUnit() {
            return 360 / this.countPerRing
        },
        /**
        * Used for calculating x/y grid location based on degrees
        */
        degrees() {
            return this.degreesPerUnit * Math.PI / 180
        },
        /**
        * Calculates the angle the clock hand should be rotated for the
        * selected value
        */
        handRotateAngle() {
            let currentAngle = this.prevAngle;
            while (currentAngle < 0) currentAngle += 360;
            const targetAngle = this.calcHandAngle(this.displayedValue);
            const degreesDiff = this.shortestDistanceDegrees(currentAngle, targetAngle);
            const angle = this.prevAngle + degreesDiff;
            return angle
        },
        /**
        * Determines how long the selector hand is based on if the
        * selected value is located along the outer or inner ring
        */
        handScale() {
            return this.calcHandScale(this.displayedValue)
        },
        handStyle() {
            return {
                transform: `rotate(${this.handRotateAngle}deg) scaleY(${this.handScale})`,
                transition: '.3s cubic-bezier(.25,.8,.50,1)'
            }
        },
        /**
        * The value the hand should be pointing at
        */
        displayedValue() {
            return this.inputValue == null ? this.min : this.inputValue
        }
    },
    watch: {
        value(value) {
            if (value !== this.inputValue) {
                this.prevAngle = this.handRotateAngle;
            }
            this.inputValue = value;
        }
    },
    methods: {
        isDisabled(value) {
            return this.disabledValues && this.disabledValues(value)
        },
        /**
        * Calculates the distance between two points
        */
        euclidean(p0, p1) {
            const dx = p1.x - p0.x;
            const dy = p1.y - p0.y;

            return Math.sqrt(dx * dx + dy * dy)
        },
        shortestDistanceDegrees(start, stop) {
            const modDiff = (stop - start) % 360;
            const shortestDistance = 180 - Math.abs(Math.abs(modDiff) - 180);
            return (modDiff + 360) % 360 < 180 ? shortestDistance * 1 : shortestDistance * -1
        },
        /**
        * Calculates the angle of the line from the center point
        * to the given point.
        */
        coordToAngle(center, p1) {
            const value = 2 *
                Math.atan2(p1.y - center.y - this.euclidean(center, p1), p1.x - center.x);
            return Math.abs(value * 180 / Math.PI)
        },
        /**
        * Generates the inline style translate() property for a
        * number indicator, which determines it's location on the
        * clock face
        */
        getNumberTranslate(value) {
            const { x, y } = this.getNumberCoords(value);
            return `translate(${x}px, ${y}px)`
        },
        /***
        * Calculates the coordinates on the clock face for a number
        * indicator value
        */
        getNumberCoords(value) {
            const radius = this.isInnerRing(value) ? this.innerRadius : this.outerRadius;
            return {
                x: Math.round(radius * Math.sin((value - this.min) * this.degrees)),
                y: Math.round(-radius * Math.cos((value - this.min) * this.degrees))
            }
        },
        getFaceNumberClasses(num) {
            return {
                active: num.value === this.displayedValue,
                disabled: this.isDisabled(num.value)
            }
        },
        /**
        * Determines if a value resides on the inner ring
        */
        isInnerRing(value) {
            return this.double && (value - this.min >= this.countPerRing)
        },
        calcHandAngle(value) {
            let angle = this.degreesPerUnit * (value - this.min);
            if (this.isInnerRing(value)) angle -= 360;
            return angle
        },
        calcHandScale(value) {
            return this.isInnerRing(value)
                ? ((this.innerRadius) / this.outerRadius)
                : 1
        },
        onMouseDown(e) {
            e.preventDefault();
            this.isDragging = true;
            this.onDragMove(e);
        },
        onMouseUp() {
            this.isDragging = false;
            if (!this.isDisabled(this.inputValue)) {
                this.$emit('change', this.inputValue);
            }
        },
        onDragMove(e) {
            e.preventDefault();
            if (!this.isDragging && e.type !== 'click') return

            const { width, top, left } = this.$refs.clock.getBoundingClientRect();
            const { clientX, clientY } = 'touches' in e ? e.touches[0] : e;
            const center = { x: width / 2, y: -width / 2 };
            const coords = { x: clientX - left, y: top - clientY };
            const handAngle = Math.round(this.coordToAngle(center, coords) + 360) % 360;
            const insideClick = this.double && this.euclidean(center, coords) <
                (this.outerRadius + this.innerRadius) / 2 - 16;

            let value = Math.round(handAngle / this.degreesPerUnit) +
                this.min +
                (insideClick ? this.countPerRing : 0);

            // Necessary to fix edge case when selecting left part of max value
            if (handAngle >= (360 - this.degreesPerUnit / 2)) {
                value = insideClick ? this.max : this.min;
            }
            this.update(value);
        },
        update(value) {
            if (this.inputValue !== value && !this.isDisabled(value)) {
                this.prevAngle = this.handRotateAngle;
                this.inputValue = value;
                this.$emit('input', value);
            }
        }
    }
};

const _hoisted_1$1$7 = {
  class: "b-clockpicker-face-outer-ring",
  ref: "clock"
};

function render$1$a(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createElementBlock("div", {
    class: "b-clockpicker-face",
    onMousedown: _cache[0] || (_cache[0] = (...args) => ($options.onMouseDown && $options.onMouseDown(...args))),
    onMouseup: _cache[1] || (_cache[1] = (...args) => ($options.onMouseUp && $options.onMouseUp(...args))),
    onMousemove: _cache[2] || (_cache[2] = (...args) => ($options.onDragMove && $options.onDragMove(...args))),
    onTouchstart: _cache[3] || (_cache[3] = (...args) => ($options.onMouseDown && $options.onMouseDown(...args))),
    onTouchend: _cache[4] || (_cache[4] = (...args) => ($options.onMouseUp && $options.onMouseUp(...args))),
    onTouchmove: _cache[5] || (_cache[5] = (...args) => ($options.onDragMove && $options.onDragMove(...args)))
  }, [
    createBaseVNode("div", _hoisted_1$1$7, [
      createBaseVNode("div", {
        class: "b-clockpicker-face-hand",
        style: normalizeStyle($options.handStyle)
      }, null, 4 /* STYLE */),
      (openBlock(true), createElementBlock(Fragment, null, renderList($props.faceNumbers, (num, index) => {
        return (openBlock(), createElementBlock("span", {
          key: index,
          class: normalizeClass(["b-clockpicker-face-number", $options.getFaceNumberClasses(num)]),
          style: normalizeStyle({ transform: $options.getNumberTranslate(num.value) })
        }, [
          createBaseVNode("span", null, toDisplayString(num.label), 1 /* TEXT */)
        ], 6 /* CLASS, STYLE */))
      }), 128 /* KEYED_FRAGMENT */))
    ], 512 /* NEED_PATCH */)
  ], 32 /* HYDRATE_EVENTS */))
}

script$1$c.render = render$1$a;
script$1$c.__file = "src/components/clockpicker/ClockpickerFace.vue";

const outerPadding = 12;

var script$w = {
    name: 'BClockpicker',
    components: {
        [script$1$c.name]: script$1$c,
        [script$H.name]: script$H,
        [script$x.name]: script$x,
        [script$I.name]: script$I,
        [script$1$e.name]: script$1$e,
        [script$y.name]: script$y
    },
    mixins: [TimepickerMixin],
    props: {
        pickerSize: {
            type: Number,
            default: 290
        },
        incrementMinutes: {
            type: Number,
            default: 5
        },
        autoSwitch: {
            type: Boolean,
            default: true
        },
        type: {
            type: String,
            default: 'is-primary'
        },
        hoursLabel: {
            type: String,
            default: () => config.defaultClockpickerHoursLabel || 'Hours'
        },
        minutesLabel: {
            type: String,
            default: () => config.defaultClockpickerMinutesLabel || 'Min'
        }
    },
    data() {
        return {
            isSelectingHour: true,
            isDragging: false,
            _isClockpicker: true
        }
    },
    computed: {
        hoursDisplay() {
            if (this.hoursSelected == null) return '--'
            if (this.isHourFormat24) return this.pad(this.hoursSelected)

            let display = this.hoursSelected;
            if (this.meridienSelected === this.pmString) {
                display -= 12;
            }
            if (display === 0) display = 12;
            return display
        },
        minutesDisplay() {
            return this.minutesSelected == null ? '--' : this.pad(this.minutesSelected)
        },
        minFaceValue() {
            return this.isSelectingHour &&
                !this.isHourFormat24 &&
                this.meridienSelected === this.pmString
                ? 12
                : 0
        },
        maxFaceValue() {
            return this.isSelectingHour
                ? (
                    !this.isHourFormat24 &&
                    this.meridienSelected === this.amString
                        ? 11
                        : 23
                )
                : 59
        },
        faceSize() {
            return this.pickerSize - (outerPadding * 2)
        },
        faceDisabledValues() {
            return this.isSelectingHour ? this.isHourDisabled : this.isMinuteDisabled
        }
    },
    methods: {
        onClockInput(value) {
            if (this.isSelectingHour) {
                this.hoursSelected = value;
                this.onHoursChange(value);
            } else {
                this.minutesSelected = value;
                this.onMinutesChange(value);
            }
        },
        onClockChange(value) {
            if (this.autoSwitch && this.isSelectingHour) {
                this.isSelectingHour = !this.isSelectingHour;
            }
        },
        onMeridienClick(value) {
            if (this.meridienSelected !== value) {
                this.meridienSelected = value;
                this.onMeridienChange(value);
            }
        },
        /*
         * Avoid dropdown toggle when is already visible
         */
        onInputClick(event) {
            if (this.$refs.dropdown.isActive) {
                event.stopPropagation();
            }
        }
    }
};

const _hoisted_1$t = ["disabled"];
const _hoisted_2$r = {
  key: 0,
  class: "card-header"
};
const _hoisted_3$i = { class: "b-clockpicker-header card-header-title" };
const _hoisted_4$e = { class: "b-clockpicker-time" };
const _hoisted_5$b = {
  key: 0,
  class: "b-clockpicker-period"
};
const _hoisted_6$8 = { class: "card-content" };
const _hoisted_7$8 = {
  key: 0,
  class: "b-clockpicker-time"
};
const _hoisted_8$7 = {
  key: 1,
  class: "b-clockpicker-period"
};
const _hoisted_9$5 = {
  key: 1,
  class: "b-clockpicker-footer card-footer"
};

function render$v(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_b_input = resolveComponent("b-input");
  const _component_b_clockpicker_face = resolveComponent("b-clockpicker-face");
  const _component_b_dropdown = resolveComponent("b-dropdown");

  return (openBlock(), createElementBlock("div", mergeProps({
    class: ["b-clockpicker control", [_ctx.size, $props.type, {'is-expanded': _ctx.expanded}]]
  }, _ctx.rootAttrs), [
    (!_ctx.isMobile || _ctx.inline)
      ? (openBlock(), createBlock(_component_b_dropdown, {
          key: 0,
          ref: "dropdown",
          position: _ctx.position,
          disabled: _ctx.disabledOrUndefined,
          inline: _ctx.inline,
          "mobile-modal": _ctx.mobileModal,
          "append-to-body": _ctx.appendToBody,
          "append-to-body-copy-parent": "",
          onActiveChange: _ctx.onActiveChange
        }, createSlots({
          default: withCtx(() => [
            createBaseVNode("div", {
              class: "card",
              disabled: _ctx.disabledOrUndefined,
              custom: ""
            }, [
              (_ctx.inline)
                ? (openBlock(), createElementBlock("header", _hoisted_2$r, [
                    createBaseVNode("div", _hoisted_3$i, [
                      createBaseVNode("div", _hoisted_4$e, [
                        createBaseVNode("span", {
                          class: normalizeClass(["b-clockpicker-btn", { active: $data.isSelectingHour }]),
                          onClick: _cache[3] || (_cache[3] = $event => ($data.isSelectingHour = true))
                        }, toDisplayString($options.hoursDisplay), 3 /* TEXT, CLASS */),
                        createBaseVNode("span", null, toDisplayString(_ctx.hourLiteral), 1 /* TEXT */),
                        createBaseVNode("span", {
                          class: normalizeClass(["b-clockpicker-btn", { active: !$data.isSelectingHour }]),
                          onClick: _cache[4] || (_cache[4] = $event => ($data.isSelectingHour = false))
                        }, toDisplayString($options.minutesDisplay), 3 /* TEXT, CLASS */)
                      ]),
                      (!_ctx.isHourFormat24)
                        ? (openBlock(), createElementBlock("div", _hoisted_5$b, [
                            createBaseVNode("div", {
                              class: normalizeClass(["b-clockpicker-btn", {
                                    active: _ctx.meridienSelected === _ctx.amString || _ctx.meridienSelected === _ctx.AM
                                }]),
                              onClick: _cache[5] || (_cache[5] = $event => ($options.onMeridienClick(_ctx.amString)))
                            }, toDisplayString(_ctx.amString), 3 /* TEXT, CLASS */),
                            createBaseVNode("div", {
                              class: normalizeClass(["b-clockpicker-btn", {
                                    active: _ctx.meridienSelected === _ctx.pmString || _ctx.meridienSelected === _ctx.PM
                                }]),
                              onClick: _cache[6] || (_cache[6] = $event => ($options.onMeridienClick(_ctx.pmString)))
                            }, toDisplayString(_ctx.pmString), 3 /* TEXT, CLASS */)
                          ]))
                        : createCommentVNode("v-if", true)
                    ])
                  ]))
                : createCommentVNode("v-if", true),
              createBaseVNode("div", _hoisted_6$8, [
                createBaseVNode("div", {
                  class: "b-clockpicker-body",
                  style: normalizeStyle({ width: $options.faceSize + 'px', height: $options.faceSize + 'px' })
                }, [
                  (!_ctx.inline)
                    ? (openBlock(), createElementBlock("div", _hoisted_7$8, [
                        createBaseVNode("div", {
                          class: normalizeClass(["b-clockpicker-btn", { active: $data.isSelectingHour }]),
                          onClick: _cache[7] || (_cache[7] = $event => ($data.isSelectingHour = true))
                        }, toDisplayString($props.hoursLabel), 3 /* TEXT, CLASS */),
                        createBaseVNode("span", {
                          class: normalizeClass(["b-clockpicker-btn", { active: !$data.isSelectingHour }]),
                          onClick: _cache[8] || (_cache[8] = $event => ($data.isSelectingHour = false))
                        }, toDisplayString($props.minutesLabel), 3 /* TEXT, CLASS */)
                      ]))
                    : createCommentVNode("v-if", true),
                  (!_ctx.isHourFormat24 && !_ctx.inline)
                    ? (openBlock(), createElementBlock("div", _hoisted_8$7, [
                        createBaseVNode("div", {
                          class: normalizeClass(["b-clockpicker-btn", {
                                    active: _ctx.meridienSelected === _ctx.amString || _ctx.meridienSelected === _ctx.AM
                                }]),
                          onClick: _cache[9] || (_cache[9] = $event => ($options.onMeridienClick(_ctx.amString)))
                        }, toDisplayString(_ctx.amString), 3 /* TEXT, CLASS */),
                        createBaseVNode("div", {
                          class: normalizeClass(["b-clockpicker-btn", {
                                    active: _ctx.meridienSelected === _ctx.pmString || _ctx.meridienSelected === _ctx.PM
                                }]),
                          onClick: _cache[10] || (_cache[10] = $event => ($options.onMeridienClick(_ctx.pmString)))
                        }, toDisplayString(_ctx.pmString), 3 /* TEXT, CLASS */)
                      ]))
                    : createCommentVNode("v-if", true),
                  createVNode(_component_b_clockpicker_face, {
                    "picker-size": $options.faceSize,
                    min: $options.minFaceValue,
                    max: $options.maxFaceValue,
                    "face-numbers": $data.isSelectingHour ? _ctx.hours : _ctx.minutes,
                    "disabled-values": $options.faceDisabledValues,
                    double: $data.isSelectingHour && _ctx.isHourFormat24,
                    value: $data.isSelectingHour ? _ctx.hoursSelected : _ctx.minutesSelected,
                    onInput: $options.onClockInput,
                    onChange: $options.onClockChange
                  }, null, 8 /* PROPS */, ["picker-size", "min", "max", "face-numbers", "disabled-values", "double", "value", "onInput", "onChange"])
                ], 4 /* STYLE */)
              ]),
              (_ctx.$slots.default !== undefined && _ctx.$slots.default().length)
                ? (openBlock(), createElementBlock("footer", _hoisted_9$5, [
                    renderSlot(_ctx.$slots, "default")
                  ]))
                : createCommentVNode("v-if", true)
            ], 8 /* PROPS */, _hoisted_1$t)
          ]),
          _: 2 /* DYNAMIC */
        }, [
          (!_ctx.inline)
            ? {
                name: "trigger",
                fn: withCtx(() => [
                  renderSlot(_ctx.$slots, "trigger", {}, () => [
                    createVNode(_component_b_input, mergeProps({
                      ref: "input",
                      autocomplete: "off",
                      value: _ctx.formatValue(_ctx.computedValue),
                      placeholder: _ctx.placeholder,
                      size: _ctx.size,
                      icon: _ctx.icon,
                      "icon-pack": _ctx.iconPack,
                      loading: _ctx.loading,
                      disabled: _ctx.disabledOrUndefined,
                      readonly: !_ctx.editable,
                      rounded: _ctx.rounded
                    }, _ctx.fallthroughAttrs, {
                      "use-html5-validation": _ctx.useHtml5Validation,
                      onClick: $options.onInputClick,
                      onKeyup: _cache[0] || (_cache[0] = withKeys($event => (_ctx.toggle(true)), ["enter"])),
                      onChange: _cache[1] || (_cache[1] = $event => (_ctx.onChange($event.target.value))),
                      onFocus: _ctx.handleOnFocus,
                      onBlur: _cache[2] || (_cache[2] = $event => (_ctx.checkHtml5Validity()))
                    }), null, 16 /* FULL_PROPS */, ["value", "placeholder", "size", "icon", "icon-pack", "loading", "disabled", "readonly", "rounded", "use-html5-validation", "onClick", "onFocus"])
                  ])
                ]),
                key: "0"
              }
            : undefined
        ]), 1032 /* PROPS, DYNAMIC_SLOTS */, ["position", "disabled", "inline", "mobile-modal", "append-to-body", "onActiveChange"]))
      : (openBlock(), createBlock(_component_b_input, mergeProps({
          key: 1,
          ref: "input",
          type: "time",
          autocomplete: "off",
          value: _ctx.formatHHMMSS(_ctx.computedValue),
          placeholder: _ctx.placeholder,
          size: _ctx.size,
          icon: _ctx.icon,
          "icon-pack": _ctx.iconPack,
          loading: _ctx.loading,
          max: _ctx.formatHHMMSS(_ctx.maxTime),
          min: _ctx.formatHHMMSS(_ctx.minTime),
          disabled: _ctx.disabledOrUndefined,
          readonly: false
        }, _ctx.fallthroughAttrs, {
          "use-html5-validation": _ctx.useHtml5Validation,
          onClick: _cache[11] || (_cache[11] = withModifiers($event => (_ctx.toggle(true)), ["stop"])),
          onKeyup: _cache[12] || (_cache[12] = withKeys($event => (_ctx.toggle(true)), ["enter"])),
          onChange: _ctx.onChangeNativePicker,
          onFocus: _ctx.handleOnFocus,
          onBlur: _cache[13] || (_cache[13] = $event => (_ctx.onBlur() && _ctx.checkHtml5Validity()))
        }), null, 16 /* FULL_PROPS */, ["value", "placeholder", "size", "icon", "icon-pack", "loading", "max", "min", "disabled", "use-html5-validation", "onChange", "onFocus"]))
  ], 16 /* FULL_PROPS */))
}

script$w.render = render$v;
script$w.__file = "src/components/clockpicker/Clockpicker.vue";

var Plugin$z = {
  install: function install(Vue) {
    registerComponent(Vue, script$w);
  }
};

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var script$v = {
    name: 'BSelect',
    components: {
        [script$I.name]: script$I
    },
    mixins: [CompatFallthroughMixin, FormElementMixin],
    props: {
        modelValue: {
            type: [String, Number, Boolean, Object, Array, Function, Date],
            default: null
        },
        placeholder: String,
        multiple: Boolean,
        nativeSize: [String, Number]
    },
    emits: ['blur', 'focus', 'update:modelValue'],
    data() {
        return {
            selected: this.modelValue,
            _elementRef: 'select'
        }
    },
    computed: {
        computedValue: {
            get() {
                return this.selected
            },
            set(value) {
                this.selected = value;
                this.$emit('update:modelValue', value);
                !this.isValid && this.checkHtml5Validity();
            }
        },
        spanClasses() {
            return [this.size, this.statusType, {
                'is-fullwidth': this.expanded,
                'is-loading': this.loading,
                'is-multiple': this.multiple,
                'is-rounded': this.rounded,
                'is-empty': this.selected === null
            }]
        }
    },
    watch: {
        /**
        * When v-model is changed:
        *   1. Set the selected option.
        *   2. If it's invalid, validate again.
        */
        modelValue(value) {
            this.selected = value;
            !this.isValid && this.checkHtml5Validity();
        }
    }
};

const _hoisted_1$s = ["multiple", "size"];
const _hoisted_2$q = {
  key: 0,
  value: null,
  disabled: "",
  hidden: ""
};

function render$u(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_b_icon = resolveComponent("b-icon");

  return (openBlock(), createElementBlock("div", mergeProps({
    class: ["control", { 'is-expanded': _ctx.expanded, 'has-icons-left': _ctx.icon }]
  }, _ctx.rootAttrs), [
    createBaseVNode("span", {
      class: normalizeClass(["select", $options.spanClasses])
    }, [
      withDirectives(createBaseVNode("select", mergeProps({
        "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => (($options.computedValue) = $event)),
        ref: "select",
        multiple: $props.multiple,
        size: $props.nativeSize
      }, _ctx.fallthroughAttrs, {
        onBlur: _cache[1] || (_cache[1] = $event => (_ctx.$emit('blur', $event) && _ctx.checkHtml5Validity())),
        onFocus: _cache[2] || (_cache[2] = $event => (_ctx.$emit('focus', $event)))
      }), [
        ($props.placeholder)
          ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              ($options.computedValue == null)
                ? (openBlock(), createElementBlock("option", _hoisted_2$q, toDisplayString($props.placeholder), 1 /* TEXT */))
                : createCommentVNode("v-if", true)
            ], 64 /* STABLE_FRAGMENT */))
          : createCommentVNode("v-if", true),
        renderSlot(_ctx.$slots, "default")
      ], 16 /* FULL_PROPS */, _hoisted_1$s), [
        [vModelSelect, $options.computedValue]
      ])
    ], 2 /* CLASS */),
    (_ctx.icon)
      ? (openBlock(), createBlock(_component_b_icon, {
          key: 0,
          class: "is-left",
          icon: _ctx.icon,
          pack: _ctx.iconPack,
          size: _ctx.iconSize
        }, null, 8 /* PROPS */, ["icon", "pack", "size"]))
      : createCommentVNode("v-if", true)
  ], 16 /* FULL_PROPS */))
}

script$v.render = render$u;
script$v.__file = "src/components/select/Select.vue";

var script$u = {
    name: 'BTooltip',
    props: {
        active: {
            type: Boolean,
            default: true
        },
        type: {
            type: String,
            default: () => config.defaultTooltipType
        },
        label: String,
        delay: {
            type: Number,
            default: () => config.defaultTooltipDelay
        },
        closeDelay: {
            type: Number,
            default: () => config.defaultTooltipCloseDelay
        },
        position: {
            type: String,
            default: 'is-top',
            validator(value) {
                return [
                    'is-top',
                    'is-bottom',
                    'is-left',
                    'is-right'
                ].indexOf(value) > -1
            }
        },
        triggers: {
            type: Array,
            default: () => ['hover']
        },
        always: Boolean,
        square: Boolean,
        dashed: Boolean,
        multilined: Boolean,
        size: {
            type: String,
            default: 'is-medium'
        },
        appendToBody: Boolean,
        animated: {
            type: Boolean,
            default: true
        },
        animation: {
            type: String,
            default: 'fade'
        },
        contentClass: String,
        autoClose: {
            type: [Array, Boolean],
            default: true
        }
    },
    emits: ['close', 'open'],
    data() {
        return {
            isActive: false,
            triggerStyle: {},
            timer: null,
            _bodyEl: undefined, // Used to append to body
            resizeObserver: undefined,
            resizeListener: undefined,
            timeOutID: null
        }
    },
    computed: {
        rootClasses() {
            return ['b-tooltip', this.type, this.position, this.size, {
                'is-square': this.square,
                'is-always': this.always,
                'is-multiline': this.multilined,
                'is-dashed': this.dashed
            }]
        },
        newAnimation() {
            return this.animated ? this.animation : undefined
        }
    },
    watch: {
        isActive() {
            this.$emit(this.isActive ? 'open' : 'close');
            if (this.appendToBody) {
                this.updateAppendToBody();
            }
        }
    },
    methods: {
        updateAppendToBody() {
            const tooltip = this.$refs.tooltip;
            const trigger = this.$refs.trigger;
            if (tooltip && trigger) {
                // update wrapper tooltip
                const tooltipEl = this.$data._bodyEl.children[0];
                tooltipEl.classList.forEach((item) => tooltipEl.classList.remove(item));
                if (
                    this.$vnode &&
                    this.$vnode.data &&
                    this.$vnode.data.staticClass
                ) {
                    tooltipEl.classList.add(this.$vnode.data.staticClass);
                }
                this.rootClasses.forEach((item) => {
                    if (typeof item === 'object') {
                        for (const key in item) {
                            if (item[key]) {
                                tooltipEl.classList.add(key);
                            }
                        }
                    } else {
                        tooltipEl.classList.add(item);
                    }
                });

                const rect = trigger.getBoundingClientRect();

                const top = rect.top + window.scrollY;
                const left = rect.left + window.scrollX;

                // `tooltipEl` will be placed relative to `wrapper`
                // because `wrapper` should create a stacking context
                // as its z-index is non-auto
                tooltipEl.style.position = 'absolute';
                switch (this.position) {
                    case 'is-top':
                        tooltipEl.style.width = `${trigger.clientWidth}px`;
                        tooltipEl.style.height = '0px';
                        tooltipEl.style.top = '0px';
                        tooltipEl.style.left = '0px';
                        break
                    case 'is-bottom':
                        tooltipEl.style.width = `${trigger.clientWidth}px`;
                        tooltipEl.style.height = '0px';
                        tooltipEl.style.top = `${trigger.clientHeight}px`;
                        tooltipEl.style.left = '0px';
                        break
                    case 'is-left':
                        tooltipEl.style.width = '0px';
                        tooltipEl.style.height = `${trigger.clientHeight}px`;
                        tooltipEl.style.top = '0px';
                        tooltipEl.style.left = '0px';
                        break
                    case 'is-right':
                        tooltipEl.style.width = '0px';
                        tooltipEl.style.height = `${trigger.clientHeight}px`;
                        tooltipEl.style.top = '0px';
                        tooltipEl.style.left = `${trigger.clientWidth}px`;
                        break
                }

                const wrapper = this.$data._bodyEl;
                wrapper.style.position = 'absolute';
                wrapper.style.top = `${top}px`;
                wrapper.style.left = `${left}px`;
                wrapper.style.width = '0px';
                wrapper.style.zIndex = this.isActive || this.always ? '99' : '-1';
                this.triggerStyle = {
                    zIndex: this.isActive || this.always ? '100' : undefined
                };
            }
        },
        onClick() {
            if (this.triggers.indexOf('click') < 0) return
            // if not active, toggle after clickOutside event
            // this fixes toggling programmatic
            this.$nextTick(() => {
                this.timeOutID = setTimeout(() => this.open());
            });
        },
        onHover() {
            if (this.triggers.indexOf('hover') < 0) return
            this.open();
        },
        onContextMenu(e) {
            if (this.triggers.indexOf('contextmenu') < 0) return
            e.preventDefault();
            this.open();
        },
        onFocus() {
            if (this.triggers.indexOf('focus') < 0) return
            this.open();
        },
        open() {
            if (this.delay) {
                this.timer = setTimeout(() => {
                    this.isActive = true;
                    this.timer = null;
                }, this.delay);
            } else {
                this.isActive = true;
            }
        },
        close() {
            if (typeof this.autoClose === 'boolean') {
                if (this.autoClose && this.timer) clearTimeout(this.timer);
                if (this.closeDelay) {
                    this.timer = setTimeout(() => {
                        this.isActive = !this.autoClose;
                        this.timer = null;
                    }, this.closeDelay);
                } else {
                    this.isActive = !this.autoClose;
                }
            }
        },
        /**
        * Close tooltip if clicked outside.
        */
        clickedOutside(event) {
            if (this.isActive) {
                if (Array.isArray(this.autoClose)) {
                    if (this.autoClose.includes('outside')) {
                        if (!this.isInWhiteList(event.target)) {
                            this.isActive = false;
                            return
                        }
                    }
                    if (this.autoClose.includes('inside')) {
                        if (this.isInWhiteList(event.target)) this.isActive = false;
                    }
                }
            }
        },
        /**
         * Keypress event that is bound to the document
         */
        keyPress({ key }) {
            if (this.isActive && (key === 'Escape' || key === 'Esc')) {
                if (Array.isArray(this.autoClose)) {
                    if (this.autoClose.indexOf('escape') >= 0) this.isActive = false;
                }
            }
        },
        /**
        * White-listed items to not close when clicked.
        */
        isInWhiteList(el) {
            if (el === this.$refs.content) return true
            // All chidren from content
            if (this.$refs.content != null) {
                const children = this.$refs.content.querySelectorAll('*');
                for (const child of children) {
                    if (el === child) {
                        return true
                    }
                }
            }
            return false
        }
    },
    mounted() {
        if (this.appendToBody && typeof window !== 'undefined') {
            this.controller = new window.AbortController();
            this.$data._bodyEl = createAbsoluteElement(this.$refs.content);
            this.updateAppendToBody();
            // updates the tooltip position if the tooltip is inside
            // `.animation-content`
            const animation = this.$el.closest('.animation-content');
            if (animation != null) {
                const listener = () => {
                    this.updateAppendToBody();
                    animation.removeEventListener('transitionend', listener);
                };
                animation.addEventListener('transitionend', listener, {
                    signal: this.controller.signal
                });
            }
            // observes changes in the window size
            this.resizeListener = () => this.updateAppendToBody();
            window.addEventListener('resize', this.resizeListener);
            // observes changes in the size of the immediate parent
            this.resizeObserver = new ResizeObserver(this.resizeListener);
            if (this.$el.parentNode != null && this.$el.parentNode.nodeType === Node.ELEMENT_NODE) {
                this.resizeObserver.observe(this.$el.parentNode);
            }
        }
    },
    created() {
        if (typeof window !== 'undefined') {
            document.addEventListener('click', this.clickedOutside);
            document.addEventListener('keyup', this.keyPress);
        }
    },
    beforeUnmount() {
        if (typeof window !== 'undefined') {
            document.removeEventListener('click', this.clickedOutside);
            document.removeEventListener('keyup', this.keyPress);
        }
        if (this.resizeListener != null) {
            window.removeEventListener('resize', this.resizeListener);
        }
        if (this.resizeObserver != null) {
            this.resizeObserver.disconnect();
        }
        if (this.appendToBody) {
            removeElement(this.$data._bodyEl);
        }
        if (this.controller != null) {
            this.controller.abort();
        }
        clearTimeout(this.timer);
        clearTimeout(this.timeOutID);
    }
};

function render$t(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createElementBlock("div", {
    ref: "tooltip",
    class: normalizeClass($options.rootClasses)
  }, [
    createVNode(Transition, {
      name: $options.newAnimation,
      persisted: ""
    }, {
      default: withCtx(() => [
        withDirectives(createBaseVNode("div", {
          ref: "content",
          class: normalizeClass(['tooltip-content', $props.contentClass])
        }, [
          ($props.label)
            ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createTextVNode(toDisplayString($props.label), 1 /* TEXT */)
              ], 64 /* STABLE_FRAGMENT */))
            : (_ctx.$slots.content)
              ? renderSlot(_ctx.$slots, "content", { key: 1 })
              : createCommentVNode("v-if", true)
        ], 2 /* CLASS */), [
          [vShow, $props.active && ($data.isActive || $props.always)]
        ])
      ]),
      _: 3 /* FORWARDED */
    }, 8 /* PROPS */, ["name"]),
    createBaseVNode("div", {
      ref: "trigger",
      class: "tooltip-trigger",
      style: normalizeStyle($data.triggerStyle),
      onClick: _cache[0] || (_cache[0] = (...args) => ($options.onClick && $options.onClick(...args))),
      onContextmenu: _cache[1] || (_cache[1] = (...args) => ($options.onContextMenu && $options.onContextMenu(...args))),
      onMouseenter: _cache[2] || (_cache[2] = (...args) => ($options.onHover && $options.onHover(...args))),
      onFocusCapture: _cache[3] || (_cache[3] = (...args) => ($options.onFocus && $options.onFocus(...args))),
      onBlurCapture: _cache[4] || (_cache[4] = (...args) => ($options.close && $options.close(...args))),
      onMouseleave: _cache[5] || (_cache[5] = (...args) => ($options.close && $options.close(...args)))
    }, [
      renderSlot(_ctx.$slots, "default", { ref: "slot" })
    ], 36 /* STYLE, HYDRATE_EVENTS */)
  ], 2 /* CLASS */))
}

script$u.render = render$t;
script$u.__file = "src/components/tooltip/Tooltip.vue";

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e,
      n,
      i,
      u,
      a = [],
      f = !0,
      o = !1;
    try {
      if (i = (t = t.call(r)).next, 0 === l) ; else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
    } catch (r) {
      o = !0, n = r;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _isNativeFunction(fn) {
  try {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  } catch (e) {
    return typeof fn === "function";
  }
}

function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct$1()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;
  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;
    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);
      _cache.set(Class, Wrapper);
    }
    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };
  return _wrapNativeSuper(Class);
}

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var colorChannels = ['red', 'green', 'blue', 'alpha'];
var colorsNammed = {
  transparent: '#00000000',
  black: '#000000',
  silver: '#c0c0c0',
  gray: '#808080',
  white: '#ffffff',
  maroon: '#800000',
  red: '#ff0000',
  purple: '#800080',
  fuchsia: '#ff00ff',
  green: '#008000',
  lime: '#00ff00',
  olive: '#808000',
  yellow: '#ffff00',
  navy: '#000080',
  blue: '#0000ff',
  teal: '#008080',
  aqua: '#00ffff',
  orange: '#ffa500',
  aliceblue: '#f0f8ff',
  antiquewhite: '#faebd7',
  aquamarine: '#7fffd4',
  azure: '#f0ffff',
  beige: '#f5f5dc',
  bisque: '#ffe4c4',
  blanchedalmond: '#ffebcd',
  blueviolet: '#8a2be2',
  brown: '#a52a2a',
  burlywood: '#deb887',
  cadetblue: '#5f9ea0',
  chartreuse: '#7fff00',
  chocolate: '#d2691e',
  coral: '#ff7f50',
  cornflowerblue: '#6495ed',
  cornsilk: '#fff8dc',
  crimson: '#dc143c',
  cyan: '#00ffff',
  darkblue: '#00008b',
  darkcyan: '#008b8b',
  darkgoldenrod: '#b8860b',
  darkgray: '#a9a9a9',
  darkgreen: '#006400',
  darkgrey: '#a9a9a9',
  darkkhaki: '#bdb76b',
  darkmagenta: '#8b008b',
  darkolivegreen: '#556b2f',
  darkorange: '#ff8c00',
  darkorchid: '#9932cc',
  darkred: '#8b0000',
  darksalmon: '#e9967a',
  darkseagreen: '#8fbc8f',
  darkslateblue: '#483d8b',
  darkslategray: '#2f4f4f',
  darkslategrey: '#2f4f4f',
  darkturquoise: '#00ced1',
  darkviolet: '#9400d3',
  deeppink: '#ff1493',
  deepskyblue: '#00bfff',
  dimgray: '#696969',
  dimgrey: '#696969',
  dodgerblue: '#1e90ff',
  firebrick: '#b22222',
  floralwhite: '#fffaf0',
  forestgreen: '#228b22',
  gainsboro: '#dcdcdc',
  ghostwhite: '#f8f8ff',
  gold: '#ffd700',
  goldenrod: '#daa520',
  greenyellow: '#adff2f',
  grey: '#808080',
  honeydew: '#f0fff0',
  hotpink: '#ff69b4',
  indianred: '#cd5c5c',
  indigo: '#4b0082',
  ivory: '#fffff0',
  khaki: '#f0e68c',
  lavender: '#e6e6fa',
  lavenderblush: '#fff0f5',
  lawngreen: '#7cfc00',
  lemonchiffon: '#fffacd',
  lightblue: '#add8e6',
  lightcoral: '#f08080',
  lightcyan: '#e0ffff',
  lightgoldenrodyellow: '#fafad2',
  lightgray: '#d3d3d3',
  lightgreen: '#90ee90',
  lightgrey: '#d3d3d3',
  lightpink: '#ffb6c1',
  lightsalmon: '#ffa07a',
  lightseagreen: '#20b2aa',
  lightskyblue: '#87cefa',
  lightslategray: '#778899',
  lightslategrey: '#778899',
  lightsteelblue: '#b0c4de',
  lightyellow: '#ffffe0',
  limegreen: '#32cd32',
  linen: '#faf0e6',
  magenta: '#ff00ff',
  mediumaquamarine: '#66cdaa',
  mediumblue: '#0000cd',
  mediumorchid: '#ba55d3',
  mediumpurple: '#9370db',
  mediumseagreen: '#3cb371',
  mediumslateblue: '#7b68ee',
  mediumspringgreen: '#00fa9a',
  mediumturquoise: '#48d1cc',
  mediumvioletred: '#c71585',
  midnightblue: '#191970',
  mintcream: '#f5fffa',
  mistyrose: '#ffe4e1',
  moccasin: '#ffe4b5',
  navajowhite: '#ffdead',
  oldlace: '#fdf5e6',
  olivedrab: '#6b8e23',
  orangered: '#ff4500',
  orchid: '#da70d6',
  palegoldenrod: '#eee8aa',
  palegreen: '#98fb98',
  paleturquoise: '#afeeee',
  palevioletred: '#db7093',
  papayawhip: '#ffefd5',
  peachpuff: '#ffdab9',
  peru: '#cd853f',
  pink: '#ffc0cb',
  plum: '#dda0dd',
  powderblue: '#b0e0e6',
  rosybrown: '#bc8f8f',
  royalblue: '#4169e1',
  saddlebrown: '#8b4513',
  salmon: '#fa8072',
  sandybrown: '#f4a460',
  seagreen: '#2e8b57',
  seashell: '#fff5ee',
  sienna: '#a0522d',
  skyblue: '#87ceeb',
  slateblue: '#6a5acd',
  slategray: '#708090',
  slategrey: '#708090',
  snow: '#fffafa',
  springgreen: '#00ff7f',
  steelblue: '#4682b4',
  tan: '#d2b48c',
  thistle: '#d8bfd8',
  tomato: '#ff6347',
  turquoise: '#40e0d0',
  violet: '#ee82ee',
  wheat: '#f5deb3',
  whitesmoke: '#f5f5f5',
  yellowgreen: '#9acd32',
  rebeccapurple: '#663399'
};
var ColorTypeError = /*#__PURE__*/function (_Error) {
  _inherits(ColorTypeError, _Error);
  var _super = _createSuper(ColorTypeError);
  function ColorTypeError() {
    _classCallCheck(this, ColorTypeError);
    return _super.call(this, 'ColorTypeError: type must be hex(a), rgb(a) or hsl(a)');
  }
  return _createClass(ColorTypeError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
var Color = /*#__PURE__*/function (_Symbol$toString) {
  function Color() {
    var _this = this;
    _classCallCheck(this, Color);
    if (arguments.length > 0) {
      return Color.parse.apply(Color, arguments);
    }
    this.$channels = new Uint8Array(colorChannels.length);
    colorChannels.forEach(function (channel, index) {
      Object.defineProperty(_this, channel, {
        get: function get() {
          return _this.$channels[index];
        },
        set: function set(_byte) {
          if (!Number.isNaN(_byte / 1)) {
            _this.$channels[index] = Math.min(255, Math.max(0, _byte));
          }
        },
        enumerable: true,
        configurable: true
      });
    })
    // Required for observability
    ;
    ['hue', 'saturation', 'lightness'].forEach(function (name) {
      var capitalizedName = name.replace(/^./, function (m) {
        return m.toUpperCase();
      });
      Object.defineProperty(_this, name, {
        get: function get() {
          return _this["get".concat(capitalizedName)]();
        },
        set: function set(value) {
          if (!Number.isNaN(value / 1)) {
            _this["set".concat(capitalizedName)](value);
          }
        },
        enumerable: true,
        configurable: true
      });
    });
  }
  _createClass(Color, [{
    key: "getHue",
    value: function getHue() {
      var _Array$from$map = Array.from(this.$channels).map(function (c) {
          return c / 255;
        }),
        _Array$from$map2 = _slicedToArray(_Array$from$map, 3),
        red = _Array$from$map2[0],
        green = _Array$from$map2[1],
        blue = _Array$from$map2[2];
      var _ref = [Math.min(red, green, blue), Math.max(red, green, blue)],
        min = _ref[0],
        max = _ref[1];
      var delta = max - min;
      var hue = 0;
      if (delta === 0) {
        return hue;
      }
      if (red === max) {
        hue = (green - blue) / delta % 6;
      } else if (green === max) {
        hue = (blue - red) / delta + 2;
      } else {
        hue = (red - green) / delta + 4;
      }
      hue *= 60;
      while (hue !== -Infinity && hue < 0) hue += 360;
      return Math.round(hue % 360);
    }
  }, {
    key: "setHue",
    value: function setHue(value) {
      var color = Color.fromHSL(value, this.saturation, this.lightness, this.alpha / 255);
      for (var i = 0; i < this.$channels.length; i++) {
        this.$channels[i] = Number(color.$channels[i]);
      }
    }
  }, {
    key: "getSaturation",
    value: function getSaturation() {
      var _Array$from$map3 = Array.from(this.$channels).map(function (c) {
          return c / 255;
        }),
        _Array$from$map4 = _slicedToArray(_Array$from$map3, 3),
        red = _Array$from$map4[0],
        green = _Array$from$map4[1],
        blue = _Array$from$map4[2];
      var _ref2 = [Math.min(red, green, blue), Math.max(red, green, blue)],
        min = _ref2[0],
        max = _ref2[1];
      var delta = max - min;
      return delta !== 0 ? Math.round(delta / (1 - Math.abs(2 * this.lightness - 1)) * 100) / 100 : 0;
    }
  }, {
    key: "setSaturation",
    value: function setSaturation(value) {
      var _this2 = this;
      var color = Color.fromHSL(this.hue, value, this.lightness, this.alpha / 255);
      colorChannels.forEach(function (_, i) {
        return _this2.$channels[i] = color.$channels[i];
      });
    }
  }, {
    key: "getLightness",
    value: function getLightness() {
      var _Array$from$map5 = Array.from(this.$channels).map(function (c) {
          return c / 255;
        }),
        _Array$from$map6 = _slicedToArray(_Array$from$map5, 3),
        red = _Array$from$map6[0],
        green = _Array$from$map6[1],
        blue = _Array$from$map6[2];
      var _ref3 = [Math.min(red, green, blue), Math.max(red, green, blue)],
        min = _ref3[0],
        max = _ref3[1];
      return Math.round((max + min) / 2 * 100) / 100;
    }
  }, {
    key: "setLightness",
    value: function setLightness(value) {
      var _this3 = this;
      var color = Color.fromHSL(this.hue, this.lightness, value, this.alpha / 255);
      colorChannels.forEach(function (_, i) {
        return _this3.$channels[i] = color.$channels[i];
      });
    }
  }, {
    key: "clone",
    value: function clone() {
      var _this4 = this;
      var color = new Color();
      colorChannels.forEach(function (_, i) {
        return color.$channels[i] = _this4.$channels[i];
      });
      return color;
    }
  }, {
    key: "toString",
    value: function toString() {
      var _this5 = this;
      var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'hex';
      switch (String(type).toLowerCase()) {
        case 'hex':
          return '#' + colorChannels.slice(0, 3).map(function (channel) {
            return _this5[channel].toString(16).padStart(2, '0');
          }).join('');
        case 'hexa':
          return '#' + colorChannels.map(function (channel) {
            return _this5[channel].toString(16).padStart(2, '0');
          }).join('');
        case 'rgb':
          return "rgb(".concat(this.red, ", ").concat(this.green, ", ").concat(this.blue, ")");
        case 'rgba':
          return "rgba(".concat(this.red, ", ").concat(this.green, ", ").concat(this.blue, ", ").concat(Math.round(this.alpha / 2.55) / 100, ")");
        case 'hsl':
          return "hsl(".concat(Math.round(this.hue), "deg, ").concat(Math.round(this.saturation * 100), "%, ").concat(Math.round(this.lightness * 100), "%)");
        case 'hsla':
          return "hsla(".concat(Math.round(this.hue), "deg, ").concat(Math.round(this.saturation * 100), "%, ").concat(Math.round(this.lightness * 100), "%, ").concat(Math.round(this.alpha / 2.55) / 100, ")");
        default:
          throw new ColorTypeError();
      }
    }
  }, {
    key: _Symbol$toString,
    get: function get() {
      return this.toString('hex');
    }
  }], [{
    key: "parse",
    value: function parse() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (_typeof(args[0]) === 'object') {
        return Color.parseObject(args[0]);
      } else if (args.every(function (arg) {
        return !Number.isNaN(arg / 1);
      })) {
        var color = new Color();
        if (args.length > 3) {
          color.red = args[0];
          color.green = args[1];
          color.blue = args[2];
          if (args[3]) {
            color.alpha = args[3];
          }
        } else if (args.length === 1) {
          var index = Number(args[0]);
          return Color.parseIndex(index, index > Math.pow(2, 24) ? 3 : 4);
        }
      } else if (typeof args[0] === 'string') {
        var match = null;
        if (typeof colorsNammed[args[0].toLowerCase()] === 'string') {
          return Color.parseHex(colorsNammed[args[0].toLowerCase()]);
        } else if ((match = args[0].match(/^(#|&h|0x)?(([a-f0-9]{3,4}){1,2})$/i)) !== null) {
          return Color.parseHex(match[2]);
        } else if ((match = args[0].match(/^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)(\s*,\s*(\d*\.?\d+))?\s*\)$/i)) !== null) {
          var channels = [match[1], match[2], match[3], typeof match[5] !== 'undefined' ? match[5] : 1];
          return Color.fromRGB.apply(Color, _toConsumableArray(channels.map(function (value) {
            return Number(value);
          })));
        } else if (args[0].match(/^(h(sl|wb)a?|lab|color|cmyk)\(/i)) {
          throw new Error('Color expression not implemented yet');
        }
      }
      throw new Error('Invalid color expression');
    }
  }, {
    key: "parseObject",
    value: function parseObject(object) {
      var color = new Color();
      if (object === null || _typeof(object) !== 'object') {
        return color;
      }
      if (Color.isColor(object)) {
        return object.clone();
      }
      colorChannels.forEach(function (channel) {
        if (!Number.isNaN(object[channel])) {
          color[channel] = object[channel];
        }
      });
      return color;
    }
  }, {
    key: "parseHex",
    value: function parseHex(hex) {
      if (typeof hex !== 'string') {
        throw new Error('Hex expression must be a string');
      }
      hex = hex.trim().replace(/^(0x|&h|#)/i, '');
      if (hex.length === 3 || hex.length === 4) {
        hex = hex.split('').map(function (c) {
          return c.repeat(2);
        }).join('');
      }
      if (!(hex.length === 6 || hex.length === 8)) {
        throw new Error('Incorrect Hex expression length');
      }
      var chans = hex.split(/(..)/).filter(function (value) {
        return value;
      }).map(function (value) {
        return Number.parseInt(value, 16);
      });
      if (typeof chans[3] === 'number') {
        chans[3] /= 255;
      }
      return Color.fromRGB.apply(Color, _toConsumableArray(chans));
    }
  }, {
    key: "parseIndex",
    value: function parseIndex(value) {
      var channels = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;
      var color = new Color();
      for (var i = 0; i < 4; i++) {
        color[colorChannels[i]] = value >> (channels - i) * 8 && 0xff;
      }
      return color;
    }
  }, {
    key: "fromRGB",
    value: function fromRGB(red, green, blue) {
      var alpha = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      if ([red, green, blue, alpha].some(function (arg) {
        return Number.isNaN(arg / 1);
      })) {
        throw new Error('Invalid arguments');
      }
      alpha *= 255;
      var color = new Color();
      [red, green, blue, alpha].forEach(function (value, index) {
        color[colorChannels[index]] = value;
      });
      return color;
    }
  }, {
    key: "fromHSL",
    value: function fromHSL(hue, saturation, lightness) {
      var alpha = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      if ([hue, saturation, lightness, alpha].some(function (arg) {
        return Number.isNaN(arg);
      })) {
        throw new Error('Invalid arguments');
      }
      while (hue < 0 && hue !== -Infinity) hue += 360;
      hue = hue % 360;
      saturation = Math.max(0, Math.min(1, saturation));
      lightness = Math.max(0, Math.min(1, lightness));
      alpha = Math.max(0, Math.min(1, alpha));
      var c = (1 - Math.abs(2 * lightness - 1)) * saturation;
      var x = c * (1 - Math.abs(hue / 60 % 2 - 1));
      var m = lightness - c / 2;
      var _ref4 = hue < 60 ? [c, x, 0] : hue < 120 ? [x, c, 0] : hue < 180 ? [0, c, x] : hue < 240 ? [0, x, c] : hue < 300 ? [x, 0, c] : [c, 0, x],
        _ref5 = _slicedToArray(_ref4, 3),
        r = _ref5[0],
        g = _ref5[1],
        b = _ref5[2];
      return Color.fromRGB((r + m) * 255, (g + m) * 255, (b + m) * 255, alpha);
    }
  }, {
    key: "isColor",
    value: function isColor(arg) {
      return arg instanceof Color;
    }
  }]);
  return Color;
}(Symbol.toString);
var Color$1 = Color;

const cos30 = 0.86602540378;
const sin30 = 0.5;

let id = 0;

var script$3$4 = {
    name: 'BColorpickerHSLRepresentationTriangle',
    props: {
        value: {
            type: Object,
            required: true,
            validator(value) {
                return typeof value.hue === 'number' &&
                    typeof value.saturation === 'number' &&
                    typeof value.lightness === 'number'
            }
        },
        size: {
            type: Number,
            default: 200
        },
        thickness: {
            type: Number,
            default: 20
        }
    },
    emits: ['input'],
    data() {
        return {
            id: id++,
            hue: this.value.hue,
            saturation: this.value.saturation,
            lightness: this.value.lightness,
            captureMouse: false,
            captureType: 'hue',
            clientOffset: {
                cx: -1,
                cy: -1,
                width: 0,
                height: 0
            },
            cos30,
            sin30,
            debounce: 0
        }
    },
    computed: {
        viewBox() {
            const { size } = this;
            return `0 0 ${size} ${size}`
        },
        internalRadius() {
            return this.size / 2 - this.thickness
        },
        haloPath() {
            const { size, thickness } = this;
            const radius = size / 2 - 2; // 2px padding
            const thicknessRadius = radius - thickness;
            const center = size / 2;

            return `M${center - radius} ${center}a${radius}  ${radius}  0 1 1 ${2 * radius} 0` +
                `h${-thickness}` +
                `a${-thicknessRadius}  ${thicknessRadius}  0 1 0 ${-2 * thicknessRadius} 0` +
                `a${thicknessRadius}  ${thicknessRadius}  0 1 0 ${2 * thicknessRadius} 0` +
                `h${thickness}` +
                `a${radius}  ${radius}  0 1 1 ${-2 * radius} 0z`
        },
        trianglePath() {
            const { size, thickness } = this;
            const radius = size - 4;
            const thicknessRadius = (radius - 2 * thickness) / 2;

            return `M0 ${-thicknessRadius}` +
                `L${cos30 * thicknessRadius} ${sin30 * thicknessRadius}` +
                `H${-cos30 * thicknessRadius}z`
        }
    },
    watch: {
        captureMouse(newValue, oldValue) {
            if (oldValue === false && newValue !== false) {
                const rect = this.$el.getBoundingClientRect();
                // Caching offset
                this.clientOffset.cx = rect.x + rect.width / 2;
                this.clientOffset.cy = rect.y + rect.height / 2;
                this.clientOffset.width = rect.width;
                this.clientOffset.height = rect.height;
            }
        },
        value: {
            deep: true,
            handler(newColor) {
                const { hue, saturation, lightness } = newColor;

                window.clearTimeout(this.debounce);
                this.debounce = window.setTimeout(() => {
                    if (lightness >= 0.03 && lightness <= 0.97 && saturation > 0) {
                        this.hue = hue;
                    }
                    this.saturation = saturation;
                    this.lightness = lightness;
                }, 200);
            }
        }
    },
    methods: {
        increaseHue(value = 1) {
            this.hue = (this.hue + value) % 360;
        },
        decreaseHue(value = 1) {
            this.hue = (360 + this.hue - value) % 360;
        },
        increaseSaturation(value = 0.01) {
            this.saturation = Math.min(1, Math.max(0, this.saturation + value));
            this.lightness = Math.min(
                0.5 + (1 - this.saturation) * 0.5,
                Math.max(
                    0.5 - (1 - this.saturation) * 0.5,
                    this.lightness
                )
            );
        },
        decreaseSaturation(value = 0.01) {
            this.saturation = Math.min(1, Math.max(0, this.saturation - value));
            this.lightness = Math.min(
                0.5 + (1 - this.saturation) * 0.5,
                Math.max(
                    0.5 - (1 - this.saturation) * 0.5,
                    this.lightness
                )
            );
        },
        increaseLightness(value = 0.01) {
            this.lightness = Math.min(
                0.5 + (1 - this.saturation) * 0.5,
                Math.max(
                    0.5 - (1 - this.saturation) * 0.5,
                    this.lightness + value
                )
            );
        },
        decreaseLightness(value = 0.01) {
            this.lightness = Math.min(
                0.5 + (1 - this.saturation) * 0.5,
                Math.max(
                    0.5 - (1 - this.saturation) * 0.5,
                    this.lightness - value
                )
            );
        },
        hueKeyPress(event) {
            let handled = false;
            switch (event.key) {
                case 'ArrowRight':
                case 'ArrowUp':
                    this.increaseHue();
                    handled = true;
                    break
                case 'ArrowLeft':
                case 'ArrowDown':
                    this.decreaseHue();
                    handled = true;
                    break
                case 'Home':
                    this.increaseHue(360 - this.hue);
                    handled = true;
                    break
                case 'End':
                    this.decreaseHue(this.hue);
                    handled = true;
                    break
                case 'PageUp':
                    this.increaseHue(60 - this.hue % 60);
                    handled = true;
                    break
                case 'PageDown':
                    this.decreaseHue(60 + this.hue % 60);
                    handled = true;
                    break
            }
            if (handled) {
                event.preventDefault();
                event.stopPropagation();
                this.emitColor();
            }
        },
        slKeyPress(event) {
            let handled = false;
            switch (event.key) {
                case 'ArrowRight':
                    this.decreaseLightness();
                    handled = true;
                    break
                case 'ArrowUp':
                    this.increaseSaturation();
                    handled = true;
                    break
                case 'ArrowLeft':
                    this.increaseLightness();
                    handled = true;
                    break
                case 'ArrowDown':
                    this.decreaseSaturation();
                    handled = true;
                    break
                case 'Home':
                    this.increaseLightness(1 - this.lightness);
                    handled = true;
                    break
                case 'End':
                    this.decreaseLightness(this.lightness);
                    handled = true;
                    break
                case 'PageUp':
                    this.increaseSaturation(1 - this.saturation);
                    handled = true;
                    break
                case 'PageDown':
                    this.decreaseSaturation(this.saturation);
                    handled = true;
                    break
            }
            if (handled) {
                event.preventDefault();
                event.stopPropagation();
                this.emitColor();
            }
        },
        clickHue(event) {
            this.startMouseCapture(event);
            this.trackMouse(event);
            this.stopMouseCapture(event);
            this.$refs.hueCursor.focus();
        },
        clickSL(event) {
            this.startMouseCapture(event);
            this.trackMouse(event);
            this.stopMouseCapture(event);
            this.$refs.slCursor.focus();
        },
        trackMouse(event) {
            if (this.captureMouse === false) {
                return
            }
            event.preventDefault();
            event.stopPropagation();

            let [mouseX, mouseY] = [0, 0];
            if (typeof event.touches !== 'undefined' && event.touches.length) {
                [mouseX, mouseY] = [event.touches[0].clientX, event.touches[0].clientY];
            } else {
                [mouseX, mouseY] = [event.clientX, event.clientY];
            }
            const angle = Math.atan2(
                mouseY - this.clientOffset.cy,
                mouseX - this.clientOffset.cx
            );

            if (this.captureType === 'sl') {
                const d = Math.sqrt(
                    Math.pow(mouseX - this.clientOffset.cx, 2) +
                    Math.pow(mouseY - this.clientOffset.cy, 2)
                );
                const ratio = this.size / this.clientOffset.width;
                const dx = d * Math.cos(angle - this.hue / 180 * Math.PI) * ratio;
                const dy = d * Math.sin(angle - this.hue / 180 * Math.PI) * ratio;
                const radius = this.internalRadius;
                const saturation = 1 - (Math.min(
                    radius * sin30,
                    Math.max(
                        -radius,
                        dy
                    )
                ) + radius) / (radius + radius * sin30);
                const lightness = (Math.min(
                    (radius * cos30) * (1 - saturation),
                    Math.max(
                        (-radius * cos30) * (1 - saturation),
                        dx
                    )
                ) + radius * cos30) / (radius * 2 * cos30);

                this.saturation = Math.round(saturation * 1000) / 1000;
                this.lightness = 1 - Math.round(lightness * 1000) / 1000;
            } else {
                this.hue = Math.round(angle / Math.PI * 180 + 90) % 360;
            }
            this.emitColor();
        },
        startMouseCapture(event) {
            event.stopPropagation();

            this.captureMouse = true;
            if (event.target.closest('.colorpicker-triangle-slider-sl') !== null) {
                this.captureType = 'sl';
            } else {
                this.captureType = 'hue';
            }
        },
        stopMouseCapture(event) {
            if (this.captureMouse !== false) {
                event.preventDefault();
                event.stopPropagation();
                this.$refs[this.captureType === 'sl' ? 'slCursor' : 'hueCursor'].focus();
            }
            this.captureMouse = false;
        },
        emitColor() {
            const { hue, saturation, lightness } = this;
            this.$emit('input', Color$1.fromHSL(hue, saturation, lightness));
            window.clearTimeout(this.debounce);
        }
    },
    mounted() {
        window.addEventListener('mousemove', this.trackMouse);
        window.addEventListener('touchmove', this.trackMouse, { passive: false });
        window.addEventListener('mouseup', this.stopMouseCapture);
        window.addEventListener('touchend', this.stopMouseCapture);
    },
    beforeUnmount() {
        window.removeEventListener('mousemove', this.trackMouse);
        window.removeEventListener('touchmove', this.trackMouse);
        window.removeEventListener('mouseup', this.stopMouseCapture);
        window.removeEventListener('touchend', this.stopMouseCapture);

        clearTimeout(this.debounce);
    }
};

const _hoisted_1$3$2 = ["viewBox"];
const _hoisted_2$1$5 = ["id"];
const _hoisted_3$1$3 = /*#__PURE__*/createBaseVNode("stop", {
  offset: "0%",
  "stop-color": "#fff"
}, null, -1 /* HOISTED */);
const _hoisted_4$1$2 = /*#__PURE__*/createBaseVNode("stop", {
  offset: "100%",
  "stop-color": "#000"
}, null, -1 /* HOISTED */);
const _hoisted_5$a = [
  _hoisted_3$1$3,
  _hoisted_4$1$2
];
const _hoisted_6$7 = ["id"];
const _hoisted_7$7 = ["stop-color"];
const _hoisted_8$6 = ["stop-color"];
const _hoisted_9$4 = ["id"];
const _hoisted_10$3 = ["d"];
const _hoisted_11$3 = { class: "colorpicker-triangle-slider-hue" };
const _hoisted_12$3 = ["width", "height", "clip-path"];
const _hoisted_13$1 = ["x", "height"];
const _hoisted_14$1 = ["aria-valuenow"];
const _hoisted_15$1 = ["d", "fill"];
const _hoisted_16$1 = ["d", "fill"];
const _hoisted_17$1 = ["x", "y"];
const _hoisted_18$1 = ["aria-datavalues"];

function render$3$2(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createElementBlock("svg", {
    viewBox: $options.viewBox,
    class: "b-colorpicker-triangle"
  }, [
    createBaseVNode("defs", null, [
      createBaseVNode("linearGradient", {
        id: `cp-triangle-gradient-ligthness-${$data.id}`,
        x1: "0",
        y1: "0",
        x2: "1",
        y2: "0"
      }, [..._hoisted_5$a], 8 /* PROPS */, _hoisted_2$1$5),
      createBaseVNode("linearGradient", {
        id: `cp-triangle-gradient-saturation-${$data.id}`,
        x1: "0",
        y1: "0",
        x2: "0",
        y2: "1"
      }, [
        createBaseVNode("stop", {
          offset: "0%",
          "stop-color": `hsl(${$data.hue}deg, 100%, 50%)`,
          "stop-opacity": "1"
        }, null, 8 /* PROPS */, _hoisted_7$7),
        createBaseVNode("stop", {
          offset: "100%",
          "stop-color": `hsl(${$data.hue}deg, 100%, 50%)`,
          "stop-opacity": "0"
        }, null, 8 /* PROPS */, _hoisted_8$6)
      ], 8 /* PROPS */, _hoisted_6$7),
      createBaseVNode("clipPath", {
        id: `cp-triangle-clip-${$data.id}`
      }, [
        createBaseVNode("path", { d: $options.haloPath }, null, 8 /* PROPS */, _hoisted_10$3)
      ], 8 /* PROPS */, _hoisted_9$4)
    ]),
    createBaseVNode("g", _hoisted_11$3, [
      (openBlock(), createElementBlock("foreignObject", {
        x: 0,
        y: 0,
        width: $props.size,
        height: $props.size,
        "clip-path": `url(#cp-triangle-clip-${$data.id})`
      }, [
        createBaseVNode("div", {
          class: "colorpicker-triangle-hue",
          onClick: _cache[0] || (_cache[0] = (...args) => ($options.clickHue && $options.clickHue(...args))),
          onMousedown: _cache[1] || (_cache[1] = withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"])),
          onTouchstart: _cache[2] || (_cache[2] = withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"]))
        }, null, 32 /* HYDRATE_EVENTS */)
      ], 8 /* PROPS */, _hoisted_12$3)),
      createBaseVNode("g", {
        style: normalizeStyle(`transform: rotate(${$data.hue}deg)`)
      }, [
        (openBlock(), createElementBlock("foreignObject", {
          x: $props.size / 2 - 4,
          y: 0,
          width: "8",
          height: $props.thickness + 4
        }, [
          createBaseVNode("div", {
            ref: "hueCursor",
            class: "hue-range-thumb",
            style: normalizeStyle(`background-color: hsl(${$data.hue}deg, 100%, 50%)`),
            role: "slider",
            tabindex: "0",
            "aria-label": "Hue",
            "aria-valuemin": "0",
            "aria-valuenow": $data.hue,
            "aria-valuemax": "360",
            onClick: _cache[3] || (_cache[3] = (...args) => ($options.clickHue && $options.clickHue(...args))),
            onKeydown: _cache[4] || (_cache[4] = (...args) => ($options.hueKeyPress && $options.hueKeyPress(...args))),
            onMousedown: _cache[5] || (_cache[5] = withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"])),
            onTouchstart: _cache[6] || (_cache[6] = withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"]))
          }, null, 44 /* STYLE, PROPS, HYDRATE_EVENTS */, _hoisted_14$1)
        ], 8 /* PROPS */, _hoisted_13$1))
      ], 4 /* STYLE */)
    ]),
    createBaseVNode("g", {
      class: "colorpicker-triangle-slider-sl",
      style: normalizeStyle(`transform: rotate(${$data.hue}deg) translate(50%, 50%)`),
      role: "graphics-datagroup",
      "aria-datascales": "lightness, saturation"
    }, [
      createBaseVNode("path", {
        d: $options.trianglePath,
        fill: `url(#cp-triangle-gradient-ligthness-${$data.id})`
      }, null, 8 /* PROPS */, _hoisted_15$1),
      createBaseVNode("path", {
        d: $options.trianglePath,
        fill: `url(#cp-triangle-gradient-saturation-${$data.id})`,
        style: {"mix-blend-mode":"overlay"},
        onClick: _cache[7] || (_cache[7] = (...args) => ($options.clickSL && $options.clickSL(...args))),
        onMousedown: _cache[8] || (_cache[8] = withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"])),
        onTouchstart: _cache[9] || (_cache[9] = withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"]))
      }, null, 40 /* PROPS, HYDRATE_EVENTS */, _hoisted_16$1),
      (openBlock(), createElementBlock("foreignObject", {
        x: (($options.internalRadius - 3) * $data.cos30) * (-$data.lightness + 0.5) * 2 - 6,
        y: -$options.internalRadius + (1 - $data.saturation) * ($options.internalRadius - 3) * 1.5 - 3,
        width: "12",
        height: "12"
      }, [
        createBaseVNode("div", {
          ref: "slCursor",
          class: "sl-range-thumb",
          style: normalizeStyle({
                        backgroundColor: `hsl(${$data.hue}deg, ${$data.saturation * 100}%, ${$data.lightness * 100}%)`
                    }),
          tabindex: "0",
          "aria-datavalues": `${$data.saturation * 100}%, ${$data.lightness * 100}%`,
          onClick: _cache[10] || (_cache[10] = (...args) => ($options.clickSL && $options.clickSL(...args))),
          onKeydown: _cache[11] || (_cache[11] = (...args) => ($options.slKeyPress && $options.slKeyPress(...args))),
          onMousedown: _cache[12] || (_cache[12] = withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"])),
          onTouchstart: _cache[13] || (_cache[13] = withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"]))
        }, null, 44 /* STYLE, PROPS, HYDRATE_EVENTS */, _hoisted_18$1)
      ], 8 /* PROPS */, _hoisted_17$1))
    ], 4 /* STYLE */)
  ], 8 /* PROPS */, _hoisted_1$3$2))
}

script$3$4.render = render$3$2;
script$3$4.__file = "src/components/colorpicker/ColorpickerHSLRepresentationTriangle.vue";

const precision = (strs, ...values) => {
    const tmp = [];
    strs.forEach((str, i) => {
        tmp.push(str);

        if (values[i]) {
            tmp.push(
                Number.isNaN(values[i] / 1)
                    ? values[i]
                    : Math.round(values * 10) / 10
            );
        }
    });

    return tmp.join('')
};

var script$2$6 = {
    name: 'BColorpickerHSLRepresentationSquare',
    props: {
        value: {
            type: Object,
            required: true,
            validator(value) {
                return typeof value.hue === 'number' &&
                    typeof value.saturation === 'number' &&
                    typeof value.lightness === 'number'
            }
        },
        size: {
            type: Number,
            default: 200
        },
        thickness: {
            type: Number,
            default: 20
        }
    },
    emits: ['input'],
    data() {
        return {
            hue: this.value.hue,
            saturation: this.value.saturation,
            lightness: this.value.lightness,
            captureMouse: false,
            captureType: 'hue',
            clientOffset: {
                cx: -1,
                cy: -1,
                width: 0,
                height: 0
            },
            debounce: 0
        }
    },
    computed: {
        hueThumbStyle() {
            const { hue, size, thickness } = this;
            const side = size - thickness;
            const offset = size / 2;
            const angle = ((hue + 720 + 90) % 360) / 180 * Math.PI;
            const ciq = 1 / Math.cos(Math.PI / 4);
            const { x, y } = {
                x: -Math.min(1, Math.max(-1, ciq * Math.cos(angle))) / 2 * side + offset,
                y: -Math.min(1, Math.max(-1, ciq * Math.sin(angle))) / 2 * side + offset
            };
            return {
                background: `hsl(${hue}deg, 100%, 50%)`,
                left: precision`${x}px`,
                top: precision`${y}px`,
                width: precision`${thickness - 2}px`
            }
        },
        slThumbStyle() {
            let { hue, saturation, lightness } = this;
            saturation = Math.max(0, Math.min(1, saturation));
            lightness = Math.max(0, Math.min(1, lightness));
            return {
                background: `hsl(${hue}deg, ${saturation * 100}%, ${lightness * 100}%)`,
                left: `${saturation * 100}%`,
                top: `${(1 - lightness) * 100}%`
            }
        },
        SLBackground() {
            const { hue } = this;
            return `linear-gradient(90deg, hsl(${hue}deg, 0%, 50%), hsl(${hue}deg, 100%, 50%))`
        }
    },
    watch: {
        captureMouse(newValue, oldValue) {
            if (oldValue === false && newValue !== false) {
                const rect = this.$el.getBoundingClientRect();
                // Caching offset
                this.clientOffset.cx = rect.x + rect.width / 2;
                this.clientOffset.cy = rect.y + rect.height / 2;
                this.clientOffset.width = rect.width;
                this.clientOffset.height = rect.height;
            }
        },
        value: {
            deep: true,
            handler(newColor) {
                const { hue, saturation, lightness } = newColor;

                window.clearTimeout(this.debounce);
                this.debounce = window.setTimeout(() => {
                    this.hue = hue;
                    this.saturation = saturation;
                    this.lightness = lightness;
                }, 200);
            }
        }
    },
    methods: {
        increaseHue(value = 1) {
            this.hue = (this.hue + value) % 360;
        },
        decreaseHue(value = 1) {
            this.hue = (360 + this.hue - value) % 360;
        },
        increaseSaturation(value = 0.01) {
            this.saturation = Math.min(1, Math.max(0, this.saturation + value));
            this.lightness = Math.min(
                0.5 + (1 - this.saturation) * 0.5,
                Math.max(
                    0.5 - (1 - this.saturation) * 0.5,
                    this.lightness
                )
            );
        },
        decreaseSaturation(value = 0.01) {
            this.saturation = Math.min(1, Math.max(0, this.saturation - value));
            this.lightness = Math.min(
                0.5 + (1 - this.saturation) * 0.5,
                Math.max(
                    0.5 - (1 - this.saturation) * 0.5,
                    this.lightness
                )
            );
        },
        increaseLightness(value = 0.01) {
            this.lightness = Math.min(
                0.5 + (1 - this.saturation) * 0.5,
                Math.max(
                    0.5 - (1 - this.saturation) * 0.5,
                    this.lightness + value
                )
            );
        },
        decreaseLightness(value = 0.01) {
            this.lightness = Math.min(
                0.5 + (1 - this.saturation) * 0.5,
                Math.max(
                    0.5 - (1 - this.saturation) * 0.5,
                    this.lightness - value
                )
            );
        },
        hueKeyPress(event) {
            let handled = false;
            switch (event.key) {
                case 'ArrowRight':
                case 'ArrowUp':
                    this.increaseHue();
                    handled = true;
                    break
                case 'ArrowLeft':
                case 'ArrowDown':
                    this.decreaseHue();
                    handled = true;
                    break
                case 'Home':
                    this.increaseHue(360 - this.hue);
                    handled = true;
                    break
                case 'End':
                    this.decreaseHue(this.hue);
                    handled = true;
                    break
                case 'PageUp':
                    this.increaseHue(60 - this.hue % 60);
                    handled = true;
                    break
                case 'PageDown':
                    this.decreaseHue(60 + this.hue % 60);
                    handled = true;
                    break
            }
            if (handled) {
                event.preventDefault();
                event.stopPropagation();
                this.emitColor();
            }
        },
        slKeyPress(event) {
            let handled = false;
            switch (event.key) {
                case 'ArrowRight':
                    this.increaseSaturation();
                    handled = true;
                    break
                case 'ArrowUp':
                    this.increaseLightness();
                    handled = true;
                    break
                case 'ArrowLeft':
                    this.decreaseSaturation();
                    handled = true;
                    break
                case 'ArrowDown':
                    this.decreaseLightness();
                    handled = true;
                    break
                case 'Home':
                    this.increaseLightness(1 - this.lightness);
                    handled = true;
                    break
                case 'End':
                    this.decreaseLightness(this.lightness);
                    handled = true;
                    break
                case 'PageUp':
                    this.increaseSaturation(1 - this.saturation);
                    handled = true;
                    break
                case 'PageDown':
                    this.decreaseSaturation(this.saturation);
                    handled = true;
                    break
            }
            if (handled) {
                event.preventDefault();
                event.stopPropagation();
                this.emitColor();
            }
        },
        startMouseCapture(event) {
            event.stopPropagation();

            this.captureMouse = true;
            if (event.target.closest('.colorpicker-square-slider-sl') !== null) {
                this.captureType = 'sl';
            } else {
                this.captureType = 'hue';
            }
        },
        stopMouseCapture(event) {
            if (this.captureMouse !== false) {
                event.preventDefault();
                event.stopPropagation();
                this.$refs[this.captureType === 'sl' ? 'slCursor' : 'hueCursor'].focus();
            }
            this.captureMouse = false;
        },
        clickHue(event) {
            this.startMouseCapture(event);
            this.trackMouse(event);
            this.stopMouseCapture(event);
            this.$refs.hueCursor.focus();
        },
        clickSL(event) {
            this.startMouseCapture(event);
            this.trackMouse(event);
            this.stopMouseCapture(event);
            this.$refs.slCursor.focus();
        },
        trackMouse(event) {
            if (this.captureMouse === false) {
                return
            }
            event.preventDefault();
            event.stopPropagation();

            let [mouseX, mouseY] = [0, 0];
            if (typeof event.touches !== 'undefined' && event.touches.length) {
                [mouseX, mouseY] = [event.touches[0].clientX, event.touches[0].clientY];
            } else {
                [mouseX, mouseY] = [event.clientX, event.clientY];
            }
            const angle = Math.atan2(
                mouseY - this.clientOffset.cy,
                mouseX - this.clientOffset.cx
            );

            if (this.captureType === 'sl') {
                const saturation = (mouseX - this.clientOffset.cx) /
                    (this.clientOffset.width - this.thickness * 2) +
                    0.5;
                const lightness = (mouseY - this.clientOffset.cy) /
                    (this.clientOffset.height - this.thickness * 2) +
                    0.5;

                this.saturation = Math.round(Math.min(1, Math.max(0, saturation)) * 1000) / 1000;
                this.lightness = 1 - Math.round(Math.min(1, Math.max(0, lightness)) * 1000) / 1000;
            } else {
                this.hue = Math.round(angle / Math.PI * 180 + 90) % 360;
            }
            this.emitColor();
        },
        emitColor() {
            const { hue, saturation, lightness } = this;
            this.$emit('input', Color$1.fromHSL(hue, saturation, lightness));
            window.clearTimeout(this.debounce);
        }
    },
    mounted() {
        window.addEventListener('mousemove', this.trackMouse);
        window.addEventListener('touchmove', this.trackMouse, { passive: false });
        window.addEventListener('mouseup', this.stopMouseCapture);
        window.addEventListener('touchend', this.stopMouseCapture);
    },
    beforeUnmount() {
        window.removeEventListener('mousemove', this.trackMouse);
        window.removeEventListener('touchmove', this.trackMouse);
        window.removeEventListener('mouseup', this.stopMouseCapture);
        window.removeEventListener('touchend', this.stopMouseCapture);

        clearTimeout(this.debounce);
    }
};

const _hoisted_1$2$5 = ["aria-datavalues"];

function render$2$6(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createElementBlock("div", {
    class: "b-colorpicker-square",
    style: normalizeStyle({ width: `${$props.size}px` })
  }, [
    createBaseVNode("div", {
      class: "colorpicker-square-slider-hue",
      onClick: _cache[0] || (_cache[0] = (...args) => ($options.clickHue && $options.clickHue(...args))),
      onMousedown: _cache[1] || (_cache[1] = withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"])),
      onTouchstart: _cache[2] || (_cache[2] = withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"]))
    }, [
      createBaseVNode("div", {
        ref: "hueCursor",
        role: "slider",
        class: "hue-range-thumb",
        tabindex: "0",
        "aria-label": "Hue",
        "aria-valuemin": "0",
        "aria-valuemax": "359",
        style: normalizeStyle($options.hueThumbStyle)
      }, null, 4 /* STYLE */)
    ], 32 /* HYDRATE_EVENTS */),
    createBaseVNode("div", {
      class: "colorpicker-square-slider-sl",
      style: normalizeStyle({
                background: $options.SLBackground,
                margin: `${$props.thickness}px`
            }),
      "aria-datascales": "lightness, saturation",
      onClick: _cache[7] || (_cache[7] = (...args) => ($options.clickSL && $options.clickSL(...args))),
      onMousedown: _cache[8] || (_cache[8] = withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"])),
      onTouchstart: _cache[9] || (_cache[9] = withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"]))
    }, [
      createBaseVNode("div", {
        ref: "slCursor",
        role: "slider",
        class: "sl-range-thumb",
        tabindex: "0",
        "aria-datavalues": `${$data.saturation * 100}%, ${$data.lightness * 100}%`,
        style: normalizeStyle($options.slThumbStyle),
        onClick: _cache[3] || (_cache[3] = (...args) => ($options.clickSL && $options.clickSL(...args))),
        onKeydown: _cache[4] || (_cache[4] = (...args) => ($options.slKeyPress && $options.slKeyPress(...args))),
        onMousedown: _cache[5] || (_cache[5] = withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"])),
        onTouchstart: _cache[6] || (_cache[6] = withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"]))
      }, null, 44 /* STYLE, PROPS, HYDRATE_EVENTS */, _hoisted_1$2$5)
    ], 36 /* STYLE, HYDRATE_EVENTS */)
  ], 4 /* STYLE */))
}

script$2$6.render = render$2$6;
script$2$6.__file = "src/components/colorpicker/ColorpickerHSLRepresentationSquare.vue";

var script$1$b = {
    name: 'BColorpickerAlphaSlider',
    components: {
        [script$u.name]: script$u
    },
    props: {
        value: {
            type: Number,
            validator: (value) => value >= 0 && value < 256
        },
        color: [String, Object]
    },
    emits: ['input'],
    data() {
        const color = Color$1.parse(this.color);

        color.alpha = 0;
        return {
            startColor: color.toString('hex'),
            endColor: color.toString('hexa'),
            percent: Math.round((1 - this.value / 255) * 100),
            captureMouse: false,
            clientOffset: {
                cx: -1,
                cy: -1,
                width: 0,
                height: 0
            }
        }
    },
    computed: {
        style() {
            return {
                backgroundImage:
                    `linear-gradient(90deg, ${this.startColor} 0%, ${this.endColor} 100%),
                    linear-gradient(45deg, #c7c7c7 25%, transparent 25%, transparent 75%, #c7c7c7 75%, #c7c7c7),
                    linear-gradient(45deg, #c7c7c7 25%, transparent 25%, transparent 75%, #c7c7c7 75%, #c7c7c7)`,
                backgroundSize: '100% 100%, 1em 1em, 1em 1em',
                backgroundPosition: '0 0, .5em .5em, 0 0'
            }
        }
    },
    watch: {
        value(newValue, oldValue) {
            if (newValue !== oldValue) {
                this.percent = Math.round((1 - newValue / 255) * 100);
            }
        },
        color(newColor) {
            const color = Color$1.parse(newColor);

            color.alpha = 0;
            this.startColor = color.toString('hex');
            this.endColor = color.toString('hexa');
        },
        captureMouse(newValue, oldValue) {
            if (oldValue === false && newValue !== false) {
                const rect = this.$el.getBoundingClientRect();
                // Caching offset
                this.clientOffset.cx = rect.x + rect.width / 2;
                this.clientOffset.cy = rect.y + rect.height / 2;
                this.clientOffset.width = rect.width;
                this.clientOffset.height = rect.height;
            }
        }
    },
    methods: {
        increaseAlpha(value = 1) {
            this.percent = Math.max(0, Math.min(100, this.percent + value));
        },
        decreaseAlpha(value = 0.01) {
            this.increaseAlpha(-value);
        },
        alphaKeyPress(event) {
            let handled = false;
            switch (event.key) {
                case 'ArrowRight':
                case 'ArrowUp':
                    this.increaseAlpha();
                    handled = true;
                    break
                case 'ArrowLeft':
                case 'ArrowDown':
                    this.decreaseAlpha();
                    handled = true;
                    break
                case 'Home':
                    this.decreaseAlpha(this.percent);
                    handled = true;
                    break
                case 'End':
                    this.increaseAlpha(100 - this.percent);
                    handled = true;
                    break
                case 'PageUp':
                    this.increaseAlpha(10 - (this.percent % 10));
                    handled = true;
                    break
                case 'PageDown':
                    this.decreaseAlpha(this.percent % 10);
                    handled = true;
                    break
            }
            if (handled) {
                event.preventDefault();
                event.stopPropagation();
                this.emitAlpha();
            }
        },
        clickAlpha(event) {
            this.startMouseCapture(event);
            this.trackMouse(event);
            this.stopMouseCapture(event);
            this.$refs.alphaCursor.focus();
        },
        startMouseCapture(event) {
            event.stopPropagation();

            this.captureMouse = true;
        },
        trackMouse(event) {
            if (this.captureMouse === false) {
                return
            }
            event.preventDefault();
            event.stopPropagation();

            let [mouseX] = [0, 0];
            if (typeof event.touches !== 'undefined' && event.touches.length) {
                [mouseX] = [event.touches[0].clientX];
            } else {
                [mouseX] = [event.clientX];
            }

            const ratio = 0.5 + (this.clientOffset.cx - mouseX) / this.clientOffset.width;
            this.percent = Math.round(100 - Math.max(0, Math.min(1, ratio)) * 100);
            this.emitAlpha();
        },
        stopMouseCapture(event) {
            if (this.captureMouse !== false) {
                event.preventDefault();
                event.stopPropagation();
                this.$refs.alphaCursor.focus();
            }
            this.captureMouse = false;
        },
        emitAlpha() {
            this.$emit('input', (1 - this.percent / 100) * 255);
        }
    },
    mounted() {
        window.addEventListener('mousemove', this.trackMouse);
        window.addEventListener('touchmove', this.trackMouse, { passive: false });
        window.addEventListener('mouseup', this.stopMouseCapture);
        window.addEventListener('touchend', this.stopMouseCapture);
    },
    beforeUnmount() {
        window.removeEventListener('mousemove', this.trackMouse);
        window.removeEventListener('touchmove', this.trackMouse);
        window.removeEventListener('mouseup', this.stopMouseCapture);
        window.removeEventListener('touchend', this.stopMouseCapture);
    }
};

const _hoisted_1$1$6 = ["aria-valuenow"];

function render$1$9(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_b_tooltip = resolveComponent("b-tooltip");

  return (openBlock(), createElementBlock("div", {
    class: "b-colorpicker-alpha-slider",
    style: normalizeStyle($options.style),
    onClick: _cache[0] || (_cache[0] = (...args) => ($options.clickAlpha && $options.clickAlpha(...args))),
    onKeydown: _cache[1] || (_cache[1] = (...args) => ($options.alphaKeyPress && $options.alphaKeyPress(...args))),
    onMousedown: _cache[2] || (_cache[2] = (...args) => ($options.startMouseCapture && $options.startMouseCapture(...args))),
    onTouchstart: _cache[3] || (_cache[3] = withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"]))
  }, [
    createBaseVNode("div", {
      ref: "alphaCursor",
      role: "slider",
      class: "alpha-range-thumb",
      tabindex: "0",
      "aria-label": "Tranparency",
      "aria-valuemin": "0",
      "aria-valuenow": $data.percent,
      "aria-valuemax": "100",
      style: normalizeStyle({ left: `${$data.percent}%` })
    }, [
      createVNode(_component_b_tooltip, {
        label: `${$data.percent}%`,
        always: $data.captureMouse
      }, {
        default: withCtx(() => [
          createTextVNode("   ")
        ]),
        _: 1 /* STABLE */
      }, 8 /* PROPS */, ["label", "always"])
    ], 12 /* STYLE, PROPS */, _hoisted_1$1$6)
  ], 36 /* STYLE, HYDRATE_EVENTS */))
}

script$1$b.render = render$1$9;
script$1$b.__file = "src/components/colorpicker/ColorpickerAlphaSlider.vue";

const defaultColorFormatter = (color, vm) => {
    if (color.alpha < 1) {
        return color.toString('hexa')
    } else {
        return color.toString('hex')
    }
};

const defaultColorParser = (color, vm) => {
    return Color$1.parse(color)
};

var script$t = {
    name: 'BColorpicker',
    components: {
        [script$3$4.name]: script$3$4,
        [script$2$6.name]: script$2$6,
        [script$1$b.name]: script$1$b,
        [script$H.name]: script$H,
        [script$x.name]: script$x,
        [script$v.name]: script$v,
        [script$I.name]: script$I,
        [script$E.name]: script$E,
        [script$1$e.name]: script$1$e,
        [script$y.name]: script$y
    },
    mixins: [FormElementMixin],
    inheritAttrs: false,
    provide() {
        return {
            $colorpicker: this
        }
    },
    props: {
        modelValue: {
            type: [String, Object],
            validator(value) {
                return typeof value === 'string' ||
                    (
                        typeof value === 'object' &&
                        typeof value.red === 'number' &&
                        typeof value.green === 'number' &&
                        typeof value.blue === 'number'
                    )
            }
        },
        mobileNative: {
            type: Boolean,
            default: false
        },
        representation: {
            type: String,
            default: 'triangle',
            value(value) {
                return ['triangle', 'square'].some((r) => r === value)
            }
        },
        inline: Boolean,
        disabled: Boolean,
        horizontalColorPicker: {
            type: Boolean,
            default: false
        },
        colorFormatter: {
            type: Function,
            default: (color, vm) => {
                if (typeof config.defaultColorFormatter === 'function') {
                    return config.defaultColorFormatter(color)
                } else {
                    return defaultColorFormatter(color)
                }
            }
        },
        colorParser: {
            type: Function,
            default: (color, vm) => {
                if (typeof config.defaultColorParser === 'function') {
                    return config.defaultColorParser(color)
                } else {
                    return defaultColorParser(color)
                }
            }
        },
        alpha: {
            type: Boolean,
            default: false
        },
        expanded: Boolean,
        position: String,
        mobileModal: {
            type: Boolean,
            default: () => config.defaultDatepickerMobileModal
        },
        focusable: {
            type: Boolean,
            default: true
        },
        trapFocus: {
            type: Boolean,
            default: () => config.defaultTrapFocus
        },
        appendToBody: Boolean
    },
    emits: ['active-change', 'update:modelValue'],
    data() {
        return {
            color: this.parseColor(this.modelValue)
        }
    },
    computed: {
        computedValue: {
            set(value) {
                this.color = this.parseColor(value);
            },
            get() {
                return this.color
            }
        },
        background() {
            if (this.alpha) {
                return `linear-gradient(
                    45deg,
                    ${this.computedValue.toString('hex')} 50%,
                    ${this.computedValue.toString('hexa')} 50%
                )`
            } else {
                const hex = this.computedValue.toString('hex');
                return `linear-gradient(
                    45deg,
                    ${hex} 50%,
                    ${hex} 50%
                )`
            }
        },
        triggerStyle() {
            const { red, green, blue } = this.computedValue;
            const light = (red * 0.299 + green * 0.587 + blue * 0.114) > 186;

            return {
                backgroundColor: '#ffffff',
                backgroundImage: `
                    ${this.background},
                    linear-gradient(45deg, #c7c7c7 25%, transparent 25%, transparent 75%, #c7c7c7 75%, #c7c7c7),
                    linear-gradient(45deg, #c7c7c7 25%, transparent 25%, transparent 75%, #c7c7c7 75%, #c7c7c7)
                `,
                backgroundSize: '100% 100%, 16px 16px, 16px 16px',
                backgroundPosition: '0 0, 8px 8px, 0 0',
                color: light ? '#000000' : '#FFFFFF',
                textShadow: `0 0 2px ${light ? '#FFFFFFAA' : '#000000AA'}`
            }
        },

        isMobile() {
            return this.mobileNative && isMobile.any()
        },

        ariaRole() {
            if (!this.inline) {
                return 'dialog'
            } else {
                return undefined
            }
        }
    },
    watch: {
        modelValue(value) {
            this.computedValue = new Color$1(value);
        }
    },
    methods: {
        parseColor(color) {
            try {
                return this.colorParser(color)
            } catch (e) {
                return new Color$1()
            }
        },
        updateColor(value) {
            value.alpha = this.computedValue.alpha;
            this.computedValue = value;
            this.$emit('update:modelValue', value);
        },
        updateAlpha(alpha) {
            this.computedValue.alpha = alpha;
            this.$emit('update:modelValue', this.computedValue);
        },
        updateRGB() {
            this.$emit('update:modelValue', this.computedValue);
        },
        /*
         * Format color into string
         */
        formatValue(value) {
            return value ? this.colorFormatter(value, this) : null
        },

        /*
         * Toggle datepicker
         */
        togglePicker(active) {
            if (this.$refs.dropdown) {
                const isActive = typeof active === 'boolean'
                    ? active
                    : !this.$refs.dropdown.isActive;
                if (isActive) {
                    this.$refs.dropdown.isActive = isActive;
                } else if (this.closeOnClick) {
                    this.$refs.dropdown.isActive = isActive;
                }
            }
        },

        /*
         * Call default onFocus method and show datepicker
         */
        handleOnFocus(event) {
            this.onFocus(event);
            if (this.openOnFocus) {
                this.togglePicker(true);
            }
        },

        /*
         * Toggle dropdown
         */
        toggle() {
            if (this.mobileNative && this.isMobile) {
                const input = this.$refs.input.$refs.input;
                input.focus();
                input.click();
                return
            }
            this.$refs.dropdown.toggle();
        },

        /*
         * Avoid dropdown toggle when is already visible
         */
        onInputClick(event) {
            if (this.$refs.dropdown.isActive) {
                event.stopPropagation();
            }
        },

        /**
         * Keypress event that is bound to the document.
         */
        keyPress({ key }) {
            if (this.$refs.dropdown && this.$refs.dropdown.isActive && (key === 'Escape' || key === 'Esc')) {
                this.togglePicker(false);
            }
        },

        /**
         * Emit 'blur' event on dropdown is not active (closed)
         */
        onActiveChange(value) {
            if (!value) {
                this.onBlur();
            }
            /*
             * Emit 'active-change' when on dropdown active state change
             */
            this.$emit('active-change', value);
        }
    }
};

const _hoisted_1$r = { class: "color-name" };
const _hoisted_2$p = { class: "colorpicker-header" };
const _hoisted_3$h = { class: "colorpicker-content" };
const _hoisted_4$d = { class: "colorpicker-footer" };

function render$s(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_b_button = resolveComponent("b-button");
  const _component_b_colorpicker_h_s_l_representation_square = resolveComponent("b-colorpicker-h-s-l-representation-square");
  const _component_b_colorpicker_h_s_l_representation_triangle = resolveComponent("b-colorpicker-h-s-l-representation-triangle");
  const _component_b_colorpicker_alpha_slider = resolveComponent("b-colorpicker-alpha-slider");
  const _component_b_input = resolveComponent("b-input");
  const _component_b_field = resolveComponent("b-field");
  const _component_b_dropdown_item = resolveComponent("b-dropdown-item");
  const _component_b_dropdown = resolveComponent("b-dropdown");

  return (openBlock(), createElementBlock("div", {
    class: normalizeClass(["colorpicker control", [_ctx.size, {'is-expanded': $props.expanded}]])
  }, [
    (!$options.isMobile || $props.inline)
      ? (openBlock(), createBlock(_component_b_dropdown, {
          key: 0,
          ref: "dropdown",
          position: $props.position,
          expanded: $props.expanded,
          disabled: $props.disabled,
          inline: $props.inline,
          "mobile-modal": $props.mobileModal,
          "trap-focus": $props.trapFocus,
          "aria-role": $options.ariaRole,
          "append-to-body": $props.appendToBody,
          "append-to-body-copy-parent": "",
          onActiveChange: $options.onActiveChange
        }, createSlots({
          default: withCtx(() => [
            createVNode(_component_b_dropdown_item, {
              disabled: $props.disabled,
              focusable: $props.focusable,
              custom: "",
              class: normalizeClass({'dropdown-horizontal-colorpicker': $props.horizontalColorPicker})
            }, {
              default: withCtx(() => [
                createBaseVNode("div", null, [
                  createBaseVNode("header", _hoisted_2$p, [
                    (_ctx.$slots.header !== undefined && _ctx.$slots.header.length)
                      ? renderSlot(_ctx.$slots, "header", { key: 0 })
                      : createCommentVNode("v-if", true)
                  ]),
                  createBaseVNode("div", _hoisted_3$h, [
                    ($props.representation === 'square')
                      ? (openBlock(), createBlock(_component_b_colorpicker_h_s_l_representation_square, {
                          key: 0,
                          value: $options.computedValue,
                          onInput: $options.updateColor
                        }, null, 8 /* PROPS */, ["value", "onInput"]))
                      : (openBlock(), createBlock(_component_b_colorpicker_h_s_l_representation_triangle, {
                          key: 1,
                          value: $options.computedValue,
                          onInput: $options.updateColor
                        }, null, 8 /* PROPS */, ["value", "onInput"]))
                  ])
                ]),
                createBaseVNode("footer", _hoisted_4$d, [
                  ($props.alpha)
                    ? (openBlock(), createBlock(_component_b_colorpicker_alpha_slider, {
                        key: 0,
                        value: $options.computedValue.alpha,
                        onInput: $options.updateAlpha,
                        color: $options.computedValue
                      }, null, 8 /* PROPS */, ["value", "onInput", "color"]))
                    : createCommentVNode("v-if", true),
                  renderSlot(_ctx.$slots, "footer", { color: $options.computedValue }, () => [
                    createVNode(_component_b_field, {
                      class: "colorpicker-fields",
                      grouped: ""
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_b_field, {
                          horizontal: "",
                          label: "R"
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_b_input, {
                              type: "number",
                              modelValue: $options.computedValue.red,
                              "onUpdate:modelValue": [
                                _cache[0] || (_cache[0] = $event => (($options.computedValue.red) = $event)),
                                $options.updateRGB
                              ],
                              modelModifiers: { number: true },
                              size: "is-small",
                              "aria-label": "Red"
                            }, null, 8 /* PROPS */, ["modelValue", "onUpdate:modelValue"])
                          ]),
                          _: 1 /* STABLE */
                        }),
                        createVNode(_component_b_field, {
                          horizontal: "",
                          label: "G"
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_b_input, {
                              type: "number",
                              modelValue: $options.computedValue.green,
                              "onUpdate:modelValue": [
                                _cache[1] || (_cache[1] = $event => (($options.computedValue.green) = $event)),
                                $options.updateRGB
                              ],
                              modelModifiers: { number: true },
                              size: "is-small",
                              "aria-label": "Green"
                            }, null, 8 /* PROPS */, ["modelValue", "onUpdate:modelValue"])
                          ]),
                          _: 1 /* STABLE */
                        }),
                        createVNode(_component_b_field, {
                          horizontal: "",
                          label: "B"
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_b_input, {
                              type: "number",
                              modelValue: $options.computedValue.blue,
                              "onUpdate:modelValue": [
                                _cache[2] || (_cache[2] = $event => (($options.computedValue.blue) = $event)),
                                $options.updateRGB
                              ],
                              modelModifiers: { number: true },
                              size: "is-small",
                              "aria-label": "Blue"
                            }, null, 8 /* PROPS */, ["modelValue", "onUpdate:modelValue"])
                          ]),
                          _: 1 /* STABLE */
                        })
                      ]),
                      _: 1 /* STABLE */
                    })
                  ])
                ])
              ]),
              _: 3 /* FORWARDED */
            }, 8 /* PROPS */, ["disabled", "focusable", "class"])
          ]),
          _: 2 /* DYNAMIC */
        }, [
          (!$props.inline)
            ? {
                name: "trigger",
                fn: withCtx(() => [
                  renderSlot(_ctx.$slots, "trigger", {}, () => [
                    createVNode(_component_b_button, {
                      style: normalizeStyle($options.triggerStyle),
                      expanded: $props.expanded,
                      disabled: $props.disabled
                    }, {
                      default: withCtx(() => [
                        createBaseVNode("span", _hoisted_1$r, toDisplayString($props.colorFormatter($options.computedValue)), 1 /* TEXT */)
                      ]),
                      _: 1 /* STABLE */
                    }, 8 /* PROPS */, ["style", "expanded", "disabled"])
                  ])
                ]),
                key: "0"
              }
            : undefined
        ]), 1032 /* PROPS, DYNAMIC_SLOTS */, ["position", "expanded", "disabled", "inline", "mobile-modal", "trap-focus", "aria-role", "append-to-body", "onActiveChange"]))
      : createCommentVNode("v-if", true)
  ], 2 /* CLASS */))
}

script$t.render = render$s;
script$t.__file = "src/components/colorpicker/Colorpicker.vue";

var Plugin$y = {
  install: function install(Vue) {
    registerComponent(Vue, script$t);
  }
};

var script$3$3 = {
    name: 'BDatepickerTableRow',
    inject: {
        $datepicker: { name: '$datepicker', default: false }
    },
    props: {
        selectedDate: {
            type: [Date, Array]
        },
        hoveredDateRange: Array,
        day: {
            type: Number
        },
        week: {
            type: Array,
            required: true
        },
        month: {
            type: Number,
            required: true
        },
        minDate: Date,
        maxDate: Date,
        disabled: Boolean,
        unselectableDates: [Array, Function],
        unselectableDaysOfWeek: Array,
        selectableDates: [Array, Function],
        events: Array,
        indicators: String,
        dateCreator: Function,
        nearbyMonthDays: Boolean,
        nearbySelectableMonthDays: Boolean,
        showWeekNumber: Boolean,
        weekNumberClickable: Boolean,
        range: Boolean,
        multiple: Boolean,
        rulesForFirstWeek: Number,
        firstDayOfWeek: Number
    },
    emits: ['change-focus', 'rangeHoverEndDate', 'select'],
    watch: {
        day(day) {
            const refName = `day-${this.month}-${day}`;
            this.$nextTick(() => {
                // Vue ≥ v3.0 < v3.2.25, refs in v-for are stored as a single object,
                // but ≥ v3.2.25, refs in v-for are stored in an array (same as Vue 2)
                let cell;
                if (Array.isArray(this.$refs[refName])) {
                    cell = this.$refs[refName][0];
                } else {
                    cell = this.$refs[refName];
                }
                if (cell) {
                    cell.focus();
                }
            }); // $nextTick needed when month is changed
        }
    },
    methods: {
        firstWeekOffset(year, dow, doy) {
            // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            const fwd = 7 + dow - doy;
            // first-week day local weekday -- which local weekday is fwd
            const firstJanuary = new Date(year, 0, fwd);
            const fwdlw = (7 + firstJanuary.getDay() - dow) % 7;
            return -fwdlw + fwd - 1
        },
        daysInYear(year) {
            return this.isLeapYear(year) ? 366 : 365
        },
        isLeapYear(year) {
            return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0
        },
        getSetDayOfYear(input) {
            return Math.round((input - new Date(input.getFullYear(), 0, 1)) / 864e5) + 1
        },
        weeksInYear(year, dow, doy) {
            const weekOffset = this.firstWeekOffset(year, dow, doy);
            const weekOffsetNext = this.firstWeekOffset(year + 1, dow, doy);
            return (this.daysInYear(year) - weekOffset + weekOffsetNext) / 7
        },
        getWeekNumber(mom) {
            const dow = this.firstDayOfWeek; // first day of week
            // Rules for the first week : 1 for the 1st January, 4 for the 4th January
            const doy = this.rulesForFirstWeek;
            const weekOffset = this.firstWeekOffset(mom.getFullYear(), dow, doy);
            const week = Math.floor((this.getSetDayOfYear(mom) - weekOffset - 1) / 7) + 1;
            let resWeek;
            let resYear;
            if (week < 1) {
                resYear = mom.getFullYear() - 1;
                resWeek = week + this.weeksInYear(resYear, dow, doy);
            } else if (week > this.weeksInYear(mom.getFullYear(), dow, doy)) {
                resWeek = week - this.weeksInYear(mom.getFullYear(), dow, doy);
                resYear = mom.getFullYear() + 1;
            } else {
                resYear = mom.getFullYear();
                resWeek = week;
            }
            return { week: resWeek, year: resYear }
        },
        clickWeekNumber(weekData) {
            if (this.weekNumberClickable) {
                this.$datepicker.$emit('week-number-click', weekData.week, weekData.year);
            }
        },
        /*
         * Check that selected day is within earliest/latest params and
         * is within this month
         */
        selectableDate(day) {
            const validity = [];

            if (this.minDate) {
                validity.push(day >= this.minDate);
            }

            if (this.maxDate) {
                validity.push(day <= this.maxDate);
            }

            if (this.nearbyMonthDays && !this.nearbySelectableMonthDays) {
                validity.push(day.getMonth() === this.month);
            }

            if (this.selectableDates) {
                if (typeof this.selectableDates === 'function') {
                    if (this.selectableDates(day)) {
                        return true
                    } else {
                        validity.push(false);
                    }
                } else {
                    for (let i = 0; i < this.selectableDates.length; i++) {
                        const enabledDate = this.selectableDates[i];
                        if (day.getDate() === enabledDate.getDate() &&
                            day.getFullYear() === enabledDate.getFullYear() &&
                            day.getMonth() === enabledDate.getMonth()) {
                            return true
                        } else {
                            validity.push(false);
                        }
                    }
                }
            }

            if (this.unselectableDates) {
                if (typeof this.unselectableDates === 'function') {
                    validity.push(!this.unselectableDates(day));
                } else {
                    for (let i = 0; i < this.unselectableDates.length; i++) {
                        const disabledDate = this.unselectableDates[i];
                        validity.push(
                            day.getDate() !== disabledDate.getDate() ||
                                day.getFullYear() !== disabledDate.getFullYear() ||
                                day.getMonth() !== disabledDate.getMonth()
                        );
                    }
                }
            }

            if (this.unselectableDaysOfWeek) {
                for (let i = 0; i < this.unselectableDaysOfWeek.length; i++) {
                    const dayOfWeek = this.unselectableDaysOfWeek[i];
                    validity.push(day.getDay() !== dayOfWeek);
                }
            }

            return validity.indexOf(false) < 0
        },

        /*
        * Emit select event with chosen date as payload
        */
        emitChosenDate(day) {
            if (this.disabled) return

            if (this.selectableDate(day)) {
                this.$emit('select', day);
            }
        },

        eventsDateMatch(day) {
            if (!this.events || !this.events.length) return false

            const dayEvents = [];

            for (let i = 0; i < this.events.length; i++) {
                if (this.events[i].date.getDay() === day.getDay()) {
                    dayEvents.push(this.events[i]);
                }
            }

            if (!dayEvents.length) {
                return false
            }

            return dayEvents
        },

        /*
        * Build classObject for cell using validations
        */
        classObject(day) {
            function dateMatch(dateOne, dateTwo, multiple) {
                // if either date is null or undefined, return false
                // if using multiple flag, return false
                if (!dateOne || !dateTwo || multiple) {
                    return false
                }

                if (Array.isArray(dateTwo)) {
                    return dateTwo.some((date) => (
                        dateOne.getDate() === date.getDate() &&
                        dateOne.getFullYear() === date.getFullYear() &&
                        dateOne.getMonth() === date.getMonth()
                    ))
                }
                return (dateOne.getDate() === dateTwo.getDate() &&
                    dateOne.getFullYear() === dateTwo.getFullYear() &&
                    dateOne.getMonth() === dateTwo.getMonth())
            }

            function dateWithin(dateOne, dates, multiple) {
                if (!Array.isArray(dates) || multiple) { return false }

                return dateOne > dates[0] && dateOne < dates[1]
            }

            return {
                'is-selected': dateMatch(day, this.selectedDate) || dateWithin(day, this.selectedDate, this.multiple),
                'is-first-selected':
                    dateMatch(
                        day,
                        Array.isArray(this.selectedDate) && this.selectedDate[0],
                        this.multiple
                    ),
                'is-within-selected':
                    dateWithin(day, this.selectedDate, this.multiple),
                'is-last-selected':
                    dateMatch(
                        day,
                        Array.isArray(this.selectedDate) && this.selectedDate[1],
                        this.multiple
                    ),
                'is-within-hovered-range':
                    this.hoveredDateRange && this.hoveredDateRange.length === 2 &&
                    (dateMatch(day, this.hoveredDateRange) ||
                        dateWithin(day, this.hoveredDateRange)),
                'is-first-hovered': dateMatch(
                    day,
                    Array.isArray(this.hoveredDateRange) && this.hoveredDateRange[0]
                ),
                'is-within-hovered':
                    dateWithin(day, this.hoveredDateRange),
                'is-last-hovered': dateMatch(
                    day,
                    Array.isArray(this.hoveredDateRange) && this.hoveredDateRange[1]
                ),
                'is-today': dateMatch(day, this.dateCreator()),
                'is-selectable': this.selectableDate(day) && !this.disabled,
                'is-unselectable': !this.selectableDate(day) || this.disabled,
                'is-invisible': !this.nearbyMonthDays && day.getMonth() !== this.month,
                'is-nearby': this.nearbySelectableMonthDays && day.getMonth() !== this.month,
                'has-event': this.eventsDateMatch(day),
                [this.indicators]: this.eventsDateMatch(day)
            }
        },
        setRangeHoverEndDate(day) {
            if (this.range) {
                this.$emit('rangeHoverEndDate', day);
            }
        },

        manageKeydown(event, weekDay) {
            // https://developer.mozilla.org/fr/docs/Web/API/KeyboardEvent/key/Key_Values#Navigation_keys
            const { key } = event;
            let preventDefault = true;
            switch (key) {
                case 'Tab': {
                    preventDefault = false;
                    break
                }

                case ' ':
                case 'Space':
                case 'Spacebar':
                case 'Enter': {
                    this.emitChosenDate(weekDay);
                    break
                }

                case 'ArrowLeft':
                case 'Left': {
                    this.changeFocus(weekDay, -1);
                    break
                }
                case 'ArrowRight':
                case 'Right': {
                    this.changeFocus(weekDay, 1);
                    break
                }
                case 'ArrowUp':
                case 'Up': {
                    this.changeFocus(weekDay, -7);
                    break
                }
                case 'ArrowDown':
                case 'Down': {
                    this.changeFocus(weekDay, 7);
                    break
                }
            }

            if (preventDefault) {
                event.preventDefault();
            }
        },

        changeFocus(day, inc) {
            const nextDay = new Date(day.getTime());
            nextDay.setDate(day.getDate() + inc);
            while (
                (!this.minDate || nextDay > this.minDate) &&
                (!this.maxDate || nextDay < this.maxDate) &&
                !this.selectableDate(nextDay)
            ) {
                nextDay.setDate(nextDay.getDate() + Math.sign(inc));
            }
            this.setRangeHoverEndDate(nextDay);
            this.$emit('change-focus', nextDay);
        }
    }
};

const _hoisted_1$3$1 = { class: "datepicker-row" };
const _hoisted_2$3$1 = ["disabled", "onClick", "onMouseenter", "onKeydown", "tabindex"];
const _hoisted_3$2$1 = {
  key: 0,
  class: "events"
};
const _hoisted_4$2$1 = {
  key: 0,
  class: "events"
};

function render$3$1(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createElementBlock("div", _hoisted_1$3$1, [
    ($props.showWeekNumber)
      ? (openBlock(), createElementBlock("a", {
          key: 0,
          class: normalizeClass(["datepicker-cell is-week-number", {'is-clickable': $props.weekNumberClickable }]),
          onClick: _cache[0] || (_cache[0] = withModifiers($event => ($options.clickWeekNumber($options.getWeekNumber($props.week[6]))), ["prevent"]))
        }, [
          createBaseVNode("span", null, toDisplayString($options.getWeekNumber($props.week[6]).week), 1 /* TEXT */)
        ], 2 /* CLASS */))
      : createCommentVNode("v-if", true),
    (openBlock(true), createElementBlock(Fragment, null, renderList($props.week, (weekDay, index) => {
      return (openBlock(), createElementBlock(Fragment, { key: index }, [
        ($options.selectableDate(weekDay) && !$props.disabled)
          ? (openBlock(), createElementBlock("a", {
              key: 0,
              ref_for: true,
              ref: `day-${weekDay.getMonth()}-${weekDay.getDate()}`,
              class: normalizeClass([$options.classObject(weekDay), "datepicker-cell"]),
              role: "button",
              href: "#",
              disabled: $props.disabled || undefined,
              onClick: withModifiers($event => ($options.emitChosenDate(weekDay)), ["prevent"]),
              onMouseenter: $event => ($options.setRangeHoverEndDate(weekDay)),
              onKeydown: $event => ($options.manageKeydown($event, weekDay)),
              tabindex: $props.day === weekDay.getDate() && $props.month === weekDay.getMonth() ? null : -1
            }, [
              createBaseVNode("span", null, toDisplayString(weekDay.getDate()), 1 /* TEXT */),
              ($options.eventsDateMatch(weekDay))
                ? (openBlock(), createElementBlock("div", _hoisted_3$2$1, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList($options.eventsDateMatch(weekDay), (event, evIdx) => {
                      return (openBlock(), createElementBlock("div", {
                        class: normalizeClass(["event", event.type]),
                        key: evIdx
                      }, null, 2 /* CLASS */))
                    }), 128 /* KEYED_FRAGMENT */))
                  ]))
                : createCommentVNode("v-if", true)
            ], 42 /* CLASS, PROPS, HYDRATE_EVENTS */, _hoisted_2$3$1))
          : (openBlock(), createElementBlock("div", {
              key: 1,
              class: normalizeClass([$options.classObject(weekDay), "datepicker-cell"])
            }, [
              createBaseVNode("span", null, toDisplayString(weekDay.getDate()), 1 /* TEXT */),
              ($options.eventsDateMatch(weekDay))
                ? (openBlock(), createElementBlock("div", _hoisted_4$2$1, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList($options.eventsDateMatch(weekDay), (event, evIdx) => {
                      return (openBlock(), createElementBlock("div", {
                        class: normalizeClass(["event", event.type]),
                        key: evIdx
                      }, null, 2 /* CLASS */))
                    }), 128 /* KEYED_FRAGMENT */))
                  ]))
                : createCommentVNode("v-if", true)
            ], 2 /* CLASS */))
      ], 64 /* STABLE_FRAGMENT */))
    }), 128 /* KEYED_FRAGMENT */))
  ]))
}

script$3$3.render = render$3$1;
script$3$3.__file = "src/components/datepicker/DatepickerTableRow.vue";

var script$2$5 = {
    name: 'BDatepickerTable',
    components: {
        [script$3$3.name]: script$3$3
    },
    props: {
        modelValue: {
            type: [Date, Array]
        },
        dayNames: Array,
        monthNames: Array,
        firstDayOfWeek: Number,
        events: Array,
        indicators: String,
        minDate: Date,
        maxDate: Date,
        focused: Object,
        disabled: Boolean,
        dateCreator: Function,
        unselectableDates: [Array, Function],
        unselectableDaysOfWeek: Array,
        selectableDates: [Array, Function],
        nearbyMonthDays: Boolean,
        nearbySelectableMonthDays: Boolean,
        showWeekNumber: Boolean,
        weekNumberClickable: Boolean,
        rulesForFirstWeek: Number,
        range: Boolean,
        multiple: Boolean
    },
    emits: ['range-end', 'range-start', 'update:focused', 'update:modelValue'],
    data() {
        return {
            selectedBeginDate: undefined,
            selectedEndDate: undefined,
            hoveredEndDate: undefined
        }
    },
    computed: {
        multipleSelectedDates: {
            get() {
                return this.multiple && this.modelValue ? this.modelValue : []
            },
            set(value) {
                this.$emit('update:modelValue', value);
            }
        },
        visibleDayNames() {
            const visibleDayNames = [];
            let index = this.firstDayOfWeek;
            while (visibleDayNames.length < this.dayNames.length) {
                const currentDayName = this.dayNames[(index % this.dayNames.length)];
                visibleDayNames.push(currentDayName);
                index++;
            }
            if (this.showWeekNumber) visibleDayNames.unshift('');
            return visibleDayNames
        },

        hasEvents() {
            return this.events && this.events.length
        },

        /*
        * Return array of all events in the specified month
        */
        eventsInThisMonth() {
            if (!this.events) return []

            const monthEvents = [];

            for (let i = 0; i < this.events.length; i++) {
                let event = this.events[i];

                if (!Object.prototype.hasOwnProperty.call(event, 'date')) {
                    event = { date: event };
                }
                if (!Object.prototype.hasOwnProperty.call(event, 'type')) {
                    event.type = 'is-primary';
                }
                if (
                    event.date.getMonth() === this.focused.month &&
                    event.date.getFullYear() === this.focused.year
                ) {
                    monthEvents.push(event);
                }
            }

            return monthEvents
        },
        /*
        * Return array of all weeks in the specified month
        */
        weeksInThisMonth() {
            this.validateFocusedDay();
            const month = this.focused.month;
            const year = this.focused.year;
            const weeksInThisMonth = [];

            let startingDay = 1;

            while (weeksInThisMonth.length < 6) {
                const newWeek = this.weekBuilder(startingDay, month, year);
                weeksInThisMonth.push(newWeek);
                startingDay += 7;
            }

            return weeksInThisMonth
        },
        hoveredDateRange() {
            if (!this.range) {
                return []
            }
            if (!isNaN(this.selectedEndDate)) {
                return []
            }
            if (this.hoveredEndDate < this.selectedBeginDate) {
                return [this.hoveredEndDate, this.selectedBeginDate].filter(isDefined)
            }
            return [this.selectedBeginDate, this.hoveredEndDate].filter(isDefined)
        },

        disabledOrUndefined() {
            // On Vue 3, setting a boolean attribute `false` does not remove it,
            // `null` or `undefined` has to be given to remove it.
            return this.disabled || undefined
        }
    },
    methods: {
        /*
        * Emit input event with selected date as payload for v-model in parent
        */
        updateSelectedDate(date) {
            if (!this.range && !this.multiple) {
                this.$emit('update:modelValue', date);
            } else if (this.range) {
                this.handleSelectRangeDate(date);
            } else if (this.multiple) {
                this.handleSelectMultipleDates(date);
            }
        },

        /*
        * If both begin and end dates are set, reset the end date and set the begin date.
        * If only begin date is selected, emit an array of the begin date and the new date.
        * If not set, only set the begin date.
        */
        handleSelectRangeDate(date) {
            if (this.selectedBeginDate && this.selectedEndDate) {
                this.selectedBeginDate = date;
                this.selectedEndDate = undefined;
                this.$emit('range-start', date);
            } else if (this.selectedBeginDate && !this.selectedEndDate) {
                if (this.selectedBeginDate > date) {
                    this.selectedEndDate = this.selectedBeginDate;
                    this.selectedBeginDate = date;
                } else {
                    this.selectedEndDate = date;
                }
                this.$emit('range-end', date);
                this.$emit('update:modelValue', [this.selectedBeginDate, this.selectedEndDate]);
            } else {
                this.selectedBeginDate = date;
                this.$emit('range-start', date);
            }
        },

        /*
        * If selected date already exists list of selected dates, remove it from the list
        * Otherwise, add date to list of selected dates
        */
        handleSelectMultipleDates(date) {
            const multipleSelect = this.multipleSelectedDates.filter((selectedDate) =>
                selectedDate.getDate() === date.getDate() &&
                selectedDate.getFullYear() === date.getFullYear() &&
                selectedDate.getMonth() === date.getMonth()
            );
            if (multipleSelect.length) {
                this.multipleSelectedDates = this.multipleSelectedDates.filter((selectedDate) =>
                    selectedDate.getDate() !== date.getDate() ||
                    selectedDate.getFullYear() !== date.getFullYear() ||
                    selectedDate.getMonth() !== date.getMonth()
                );
            } else {
                this.multipleSelectedDates = [...this.multipleSelectedDates, date];
            }
        },

        /*
         * Return array of all days in the week that the startingDate is within
         */
        weekBuilder(startingDate, month, year) {
            const thisMonth = new Date(year, month);

            const thisWeek = [];

            const dayOfWeek = new Date(year, month, startingDate).getDay();

            const end = dayOfWeek >= this.firstDayOfWeek
                ? (dayOfWeek - this.firstDayOfWeek)
                : ((7 - this.firstDayOfWeek) + dayOfWeek);

            let daysAgo = 1;
            for (let i = 0; i < end; i++) {
                thisWeek.unshift(new Date(
                    thisMonth.getFullYear(),
                    thisMonth.getMonth(),
                    startingDate - daysAgo)
                );
                daysAgo++;
            }

            thisWeek.push(new Date(year, month, startingDate));

            let daysForward = 1;
            while (thisWeek.length < 7) {
                thisWeek.push(new Date(year, month, startingDate + daysForward));
                daysForward++;
            }

            return thisWeek
        },

        validateFocusedDay() {
            const focusedDate = new Date(this.focused.year, this.focused.month, this.focused.day);
            if (this.selectableDate(focusedDate)) return

            let day = 0;
            // Number of days in the current month
            const monthDays = new Date(this.focused.year, this.focused.month + 1, 0).getDate();
            let firstFocusable = null;
            while (!firstFocusable && ++day < monthDays) {
                const date = new Date(this.focused.year, this.focused.month, day);
                if (this.selectableDate(date)) {
                    firstFocusable = focusedDate;

                    const focused = {
                        day: date.getDate(),
                        month: date.getMonth(),
                        year: date.getFullYear()
                    };
                    this.$emit('update:focused', focused);
                }
            }
        },

        /*
         * Check that selected day is within earliest/latest params and
         * is within this month
         */
        selectableDate(day) {
            const validity = [];

            if (this.minDate) {
                validity.push(day >= this.minDate);
            }

            if (this.maxDate) {
                validity.push(day <= this.maxDate);
            }

            if (this.nearbyMonthDays && !this.nearbySelectableMonthDays) {
                validity.push(day.getMonth() === this.focused.month);
            }

            if (this.selectableDates) {
                if (typeof this.selectableDates === 'function') {
                    if (this.selectableDates(day)) {
                        return true
                    } else {
                        validity.push(false);
                    }
                } else {
                    for (let i = 0; i < this.selectableDates.length; i++) {
                        const enabledDate = this.selectableDates[i];
                        if (day.getDate() === enabledDate.getDate() &&
                            day.getFullYear() === enabledDate.getFullYear() &&
                            day.getMonth() === enabledDate.getMonth()) {
                            return true
                        } else {
                            validity.push(false);
                        }
                    }
                }
            }

            if (this.unselectableDates) {
                if (typeof this.unselectableDates === 'function') {
                    validity.push(!this.unselectableDates(day));
                } else {
                    for (let i = 0; i < this.unselectableDates.length; i++) {
                        const disabledDate = this.unselectableDates[i];
                        validity.push(
                            day.getDate() !== disabledDate.getDate() ||
                                day.getFullYear() !== disabledDate.getFullYear() ||
                                day.getMonth() !== disabledDate.getMonth()
                        );
                    }
                }
            }

            if (this.unselectableDaysOfWeek) {
                for (let i = 0; i < this.unselectableDaysOfWeek.length; i++) {
                    const dayOfWeek = this.unselectableDaysOfWeek[i];
                    validity.push(day.getDay() !== dayOfWeek);
                }
            }

            return validity.indexOf(false) < 0
        },

        eventsInThisWeek(week) {
            return this.eventsInThisMonth.filter((event) => {
                const stripped = new Date(Date.parse(event.date));
                stripped.setHours(0, 0, 0, 0);
                const timed = stripped.getTime();

                return week.some((weekDate) => weekDate.getTime() === timed)
            })
        },

        setRangeHoverEndDate(day) {
            this.hoveredEndDate = day;
        },

        changeFocus(day) {
            const focused = {
                day: day.getDate(),
                month: day.getMonth(),
                year: day.getFullYear()
            };
            this.$emit('update:focused', focused);
        }
    }
};

const _hoisted_1$2$4 = { class: "datepicker-table" };
const _hoisted_2$2$2 = { class: "datepicker-header" };

function render$2$5(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_b_datepicker_table_row = resolveComponent("b-datepicker-table-row");

  return (openBlock(), createElementBlock("section", _hoisted_1$2$4, [
    createBaseVNode("header", _hoisted_2$2$2, [
      (openBlock(true), createElementBlock(Fragment, null, renderList($options.visibleDayNames, (day, index) => {
        return (openBlock(), createElementBlock("div", {
          key: index,
          class: "datepicker-cell"
        }, [
          createBaseVNode("span", null, toDisplayString(day), 1 /* TEXT */)
        ]))
      }), 128 /* KEYED_FRAGMENT */))
    ]),
    createBaseVNode("div", {
      class: normalizeClass(["datepicker-body", {'has-events':$options.hasEvents}])
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList($options.weeksInThisMonth, (week, index) => {
        return (openBlock(), createBlock(_component_b_datepicker_table_row, {
          key: index,
          "selected-date": $props.modelValue,
          day: $props.focused.day,
          week: week,
          month: $props.focused.month,
          "min-date": $props.minDate,
          "max-date": $props.maxDate,
          disabled: $options.disabledOrUndefined,
          "unselectable-dates": $props.unselectableDates,
          "unselectable-days-of-week": $props.unselectableDaysOfWeek,
          "selectable-dates": $props.selectableDates,
          events: $options.eventsInThisWeek(week),
          indicators: $props.indicators,
          "date-creator": $props.dateCreator,
          "nearby-month-days": $props.nearbyMonthDays,
          "nearby-selectable-month-days": $props.nearbySelectableMonthDays,
          "show-week-number": $props.showWeekNumber,
          "week-number-clickable": $props.weekNumberClickable,
          "first-day-of-week": $props.firstDayOfWeek,
          "rules-for-first-week": $props.rulesForFirstWeek,
          range: $props.range,
          "hovered-date-range": $options.hoveredDateRange,
          onSelect: $options.updateSelectedDate,
          onRangeHoverEndDate: $options.setRangeHoverEndDate,
          multiple: $props.multiple,
          onChangeFocus: $options.changeFocus
        }, null, 8 /* PROPS */, ["selected-date", "day", "week", "month", "min-date", "max-date", "disabled", "unselectable-dates", "unselectable-days-of-week", "selectable-dates", "events", "indicators", "date-creator", "nearby-month-days", "nearby-selectable-month-days", "show-week-number", "week-number-clickable", "first-day-of-week", "rules-for-first-week", "range", "hovered-date-range", "onSelect", "onRangeHoverEndDate", "multiple", "onChangeFocus"]))
      }), 128 /* KEYED_FRAGMENT */))
    ], 2 /* CLASS */)
  ]))
}

script$2$5.render = render$2$5;
script$2$5.__file = "src/components/datepicker/DatepickerTable.vue";

var script$1$a = {
    name: 'BDatepickerMonth',
    props: {
        modelValue: {
            type: [Date, Array]
        },
        monthNames: Array,
        events: Array,
        indicators: String,
        minDate: Date,
        maxDate: Date,
        focused: Object,
        disabled: Boolean,
        dateCreator: Function,
        unselectableDates: [Array, Function],
        unselectableDaysOfWeek: Array,
        selectableDates: [Array, Function],
        range: Boolean,
        multiple: Boolean
    },
    emits: ['change-focus', 'range-end', 'range-start', 'update:modelValue'],
    data() {
        return {
            selectedBeginDate: undefined,
            selectedEndDate: undefined,
            hoveredEndDate: undefined,
            multipleSelectedDates: this.multiple && this.modelValue ? this.modelValue : []
        }
    },
    computed: {
        hasEvents() {
            return this.events && this.events.length
        },

        /*
        * Return array of all events in the specified month
        */
        eventsInThisYear() {
            if (!this.events) return []

            const yearEvents = [];

            for (let i = 0; i < this.events.length; i++) {
                let event = this.events[i];

                if (!Object.prototype.hasOwnProperty.call(event, 'date')) {
                    event = { date: event };
                }
                if (!Object.prototype.hasOwnProperty.call(event, 'type')) {
                    event.type = 'is-primary';
                }
                if (
                    event.date.getFullYear() === this.focused.year
                ) {
                    yearEvents.push(event);
                }
            }

            return yearEvents
        },
        monthDates() {
            const year = this.focused.year;
            const months = [];
            for (let i = 0; i < 12; i++) {
                const d = new Date(year, i, 1);
                d.setHours(0, 0, 0, 0);
                months.push(d);
            }
            return months
        },

        focusedMonth() {
            return this.focused.month
        },

        hoveredDateRange() {
            if (!this.range) {
                return []
            }
            if (!isNaN(this.selectedEndDate)) {
                return []
            }
            if (this.hoveredEndDate < this.selectedBeginDate) {
                return [this.hoveredEndDate, this.selectedBeginDate].filter(isDefined)
            }
            return [this.selectedBeginDate, this.hoveredEndDate].filter(isDefined)
        },

        disabledOrUndefined() {
            // On Vue 3, setting a boolean attribute `false` does not remove it,
            // `null` or `undefined` has to be given to remove it.
            return this.disabled || undefined
        }
    },
    watch: {
        focusedMonth(month) {
            const refName = `month-${month}`;
            this.$nextTick(() => {
                // Vue ≥ v3.0 < v3.2.25, refs in v-for are stored as a single object,
                // but ≥ v3.2.25, refs in v-for are stored in an array (same as Vue 2)
                let cell;
                if (Array.isArray(this.$refs[refName])) {
                    cell = this.$refs[refName][0];
                } else {
                    cell = this.$refs[refName];
                }
                if (cell) {
                    cell.focus();
                }
            }); // $nextTick needed when year is changed
        }
    },
    methods: {
        selectMultipleDates(date) {
            const multipleSelect = this.multipleSelectedDates.filter((selectedDate) =>
                selectedDate.getDate() === date.getDate() &&
                selectedDate.getFullYear() === date.getFullYear() &&
                selectedDate.getMonth() === date.getMonth()
            );
            if (multipleSelect.length) {
                this.multipleSelectedDates = this.multipleSelectedDates.filter((selectedDate) =>
                    selectedDate.getDate() !== date.getDate() ||
                    selectedDate.getFullYear() !== date.getFullYear() ||
                    selectedDate.getMonth() !== date.getMonth()
                );
            } else {
                this.multipleSelectedDates.push(date);
            }
            this.$emit('update:modelValue', this.multipleSelectedDates);
        },

        selectableDate(day) {
            const validity = [];

            if (this.minDate) {
                validity.push(day >= this.minDate);
            }

            if (this.maxDate) {
                validity.push(day <= this.maxDate);
            }

            validity.push(day.getFullYear() === this.focused.year);

            if (this.selectableDates) {
                if (typeof this.selectableDates === 'function') {
                    if (this.selectableDates(day)) {
                        return true
                    } else {
                        validity.push(false);
                    }
                } else {
                    for (let i = 0; i < this.selectableDates.length; i++) {
                        const enabledDate = this.selectableDates[i];
                        if (day.getFullYear() === enabledDate.getFullYear() &&
                            day.getMonth() === enabledDate.getMonth()) {
                            return true
                        } else {
                            validity.push(false);
                        }
                    }
                }
            }

            if (this.unselectableDates) {
                if (typeof this.unselectableDates === 'function') {
                    validity.push(!this.unselectableDates(day));
                } else {
                    for (let i = 0; i < this.unselectableDates.length; i++) {
                        const disabledDate = this.unselectableDates[i];
                        validity.push(
                            day.getFullYear() !== disabledDate.getFullYear() ||
                                day.getMonth() !== disabledDate.getMonth()
                        );
                    }
                }
            }

            if (this.unselectableDaysOfWeek) {
                for (let i = 0; i < this.unselectableDaysOfWeek.length; i++) {
                    const dayOfWeek = this.unselectableDaysOfWeek[i];
                    validity.push(day.getDay() !== dayOfWeek);
                }
            }

            return validity.indexOf(false) < 0
        },
        eventsDateMatch(day) {
            if (!this.eventsInThisYear.length) return false

            const monthEvents = [];

            for (let i = 0; i < this.eventsInThisYear.length; i++) {
                if (this.eventsInThisYear[i].date.getMonth() === day.getMonth()) {
                    monthEvents.push(this.events[i]);
                }
            }

            if (!monthEvents.length) {
                return false
            }

            return monthEvents
        },
        /*
        * Build classObject for cell using validations
        */
        classObject(day) {
            function dateMatch(dateOne, dateTwo, multiple) {
                // if either date is null or undefined, return false
                if (!dateOne || !dateTwo || multiple) {
                    return false
                }
                if (Array.isArray(dateTwo)) {
                    return dateTwo.some((date) => (
                        dateOne.getFullYear() === date.getFullYear() &&
                        dateOne.getMonth() === date.getMonth()
                    ))
                }
                return (dateOne.getFullYear() === dateTwo.getFullYear() &&
                    dateOne.getMonth() === dateTwo.getMonth())
            }
            function dateWithin(dateOne, dates, multiple) {
                if (!Array.isArray(dates) || multiple) { return false }

                return dateOne > dates[0] && dateOne < dates[1]
            }
            function dateMultipleSelected(dateOne, dates, multiple) {
                if (!Array.isArray(dates) || !multiple) { return false }
                return dates.some((date) => (
                    dateOne.getDate() === date.getDate() &&
                    dateOne.getFullYear() === date.getFullYear() &&
                    dateOne.getMonth() === date.getMonth()
                ))
            }

            return {
                'is-selected': dateMatch(day, this.modelValue, this.multiple) ||
                               dateWithin(day, this.modelValue, this.multiple) ||
                               dateMultipleSelected(day, this.multipleSelectedDates, this.multiple),
                'is-first-selected':
                    dateMatch(
                        day,
                        Array.isArray(this.modelValue) && this.modelValue[0],
                        this.multiple
                    ),
                'is-within-selected':
                    dateWithin(day, this.modelValue, this.multiple),
                'is-last-selected':
                    dateMatch(
                        day,
                        Array.isArray(this.modelValue) && this.modelValue[1],
                        this.multiple
                    ),
                'is-within-hovered-range':
                    this.hoveredDateRange && this.hoveredDateRange.length === 2 &&
                    (dateMatch(day, this.hoveredDateRange) ||
                        dateWithin(day, this.hoveredDateRange)),
                'is-first-hovered': dateMatch(
                    day,
                    Array.isArray(this.hoveredDateRange) && this.hoveredDateRange[0]
                ),
                'is-within-hovered':
                    dateWithin(day, this.hoveredDateRange),
                'is-last-hovered': dateMatch(
                    day,
                    Array.isArray(this.hoveredDateRange) && this.hoveredDateRange[1]
                ),
                'is-today': dateMatch(day, this.dateCreator()),
                'is-selectable': this.selectableDate(day) && !this.disabled,
                'is-unselectable': !this.selectableDate(day) || this.disabled
            }
        },

        manageKeydown({ key }, date) {
            // https://developer.mozilla.org/fr/docs/Web/API/KeyboardEvent/key/Key_Values#Navigation_keys
            switch (key) {
                case ' ':
                case 'Space':
                case 'Spacebar':
                case 'Enter': {
                    this.updateSelectedDate(date);
                    break
                }

                case 'ArrowLeft':
                case 'Left': {
                    this.changeFocus(date, -1);
                    break
                }
                case 'ArrowRight':
                case 'Right': {
                    this.changeFocus(date, 1);
                    break
                }
                case 'ArrowUp':
                case 'Up': {
                    this.changeFocus(date, -3);
                    break
                }
                case 'ArrowDown':
                case 'Down': {
                    this.changeFocus(date, 3);
                    break
                }
            }
        },

        /*
        * Emit input event with selected date as payload for v-model in parent
        */
        updateSelectedDate(date) {
            if (!this.range && !this.multiple) {
                this.emitChosenDate(date);
            } else if (this.range) {
                this.handleSelectRangeDate(date);
            } else if (this.multiple) {
                this.selectMultipleDates(date);
            }
        },

        /*
         * Emit select event with chosen date as payload
         */
        emitChosenDate(day) {
            if (this.disabled) return

            if (!this.multiple) {
                if (this.selectableDate(day)) {
                    this.$emit('update:modelValue', day);
                }
            } else {
                this.selectMultipleDates(day);
            }
        },

        /*
        * If both begin and end dates are set, reset the end date and set the begin date.
        * If only begin date is selected, emit an array of the begin date and the new date.
        * If not set, only set the begin date.
        */
        handleSelectRangeDate(date) {
            if (this.disabled) return
            if (this.selectedBeginDate && this.selectedEndDate) {
                this.selectedBeginDate = date;
                this.selectedEndDate = undefined;
                this.$emit('range-start', date);
            } else if (this.selectedBeginDate && !this.selectedEndDate) {
                if (this.selectedBeginDate > date) {
                    this.selectedEndDate = this.selectedBeginDate;
                    this.selectedBeginDate = date;
                } else {
                    this.selectedEndDate = date;
                }
                this.$emit('range-end', date);
                this.$emit('update:modelValue', [this.selectedBeginDate, this.selectedEndDate]);
            } else {
                this.selectedBeginDate = date;
                this.$emit('range-start', date);
            }
        },

        setRangeHoverEndDate(day) {
            if (this.range) {
                this.hoveredEndDate = day;
            }
        },

        changeFocus(month, inc) {
            const nextMonth = month;
            nextMonth.setMonth(month.getMonth() + inc);
            this.$emit('change-focus', nextMonth);
        }
    }
};

const _hoisted_1$1$5 = { class: "datepicker-table" };
const _hoisted_2$1$4 = { class: "datepicker-months" };
const _hoisted_3$1$2 = ["disabled", "onClick", "onMouseenter", "onKeydown", "tabindex"];
const _hoisted_4$1$1 = {
  key: 0,
  class: "events"
};

function render$1$8(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createElementBlock("section", _hoisted_1$1$5, [
    createBaseVNode("div", {
      class: normalizeClass(["datepicker-body", {'has-events':$options.hasEvents}])
    }, [
      createBaseVNode("div", _hoisted_2$1$4, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($options.monthDates, (date, index) => {
          return (openBlock(), createElementBlock(Fragment, { key: index }, [
            ($options.selectableDate(date) && !$props.disabled)
              ? (openBlock(), createElementBlock("a", {
                  key: 0,
                  ref_for: true,
                  ref: `month-${date.getMonth()}`,
                  class: normalizeClass([[
                            $options.classObject(date),
                            {'has-event': $options.eventsDateMatch(date)},
                            $props.indicators
                        ], "datepicker-cell"]),
                  role: "button",
                  href: "#",
                  disabled: $options.disabledOrUndefined,
                  onClick: withModifiers($event => ($options.updateSelectedDate(date)), ["prevent"]),
                  onMouseenter: $event => ($options.setRangeHoverEndDate(date)),
                  onKeydown: withModifiers($event => ($options.manageKeydown($event, date)), ["prevent"]),
                  tabindex: $props.focused.month === date.getMonth() ? null : -1
                }, [
                  createTextVNode(toDisplayString($props.monthNames[date.getMonth()]) + " ", 1 /* TEXT */),
                  ($options.eventsDateMatch(date))
                    ? (openBlock(), createElementBlock("div", _hoisted_4$1$1, [
                        (openBlock(true), createElementBlock(Fragment, null, renderList($options.eventsDateMatch(date), (event, evIdx) => {
                          return (openBlock(), createElementBlock("div", {
                            class: normalizeClass(["event", event.type]),
                            key: evIdx
                          }, null, 2 /* CLASS */))
                        }), 128 /* KEYED_FRAGMENT */))
                      ]))
                    : createCommentVNode("v-if", true)
                ], 42 /* CLASS, PROPS, HYDRATE_EVENTS */, _hoisted_3$1$2))
              : (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: normalizeClass([$options.classObject(date), "datepicker-cell"])
                }, toDisplayString($props.monthNames[date.getMonth()]), 3 /* TEXT, CLASS */))
          ], 64 /* STABLE_FRAGMENT */))
        }), 128 /* KEYED_FRAGMENT */))
      ])
    ], 2 /* CLASS */)
  ]))
}

script$1$a.render = render$1$8;
script$1$a.__file = "src/components/datepicker/DatepickerMonth.vue";

const defaultDateFormatter = (date, vm) => {
    const targetDates = Array.isArray(date) ? date : [date];
    const dates = targetDates.map((date) => {
        const d = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 12);
        return !vm.isTypeMonth ? vm.dtf.format(d) : vm.dtfMonth.format(d)
    });
    return !vm.multiple ? dates.join(' - ') : dates.join(', ')
};

const defaultDateParser = (date, vm) => {
    if (vm.dtf.formatToParts && typeof vm.dtf.formatToParts === 'function') {
        const formatRegex = (vm.isTypeMonth ? vm.dtfMonth : vm.dtf)
            .formatToParts(new Date(2000, 11, 25)).map((part) => {
                if (part.type === 'literal') {
                    return part.value
                }
                return `((?!=<${part.type}>)\\d+)`
            }).join('');
        const dateGroups = matchWithGroups(formatRegex, date);

        // We do a simple validation for the group.
        // If it is not valid, it will fallback to Date.parse below
        if (
            dateGroups.year &&
            dateGroups.year.length === 4 &&
            dateGroups.month &&
            dateGroups.month <= 12
        ) {
            if (vm.isTypeMonth) return new Date(dateGroups.year, dateGroups.month - 1)
            else if (dateGroups.day && dateGroups.day <= 31) {
                return new Date(dateGroups.year, dateGroups.month - 1, dateGroups.day, 12)
            }
        }
    }
    // Fallback if formatToParts is not supported or if we were not able to parse a valid date
    if (!vm.isTypeMonth) return new Date(Date.parse(date))
    if (date) {
        const s = date.split('/');
        const year = s[0].length === 4 ? s[0] : s[1];
        const month = s[0].length === 2 ? s[0] : s[1];
        if (year && month) {
            return new Date(parseInt(year, 10), parseInt(month - 1, 10), 1, 0, 0, 0, 0)
        }
    }
    return null
};

var script$s = {
    name: 'BDatepicker',
    components: {
        [script$2$5.name]: script$2$5,
        [script$1$a.name]: script$1$a,
        [script$H.name]: script$H,
        [script$x.name]: script$x,
        [script$v.name]: script$v,
        [script$I.name]: script$I,
        [script$1$e.name]: script$1$e,
        [script$y.name]: script$y
    },
    mixins: [CompatFallthroughMixin, FormElementMixin],
    provide() {
        return {
            $datepicker: this
        }
    },
    props: {
        modelValue: {
            type: [Date, Array]
        },
        dayNames: {
            type: Array,
            default: () => {
                if (!Array.isArray(config.defaultDayNames)) {
                    return undefined
                }
                return config.defaultDayNames
            }
        },
        monthNames: {
            type: Array,
            default: () => {
                if (!Array.isArray(config.defaultMonthNames)) {
                    return undefined
                }
                return config.defaultMonthNames
            }
        },
        firstDayOfWeek: {
            type: Number,
            default: () => {
                if (typeof config.defaultFirstDayOfWeek === 'number') {
                    return config.defaultFirstDayOfWeek
                } else {
                    return 0
                }
            }
        },
        inline: Boolean,
        minDate: Date,
        maxDate: Date,
        focusedDate: Date,
        placeholder: String,
        editable: Boolean,
        disabled: Boolean,
        horizontalTimePicker: Boolean,
        unselectableDates: [Array, Function],
        unselectableDaysOfWeek: {
            type: Array,
            default: () => config.defaultUnselectableDaysOfWeek
        },
        selectableDates: [Array, Function],
        dateFormatter: {
            type: Function,
            default: (date, vm) => {
                if (typeof config.defaultDateFormatter === 'function') {
                    return config.defaultDateFormatter(date)
                } else {
                    return defaultDateFormatter(date, vm)
                }
            }
        },
        dateParser: {
            type: Function,
            default: (date, vm) => {
                if (typeof config.defaultDateParser === 'function') {
                    return config.defaultDateParser(date)
                } else {
                    return defaultDateParser(date, vm)
                }
            }
        },
        dateCreator: {
            type: Function,
            default: () => {
                if (typeof config.defaultDateCreator === 'function') {
                    return config.defaultDateCreator()
                } else {
                    return new Date()
                }
            }
        },
        mobileNative: {
            type: Boolean,
            default: () => config.defaultDatepickerMobileNative
        },
        position: String,
        iconRight: String,
        iconRightClickable: Boolean,
        events: Array,
        indicators: {
            type: String,
            default: 'dots'
        },
        openOnFocus: Boolean,
        iconPrev: {
            type: String,
            default: () => config.defaultIconPrev
        },
        iconNext: {
            type: String,
            default: () => config.defaultIconNext
        },
        yearsRange: {
            type: Array,
            default: () => config.defaultDatepickerYearsRange
        },
        type: {
            type: String,
            validator: (value) => {
                return [
                    'month'
                ].indexOf(value) >= 0
            }
        },
        nearbyMonthDays: {
            type: Boolean,
            default: () => config.defaultDatepickerNearbyMonthDays
        },
        nearbySelectableMonthDays: {
            type: Boolean,
            default: () => config.defaultDatepickerNearbySelectableMonthDays
        },
        showWeekNumber: {
            type: Boolean,
            default: () => config.defaultDatepickerShowWeekNumber
        },
        weekNumberClickable: {
            type: Boolean,
            default: () => config.defaultDatepickerWeekNumberClickable
        },
        rulesForFirstWeek: {
            type: Number,
            default: () => 4
        },
        range: {
            type: Boolean,
            default: false
        },
        closeOnClick: {
            type: Boolean,
            default: true
        },
        multiple: {
            type: Boolean,
            default: false
        },
        mobileModal: {
            type: Boolean,
            default: () => config.defaultDatepickerMobileModal
        },
        focusable: {
            type: Boolean,
            default: true
        },
        trapFocus: {
            type: Boolean,
            default: () => config.defaultTrapFocus
        },
        appendToBody: Boolean,
        ariaNextLabel: String,
        ariaPreviousLabel: String
    },
    emits: [
        'active-change',
        'change-month',
        'change-year',
        'icon-right-click',
        'range-end',
        'range-start',
        'update:modelValue',
        'week-number-click' // emitted from `DatepickerTableRow`
    ],
    data() {
        const focusedDate = (Array.isArray(this.modelValue)
            ? this.modelValue[0]
            : (this.modelValue)) || this.focusedDate || this.dateCreator();

        if (!this.modelValue &&
            this.maxDate &&
            this.maxDate.getFullYear() < focusedDate.getFullYear()) {
            focusedDate.setFullYear(this.maxDate.getFullYear());
        }

        return {
            dateSelected: this.modelValue,
            focusedDateData: {
                day: focusedDate.getDate(),
                month: focusedDate.getMonth(),
                year: focusedDate.getFullYear()
            },
            _elementRef: 'input',
            _isDatepicker: true
        }
    },
    computed: {
        computedValue: {
            get() {
                return this.dateSelected
            },
            set(value) {
                this.updateInternalState(value);
                if (!this.multiple) this.togglePicker(false);
                this.$emit('update:modelValue', value);
                if (this.useHtml5Validation) {
                    this.$nextTick(() => {
                        this.checkHtml5Validity();
                    });
                }
            }
        },
        formattedValue() {
            return this.formatValue(this.computedValue)
        },
        localeOptions() {
            return new Intl.DateTimeFormat(this.locale, {
                year: 'numeric',
                month: 'numeric'
            }).resolvedOptions()
        },
        dtf() {
            return new Intl.DateTimeFormat(this.locale)
        },
        dtfMonth() {
            return new Intl.DateTimeFormat(this.locale, {
                year: this.localeOptions.year || 'numeric',
                month: this.localeOptions.month || '2-digit'
            })
        },
        newMonthNames() {
            if (Array.isArray(this.monthNames)) {
                return this.monthNames
            }
            return getMonthNames(this.locale)
        },
        newDayNames() {
            if (Array.isArray(this.dayNames)) {
                return this.dayNames
            }
            return getWeekdayNames(this.locale)
        },
        listOfMonths() {
            let minMonth = 0;
            let maxMonth = 12;
            if (this.minDate && this.focusedDateData.year === this.minDate.getFullYear()) {
                minMonth = this.minDate.getMonth();
            }
            if (this.maxDate && this.focusedDateData.year === this.maxDate.getFullYear()) {
                maxMonth = this.maxDate.getMonth();
            }
            return this.newMonthNames.map((name, index) => {
                return {
                    name,
                    index,
                    disabled: index < minMonth || index > maxMonth
                }
            })
        },
        /*
         * Returns an array of years for the year dropdown. If earliest/latest
         * dates are set by props, range of years will fall within those dates.
         */
        listOfYears() {
            let latestYear = this.focusedDateData.year + this.yearsRange[1];
            if (this.maxDate && this.maxDate.getFullYear() < latestYear) {
                latestYear = Math.max(this.maxDate.getFullYear(), this.focusedDateData.year);
            }

            let earliestYear = this.focusedDateData.year + this.yearsRange[0];
            if (this.minDate && this.minDate.getFullYear() > earliestYear) {
                earliestYear = Math.min(this.minDate.getFullYear(), this.focusedDateData.year);
            }

            const arrayOfYears = [];
            for (let i = earliestYear; i <= latestYear; i++) {
                arrayOfYears.push(i);
            }

            return arrayOfYears.reverse()
        },

        showPrev() {
            if (!this.minDate) return false
            if (this.isTypeMonth) {
                return this.focusedDateData.year <= this.minDate.getFullYear()
            }
            const dateToCheck = new Date(this.focusedDateData.year, this.focusedDateData.month);
            const date = new Date(this.minDate.getFullYear(), this.minDate.getMonth());
            return (dateToCheck <= date)
        },

        showNext() {
            if (!this.maxDate) return false
            if (this.isTypeMonth) {
                return this.focusedDateData.year >= this.maxDate.getFullYear()
            }
            const dateToCheck = new Date(this.focusedDateData.year, this.focusedDateData.month);
            const date = new Date(this.maxDate.getFullYear(), this.maxDate.getMonth());
            return (dateToCheck >= date)
        },

        isMobile() {
            return this.mobileNative && isMobile.any()
        },

        isTypeMonth() {
            return this.type === 'month'
        },

        ariaRole() {
            if (!this.inline) {
                return 'dialog'
            } else {
                return undefined
            }
        },

        disabledOrUndefined() {
            // On Vue 3, setting a boolean attribute `false` does not remove it,
            // `null` or `undefined` has to be given to remove it.
            return this.disabled || undefined
        }
    },
    watch: {
        /**
         * When v-model is changed:
         *   1. Update internal value.
         *   2. If it's invalid, validate again.
         */
        modelValue(value) {
            this.updateInternalState(value);
            if (!this.multiple) this.togglePicker(false);
        },

        focusedDate(value) {
            if (value) {
                this.focusedDateData = {
                    day: value.getDate(),
                    month: value.getMonth(),
                    year: value.getFullYear()
                };
            }
        },

        /*
         * Emit input event on month and/or year change
         */
        'focusedDateData.month'(value) {
            this.$emit('change-month', value);
        },
        'focusedDateData.year'(value) {
            this.$emit('change-year', value);
        }
    },
    methods: {
        /*
         * Parse string into date
         */
        onChange(value) {
            const date = this.dateParser(value, this);
            if (date && (!isNaN(date) ||
                (Array.isArray(date) && date.length === 2 && !isNaN(date[0]) && !isNaN(date[1])))) {
                this.computedValue = date;
            } else {
                // Force refresh input value when not valid date
                this.computedValue = null;
                if (this.$refs.input) {
                    this.$refs.input.newValue = this.computedValue;
                }
            }
        },

        /*
         * Format date into string
         */
        formatValue(value) {
            if (Array.isArray(value)) {
                const isArrayWithValidDates = Array.isArray(value) && value.every((v) => !isNaN(v));
                return isArrayWithValidDates ? this.dateFormatter([...value], this) : null
            }
            return (value && !isNaN(value)) ? this.dateFormatter(value, this) : null
        },

        /*
         * Either decrement month by 1 if not January or decrement year by 1
         * and set month to 11 (December) or decrement year when 'month'
         */
        prev() {
            if (this.disabled) return

            if (this.isTypeMonth) {
                this.focusedDateData.year -= 1;
            } else {
                if (this.focusedDateData.month > 0) {
                    this.focusedDateData.month -= 1;
                } else {
                    this.focusedDateData.month = 11;
                    this.focusedDateData.year -= 1;
                }
            }
        },

        /*
         * Either increment month by 1 if not December or increment year by 1
         * and set month to 0 (January) or increment year when 'month'
         */
        next() {
            if (this.disabled) return

            if (this.isTypeMonth) {
                this.focusedDateData.year += 1;
            } else {
                if (this.focusedDateData.month < 11) {
                    this.focusedDateData.month += 1;
                } else {
                    this.focusedDateData.month = 0;
                    this.focusedDateData.year += 1;
                }
            }
        },

        formatNative(value) {
            return this.isTypeMonth
                ? this.formatYYYYMM(value)
                : this.formatYYYYMMDD(value)
        },

        /*
         * Format date into string 'YYYY-MM-DD'
         */
        formatYYYYMMDD(value) {
            const date = new Date(value);
            if (value && !isNaN(date)) {
                const year = date.getFullYear();
                const month = date.getMonth() + 1;
                const day = date.getDate();
                return year + '-' +
                    ((month < 10 ? '0' : '') + month) + '-' +
                    ((day < 10 ? '0' : '') + day)
            }
            return ''
        },

        /*
         * Format date into string 'YYYY-MM'
         */
        formatYYYYMM(value) {
            const date = new Date(value);
            if (value && !isNaN(date)) {
                const year = date.getFullYear();
                const month = date.getMonth() + 1;
                return year + '-' +
                    ((month < 10 ? '0' : '') + month)
            }
            return ''
        },

        /*
         * Parse date from string
         */
        onChangeNativePicker(event) {
            const date = event.target.value;
            const s = date ? date.split('-') : [];
            if (s.length === 3) {
                const year = parseInt(s[0], 10);
                const month = parseInt(s[1]) - 1;
                const day = parseInt(s[2]);
                this.computedValue = new Date(year, month, day);
            } else {
                this.computedValue = null;
            }
        },
        updateInternalState(value) {
            if (this.dateSelected === value) return
            const isArray = Array.isArray(value);
            const currentDate = isArray
                ? (!value.length ? this.dateCreator() : value[value.length - 1])
                : (!value ? this.dateCreator() : value);
            if (!isArray ||
                (isArray && this.dateSelected && value.length > this.dateSelected.length)) {
                this.focusedDateData = {
                    day: currentDate.getDate(),
                    month: currentDate.getMonth(),
                    year: currentDate.getFullYear()
                };
            }
            this.dateSelected = value;
        },

        /*
         * Toggle datepicker
         */
        togglePicker(active) {
            if (this.$refs.dropdown) {
                const isActive = typeof active === 'boolean'
                    ? active
                    : !this.$refs.dropdown.isActive;
                if (isActive) {
                    this.$refs.dropdown.isActive = isActive;
                } else if (this.closeOnClick) {
                    this.$refs.dropdown.isActive = isActive;
                }
            }
        },

        /*
         * Call default onFocus method and show datepicker
         */
        handleOnFocus(event) {
            this.onFocus(event);
            if (this.openOnFocus) {
                this.togglePicker(true);
            }
        },

        /*
         * Toggle dropdown
         */
        toggle() {
            if (this.mobileNative && this.isMobile) {
                const input = this.$refs.input.$refs.input;
                input.focus();
                input.click();
                return
            }
            this.$refs.dropdown.toggle();
        },

        /*
         * Avoid dropdown toggle when is already visible
         */
        onInputClick(event) {
            if (this.$refs.dropdown.isActive) {
                event.stopPropagation();
            }
        },

        /**
         * Keypress event that is bound to the document.
         */
        keyPress({ key }) {
            if (this.$refs.dropdown && this.$refs.dropdown.isActive && (key === 'Escape' || key === 'Esc')) {
                this.togglePicker(false);
            }
        },

        /**
         * Emit 'blur' event on dropdown is not active (closed)
         */
        onActiveChange(value) {
            if (!value) {
                this.onBlur();
            }
            /*
             * Emit 'active-change' when on dropdown active state change
             */
            this.$emit('active-change', value);
        },

        changeFocus(day) {
            this.focusedDateData = {
                day: day.getDate(),
                month: day.getMonth(),
                year: day.getFullYear()
            };
        }
    },
    created() {
        if (typeof window !== 'undefined') {
            document.addEventListener('keyup', this.keyPress);
        }
    },
    beforeUnmount() {
        if (typeof window !== 'undefined') {
            document.removeEventListener('keyup', this.keyPress);
        }
    }
};

const _hoisted_1$q = { class: "datepicker-header" };
const _hoisted_2$o = ["disabled", "aria-label"];
const _hoisted_3$g = ["disabled", "aria-label"];
const _hoisted_4$c = { class: "pagination-list" };
const _hoisted_5$9 = ["value", "disabled"];
const _hoisted_6$6 = ["value"];
const _hoisted_7$6 = { key: 1 };

function render$r(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_b_input = resolveComponent("b-input");
  const _component_b_icon = resolveComponent("b-icon");
  const _component_b_select = resolveComponent("b-select");
  const _component_b_field = resolveComponent("b-field");
  const _component_b_datepicker_table = resolveComponent("b-datepicker-table");
  const _component_b_datepicker_month = resolveComponent("b-datepicker-month");
  const _component_b_dropdown_item = resolveComponent("b-dropdown-item");
  const _component_b_dropdown = resolveComponent("b-dropdown");

  return (openBlock(), createElementBlock("div", mergeProps({
    class: ["datepicker control", [_ctx.size, {'is-expanded': _ctx.expanded}]]
  }, _ctx.rootAttrs), [
    (!$options.isMobile || $props.inline)
      ? (openBlock(), createBlock(_component_b_dropdown, {
          key: 0,
          ref: "dropdown",
          position: $props.position,
          disabled: $options.disabledOrUndefined,
          inline: $props.inline,
          "mobile-modal": $props.mobileModal,
          "trap-focus": $props.trapFocus,
          "aria-role": $options.ariaRole,
          "append-to-body": $props.appendToBody,
          "append-to-body-copy-parent": "",
          onActiveChange: $options.onActiveChange,
          "trigger-tabindex": -1
        }, createSlots({
          default: withCtx(() => [
            createVNode(_component_b_dropdown_item, {
              disabled: $options.disabledOrUndefined,
              focusable: $props.focusable,
              custom: "",
              class: normalizeClass({'dropdown-horizontal-timepicker': $props.horizontalTimePicker})
            }, {
              default: withCtx(() => [
                createBaseVNode("div", null, [
                  createBaseVNode("header", _hoisted_1$q, [
                    (_ctx.$slots.header !== undefined && _ctx.$slots.header().length)
                      ? renderSlot(_ctx.$slots, "header", { key: 0 })
                      : (openBlock(), createElementBlock("div", {
                          key: 1,
                          class: normalizeClass(["pagination field is-centered", _ctx.size])
                        }, [
                          withDirectives(createBaseVNode("a", {
                            class: "pagination-previous",
                            role: "button",
                            href: "#",
                            disabled: $options.disabledOrUndefined,
                            "aria-label": $props.ariaPreviousLabel,
                            onClick: _cache[3] || (_cache[3] = withModifiers((...args) => ($options.prev && $options.prev(...args)), ["prevent"])),
                            onKeydown: [
                              _cache[4] || (_cache[4] = withKeys(withModifiers((...args) => ($options.prev && $options.prev(...args)), ["prevent"]), ["enter"])),
                              _cache[5] || (_cache[5] = withKeys(withModifiers((...args) => ($options.prev && $options.prev(...args)), ["prevent"]), ["space"]))
                            ]
                          }, [
                            createVNode(_component_b_icon, {
                              icon: $props.iconPrev,
                              pack: _ctx.iconPack,
                              both: "",
                              type: "is-primary is-clickable"
                            }, null, 8 /* PROPS */, ["icon", "pack"])
                          ], 40 /* PROPS, HYDRATE_EVENTS */, _hoisted_2$o), [
                            [vShow, !$options.showPrev && !$props.disabled]
                          ]),
                          withDirectives(createBaseVNode("a", {
                            class: "pagination-next",
                            role: "button",
                            href: "#",
                            disabled: $options.disabledOrUndefined,
                            "aria-label": $props.ariaNextLabel,
                            onClick: _cache[6] || (_cache[6] = withModifiers((...args) => ($options.next && $options.next(...args)), ["prevent"])),
                            onKeydown: [
                              _cache[7] || (_cache[7] = withKeys(withModifiers((...args) => ($options.next && $options.next(...args)), ["prevent"]), ["enter"])),
                              _cache[8] || (_cache[8] = withKeys(withModifiers((...args) => ($options.next && $options.next(...args)), ["prevent"]), ["space"]))
                            ]
                          }, [
                            createVNode(_component_b_icon, {
                              icon: $props.iconNext,
                              pack: _ctx.iconPack,
                              both: "",
                              type: "is-primary is-clickable"
                            }, null, 8 /* PROPS */, ["icon", "pack"])
                          ], 40 /* PROPS, HYDRATE_EVENTS */, _hoisted_3$g), [
                            [vShow, !$options.showNext && !$props.disabled]
                          ]),
                          createBaseVNode("div", _hoisted_4$c, [
                            createVNode(_component_b_field, null, {
                              default: withCtx(() => [
                                (!$options.isTypeMonth)
                                  ? (openBlock(), createBlock(_component_b_select, {
                                      key: 0,
                                      modelValue: $data.focusedDateData.month,
                                      "onUpdate:modelValue": _cache[9] || (_cache[9] = $event => (($data.focusedDateData.month) = $event)),
                                      disabled: $options.disabledOrUndefined,
                                      size: _ctx.size
                                    }, {
                                      default: withCtx(() => [
                                        (openBlock(true), createElementBlock(Fragment, null, renderList($options.listOfMonths, (month) => {
                                          return (openBlock(), createElementBlock("option", {
                                            value: month.index,
                                            key: month.name,
                                            disabled: month.disabled || undefined
                                          }, toDisplayString(month.name), 9 /* TEXT, PROPS */, _hoisted_5$9))
                                        }), 128 /* KEYED_FRAGMENT */))
                                      ]),
                                      _: 1 /* STABLE */
                                    }, 8 /* PROPS */, ["modelValue", "disabled", "size"]))
                                  : createCommentVNode("v-if", true),
                                createVNode(_component_b_select, {
                                  modelValue: $data.focusedDateData.year,
                                  "onUpdate:modelValue": _cache[10] || (_cache[10] = $event => (($data.focusedDateData.year) = $event)),
                                  disabled: $options.disabledOrUndefined,
                                  size: _ctx.size
                                }, {
                                  default: withCtx(() => [
                                    (openBlock(true), createElementBlock(Fragment, null, renderList($options.listOfYears, (year) => {
                                      return (openBlock(), createElementBlock("option", {
                                        value: year,
                                        key: year
                                      }, toDisplayString(year), 9 /* TEXT, PROPS */, _hoisted_6$6))
                                    }), 128 /* KEYED_FRAGMENT */))
                                  ]),
                                  _: 1 /* STABLE */
                                }, 8 /* PROPS */, ["modelValue", "disabled", "size"])
                              ]),
                              _: 1 /* STABLE */
                            })
                          ])
                        ], 2 /* CLASS */))
                  ]),
                  (!$options.isTypeMonth)
                    ? (openBlock(), createElementBlock("div", {
                        key: 0,
                        class: normalizeClass(["datepicker-content", {'content-horizontal-timepicker': $props.horizontalTimePicker}])
                      }, [
                        createVNode(_component_b_datepicker_table, {
                          modelValue: $options.computedValue,
                          "onUpdate:modelValue": _cache[11] || (_cache[11] = $event => (($options.computedValue) = $event)),
                          "day-names": $options.newDayNames,
                          "month-names": $options.newMonthNames,
                          "first-day-of-week": $props.firstDayOfWeek,
                          "rules-for-first-week": $props.rulesForFirstWeek,
                          "min-date": $props.minDate,
                          "max-date": $props.maxDate,
                          focused: $data.focusedDateData,
                          disabled: $options.disabledOrUndefined,
                          "unselectable-dates": $props.unselectableDates,
                          "unselectable-days-of-week": $props.unselectableDaysOfWeek,
                          "selectable-dates": $props.selectableDates,
                          events: $props.events,
                          indicators: $props.indicators,
                          "date-creator": $props.dateCreator,
                          "type-month": $options.isTypeMonth,
                          "nearby-month-days": $props.nearbyMonthDays,
                          "nearby-selectable-month-days": $props.nearbySelectableMonthDays,
                          "show-week-number": $props.showWeekNumber,
                          "week-number-clickable": $props.weekNumberClickable,
                          range: $props.range,
                          multiple: $props.multiple,
                          onRangeStart: _cache[12] || (_cache[12] = date => _ctx.$emit('range-start', date)),
                          onRangeEnd: _cache[13] || (_cache[13] = date => _ctx.$emit('range-end', date)),
                          onClose: _cache[14] || (_cache[14] = $event => ($options.togglePicker(false))),
                          "onUpdate:focused": _cache[15] || (_cache[15] = $event => ($data.focusedDateData = $event))
                        }, null, 8 /* PROPS */, ["modelValue", "day-names", "month-names", "first-day-of-week", "rules-for-first-week", "min-date", "max-date", "focused", "disabled", "unselectable-dates", "unselectable-days-of-week", "selectable-dates", "events", "indicators", "date-creator", "type-month", "nearby-month-days", "nearby-selectable-month-days", "show-week-number", "week-number-clickable", "range", "multiple"])
                      ], 2 /* CLASS */))
                    : (openBlock(), createElementBlock("div", _hoisted_7$6, [
                        createVNode(_component_b_datepicker_month, {
                          modelValue: $options.computedValue,
                          "onUpdate:modelValue": _cache[16] || (_cache[16] = $event => (($options.computedValue) = $event)),
                          "month-names": $options.newMonthNames,
                          "min-date": $props.minDate,
                          "max-date": $props.maxDate,
                          focused: $data.focusedDateData,
                          disabled: $options.disabledOrUndefined,
                          "unselectable-dates": $props.unselectableDates,
                          "unselectable-days-of-week": $props.unselectableDaysOfWeek,
                          "selectable-dates": $props.selectableDates,
                          events: $props.events,
                          indicators: $props.indicators,
                          "date-creator": $props.dateCreator,
                          range: $props.range,
                          multiple: $props.multiple,
                          onRangeStart: _cache[17] || (_cache[17] = date => _ctx.$emit('range-start', date)),
                          onRangeEnd: _cache[18] || (_cache[18] = date => _ctx.$emit('range-end', date)),
                          onClose: _cache[19] || (_cache[19] = $event => ($options.togglePicker(false))),
                          onChangeFocus: $options.changeFocus,
                          "onUpdate:focused": _cache[20] || (_cache[20] = $event => ($data.focusedDateData = $event))
                        }, null, 8 /* PROPS */, ["modelValue", "month-names", "min-date", "max-date", "focused", "disabled", "unselectable-dates", "unselectable-days-of-week", "selectable-dates", "events", "indicators", "date-creator", "range", "multiple", "onChangeFocus"])
                      ]))
                ]),
                (_ctx.$slots.default !== undefined && _ctx.$slots.default().length)
                  ? (openBlock(), createElementBlock("footer", {
                      key: 0,
                      class: normalizeClass(["datepicker-footer", {'footer-horizontal-timepicker': $props.horizontalTimePicker}])
                    }, [
                      renderSlot(_ctx.$slots, "default")
                    ], 2 /* CLASS */))
                  : createCommentVNode("v-if", true)
              ]),
              _: 3 /* FORWARDED */
            }, 8 /* PROPS */, ["disabled", "focusable", "class"])
          ]),
          _: 2 /* DYNAMIC */
        }, [
          (!$props.inline)
            ? {
                name: "trigger",
                fn: withCtx((props) => [
                  renderSlot(_ctx.$slots, "trigger", normalizeProps(guardReactiveProps(props)), () => [
                    createVNode(_component_b_input, mergeProps({
                      ref: "input",
                      autocomplete: "off",
                      "model-value": $options.formattedValue,
                      placeholder: $props.placeholder,
                      size: _ctx.size,
                      icon: _ctx.icon,
                      "icon-right": $props.iconRight,
                      "icon-right-clickable": $props.iconRightClickable,
                      "icon-pack": _ctx.iconPack,
                      rounded: _ctx.rounded,
                      loading: _ctx.loading,
                      disabled: $options.disabledOrUndefined,
                      readonly: !$props.editable
                    }, _ctx.fallthroughAttrs, {
                      "use-html5-validation": false,
                      onClick: $options.onInputClick,
                      onIconRightClick: _cache[0] || (_cache[0] = $event => (_ctx.$emit('icon-right-click', $event))),
                      onKeyup: _cache[1] || (_cache[1] = withKeys($event => ($options.togglePicker(true)), ["enter"])),
                      onChange: _cache[2] || (_cache[2] = $event => ($options.onChange($event.target.value))),
                      onFocus: $options.handleOnFocus
                    }), null, 16 /* FULL_PROPS */, ["model-value", "placeholder", "size", "icon", "icon-right", "icon-right-clickable", "icon-pack", "rounded", "loading", "disabled", "readonly", "onClick", "onFocus"])
                  ])
                ]),
                key: "0"
              }
            : undefined
        ]), 1032 /* PROPS, DYNAMIC_SLOTS */, ["position", "disabled", "inline", "mobile-modal", "trap-focus", "aria-role", "append-to-body", "onActiveChange"]))
      : (openBlock(), createBlock(_component_b_input, mergeProps({
          key: 1,
          ref: "input",
          type: !$options.isTypeMonth ? 'date' : 'month',
          autocomplete: "off",
          "model-value": $options.formatNative($options.computedValue),
          placeholder: $props.placeholder,
          size: _ctx.size,
          icon: _ctx.icon,
          "icon-pack": _ctx.iconPack,
          rounded: _ctx.rounded,
          loading: _ctx.loading,
          max: $options.formatNative($props.maxDate),
          min: $options.formatNative($props.minDate),
          disabled: $options.disabledOrUndefined,
          readonly: false
        }, _ctx.fallthroughAttrs, {
          "use-html5-validation": false,
          onChange: $options.onChangeNativePicker,
          onFocus: _ctx.onFocus,
          onBlur: _ctx.onBlur
        }), null, 16 /* FULL_PROPS */, ["type", "model-value", "placeholder", "size", "icon", "icon-pack", "rounded", "loading", "max", "min", "disabled", "onChange", "onFocus", "onBlur"]))
  ], 16 /* FULL_PROPS */))
}

script$s.render = render$r;
script$s.__file = "src/components/datepicker/Datepicker.vue";

var Plugin$x = {
  install: function install(Vue) {
    registerComponent(Vue, script$s);
  }
};

var script$r = {
    name: 'BTimepicker',
    components: {
        [script$H.name]: script$H,
        [script$x.name]: script$x,
        [script$v.name]: script$v,
        [script$I.name]: script$I,
        [script$1$e.name]: script$1$e,
        [script$y.name]: script$y
    },
    mixins: [TimepickerMixin],
    data() {
        return {
            _isTimepicker: true
        }
    },
    computed: {
        nativeStep() {
            if (this.enableSeconds) {
                return '1'
            } else {
                return undefined
            }
        }
    }
};

const _hoisted_1$p = ["value", "disabled"];
const _hoisted_2$n = { class: "control is-colon" };
const _hoisted_3$f = ["value", "disabled"];
const _hoisted_4$b = { class: "control is-colon" };
const _hoisted_5$8 = ["value", "disabled"];
const _hoisted_6$5 = { class: "control is-colon" };
const _hoisted_7$5 = ["value"];
const _hoisted_8$5 = {
  key: 0,
  class: "timepicker-footer"
};

function render$q(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_b_input = resolveComponent("b-input");
  const _component_b_select = resolveComponent("b-select");
  const _component_b_field = resolveComponent("b-field");
  const _component_b_dropdown_item = resolveComponent("b-dropdown-item");
  const _component_b_dropdown = resolveComponent("b-dropdown");

  return (openBlock(), createElementBlock("div", mergeProps({
    class: ["timepicker control", [_ctx.size, {'is-expanded': _ctx.expanded}]]
  }, _ctx.rootAttrs), [
    (!_ctx.isMobile || _ctx.inline)
      ? (openBlock(), createBlock(_component_b_dropdown, {
          key: 0,
          ref: "dropdown",
          position: _ctx.position,
          disabled: _ctx.disabledOrUndefined,
          inline: _ctx.inline,
          "mobile-modal": _ctx.mobileModal,
          "append-to-body": _ctx.appendToBody,
          "append-to-body-copy-parent": "",
          onActiveChange: _ctx.onActiveChange
        }, createSlots({
          default: withCtx(() => [
            createVNode(_component_b_dropdown_item, {
              disabled: _ctx.disabledOrUndefined,
              focusable: _ctx.focusable,
              custom: ""
            }, {
              default: withCtx(() => [
                createVNode(_component_b_field, {
                  grouped: "",
                  position: "is-centered"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_b_select, {
                      modelValue: _ctx.hoursSelected,
                      "onUpdate:modelValue": _cache[2] || (_cache[2] = $event => ((_ctx.hoursSelected) = $event)),
                      onChange: _cache[3] || (_cache[3] = $event => (_ctx.onHoursChange($event.target.value))),
                      disabled: _ctx.disabledOrUndefined,
                      placeholder: "00"
                    }, {
                      default: withCtx(() => [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.hours, (hour) => {
                          return (openBlock(), createElementBlock("option", {
                            value: hour.value,
                            key: hour.value,
                            disabled: _ctx.isHourDisabled(hour.value) || undefined
                          }, toDisplayString(hour.label), 9 /* TEXT, PROPS */, _hoisted_1$p))
                        }), 128 /* KEYED_FRAGMENT */))
                      ]),
                      _: 1 /* STABLE */
                    }, 8 /* PROPS */, ["modelValue", "disabled"]),
                    createBaseVNode("span", _hoisted_2$n, toDisplayString(_ctx.hourLiteral), 1 /* TEXT */),
                    createVNode(_component_b_select, {
                      modelValue: _ctx.minutesSelected,
                      "onUpdate:modelValue": _cache[4] || (_cache[4] = $event => ((_ctx.minutesSelected) = $event)),
                      onChange: _cache[5] || (_cache[5] = $event => (_ctx.onMinutesChange($event.target.value))),
                      disabled: _ctx.disabledOrUndefined,
                      placeholder: "00"
                    }, {
                      default: withCtx(() => [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.minutes, (minute) => {
                          return (openBlock(), createElementBlock("option", {
                            value: minute.value,
                            key: minute.value,
                            disabled: _ctx.isMinuteDisabled(minute.value) || undefined
                          }, toDisplayString(minute.label), 9 /* TEXT, PROPS */, _hoisted_3$f))
                        }), 128 /* KEYED_FRAGMENT */))
                      ]),
                      _: 1 /* STABLE */
                    }, 8 /* PROPS */, ["modelValue", "disabled"]),
                    (_ctx.enableSeconds)
                      ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                          createBaseVNode("span", _hoisted_4$b, toDisplayString(_ctx.minuteLiteral), 1 /* TEXT */),
                          createVNode(_component_b_select, {
                            modelValue: _ctx.secondsSelected,
                            "onUpdate:modelValue": _cache[6] || (_cache[6] = $event => ((_ctx.secondsSelected) = $event)),
                            onChange: _cache[7] || (_cache[7] = $event => (_ctx.onSecondsChange($event.target.value))),
                            disabled: _ctx.disabledOrUndefined,
                            placeholder: "00"
                          }, {
                            default: withCtx(() => [
                              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.seconds, (second) => {
                                return (openBlock(), createElementBlock("option", {
                                  value: second.value,
                                  key: second.value,
                                  disabled: _ctx.isSecondDisabled(second.value) || undefined
                                }, toDisplayString(second.label), 9 /* TEXT, PROPS */, _hoisted_5$8))
                              }), 128 /* KEYED_FRAGMENT */))
                            ]),
                            _: 1 /* STABLE */
                          }, 8 /* PROPS */, ["modelValue", "disabled"]),
                          createBaseVNode("span", _hoisted_6$5, toDisplayString(_ctx.secondLiteral), 1 /* TEXT */)
                        ], 64 /* STABLE_FRAGMENT */))
                      : createCommentVNode("v-if", true),
                    (!_ctx.isHourFormat24)
                      ? (openBlock(), createBlock(_component_b_select, {
                          key: 1,
                          modelValue: _ctx.meridienSelected,
                          "onUpdate:modelValue": _cache[8] || (_cache[8] = $event => ((_ctx.meridienSelected) = $event)),
                          onChange: _cache[9] || (_cache[9] = $event => (_ctx.onMeridienChange($event.target.value))),
                          disabled: _ctx.disabledOrUndefined
                        }, {
                          default: withCtx(() => [
                            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.meridiens, (meridien) => {
                              return (openBlock(), createElementBlock("option", {
                                value: meridien,
                                key: meridien
                              }, toDisplayString(meridien), 9 /* TEXT, PROPS */, _hoisted_7$5))
                            }), 128 /* KEYED_FRAGMENT */))
                          ]),
                          _: 1 /* STABLE */
                        }, 8 /* PROPS */, ["modelValue", "disabled"]))
                      : createCommentVNode("v-if", true)
                  ]),
                  _: 1 /* STABLE */
                }),
                (_ctx.$slots.default !== undefined)
                  ? (openBlock(), createElementBlock("footer", _hoisted_8$5, [
                      renderSlot(_ctx.$slots, "default")
                    ]))
                  : createCommentVNode("v-if", true)
              ]),
              _: 3 /* FORWARDED */
            }, 8 /* PROPS */, ["disabled", "focusable"])
          ]),
          _: 2 /* DYNAMIC */
        }, [
          (!_ctx.inline)
            ? {
                name: "trigger",
                fn: withCtx(() => [
                  renderSlot(_ctx.$slots, "trigger", {}, () => [
                    createVNode(_component_b_input, mergeProps({
                      ref: "input",
                      autocomplete: "off",
                      "model-value": _ctx.formatValue(_ctx.computedValue),
                      placeholder: _ctx.placeholder,
                      size: _ctx.size,
                      icon: _ctx.icon,
                      "icon-pack": _ctx.iconPack,
                      loading: _ctx.loading,
                      disabled: _ctx.disabledOrUndefined,
                      readonly: !_ctx.editable || undefined,
                      rounded: _ctx.rounded
                    }, _ctx.fallthroughAttrs, {
                      "use-html5-validation": _ctx.useHtml5Validation,
                      onKeyup: _cache[0] || (_cache[0] = withKeys($event => (_ctx.toggle(true)), ["enter"])),
                      onChange: _cache[1] || (_cache[1] = $event => (_ctx.onChange($event.target.value))),
                      onFocus: _ctx.handleOnFocus
                    }), null, 16 /* FULL_PROPS */, ["model-value", "placeholder", "size", "icon", "icon-pack", "loading", "disabled", "readonly", "rounded", "use-html5-validation", "onFocus"])
                  ])
                ]),
                key: "0"
              }
            : undefined
        ]), 1032 /* PROPS, DYNAMIC_SLOTS */, ["position", "disabled", "inline", "mobile-modal", "append-to-body", "onActiveChange"]))
      : (openBlock(), createBlock(_component_b_input, mergeProps({
          key: 1,
          ref: "input",
          type: "time",
          step: $options.nativeStep,
          autocomplete: "off",
          "model-value": _ctx.formatHHMMSS(_ctx.computedValue),
          placeholder: _ctx.placeholder,
          size: _ctx.size,
          icon: _ctx.icon,
          "icon-pack": _ctx.iconPack,
          rounded: _ctx.rounded,
          loading: _ctx.loading,
          max: _ctx.formatHHMMSS(_ctx.maxTime),
          min: _ctx.formatHHMMSS(_ctx.minTime),
          disabled: _ctx.disabledOrUndefined,
          readonly: false
        }, _ctx.fallthroughAttrs, {
          "use-html5-validation": _ctx.useHtml5Validation,
          onChange: _cache[10] || (_cache[10] = $event => (_ctx.onChange($event.target.value))),
          onFocus: _ctx.handleOnFocus,
          onBlur: _cache[11] || (_cache[11] = $event => (_ctx.onBlur() && _ctx.checkHtml5Validity()))
        }), null, 16 /* FULL_PROPS */, ["step", "model-value", "placeholder", "size", "icon", "icon-pack", "rounded", "loading", "max", "min", "disabled", "use-html5-validation", "onFocus"]))
  ], 16 /* FULL_PROPS */))
}

script$r.render = render$q;
script$r.__file = "src/components/timepicker/Timepicker.vue";

const AM = 'AM';
const PM = 'PM';
var script$q = {
    name: 'BDatetimepicker',
    components: {
        [script$s.name]: script$s,
        [script$H.name]: script$H,
        [script$r.name]: script$r
    },
    mixins: [FormElementMixin],
    inheritAttrs: false,
    props: {
        modelValue: {
            type: Date
        },
        editable: {
            type: Boolean,
            default: false
        },
        placeholder: String,
        horizontalTimePicker: Boolean,
        disabled: Boolean,
        firstDayOfWeek: {
            type: Number,
            default: () => {
                if (typeof config.defaultFirstDayOfWeek === 'number') {
                    return config.defaultFirstDayOfWeek
                } else {
                    return 0
                }
            }
        },
        rulesForFirstWeek: {
            type: Number,
            default: () => 4
        },
        icon: String,
        iconRight: String,
        iconRightClickable: Boolean,
        iconPack: String,
        inline: Boolean,
        openOnFocus: Boolean,
        position: String,
        mobileNative: {
            type: Boolean,
            default: true
        },
        minDatetime: Date,
        maxDatetime: Date,
        nearbyMonthDays: {
            type: Boolean,
            default: config.defaultDatepickerNearbyMonthDays
        },
        datetimeFormatter: {
            type: Function
        },
        datetimeParser: {
            type: Function
        },
        datetimeCreator: {
            type: Function,
            default: (date) => {
                if (typeof config.defaultDatetimeCreator === 'function') {
                    return config.defaultDatetimeCreator(date)
                } else {
                    return date
                }
            }
        },
        datepicker: Object,
        timepicker: Object,
        tzOffset: {
            type: Number,
            default: 0
        },
        focusable: {
            type: Boolean,
            default: true
        },
        appendToBody: Boolean
    },
    emits: [
        'active-change',
        'change-month',
        'change-year',
        'icon-right-click',
        'update:modelValue'
    ],
    data() {
        return {
            newValue: this.adjustValue(this.modelValue)
        }
    },
    computed: {
        computedValue: {
            get() {
                return this.newValue
            },
            set(value) {
                if (value) {
                    let val = new Date(value.getTime());
                    if (this.newValue) {
                        // restore time part
                        if ((value.getDate() !== this.newValue.getDate() ||
                            value.getMonth() !== this.newValue.getMonth() ||
                            value.getFullYear() !== this.newValue.getFullYear()) &&
                            value.getHours() === 0 &&
                            value.getMinutes() === 0 &&
                            value.getSeconds() === 0) {
                            val.setHours(this.newValue.getHours(),
                                this.newValue.getMinutes(),
                                this.newValue.getSeconds(), 0);
                        }
                    } else {
                        val = this.datetimeCreator(value);
                    }
                    // check min and max range
                    if (this.minDatetime && val < this.adjustValue(this.minDatetime)) {
                        val = this.adjustValue(this.minDatetime);
                    } else if (this.maxDatetime && val > this.adjustValue(this.maxDatetime)) {
                        val = this.adjustValue(this.maxDatetime);
                    }
                    this.newValue = new Date(val.getTime());
                } else {
                    this.newValue = this.adjustValue(value);
                }
                const adjustedValue = this.adjustValue(this.newValue, true); // reverse adjust
                this.$emit('update:modelValue', adjustedValue);
            }
        },
        localeOptions() {
            return new Intl.DateTimeFormat(this.locale, {
                year: 'numeric',
                month: 'numeric',
                day: 'numeric',
                hour: 'numeric',
                minute: 'numeric',
                second: this.enableSeconds() ? 'numeric' : undefined
            }).resolvedOptions()
        },
        dtf() {
            return new Intl.DateTimeFormat(this.locale, {
                year: this.localeOptions.year || 'numeric',
                month: this.localeOptions.month || 'numeric',
                day: this.localeOptions.day || 'numeric',
                hour: this.localeOptions.hour || 'numeric',
                minute: this.localeOptions.minute || 'numeric',
                second: this.enableSeconds() ? this.localeOptions.second || 'numeric' : undefined,
                hourCycle: !this.isHourFormat24() ? 'h12' : 'h23'
            })
        },
        isMobileNative() {
            return this.mobileNative && this.tzOffset === 0
        },
        isMobile() {
            return this.isMobileNative && isMobile.any()
        },
        minDate() {
            if (!this.minDatetime) {
                return this.datepicker ? this.adjustValue(this.datepicker.minDate) : null
            }
            const adjMinDatetime = this.adjustValue(this.minDatetime);
            return new Date(adjMinDatetime.getFullYear(),
                adjMinDatetime.getMonth(),
                adjMinDatetime.getDate(), 0, 0, 0, 0)
        },
        maxDate() {
            if (!this.maxDatetime) {
                return this.datepicker ? this.adjustValue(this.datepicker.maxDate) : null
            }
            const adjMaxDatetime = this.adjustValue(this.maxDatetime);
            return new Date(adjMaxDatetime.getFullYear(),
                adjMaxDatetime.getMonth(),
                adjMaxDatetime.getDate(), 0, 0, 0, 0)
        },
        minTime() {
            if (!this.minDatetime || (this.newValue === null || typeof this.newValue === 'undefined')) {
                return this.timepicker ? this.adjustValue(this.timepicker.minTime) : null
            }
            const adjMinDatetime = this.adjustValue(this.minDatetime);
            if (adjMinDatetime.getFullYear() === this.newValue.getFullYear() &&
                adjMinDatetime.getMonth() === this.newValue.getMonth() &&
                adjMinDatetime.getDate() === this.newValue.getDate()) {
                return adjMinDatetime
            }
            return undefined
        },
        maxTime() {
            if (!this.maxDatetime || (this.newValue === null || typeof this.newValue === 'undefined')) {
                return this.timepicker ? this.adjustValue(this.timepicker.maxTime) : null
            }
            const adjMaxDatetime = this.adjustValue(this.maxDatetime);
            if (adjMaxDatetime.getFullYear() === this.newValue.getFullYear() &&
                adjMaxDatetime.getMonth() === this.newValue.getMonth() &&
                adjMaxDatetime.getDate() === this.newValue.getDate()) {
                return adjMaxDatetime
            }
            return undefined
        },
        datepickerSize() {
            return this.datepicker && this.datepicker.size
                ? this.datepicker.size
                : this.size
        },
        timepickerSize() {
            return this.timepicker && this.timepicker.size
                ? this.timepicker.size
                : this.size
        },
        timepickerDisabled() {
            return this.timepicker && this.timepicker.disabled
                ? this.timepicker.disabled
                : this.disabled
        },

        disabledOrUndefined() {
            // On Vue 3, setting a boolean attribute `false` does not remove it,
            // `null` or `undefined` has to be given to remove it.
            return this.disabled || undefined
        }
    },
    watch: {
        modelValue() {
            this.newValue = this.adjustValue(this.modelValue);
        },
        tzOffset() {
            this.newValue = this.adjustValue(this.modelValue);
        }
    },
    methods: {
        enableSeconds() {
            if (this.$refs.timepicker) {
                return this.$refs.timepicker.enableSeconds
            }
            return false
        },
        isHourFormat24() {
            if (this.$refs.timepicker) {
                return this.$refs.timepicker.isHourFormat24
            }
            return !this.localeOptions.hour12
        },
        adjustValue(value, reverse = false) {
            if (!value) return value
            if (reverse) {
                return new Date(value.getTime() - this.tzOffset * 60000)
            } else {
                return new Date(value.getTime() + this.tzOffset * 60000)
            }
        },
        defaultDatetimeParser(date) {
            if (typeof this.datetimeParser === 'function') {
                return this.datetimeParser(date)
            } else if (typeof config.defaultDatetimeParser === 'function') {
                return config.defaultDatetimeParser(date)
            } else {
                if (this.dtf.formatToParts && typeof this.dtf.formatToParts === 'function') {
                    const dayPeriods = [AM, PM, AM.toLowerCase(), PM.toLowerCase()];
                    if (this.$refs.timepicker) {
                        dayPeriods.push(this.$refs.timepicker.amString);
                        dayPeriods.push(this.$refs.timepicker.pmString);
                    }
                    const parts = this.dtf.formatToParts(new Date());
                    const formatRegex = parts.map((part, idx) => {
                        if (part.type === 'literal') {
                            if (idx + 1 < parts.length && parts[idx + 1].type === 'hour') {
                                return '[^\\d]+'
                            }
                            return part.value.replace(/ /g, '\\s?')
                        } else if (part.type === 'dayPeriod') {
                            return `((?!=<${part.type}>)(${dayPeriods.join('|')})?)`
                        }
                        return `((?!=<${part.type}>)\\d+)`
                    }).join('');
                    const datetimeGroups = matchWithGroups(formatRegex, date);

                    // We do a simple validation for the group.
                    // If it is not valid, it will fallback to Date.parse below
                    if (
                        datetimeGroups.year &&
                        datetimeGroups.year.length === 4 &&
                        datetimeGroups.month &&
                        datetimeGroups.month <= 12 &&
                        datetimeGroups.day &&
                        datetimeGroups.day <= 31 &&
                        datetimeGroups.hour &&
                        datetimeGroups.hour >= 0 &&
                        datetimeGroups.hour < 24 &&
                        datetimeGroups.minute &&
                        datetimeGroups.minute >= 0 &&
                        datetimeGroups.minute <= 59
                    ) {
                        const d = new Date(
                            datetimeGroups.year,
                            datetimeGroups.month - 1,
                            datetimeGroups.day,
                            datetimeGroups.hour,
                            datetimeGroups.minute,
                            datetimeGroups.second || 0);
                        return d
                    }
                }

                return new Date(Date.parse(date))
            }
        },
        defaultDatetimeFormatter(date) {
            if (typeof this.datetimeFormatter === 'function') {
                return this.datetimeFormatter(date)
            } else if (typeof config.defaultDatetimeFormatter === 'function') {
                return config.defaultDatetimeFormatter(date)
            } else {
                return this.dtf.format(date)
            }
        },
        /*
        * Parse date from string
        */
        onChangeNativePicker(event) {
            const date = event.target.value;
            const s = date ? date.split(/\D/) : [];
            if (s.length >= 5) {
                const year = parseInt(s[0], 10);
                const month = parseInt(s[1], 10) - 1;
                const day = parseInt(s[2], 10);
                const hours = parseInt(s[3], 10);
                const minutes = parseInt(s[4], 10);
                // Seconds are omitted intentionally; they are unsupported by input
                // type=datetime-local and cause the control to fail native validation
                this.computedValue = new Date(year, month, day, hours, minutes);
            } else {
                this.computedValue = null;
            }
        },
        /*
         * Emit 'active-change' on datepicker active state change
         */
        onActiveChange(value) {
            this.$emit('active-change', value);
        },
        formatNative(value) {
            const date = new Date(value);
            if (value && !isNaN(date)) {
                const year = date.getFullYear();
                const month = date.getMonth() + 1;
                const day = date.getDate();
                const hours = date.getHours();
                const minutes = date.getMinutes();
                const seconds = date.getSeconds();
                return year + '-' +
                    ((month < 10 ? '0' : '') + month) + '-' +
                    ((day < 10 ? '0' : '') + day) + 'T' +
                    ((hours < 10 ? '0' : '') + hours) + ':' +
                    ((minutes < 10 ? '0' : '') + minutes) + ':' +
                    ((seconds < 10 ? '0' : '') + seconds)
            }
            return ''
        },
        toggle() {
            this.$refs.datepicker.toggle();
        }
    },
    mounted() {
        if (!this.isMobile || this.inline) {
            // $refs attached, it's time to refresh datepicker (input)
            if (this.newValue) {
                this.$refs.datepicker.$forceUpdate();
            }
        }
    }
};

const _hoisted_1$o = { class: "level is-mobile" };
const _hoisted_2$m = {
  key: 0,
  class: "level-item has-text-centered"
};
const _hoisted_3$e = { class: "level-item has-text-centered" };
const _hoisted_4$a = {
  key: 1,
  class: "level-item has-text-centered"
};

function render$p(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_b_timepicker = resolveComponent("b-timepicker");
  const _component_b_datepicker = resolveComponent("b-datepicker");
  const _component_b_input = resolveComponent("b-input");

  return (!$options.isMobile || $props.inline)
    ? (openBlock(), createBlock(_component_b_datepicker, mergeProps({
        key: 0,
        ref: "datepicker",
        modelValue: $options.computedValue,
        "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => (($options.computedValue) = $event))
      }, $props.datepicker, {
        rounded: _ctx.rounded,
        "open-on-focus": $props.openOnFocus,
        position: $props.position,
        loading: _ctx.loading,
        inline: $props.inline,
        editable: $props.editable,
        expanded: _ctx.expanded,
        "close-on-click": false,
        "first-day-of-week": $props.firstDayOfWeek,
        "rules-for-first-week": $props.rulesForFirstWeek,
        "date-formatter": $options.defaultDatetimeFormatter,
        "date-parser": $options.defaultDatetimeParser,
        "min-date": $options.minDate,
        "max-date": $options.maxDate,
        "nearby-month-days": $props.nearbyMonthDays,
        icon: $props.icon,
        "icon-right": $props.iconRight,
        "icon-right-clickable": $props.iconRightClickable,
        "icon-pack": $props.iconPack,
        size: $options.datepickerSize,
        placeholder: $props.placeholder,
        "horizontal-time-picker": $props.horizontalTimePicker,
        range: false,
        disabled: $options.disabledOrUndefined,
        "mobile-native": $options.isMobileNative,
        locale: _ctx.locale,
        focusable: $props.focusable,
        "append-to-body": $props.appendToBody,
        onFocus: _ctx.onFocus,
        onBlur: _ctx.onBlur,
        onActiveChange: $options.onActiveChange,
        onIconRightClick: _cache[2] || (_cache[2] = $event => (_ctx.$emit('icon-right-click'))),
        onChangeMonth: _cache[3] || (_cache[3] = $event => (_ctx.$emit('change-month', $event))),
        onChangeYear: _cache[4] || (_cache[4] = $event => (_ctx.$emit('change-year', $event)))
      }), {
        default: withCtx(() => [
          createBaseVNode("nav", _hoisted_1$o, [
            (_ctx.$slots.left !== undefined)
              ? (openBlock(), createElementBlock("div", _hoisted_2$m, [
                  renderSlot(_ctx.$slots, "left")
                ]))
              : createCommentVNode("v-if", true),
            createBaseVNode("div", _hoisted_3$e, [
              createVNode(_component_b_timepicker, mergeProps({ ref: "timepicker" }, $props.timepicker, {
                modelValue: $options.computedValue,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => (($options.computedValue) = $event)),
                inline: "",
                editable: $props.editable,
                "min-time": $options.minTime,
                "max-time": $options.maxTime,
                size: $options.timepickerSize,
                disabled: $options.timepickerDisabled || undefined,
                focusable: $props.focusable,
                "mobile-native": $options.isMobileNative,
                locale: _ctx.locale
              }), null, 16 /* FULL_PROPS */, ["modelValue", "editable", "min-time", "max-time", "size", "disabled", "focusable", "mobile-native", "locale"])
            ]),
            (_ctx.$slots.right !== undefined)
              ? (openBlock(), createElementBlock("div", _hoisted_4$a, [
                  renderSlot(_ctx.$slots, "right")
                ]))
              : createCommentVNode("v-if", true)
          ])
        ]),
        _: 3 /* FORWARDED */
      }, 16 /* FULL_PROPS */, ["modelValue", "rounded", "open-on-focus", "position", "loading", "inline", "editable", "expanded", "first-day-of-week", "rules-for-first-week", "date-formatter", "date-parser", "min-date", "max-date", "nearby-month-days", "icon", "icon-right", "icon-right-clickable", "icon-pack", "size", "placeholder", "horizontal-time-picker", "disabled", "mobile-native", "locale", "focusable", "append-to-body", "onFocus", "onBlur", "onActiveChange"]))
    : (openBlock(), createBlock(_component_b_input, mergeProps({
        key: 1,
        ref: "input",
        type: "datetime-local",
        autocomplete: "off",
        "model-value": $options.formatNative($options.computedValue),
        placeholder: $props.placeholder,
        size: _ctx.size,
        icon: $props.icon,
        "icon-pack": $props.iconPack,
        rounded: _ctx.rounded,
        loading: _ctx.loading,
        max: $options.formatNative($options.maxDate),
        min: $options.formatNative($options.minDate),
        disabled: $options.disabledOrUndefined,
        readonly: false
      }, _ctx.$attrs, {
        "use-html5-validation": _ctx.useHtml5Validation,
        onChange: $options.onChangeNativePicker,
        onFocus: _ctx.onFocus,
        onBlur: _ctx.onBlur
      }), null, 16 /* FULL_PROPS */, ["model-value", "placeholder", "size", "icon", "icon-pack", "rounded", "loading", "max", "min", "disabled", "use-html5-validation", "onChange", "onFocus", "onBlur"]))
}

script$q.render = render$p;
script$q.__file = "src/components/datetimepicker/Datetimepicker.vue";

var Plugin$w = {
  install: function install(Vue) {
    registerComponent(Vue, script$q);
  }
};

var script$p = {
    name: 'BModal',
    directives: {
        trapFocus
    },
    props: {
        modelValue: Boolean,
        component: [Object, Function, String],
        content: [String, Array],
        programmatic: Boolean,
        props: Object,
        events: {
            type: Object,
            default() {
                return {}
            }
        },
        width: {
            type: [String, Number],
            default: 960
        },
        hasModalCard: Boolean,
        animation: {
            type: String,
            default: 'zoom-out'
        },
        canCancel: {
            type: [Array, Boolean],
            default: () => {
                return config.defaultModalCanCancel
            }
        },
        cancelCallback: {
            type: Function,
            default: () => {}
        },
        scroll: {
            type: String,
            default: () => {
                return config.defaultModalScroll
                    ? config.defaultModalScroll
                    : 'clip'
            },
            validator: (value) => {
                return [
                    'clip',
                    'keep'
                ].indexOf(value) >= 0
            }
        },
        fullScreen: Boolean,
        trapFocus: {
            type: Boolean,
            default: () => {
                return config.defaultTrapFocus
            }
        },
        autoFocus: {
            type: Boolean,
            default: () => {
                return config.defaultAutoFocus
            }
        },
        customClass: String,
        customContentClass: [String, Array, Object],
        ariaRole: {
            type: String,
            validator: (value) => {
                return [
                    'dialog',
                    'alertdialog'
                ].indexOf(value) >= 0
            }
        },
        ariaModal: Boolean,
        ariaLabel: {
            type: String,
            validator: (value) => {
                return Boolean(value)
            }
        },
        closeButtonAriaLabel: String,
        destroyOnHide: {
            type: Boolean,
            default: true
        },
        renderOnMounted: {
            type: Boolean,
            default: false
        }
    },
    emits: [
        'after-enter',
        'after-leave',
        'cancel',
        'close',
        'update:modelValue'
    ],
    data() {
        return {
            isActive: this.modelValue || false,
            savedScrollTop: null,
            newWidth: typeof this.width === 'number'
                ? this.width + 'px'
                : this.width,
            animating: !this.modelValue,
            destroyed: !(this.modelValue || this.renderOnMounted)
        }
    },
    computed: {
        cancelOptions() {
            return typeof this.canCancel === 'boolean'
                ? this.canCancel
                    ? config.defaultModalCanCancel
                    : []
                : this.canCancel
        },
        showX() {
            return this.cancelOptions.indexOf('x') >= 0
        },
        customStyle() {
            if (!this.fullScreen) {
                return { maxWidth: this.newWidth }
            }
            return null
        }
    },
    watch: {
        modelValue(value) {
            this.isActive = value;
        },
        isActive(value) {
            if (value) this.destroyed = false;
            this.handleScroll();
            this.$nextTick(() => {
                if (value && this.$el && this.$el.focus && this.autoFocus) {
                    this.$el.focus();
                }
            });
        }
    },
    methods: {
        handleScroll() {
            if (typeof window === 'undefined') return

            if (this.scroll === 'clip') {
                if (this.isActive) {
                    document.documentElement.classList.add('is-clipped');
                } else {
                    document.documentElement.classList.remove('is-clipped');
                }
                return
            }

            this.savedScrollTop = !this.savedScrollTop
                ? document.documentElement.scrollTop
                : this.savedScrollTop;

            if (this.isActive) {
                document.body.classList.add('is-noscroll');
            } else {
                document.body.classList.remove('is-noscroll');
            }

            if (this.isActive) {
                document.body.style.top = `-${this.savedScrollTop}px`;
                return
            }

            document.documentElement.scrollTop = this.savedScrollTop;
            document.body.style.top = null;
            this.savedScrollTop = null;
        },

        /**
        * Close the Modal if canCancel and call the cancelCallback prop (function).
        */
        cancel(method) {
            if (this.cancelOptions.indexOf(method) < 0) return
            this.$emit('cancel', arguments);
            this.cancelCallback.apply(null, arguments);
            this.close();
        },

        /**
        * Call the cancelCallback prop (function).
        * Emit events, and destroy modal if it's programmatic.
        */
        close() {
            this.$emit('close');
            this.$emit('update:modelValue', false);

            // Timeout for the animation complete before destroying
            if (this.programmatic) {
                this.isActive = false;
                setTimeout(() => {
                    removeElement(this.$el);
                }, 150);
            }
        },

        /**
        * Keypress event that is bound to the document.
        */
        keyPress({ key }) {
            if (this.isActive && (key === 'Escape' || key === 'Esc')) this.cancel('escape');
        },

        /**
        * Transition after-enter hook
        */
        afterEnter() {
            this.animating = false;
            this.$emit('after-enter');
        },

        /**
        * Transition before-leave hook
        */
        beforeLeave() {
            this.animating = true;
        },

        /**
        * Transition after-leave hook
        */
        afterLeave() {
            if (this.destroyOnHide) {
                this.destroyed = true;
            }
            this.$emit('after-leave');
        }
    },
    created() {
        if (typeof window !== 'undefined') {
            document.addEventListener('keyup', this.keyPress);
        }
    },
    mounted() {
        if (this.programmatic) {
            // Insert the Modal component in body tag
            // only if it's programmatic
            // the following line used be in `beforeMount`
            // but $el is null at `beforeMount`
            document.body.appendChild(this.$el);
            this.isActive = true;
        } else if (this.isActive) this.handleScroll();
    },
    beforeUnmount() {
        if (typeof window !== 'undefined') {
            document.removeEventListener('keyup', this.keyPress);
            // reset scroll
            document.documentElement.classList.remove('is-clipped');
            const savedScrollTop = !this.savedScrollTop
                ? document.documentElement.scrollTop
                : this.savedScrollTop;
            document.body.classList.remove('is-noscroll');
            document.documentElement.scrollTop = savedScrollTop;
            document.body.style.top = null;
        }
    }
};

const _hoisted_1$n = ["role", "aria-label", "aria-modal"];
const _hoisted_2$l = ["innerHTML"];
const _hoisted_3$d = ["aria-label"];

function render$o(_ctx, _cache, $props, $setup, $data, $options) {
  const _directive_trap_focus = resolveDirective("trap-focus");

  return (openBlock(), createBlock(Transition, {
    name: $props.animation,
    onAfterEnter: $options.afterEnter,
    onBeforeLeave: $options.beforeLeave,
    onAfterLeave: $options.afterLeave
  }, {
    default: withCtx(() => [
      (!$data.destroyed)
        ? withDirectives((openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(["modal is-active", [{'is-full-screen': $props.fullScreen}, $props.customClass]]),
            tabindex: "-1",
            role: $props.ariaRole,
            "aria-label": $props.ariaLabel,
            "aria-modal": $props.ariaModal || undefined
          }, [
            createBaseVNode("div", {
              class: "modal-background",
              onClick: _cache[0] || (_cache[0] = $event => ($options.cancel('outside')))
            }),
            createBaseVNode("div", {
              class: normalizeClass(["animation-content", [{ 'modal-content': !$props.hasModalCard }, $props.customContentClass]]),
              style: normalizeStyle($options.customStyle)
            }, [
              ($props.component)
                ? (openBlock(), createBlock(resolveDynamicComponent($props.component), mergeProps({ key: 0 }, $props.props, toHandlers($props.events), {
                    "can-cancel": $props.canCancel,
                    onClose: $options.close
                  }), null, 16 /* FULL_PROPS */, ["can-cancel", "onClose"]))
                : ($props.content)
                  ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                      createCommentVNode(" eslint-disable-next-line vue/no-v-html "),
                      createBaseVNode("div", { innerHTML: $props.content }, null, 8 /* PROPS */, _hoisted_2$l)
                    ], 64 /* STABLE_FRAGMENT */))
                  : renderSlot(_ctx.$slots, "default", {
                      key: 2,
                      canCancel: $props.canCancel,
                      close: $options.close
                    }),
              ($options.showX)
                ? withDirectives((openBlock(), createElementBlock("button", {
                    key: 3,
                    type: "button",
                    class: "modal-close is-large",
                    "aria-label": $props.closeButtonAriaLabel,
                    onClick: _cache[1] || (_cache[1] = $event => ($options.cancel('x')))
                  }, null, 8 /* PROPS */, _hoisted_3$d)), [
                    [vShow, !$data.animating]
                  ])
                : createCommentVNode("v-if", true)
            ], 6 /* CLASS, STYLE */)
          ], 10 /* CLASS, PROPS */, _hoisted_1$n)), [
            [vShow, $data.isActive],
            [_directive_trap_focus, $props.trapFocus]
          ])
        : createCommentVNode("v-if", true)
    ]),
    _: 3 /* FORWARDED */
  }, 8 /* PROPS */, ["name", "onAfterEnter", "onBeforeLeave", "onAfterLeave"]))
}

script$p.render = render$o;
script$p.__file = "src/components/modal/Modal.vue";

var script$o = {
    name: 'BDialog',
    components: {
        [script$I.name]: script$I,
        [script$E.name]: script$E
    },
    directives: {
        trapFocus
    },
    extends: script$p,
    props: {
        title: String,
        message: [String, Array],
        icon: String,
        iconPack: String,
        hasIcon: Boolean,
        type: {
            type: String,
            default: 'is-primary'
        },
        size: String,
        confirmText: {
            type: String,
            default: () => {
                return config.defaultDialogConfirmText
                    ? config.defaultDialogConfirmText
                    : 'OK'
            }
        },
        cancelText: {
            type: String,
            default: () => {
                return config.defaultDialogCancelText
                    ? config.defaultDialogCancelText
                    : 'Cancel'
            }
        },
        hasInput: Boolean, // Used internally to know if it's prompt
        inputAttrs: {
            type: Object,
            default: () => ({})
        },
        confirmCallback: {
            type: Function,
            default: () => {}
        },
        closeOnConfirm: {
            type: Boolean,
            default: true
        },
        container: {
            type: String,
            default: () => {
                return config.defaultContainerElement
            }
        },
        focusOn: {
            type: String,
            default: 'confirm'
        },
        trapFocus: {
            type: Boolean,
            default: () => {
                return config.defaultTrapFocus
            }
        },
        ariaRole: {
            type: String,
            validator: (value) => {
                return [
                    'dialog',
                    'alertdialog'
                ].indexOf(value) >= 0
            }
        },
        ariaModal: Boolean
    },
    emits: ['confirm'],
    data() {
        const prompt = this.hasInput
            ? this.inputAttrs.value || ''
            : '';

        return {
            prompt,
            isActive: false,
            validationMessage: '',
            isCompositing: false,
            isLoading: false
        }
    },
    computed: {
        // `safeInputAttrs` is a shallow copy of `inputAttrs` except for `value`
        // `value` should not be specified to `v-bind` of the input element
        // because it inhibits `v-model` of the input on Vue 3
        safeInputAttrs() {
            const attrs = { ...this.inputAttrs };
            delete attrs.value;
            if (typeof attrs.required === 'undefined') {
                attrs.required = true;
            }
            return attrs
        },
        dialogClass() {
            return [this.size, {
                'has-custom-container': this.container !== null
            }]
        },
        /**
        * Icon name (MDI) based on the type.
        */
        iconByType() {
            switch (this.type) {
                case 'is-info':
                    return 'information'
                case 'is-success':
                    return 'check-circle'
                case 'is-warning':
                    return 'alert'
                case 'is-danger':
                    return 'alert-circle'
                default:
                    return null
            }
        },
        showCancel() {
            return this.cancelOptions.indexOf('button') >= 0
        }
    },
    methods: {
        /**
        * If it's a prompt Dialog, validate the input.
        * Call the confirmCallback prop (function) and close the Dialog.
        */
        confirm() {
            if (this.$refs.input !== undefined) {
                if (this.isCompositing) return
                if (!this.$refs.input.checkValidity()) {
                    this.validationMessage = this.$refs.input.validationMessage;
                    this.$nextTick(() => this.$refs.input.select());
                    return
                }
            }
            this.$emit('confirm', this.prompt);
            this.confirmCallback(this.prompt, this);
            if (this.closeOnConfirm) this.close();
        },

        /**
        * Close the Dialog.
        */
        close() {
            this.isActive = false;
            this.isLoading = false;
            // Timeout for the animation complete before destroying
            setTimeout(() => {
                removeElement(this.$el);
            }, 150);
        },

        /**
        * Start the Loading.
        */
        startLoading() {
            this.isLoading = true;
        },

        /**
        * Cancel the Loading.
        */
        cancelLoading() {
            this.isLoading = false;
        }
    },
    beforeMount() {
        // Insert the Dialog component in the element container
        if (typeof window !== 'undefined') {
            this.$nextTick(() => {
                const container = document.querySelector(this.container) || document.body;
                container.appendChild(this.$el);
            });
        }
    },
    mounted() {
        this.isActive = true;

        this.$nextTick(() => {
            // Handle which element receives focus
            if (this.hasInput) {
                this.$refs.input.focus();
            } else if (this.focusOn === 'cancel' && this.showCancel) {
                this.$refs.cancelButton.$el.focus();
            } else {
                this.$refs.confirmButton.$el.focus();
            }
        });
    }
};

const _hoisted_1$m = ["role", "aria-modal"];
const _hoisted_2$k = { class: "modal-card animation-content" };
const _hoisted_3$c = {
  key: 0,
  class: "modal-card-head"
};
const _hoisted_4$9 = { class: "modal-card-title" };
const _hoisted_5$7 = { class: "media" };
const _hoisted_6$4 = {
  key: 0,
  class: "media-left"
};
const _hoisted_7$4 = { class: "media-content" };
const _hoisted_8$4 = ["innerHTML"];
const _hoisted_9$3 = {
  key: 0,
  class: "field"
};
const _hoisted_10$2 = { class: "control" };
const _hoisted_11$2 = { class: "help is-danger" };
const _hoisted_12$2 = { class: "modal-card-foot" };

function render$n(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_b_icon = resolveComponent("b-icon");
  const _component_b_button = resolveComponent("b-button");
  const _directive_trap_focus = resolveDirective("trap-focus");

  return (openBlock(), createBlock(Transition, { name: _ctx.animation }, {
    default: withCtx(() => [
      ($data.isActive)
        ? withDirectives((openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(["dialog modal is-active", $options.dialogClass]),
            role: $props.ariaRole,
            "aria-modal": $props.ariaModal
          }, [
            createBaseVNode("div", {
              class: "modal-background",
              onClick: _cache[0] || (_cache[0] = $event => (_ctx.cancel('outside')))
            }),
            createBaseVNode("div", _hoisted_2$k, [
              ($props.title)
                ? (openBlock(), createElementBlock("header", _hoisted_3$c, [
                    createBaseVNode("p", _hoisted_4$9, toDisplayString($props.title), 1 /* TEXT */)
                  ]))
                : createCommentVNode("v-if", true),
              createBaseVNode("section", {
                class: normalizeClass(["modal-card-body", { 'is-titleless': !$props.title, 'is-flex': $props.hasIcon }])
              }, [
                createBaseVNode("div", _hoisted_5$7, [
                  ($props.hasIcon && ($props.icon || $options.iconByType))
                    ? (openBlock(), createElementBlock("div", _hoisted_6$4, [
                        createVNode(_component_b_icon, {
                          icon: $props.icon ? $props.icon : $options.iconByType,
                          pack: $props.iconPack,
                          type: $props.type,
                          both: !$props.icon,
                          size: "is-large"
                        }, null, 8 /* PROPS */, ["icon", "pack", "type", "both"])
                      ]))
                    : createCommentVNode("v-if", true),
                  createBaseVNode("div", _hoisted_7$4, [
                    createBaseVNode("p", null, [
                      (_ctx.$slots.default)
                        ? renderSlot(_ctx.$slots, "default", { key: 0 })
                        : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                            createCommentVNode(" eslint-disable-next-line vue/no-v-html "),
                            createBaseVNode("div", { innerHTML: $props.message }, null, 8 /* PROPS */, _hoisted_8$4)
                          ], 64 /* STABLE_FRAGMENT */))
                    ]),
                    ($props.hasInput)
                      ? (openBlock(), createElementBlock("div", _hoisted_9$3, [
                          createBaseVNode("div", _hoisted_10$2, [
                            withDirectives(createBaseVNode("input", mergeProps({
                              "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => (($data.prompt) = $event)),
                              class: ["input", { 'is-danger': $data.validationMessage }],
                              ref: "input"
                            }, $options.safeInputAttrs, {
                              onCompositionstart: _cache[2] || (_cache[2] = $event => ($data.isCompositing = true)),
                              onCompositionend: _cache[3] || (_cache[3] = $event => ($data.isCompositing = false)),
                              onKeydown: _cache[4] || (_cache[4] = withKeys((...args) => ($options.confirm && $options.confirm(...args)), ["enter"]))
                            }), null, 16 /* FULL_PROPS */), [
                              [vModelDynamic, $data.prompt]
                            ])
                          ]),
                          createBaseVNode("p", _hoisted_11$2, toDisplayString($data.validationMessage), 1 /* TEXT */)
                        ]))
                      : createCommentVNode("v-if", true)
                  ])
                ])
              ], 2 /* CLASS */),
              createBaseVNode("footer", _hoisted_12$2, [
                ($options.showCancel)
                  ? (openBlock(), createBlock(_component_b_button, {
                      key: 0,
                      ref: "cancelButton",
                      disabled: $data.isLoading,
                      onClick: _cache[5] || (_cache[5] = $event => (_ctx.cancel('button')))
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString($props.cancelText), 1 /* TEXT */)
                      ]),
                      _: 1 /* STABLE */
                    }, 8 /* PROPS */, ["disabled"]))
                  : createCommentVNode("v-if", true),
                createVNode(_component_b_button, {
                  type: $props.type,
                  ref: "confirmButton",
                  loading: $data.isLoading,
                  onClick: $options.confirm
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString($props.confirmText), 1 /* TEXT */)
                  ]),
                  _: 1 /* STABLE */
                }, 8 /* PROPS */, ["type", "loading", "onClick"])
              ])
            ])
          ], 10 /* CLASS, PROPS */, _hoisted_1$m)), [
            [_directive_trap_focus, $props.trapFocus]
          ])
        : createCommentVNode("v-if", true)
    ]),
    _: 3 /* FORWARDED */
  }, 8 /* PROPS */, ["name"]))
}

script$o.render = render$n;
script$o.__file = "src/components/dialog/Dialog.vue";

function ownKeys$6(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$6(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$6(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$6(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function open(propsData, app) {
  var slot;
  if (Array.isArray(propsData.message)) {
    slot = propsData.message;
    delete propsData.message;
  }
  function createDialog(_onConfirm, _onCancel) {
    var container = document.createElement('div');
    // Vue 3 requires a new app to mount another component
    var vueInstance = createApp({
      data: function data() {
        return {
          dialogVNode: null
        };
      },
      methods: {
        close: function close() {
          var dialog = getComponentFromVNode(this.dialogVNode);
          if (dialog) {
            dialog.close();
          }
        },
        startLoading: function startLoading() {
          var dialog = getComponentFromVNode(this.dialogVNode);
          if (dialog) {
            dialog.startLoading();
          }
        },
        cancelLoading: function cancelLoading() {
          var dialog = getComponentFromVNode(this.dialogVNode);
          if (dialog) {
            dialog.cancelLoading();
          }
        }
      },
      render: function render() {
        this.dialogVNode = h(script$o, _objectSpread$6(_objectSpread$6({}, propsData), {}, {
          // intentionally overrides propsData.onConfirm
          // to prevent propsData.onConfirm from receiving a "confirm" event
          onConfirm: function onConfirm() {
            if (_onConfirm != null) {
              _onConfirm.apply(void 0, arguments);
            }
          },
          // intentionally override propsData.onCancel
          // to prevent propsData.onCancel from receiving a "cancel" event
          onCancel: function onCancel() {
            if (_onCancel != null) {
              _onCancel.apply(void 0, arguments);
            }
            vueInstance.unmount();
          },
          confirmCallback: function confirmCallback() {
            if (propsData.onConfirm != null) {
              propsData.onConfirm.apply(propsData, arguments);
            }
          },
          cancelCallback: function cancelCallback() {
            if (propsData.onCancel != null) {
              propsData.onCancel.apply(propsData, arguments);
            }
          }
        }), slot ? {
          "default": function _default() {
            return slot;
          }
        } : undefined);
        return this.dialogVNode;
      }
    });
    if (app) {
      copyAppContext(app, vueInstance);
    }
    return vueInstance.mount(container);
  }
  if (!config.defaultProgrammaticPromise) {
    return createDialog();
  } else {
    return new Promise(function (resolve) {
      var dialog = createDialog(function (event) {
        return resolve({
          result: event || true,
          dialog: dialog
        });
      }, function () {
        return resolve({
          result: false,
          dialog: dialog
        });
      });
    });
  }
}
var DialogProgrammatic = /*#__PURE__*/function () {
  function DialogProgrammatic(app) {
    _classCallCheck(this, DialogProgrammatic);
    this.app = app; // may be undefined in the testing environment
  }
  _createClass(DialogProgrammatic, [{
    key: "alert",
    value: function alert(params) {
      if (typeof params === 'string') {
        params = {
          message: params
        };
      }
      var defaultParam = {
        canCancel: false
      };
      var propsData = merge(defaultParam, params);
      return open(propsData, this.app);
    }
  }, {
    key: "confirm",
    value: function confirm(params) {
      var defaultParam = {};
      var propsData = merge(defaultParam, params);
      return open(propsData, this.app);
    }
  }, {
    key: "prompt",
    value: function prompt(params) {
      var defaultParam = {
        hasInput: true
      };
      var propsData = merge(defaultParam, params);
      return open(propsData, this.app);
    }
  }]);
  return DialogProgrammatic;
}();
var Plugin$v = {
  install: function install(Vue) {
    registerComponent(Vue, script$o);
    registerComponentProgrammatic(Vue, 'dialog', new DialogProgrammatic(Vue));
  }
};

var Plugin$u = {
  install: function install(Vue) {
    registerComponent(Vue, script$1$e);
    registerComponent(Vue, script$y);
  }
};

var Plugin$t = {
  install: function install(Vue) {
    registerComponent(Vue, script$x);
  }
};

var Plugin$s = {
  install: function install(Vue) {
    registerComponent(Vue, script$I);
  }
};

var Plugin$r = {
  install: function install(Vue) {
    registerComponent(Vue, script$D);
  }
};

var Plugin$q = {
  install: function install(Vue) {
    registerComponent(Vue, script$H);
  }
};

// Polyfills for SSR

var isSSR = typeof window === 'undefined';
var HTMLElement$1 = isSSR ? Object : window.HTMLElement;
var File$1 = isSSR ? Object : window.File;

var script$n = {
    name: 'BLoading',
    props: {
        modelValue: Boolean,
        programmatic: Boolean,
        container: [Object, Function, HTMLElement$1],
        isFullPage: {
            type: Boolean,
            default: true
        },
        animation: {
            type: String,
            default: 'fade'
        },
        canCancel: {
            type: Boolean,
            default: false
        },
        onCancel: {
            type: Function,
            default: () => {}
        }
    },
    emits: ['close', 'update:is-full-page', 'update:modelValue'],
    data() {
        return {
            isActive: this.modelValue || false,
            displayInFullPage: this.isFullPage
        }
    },
    watch: {
        modelValue(value) {
            this.isActive = value;
        },
        isFullPage(value) {
            this.displayInFullPage = value;
        }
    },
    methods: {
        /**
        * Close the Modal if canCancel.
        */
        cancel() {
            if (!this.canCancel || !this.isActive) return

            this.close();
        },
        /**
        * Emit events, and destroy modal if it's programmatic.
        */
        close() {
            this.onCancel.apply(null, arguments);
            this.$emit('close');
            this.$emit('update:modelValue', false);

            // Timeout for the animation complete before destroying
            if (this.programmatic) {
                this.isActive = false;
                // TODO: should the following happen outside this component;
                // i.e., in index.js?
                setTimeout(() => {
                    removeElement(this.$el);
                }, 150);
            }
        },
        /**
        * Keypress event that is bound to the document.
        */
        keyPress({ key }) {
            if (key === 'Escape' || key === 'Esc') this.cancel();
        }
    },
    created() {
        if (typeof window !== 'undefined') {
            document.addEventListener('keyup', this.keyPress);
        }
    },
    mounted() {
        // Insert the Loading component in body tag
        // only if it's programmatic
        // (moved from beforeMount because $el is not bound during beforeMount)
        // TODO: should this happen outside this component; i.e., in index.js?
        if (this.programmatic) {
            if (!this.container) {
                document.body.appendChild(this.$el);
            } else {
                this.displayInFullPage = false;
                this.$emit('update:is-full-page', false);
                this.container.appendChild(this.$el);
            }
            this.isActive = true;
        }
    },
    beforeUnmount() {
        if (typeof window !== 'undefined') {
            document.removeEventListener('keyup', this.keyPress);
        }
    }
};

const _hoisted_1$l = /*#__PURE__*/createBaseVNode("div", { class: "loading-icon" }, null, -1 /* HOISTED */);

function render$m(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock(Transition, { name: $props.animation }, {
    default: withCtx(() => [
      ($data.isActive)
        ? withDirectives((openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(["loading-overlay is-active", { 'is-full-page': $data.displayInFullPage }])
          }, [
            createBaseVNode("div", {
              class: "loading-background",
              onClick: _cache[0] || (_cache[0] = (...args) => ($options.cancel && $options.cancel(...args)))
            }),
            renderSlot(_ctx.$slots, "default", {}, () => [
              _hoisted_1$l
            ])
          ], 2 /* CLASS */)), [
            [vShow, $data.isActive]
          ])
        : createCommentVNode("v-if", true)
    ]),
    _: 3 /* FORWARDED */
  }, 8 /* PROPS */, ["name"]))
}

script$n.render = render$m;
script$n.__file = "src/components/loading/Loading.vue";

function ownKeys$5(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$5(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$5(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$5(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var LoadingProgrammatic = /*#__PURE__*/function () {
  function LoadingProgrammatic(app) {
    _classCallCheck(this, LoadingProgrammatic);
    this.app = app; // may be undefined in the testing environment
  }
  _createClass(LoadingProgrammatic, [{
    key: "open",
    value: function open(params) {
      var defaultParam = {
        programmatic: true
      };
      var propsData = merge(defaultParam, params);
      var container = document.createElement('div');
      // Vue 3 requires a new app to mount another component
      var vueInstance = createApp({
        data: function data() {
          return {
            loadingVNode: null
          };
        },
        methods: {
          close: function close() {
            // TODO: too much dependence on Vue's internal structure?
            var loading = getComponentFromVNode(this.loadingVNode);
            if (loading) {
              loading.close();
            }
          }
        },
        render: function render() {
          this.loadingVNode = h(script$n, _objectSpread$5(_objectSpread$5({}, propsData), {}, {
            onClose: function onClose() {
              if (propsData.onClose) {
                propsData.onClose.apply(propsData, arguments);
              }
              // timeout for the animation complete before destroying
              setTimeout(function () {
                vueInstance.unmount();
              }, 150);
            }
          }));
          return this.loadingVNode;
        }
      });
      if (this.app) {
        copyAppContext(this.app, vueInstance);
      }
      return vueInstance.mount(container);
    }
  }]);
  return LoadingProgrammatic;
}();
var Plugin$p = {
  install: function install(Vue) {
    registerComponent(Vue, script$n);
    registerComponentProgrammatic(Vue, 'loading', new LoadingProgrammatic(Vue));
  }
};

var MenuItemContainerMixin = {
  provide: function provide() {
    return {
      BMenuItemContainer: this
    };
  },
  data: function data() {
    return {
      menuItems: []
    };
  },
  methods: {
    appendMenuItem: function appendMenuItem(item) {
      this.menuItems.push(item);
    },
    removeMenuItem: function removeMenuItem(item) {
      var index = this.menuItems.indexOf(item);
      if (index !== -1) {
        this.menuItems.splice(index, 1);
      }
    }
  }
};

var script$2$4 = {
    name: 'BMenu',
    mixins: [MenuItemContainerMixin],
    props: {
        accordion: {
            type: Boolean,
            default: true
        },
        activable: {
            type: Boolean,
            default: true
        }
    },
    data() {
        return {
            _isMenu: true // Used by MenuItem
        }
    }
};

const _hoisted_1$2$3 = { class: "menu" };

function render$2$4(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createElementBlock("div", _hoisted_1$2$3, [
    renderSlot(_ctx.$slots, "default")
  ]))
}

script$2$4.render = render$2$4;
script$2$4.__file = "src/components/menu/Menu.vue";

var script$1$9 = {
    name: 'BMenuList',
    components: {
        [script$I.name]: script$I
    },
    props: {
        label: String,
        icon: String,
        iconPack: String,
        ariaRole: {
            type: String,
            default: ''
        },
        size: {
            type: String,
            default: 'is-small'
        }
    }
};

const _hoisted_1$1$4 = {
  key: 0,
  class: "menu-label"
};
const _hoisted_2$1$3 = ["role"];

function render$1$7(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_b_icon = resolveComponent("b-icon");

  return (openBlock(), createElementBlock(Fragment, null, [
    ($props.label || _ctx.$slots.label)
      ? (openBlock(), createElementBlock("p", _hoisted_1$1$4, [
          ($props.label)
            ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                ($props.icon)
                  ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                      createVNode(_component_b_icon, {
                        icon: $props.icon,
                        pack: $props.iconPack,
                        size: $props.size
                      }, null, 8 /* PROPS */, ["icon", "pack", "size"]),
                      createBaseVNode("span", null, toDisplayString($props.label), 1 /* TEXT */)
                    ], 64 /* STABLE_FRAGMENT */))
                  : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                      createTextVNode(toDisplayString($props.label), 1 /* TEXT */)
                    ], 64 /* STABLE_FRAGMENT */))
              ], 64 /* STABLE_FRAGMENT */))
            : renderSlot(_ctx.$slots, "label", { key: 1 })
        ]))
      : createCommentVNode("v-if", true),
    createBaseVNode("ul", {
      class: "menu-list",
      role: $props.ariaRole === 'menu' ? $props.ariaRole : undefined
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 8 /* PROPS */, _hoisted_2$1$3)
  ], 64 /* STABLE_FRAGMENT */))
}

script$1$9.render = render$1$7;
script$1$9.__file = "src/components/menu/MenuList.vue";

var script$m = {
    name: 'BMenuItem',
    components: {
        [script$I.name]: script$I
    },
    mixins: [CompatFallthroughMixin, MenuItemContainerMixin],
    inject: {
        parent: {
            from: 'BMenuItemContainer',
            default: null
        }
    },
    // deprecated, to replace with default 'value' in the next breaking change
    props: {
        label: String,
        modelValue: Boolean,
        expanded: Boolean,
        disabled: Boolean,
        iconPack: String,
        icon: String,
        animation: {
            type: String,
            default: 'slide'
        },
        tag: {
            type: String,
            default: 'a',
            validator: (value) => {
                return config.defaultLinkTags.indexOf(value) >= 0
            }
        },
        ariaRole: {
            type: String,
            default: ''
        },
        size: {
            type: String,
            default: 'is-small'
        }
    },
    emits: ['update:modelValue', 'update:expanded'],
    data() {
        return {
            newActive: this.modelValue,
            newExpanded: this.expanded
        }
    },
    computed: {
        ariaRoleMenu() {
            return this.ariaRole === 'menuitem' ? this.ariaRole : null
        }
    },
    watch: {
        modelValue(value) {
            this.newActive = value;
        },
        expanded(value) {
            this.newExpanded = value;
        }
    },
    methods: {
        onClick(event) {
            if (this.disabled) return
            const menu = this.getMenu();
            this.reset(this.parent, menu);
            this.newExpanded = this.$props.expanded || !this.newExpanded;
            this.$emit('update:expanded', this.newExpanded);
            if (menu && menu.activable) {
                this.newActive = true;
                this.$emit('update:modelValue', this.newActive);
            }
        },
        reset(parent, menu) {
            if (parent == null) {
                return
            }
            parent.menuItems.forEach((item) => {
                if (item !== this) {
                    this.reset(item, menu);
                    if (!parent.$data._isMenu || (parent.$data._isMenu && parent.accordion)) {
                        item.newExpanded = false;
                        item.$emit('update:expanded', item.newActive);
                    }
                    if (menu && menu.activable) {
                        item.newActive = false;
                        item.$emit('update:modelValue', item.newActive);
                    }
                }
            });
        },
        getMenu() {
            let parent = this.$parent;
            while (parent && !parent.$data._isMenu) {
                parent = parent.$parent;
            }
            return parent
        }
    },
    mounted() {
        if (this.parent) {
            this.parent.appendMenuItem(this);
        }
    },
    beforeUnmount() {
        if (this.parent) {
            this.parent.removeMenuItem(this);
        }
    }
};

const _hoisted_1$k = ["role"];
const _hoisted_2$j = { key: 1 };

function render$l(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_b_icon = resolveComponent("b-icon");

  return (openBlock(), createElementBlock("li", mergeProps({ role: $options.ariaRoleMenu }, _ctx.rootAttrs), [
    (openBlock(), createBlock(resolveDynamicComponent($props.tag), mergeProps(_ctx.fallthroughAttrs, {
      class: {
                'is-active': $data.newActive,
                'is-expanded': $data.newExpanded,
                'is-disabled': $props.disabled,
                'icon-text': $props.icon,
            },
      onClick: _cache[0] || (_cache[0] = $event => ($options.onClick($event)))
    }), {
      default: withCtx(() => [
        ($props.icon)
          ? (openBlock(), createBlock(_component_b_icon, {
              key: 0,
              icon: $props.icon,
              pack: $props.iconPack,
              size: $props.size
            }, null, 8 /* PROPS */, ["icon", "pack", "size"]))
          : createCommentVNode("v-if", true),
        ($props.label)
          ? (openBlock(), createElementBlock("span", _hoisted_2$j, toDisplayString($props.label), 1 /* TEXT */))
          : renderSlot(_ctx.$slots, "label", {
              key: 2,
              expanded: $data.newExpanded,
              active: $data.newActive
            })
      ]),
      _: 3 /* FORWARDED */
    }, 16 /* FULL_PROPS */, ["class"])),
    createCommentVNode(" sub menu items "),
    (_ctx.$slots.default)
      ? (openBlock(), createBlock(Transition, {
          key: 0,
          name: $props.animation,
          persisted: ""
        }, {
          default: withCtx(() => [
            withDirectives(createBaseVNode("ul", null, [
              renderSlot(_ctx.$slots, "default")
            ], 512 /* NEED_PATCH */), [
              [vShow, $data.newExpanded]
            ])
          ]),
          _: 3 /* FORWARDED */
        }, 8 /* PROPS */, ["name"]))
      : createCommentVNode("v-if", true)
  ], 16 /* FULL_PROPS */, _hoisted_1$k))
}

script$m.render = render$l;
script$m.__file = "src/components/menu/MenuItem.vue";

var Plugin$o = {
  install: function install(Vue) {
    registerComponent(Vue, script$2$4);
    // explicit `name` is needed to avoid name mangling of
    // Functional Component in production
    registerComponent(Vue, script$1$9, 'BMenuList');
    registerComponent(Vue, script$m);
  }
};

var MessageMixin = {
  components: _defineProperty({}, script$I.name, script$I),
  props: {
    modelValue: {
      type: Boolean,
      "default": true
    },
    title: String,
    closable: {
      type: Boolean,
      "default": true
    },
    message: String,
    type: String,
    hasIcon: Boolean,
    size: String,
    icon: String,
    iconPack: String,
    iconSize: String,
    autoClose: {
      type: Boolean,
      "default": false
    },
    duration: {
      type: Number,
      "default": 2000
    },
    progressBar: {
      type: Boolean,
      "default": false
    }
  },
  emits: ['click', 'close', 'update:modelValue'],
  data: function data() {
    return {
      isActive: this.modelValue,
      remainingTime: this.duration / 1000,
      // in seconds
      newIconSize: this.iconSize || this.size || 'is-large'
    };
  },
  watch: {
    modelValue: function modelValue(value) {
      this.isActive = value;
    },
    isActive: function isActive(value) {
      if (value) {
        this.setAutoClose();
        this.setDurationProgress();
      } else {
        if (this.timer) {
          clearTimeout(this.timer);
        }
      }
    }
  },
  computed: {
    /**
     * Icon name (MDI) based on type.
     */
    computedIcon: function computedIcon() {
      if (this.icon) {
        return this.icon;
      }
      switch (this.type) {
        case 'is-info':
          return 'information';
        case 'is-success':
          return 'check-circle';
        case 'is-warning':
          return 'alert';
        case 'is-danger':
          return 'alert-circle';
        default:
          return null;
      }
    }
  },
  methods: {
    /**
     * Close the Message and emit events.
     */
    close: function close() {
      this.isActive = false;
      this.resetDurationProgress();
      this.$emit('close');
      this.$emit('update:modelValue', false);
    },
    click: function click() {
      this.$emit('click');
    },
    /**
     * Set timer to auto close message
     */
    setAutoClose: function setAutoClose() {
      var _this = this;
      if (this.autoClose) {
        this.timer = setTimeout(function () {
          if (_this.isActive) {
            _this.close();
          }
        }, this.duration);
      }
    },
    setDurationProgress: function setDurationProgress() {
      var _this2 = this;
      if (this.progressBar || this.autoClose) {
        /**
         * Runs every one second to set the duration passed before
         * the alert will auto close to show it in the progress bar (Remaining Time)
         */
        this.$buefy.globalNoticeInterval = setInterval(function () {
          if (_this2.remainingTime !== 0) {
            _this2.remainingTime -= 1;
          } else {
            _this2.resetDurationProgress();
          }
        }, 1000);
      }
    },
    resetDurationProgress: function resetDurationProgress() {
      var _this3 = this;
      /**
       * Wait until the component get closed and then reset
       **/
      setTimeout(function () {
        _this3.remainingTime = _this3.duration / 1000;
        clearInterval(_this3.$buefy.globalNoticeInterval);
      }, 100);
    }
  },
  mounted: function mounted() {
    this.setAutoClose();
  }
};

const PROGRESS_INJECTION_KEY = Symbol('bprogress');

var script$l = {
    name: 'BProgress',
    provide() {
        return {
            [PROGRESS_INJECTION_KEY]: this
        }
    },
    props: {
        type: {
            type: [String, Object],
            default: 'is-darkgrey'
        },
        size: String,
        rounded: {
            type: Boolean,
            default: true
        },
        value: {
            type: Number,
            default: undefined
        },
        max: {
            type: Number,
            default: 100
        },
        showValue: {
            type: Boolean,
            default: false
        },
        format: {
            type: String,
            default: 'raw',
            validator: (value) => {
                return [
                    'raw',
                    'percent'
                ].indexOf(value) >= 0
            }
        },
        precision: {
            type: Number,
            default: 2
        },
        keepTrailingZeroes: {
            type: Boolean,
            default: false
        },
        locale: {
            type: [String, Array],
            default: () => {
                return config.defaultLocale
            }
        }
    },
    computed: {
        isIndeterminate() {
            return this.value === undefined || this.value === null
        },
        newType() {
            return [
                this.size,
                this.type,
                {
                    'is-more-than-half': this.value && this.value > this.max / 2
                }
            ]
        },
        newValue() {
            return this.calculateValue(this.value)
        },
        isNative() {
            return this.$slots.bar === undefined
        },
        wrapperClasses() {
            return {
                'is-not-native': !this.isNative,
                [this.size]: typeof this.size === 'string' && !this.isNative
            }
        }
    },
    watch: {
        /**
         * When value is changed back to undefined, value of native progress get reset to 0.
         * Need to add and remove the value attribute to have the indeterminate or not.
         */
        isIndeterminate(indeterminate) {
            this.$nextTick(() => {
                if (this.$refs.progress) {
                    if (indeterminate) {
                        this.$refs.progress.removeAttribute('value');
                    } else {
                        this.$refs.progress.setAttribute('value', this.value);
                    }
                }
            });
        }
    },
    methods: {
        calculateValue(value) {
            if (value === undefined || value === null || isNaN(value)) {
                return undefined
            }

            const minimumFractionDigits = this.keepTrailingZeroes ? this.precision : 0;
            const maximumFractionDigits = this.precision;
            if (this.format === 'percent') {
                return new Intl.NumberFormat(
                    this.locale,
                    {
                        style: 'percent',
                        minimumFractionDigits,
                        maximumFractionDigits
                    }
                ).format(value / this.max)
            }

            return new Intl.NumberFormat(
                this.locale,
                {
                    minimumFractionDigits,
                    maximumFractionDigits
                }
            ).format(value)
        }
    }
};

const _hoisted_1$j = ["max", "value"];
const _hoisted_2$i = {
  key: 2,
  class: "progress-value"
};

function render$k(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createElementBlock("div", {
    class: normalizeClass(["progress-wrapper", [$options.wrapperClasses, { 'is-squared': !$props.rounded }]])
  }, [
    ($options.isNative)
      ? (openBlock(), createElementBlock("progress", {
          key: 0,
          ref: "progress",
          class: normalizeClass(["progress", [$options.newType, { 'is-squared': !$props.rounded }]]),
          max: $props.max,
          value: $props.value
        }, toDisplayString($options.newValue), 11 /* TEXT, CLASS, PROPS */, _hoisted_1$j))
      : renderSlot(_ctx.$slots, "bar", { key: 1 }),
    ($options.isNative && $props.showValue)
      ? (openBlock(), createElementBlock("p", _hoisted_2$i, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createTextVNode(toDisplayString($options.newValue), 1 /* TEXT */)
          ])
        ]))
      : createCommentVNode("v-if", true)
  ], 2 /* CLASS */))
}

script$l.render = render$k;
script$l.__file = "src/components/progress/Progress.vue";

var script$k = {
    name: 'BMessage',
    components: {
        [script$l.name]: script$l
    },
    mixins: [MessageMixin],
    props: {
        ariaCloseLabel: String
    }
};

const _hoisted_1$i = {
  key: 0,
  class: "message-header"
};
const _hoisted_2$h = { key: 0 };
const _hoisted_3$b = { key: 1 };
const _hoisted_4$8 = ["aria-label"];
const _hoisted_5$6 = {
  key: 1,
  class: "message-body"
};
const _hoisted_6$3 = { class: "media" };
const _hoisted_7$3 = {
  key: 0,
  class: "media-left"
};
const _hoisted_8$3 = { class: "media-content" };

function render$j(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_b_icon = resolveComponent("b-icon");
  const _component_b_progress = resolveComponent("b-progress");

  return (openBlock(), createBlock(Transition, {
    name: "fade",
    persisted: ""
  }, {
    default: withCtx(() => [
      withDirectives(createBaseVNode("article", {
        class: normalizeClass(["message", [_ctx.type, _ctx.size]])
      }, [
        (_ctx.$slots.header || _ctx.title)
          ? (openBlock(), createElementBlock("header", _hoisted_1$i, [
              (_ctx.$slots.header)
                ? (openBlock(), createElementBlock("div", _hoisted_2$h, [
                    renderSlot(_ctx.$slots, "header")
                  ]))
                : (_ctx.title)
                  ? (openBlock(), createElementBlock("p", _hoisted_3$b, toDisplayString(_ctx.title), 1 /* TEXT */))
                  : createCommentVNode("v-if", true),
              (_ctx.closable)
                ? (openBlock(), createElementBlock("button", {
                    key: 2,
                    type: "button",
                    class: "delete",
                    onClick: _cache[0] || (_cache[0] = (...args) => (_ctx.close && _ctx.close(...args))),
                    "aria-label": $props.ariaCloseLabel
                  }, null, 8 /* PROPS */, _hoisted_4$8))
                : createCommentVNode("v-if", true)
            ]))
          : createCommentVNode("v-if", true),
        (_ctx.$slots.default)
          ? (openBlock(), createElementBlock("section", _hoisted_5$6, [
              createBaseVNode("div", _hoisted_6$3, [
                (_ctx.computedIcon && _ctx.hasIcon)
                  ? (openBlock(), createElementBlock("div", _hoisted_7$3, [
                      createVNode(_component_b_icon, {
                        icon: _ctx.computedIcon,
                        pack: _ctx.iconPack,
                        class: normalizeClass(_ctx.type),
                        both: "",
                        size: _ctx.newIconSize
                      }, null, 8 /* PROPS */, ["icon", "pack", "class", "size"])
                    ]))
                  : createCommentVNode("v-if", true),
                createBaseVNode("div", _hoisted_8$3, [
                  renderSlot(_ctx.$slots, "default")
                ])
              ])
            ]))
          : createCommentVNode("v-if", true),
        (_ctx.progressBar)
          ? (openBlock(), createBlock(_component_b_progress, {
              key: 2,
              class: "auto-close-progress",
              value: _ctx.remainingTime - 1,
              max: _ctx.duration / 1000 - 1,
              type: _ctx.type,
              rounded: false
            }, null, 8 /* PROPS */, ["value", "max", "type"]))
          : createCommentVNode("v-if", true)
      ], 2 /* CLASS */), [
        [vShow, _ctx.isActive]
      ])
    ]),
    _: 3 /* FORWARDED */
  }))
}

script$k.render = render$j;
script$k.__file = "src/components/message/Message.vue";

var Plugin$n = {
  install: function install(Vue) {
    registerComponent(Vue, script$k);
  }
};

function ownKeys$4(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$4(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$4(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$4(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var ModalProgrammatic = /*#__PURE__*/function () {
  function ModalProgrammatic(app) {
    _classCallCheck(this, ModalProgrammatic);
    this.app = app; // may be undefined in the testing environment
  }
  _createClass(ModalProgrammatic, [{
    key: "open",
    value: function open(params) {
      if (typeof params === 'string') {
        params = {
          content: params
        };
      }
      var defaultParam = {
        programmatic: true
      };
      if (params.parent) {
        delete params.parent;
      }
      var slot;
      if (Array.isArray(params.content)) {
        slot = params.content;
        delete params.content;
      }
      var propsData = merge(defaultParam, params);
      var container = document.createElement('div');
      // Vue 3 requires a new app to mount another component
      var vueInstance = createApp({
        data: function data() {
          return {
            modalVNode: null
          };
        },
        methods: {
          close: function close() {
            var modal = getComponentFromVNode(this.modalVNode);
            if (modal) {
              modal.close();
            }
          }
        },
        render: function render() {
          this.modalVNode = h(script$p, _objectSpread$4(_objectSpread$4({}, propsData), {}, {
            onClose: function onClose() {
              vueInstance.unmount();
            },
            // intentionally overrides propsData.onCancel
            // to prevent propsData.onCancel from receiving a "cancel" event
            onCancel: function onCancel() {},
            cancelCallback: function cancelCallback() {
              if (propsData.onCancel != null) {
                propsData.onCancel.apply(propsData, arguments);
              }
            }
          }), slot ? {
            "default": function _default() {
              return slot;
            }
          } : undefined);
          return this.modalVNode;
        }
      });
      if (this.app) {
        copyAppContext(this.app, vueInstance);
      }
      return vueInstance.mount(container);
    }
  }]);
  return ModalProgrammatic;
}();
var Plugin$m = {
  install: function install(Vue) {
    registerComponent(Vue, script$p);
    registerComponentProgrammatic(Vue, 'modal', new ModalProgrammatic(Vue));
  }
};

var NoticeMixin = {
  props: {
    type: {
      type: String,
      "default": 'is-dark'
    },
    message: [String, Array],
    duration: Number,
    queue: {
      type: Boolean,
      "default": undefined
    },
    indefinite: {
      type: Boolean,
      "default": false
    },
    pauseOnHover: {
      type: Boolean,
      "default": false
    },
    position: {
      type: String,
      "default": 'is-top',
      validator: function validator(value) {
        return ['is-top-right', 'is-top', 'is-top-left', 'is-bottom-right', 'is-bottom', 'is-bottom-left'].indexOf(value) > -1;
      }
    },
    container: String
  },
  emits: ['click', 'close'],
  data: function data() {
    return {
      isActive: false,
      isPaused: false,
      parentTop: null,
      parentBottom: null,
      newContainer: this.container || config.defaultContainerElement
    };
  },
  computed: {
    correctParent: function correctParent() {
      switch (this.position) {
        case 'is-top-right':
        case 'is-top':
        case 'is-top-left':
          return this.parentTop;
        case 'is-bottom-right':
        case 'is-bottom':
        case 'is-bottom-left':
          return this.parentBottom;
      }
    },
    transition: function transition() {
      switch (this.position) {
        case 'is-top-right':
        case 'is-top':
        case 'is-top-left':
          return {
            enter: 'fadeInDown',
            leave: 'fadeOut'
          };
        case 'is-bottom-right':
        case 'is-bottom':
        case 'is-bottom-left':
          return {
            enter: 'fadeInUp',
            leave: 'fadeOut'
          };
      }
    }
  },
  methods: {
    pause: function pause() {
      if (this.pauseOnHover && !this.indefinite) {
        this.isPaused = true;
        clearInterval(this.$buefy.globalNoticeInterval);
      }
    },
    removePause: function removePause() {
      if (this.pauseOnHover && !this.indefinite) {
        this.isPaused = false;
        this.close();
      }
    },
    shouldQueue: function shouldQueue() {
      var queue = this.queue !== undefined ? this.queue : config.defaultNoticeQueue;
      if (!queue) return false;
      return this.parentTop.childElementCount > 0 || this.parentBottom.childElementCount > 0;
    },
    click: function click() {
      this.$emit('click');
    },
    close: function close() {
      var _this = this;
      if (!this.isPaused) {
        clearTimeout(this.timer);
        this.isActive = false;
        this.$emit('close');

        // Timeout for the animation complete before destroying
        setTimeout(function () {
          removeElement(_this.$el);
        }, 150);
      }
    },
    timeoutCallback: function timeoutCallback() {
      return this.close();
    },
    showNotice: function showNotice() {
      var _this2 = this;
      if (this.shouldQueue()) this.correctParent.innerHTML = '';
      this.correctParent.insertAdjacentElement('afterbegin', this.$el);
      this.isActive = true;
      if (!this.indefinite) {
        this.timer = setTimeout(function () {
          return _this2.timeoutCallback();
        }, this.newDuration);
      }
    },
    setupContainer: function setupContainer() {
      this.parentTop = document.querySelector((this.newContainer ? this.newContainer : 'body') + '>.notices.is-top');
      this.parentBottom = document.querySelector((this.newContainer ? this.newContainer : 'body') + '>.notices.is-bottom');
      if (this.parentTop && this.parentBottom) return;
      if (!this.parentTop) {
        this.parentTop = document.createElement('div');
        this.parentTop.className = 'notices is-top';
      }
      if (!this.parentBottom) {
        this.parentBottom = document.createElement('div');
        this.parentBottom.className = 'notices is-bottom';
      }
      var container = document.querySelector(this.newContainer) || document.body;
      container.appendChild(this.parentTop);
      container.appendChild(this.parentBottom);
      if (this.newContainer) {
        this.parentTop.classList.add('has-custom-container');
        this.parentBottom.classList.add('has-custom-container');
      }
    }
  },
  beforeMount: function beforeMount() {
    this.setupContainer();
  },
  mounted: function mounted() {
    this.showNotice();
  }
};

var script$1$8 = {
    name: 'BNotification',
    components: {
        // directly registers Progress
        // in case Notification is programmatically opened
        [script$l.name]: script$l
    },
    mixins: [MessageMixin],
    props: {
        position: String,
        ariaCloseLabel: String,
        animation: {
            type: String,
            default: 'fade'
        }
    }
};

const _hoisted_1$h = ["aria-label"];
const _hoisted_2$g = {
  key: 1,
  class: "media"
};
const _hoisted_3$a = {
  key: 0,
  class: "media-left"
};
const _hoisted_4$7 = { class: "media-content" };
const _hoisted_5$5 = ["innerHTML"];

function render$1$6(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_b_icon = resolveComponent("b-icon");
  const _component_b_progress = resolveComponent("b-progress");

  return (openBlock(), createBlock(Transition, {
    name: $props.animation,
    persisted: ""
  }, {
    default: withCtx(() => [
      withDirectives(createBaseVNode("article", {
        class: normalizeClass(["notification", [_ctx.type, $props.position]]),
        onClick: _cache[1] || (_cache[1] = (...args) => (_ctx.click && _ctx.click(...args)))
      }, [
        (_ctx.closable)
          ? (openBlock(), createElementBlock("button", {
              key: 0,
              class: "delete",
              type: "button",
              onClick: _cache[0] || (_cache[0] = (...args) => (_ctx.close && _ctx.close(...args))),
              "aria-label": $props.ariaCloseLabel
            }, null, 8 /* PROPS */, _hoisted_1$h))
          : createCommentVNode("v-if", true),
        (_ctx.$slots.default || _ctx.message)
          ? (openBlock(), createElementBlock("div", _hoisted_2$g, [
              (_ctx.computedIcon && _ctx.hasIcon)
                ? (openBlock(), createElementBlock("div", _hoisted_3$a, [
                    createVNode(_component_b_icon, {
                      icon: _ctx.computedIcon,
                      pack: _ctx.iconPack,
                      size: _ctx.newIconSize,
                      both: "",
                      "aria-hidden": ""
                    }, null, 8 /* PROPS */, ["icon", "pack", "size"])
                  ]))
                : createCommentVNode("v-if", true),
              createBaseVNode("div", _hoisted_4$7, [
                (_ctx.$slots.default)
                  ? renderSlot(_ctx.$slots, "default", { key: 0 })
                  : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                      createCommentVNode(" eslint-disable-next-line vue/no-v-html "),
                      createBaseVNode("p", {
                        class: "text",
                        innerHTML: _ctx.message
                      }, null, 8 /* PROPS */, _hoisted_5$5)
                    ], 64 /* STABLE_FRAGMENT */))
              ])
            ]))
          : createCommentVNode("v-if", true),
        (_ctx.progressBar)
          ? (openBlock(), createBlock(_component_b_progress, {
              key: 2,
              class: "auto-close-progress",
              value: _ctx.remainingTime - 1,
              max: _ctx.duration / 1000 - 1,
              type: _ctx.type,
              rounded: false
            }, null, 8 /* PROPS */, ["value", "max", "type"]))
          : createCommentVNode("v-if", true)
      ], 2 /* CLASS */), [
        [vShow, _ctx.isActive]
      ])
    ]),
    _: 3 /* FORWARDED */
  }, 8 /* PROPS */, ["name"]))
}

script$1$8.render = render$1$6;
script$1$8.__file = "src/components/notification/Notification.vue";

function ownKeys$1$1(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$1$1(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$1$1(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1$1(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }

// drops props not used by `NoticeMixin` itself
// - type
// - message
// - duration
var _NoticeMixin$props = NoticeMixin.props,
  queue = _NoticeMixin$props.queue,
  indefinite = _NoticeMixin$props.indefinite,
  pauseOnHover = _NoticeMixin$props.pauseOnHover,
  position = _NoticeMixin$props.position,
  container = _NoticeMixin$props.container;
var NoticeMixinSubset = _objectSpread$1$1(_objectSpread$1$1({}, NoticeMixin), {}, {
  props: {
    queue: queue,
    indefinite: indefinite,
    pauseOnHover: pauseOnHover,
    position: position,
    container: container
  }
});

var script$j = {
    name: 'BNotificationNotice',
    components: {
        [script$1$8.name]: script$1$8
    },
    mixins: [NoticeMixinSubset],
    props: {
        duration: Number
    },
    emits: ['close'],
    data() {
        return {
            newDuration: this.duration || config.defaultNotificationDuration
        }
    },
    methods: {
        close() {
            if (!this.isPaused) {
                clearTimeout(this.timer);
                this.$refs.notification.isActive = false;
                this.$emit('close');

                // Timeout for the animation complete before destroying
                setTimeout(() => {
                    removeElement(this.$el);
                }, 150);
            }
        }
    }
};

function render$i(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_b_notification = resolveComponent("b-notification");

  return (_ctx.$slots.default != null)
    ? (openBlock(), createBlock(_component_b_notification, mergeProps({
        key: 0,
        ref: "notification",
        position: _ctx.position,
        "model-value": _ctx.isActive
      }, _ctx.$attrs, {
        duration: $props.duration,
        onClick: _ctx.click,
        onClose: $options.close,
        onMouseenter: _ctx.pause,
        onMouseleave: _ctx.removePause
      }), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3 /* FORWARDED */
      }, 16 /* FULL_PROPS */, ["position", "model-value", "duration", "onClick", "onClose", "onMouseenter", "onMouseleave"]))
    : (openBlock(), createBlock(_component_b_notification, mergeProps({
        key: 1,
        ref: "notification",
        position: _ctx.position,
        "model-value": _ctx.isActive
      }, _ctx.$attrs, {
        duration: $props.duration,
        onClick: _ctx.click,
        onClose: $options.close,
        onMouseenter: _ctx.pause,
        onMouseleave: _ctx.removePause
      }), null, 16 /* FULL_PROPS */, ["position", "model-value", "duration", "onClick", "onClose", "onMouseenter", "onMouseleave"]))
}

script$j.render = render$i;
script$j.__file = "src/components/notification/NotificationNotice.vue";

function ownKeys$3(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$3(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$3(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$3(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var NotificationProgrammatic = /*#__PURE__*/function () {
  function NotificationProgrammatic(app) {
    _classCallCheck(this, NotificationProgrammatic);
    this.app = app; // may be undefined in the testing environment
  }
  _createClass(NotificationProgrammatic, [{
    key: "open",
    value: function open(params) {
      if (typeof params === 'string') {
        params = {
          message: params
        };
      }
      var defaultParam = {
        position: config.defaultNotificationPosition || 'is-top-right'
      };
      if (params.parent) {
        delete params.parent;
      }
      var _onClose;
      if (typeof params.onClose === 'function') {
        _onClose = params.onClose;
        delete params.onClose;
      }
      var slot;
      if (Array.isArray(params.message)) {
        slot = params.message;
        delete params.message;
      }
      var propsData = merge(defaultParam, params);
      var container = document.createElement('div');
      // Vue 3 requires a new app to mount another component
      var vueInstance = createApp({
        data: function data() {
          return {
            noticeVNode: null
          };
        },
        methods: {
          close: function close() {
            var notice = getComponentFromVNode(this.noticeVNode);
            if (notice) {
              notice.close();
            }
          }
        },
        render: function render() {
          this.noticeVNode = h(script$j, _objectSpread$3(_objectSpread$3({}, propsData), {}, {
            onClose: function onClose() {
              if (_onClose != null) {
                _onClose();
              }
              // waits for a while in favor of animation
              setTimeout(function () {
                vueInstance.unmount();
              }, 150);
            }
          }), slot != null ? {
            "default": function _default() {
              return slot;
            }
          } : undefined);
          return this.noticeVNode;
        }
      });
      if (this.app) {
        copyAppContext(this.app, vueInstance);
      } else {
        // workaround for an error that
        // $buefy.globalNoticeInterval is not defined
        vueInstance.use({
          install: function install(Vue) {
            Vue.config.globalProperties.$buefy = {
              globalNoticeInterval: null
            };
          }
        });
      }
      return vueInstance.mount(container);
    }
  }]);
  return NotificationProgrammatic;
}();
var Plugin$l = {
  install: function install(Vue) {
    registerComponent(Vue, script$1$8);
    registerComponentProgrammatic(Vue, 'notification', new NotificationProgrammatic(Vue));
  }
};

var script$3$2 = {
    name: 'NavbarBurger',
    props: {
        isOpened: {
            type: Boolean,
            default: false
        }
    }
};

const _hoisted_1$g = ["aria-expanded"];
const _hoisted_2$f = /*#__PURE__*/createBaseVNode("span", { "aria-hidden": "true" }, null, -1 /* HOISTED */);
const _hoisted_3$9 = /*#__PURE__*/createBaseVNode("span", { "aria-hidden": "true" }, null, -1 /* HOISTED */);
const _hoisted_4$6 = /*#__PURE__*/createBaseVNode("span", { "aria-hidden": "true" }, null, -1 /* HOISTED */);
const _hoisted_5$4 = [
  _hoisted_2$f,
  _hoisted_3$9,
  _hoisted_4$6
];

function render$2$3(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createElementBlock("a", mergeProps({
    role: "button",
    class: ["navbar-burger burger", { 'is-active': $props.isOpened }],
    "aria-label": "menu",
    "aria-expanded": $props.isOpened || undefined
  }, _ctx.$attrs, { tabindex: "0" }), [..._hoisted_5$4], 16 /* FULL_PROPS */, _hoisted_1$g))
}

script$3$2.render = render$2$3;
script$3$2.__file = "src/components/navbar/NavbarBurger.vue";

var isTouch = typeof window !== 'undefined' && ('ontouchstart' in window || navigator.msMaxTouchPoints > 0);
var events = isTouch ? ['touchstart', 'click'] : ['click'];
var instances = [];
function processArgs(bindingValue) {
  var isFunction = typeof bindingValue === 'function';
  if (!isFunction && _typeof(bindingValue) !== 'object') {
    throw new Error("v-click-outside: Binding value should be a function or an object, ".concat(_typeof(bindingValue), " given"));
  }
  return {
    handler: isFunction ? bindingValue : bindingValue.handler,
    middleware: bindingValue.middleware || function (isClickOutside) {
      return isClickOutside;
    },
    events: bindingValue.events || events
  };
}
function onEvent(_ref) {
  var el = _ref.el,
    event = _ref.event,
    handler = _ref.handler,
    middleware = _ref.middleware;
  var isClickOutside = event.target !== el && !el.contains(event.target);
  if (!isClickOutside || !middleware(event, el)) {
    return;
  }
  handler(event, el);
}
function toggleEventListeners() {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
    eventHandlers = _ref2.eventHandlers;
  var action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'add';
  eventHandlers.forEach(function (_ref3) {
    var event = _ref3.event,
      handler = _ref3.handler;
    document["".concat(action, "EventListener")](event, handler);
  });
}
function beforeMount(el, _ref4) {
  var value = _ref4.value;
  var _processArgs = processArgs(value),
    _handler = _processArgs.handler,
    middleware = _processArgs.middleware,
    events = _processArgs.events;
  var instance = {
    el: el,
    eventHandlers: events.map(function (eventName) {
      return {
        event: eventName,
        handler: function handler(event) {
          return onEvent({
            event: event,
            el: el,
            handler: _handler,
            middleware: middleware
          });
        }
      };
    })
  };
  toggleEventListeners(instance, 'add');
  instances.push(instance);
}
function updated(el, _ref5) {
  var value = _ref5.value;
  var _processArgs2 = processArgs(value),
    _handler2 = _processArgs2.handler,
    middleware = _processArgs2.middleware,
    events = _processArgs2.events;
  // `filter` instead of `find` for compat with IE
  var instance = instances.filter(function (instance) {
    return instance.el === el;
  })[0];
  toggleEventListeners(instance, 'remove');
  instance.eventHandlers = events.map(function (eventName) {
    return {
      event: eventName,
      handler: function handler(event) {
        return onEvent({
          event: event,
          el: el,
          handler: _handler2,
          middleware: middleware
        });
      }
    };
  });
  toggleEventListeners(instance, 'add');
}
function unmounted(el) {
  // `filter` instead of `find` for compat with IE
  var instance = instances.filter(function (instance) {
    return instance.el === el;
  })[0];
  toggleEventListeners(instance, 'remove');
}
var directive = {
  beforeMount: beforeMount,
  updated: updated,
  unmounted: unmounted,
  instances: instances
};
var clickOutside = directive;

const FIXED_TOP_CLASS = 'is-fixed-top';
const BODY_FIXED_TOP_CLASS = 'has-navbar-fixed-top';
const BODY_SPACED_FIXED_TOP_CLASS = 'has-spaced-navbar-fixed-top';
const FIXED_BOTTOM_CLASS = 'is-fixed-bottom';
const BODY_FIXED_BOTTOM_CLASS = 'has-navbar-fixed-bottom';
const BODY_SPACED_FIXED_BOTTOM_CLASS = 'has-spaced-navbar-fixed-bottom';
const BODY_CENTERED_CLASS = 'has-navbar-centered';

const isFilled = (str) => !!str;

var script$2$3 = {
    name: 'BNavbar',
    components: {
        NavbarBurger: script$3$2
    },
    directives: {
        clickOutside
    },
    props: {
        type: [String, Object],
        transparent: {
            type: Boolean,
            default: false
        },
        fixedTop: {
            type: Boolean,
            default: false
        },
        fixedBottom: {
            type: Boolean,
            default: false
        },
        modelValue: {
            type: Boolean,
            default: false
        },
        centered: {
            type: Boolean,
            default: false
        },
        wrapperClass: {
            type: [String, Array, Object]
        },
        closeOnClick: {
            type: Boolean,
            default: true
        },
        mobileBurger: {
            type: Boolean,
            default: true
        },
        spaced: Boolean,
        shadow: Boolean
    },
    emits: ['update:modelValue'],
    data() {
        return {
            internalIsActive: this.modelValue,
            _isNavBar: true // Used internally by NavbarItem
        }
    },
    computed: {
        isOpened() {
            return this.internalIsActive
        },
        computedClasses() {
            return [
                this.type,
                {
                    [FIXED_TOP_CLASS]: this.fixedTop,
                    [FIXED_BOTTOM_CLASS]: this.fixedBottom,
                    [BODY_CENTERED_CLASS]: this.centered,
                    'is-spaced': this.spaced,
                    'has-shadow': this.shadow,
                    'is-transparent': this.transparent
                }
            ]
        }
    },
    watch: {
        modelValue: {
            handler(active) {
                this.internalIsActive = active;
            },
            immediate: true
        },
        fixedTop(isSet) {
            // toggle body class only on update to handle multiple navbar
            this.setBodyFixedTopClass(isSet);
        },
        bottomTop(isSet) {
            // toggle body class only on update to handle multiple navbar
            this.setBodyFixedBottomClass(isSet);
        }
    },
    methods: {
        toggleActive() {
            this.internalIsActive = !this.internalIsActive;
            this.emitUpdateParentEvent();
        },
        closeMenu() {
            if (this.closeOnClick && this.internalIsActive) {
                this.internalIsActive = false;
                this.emitUpdateParentEvent();
            }
        },
        emitUpdateParentEvent() {
            this.$emit('update:modelValue', this.internalIsActive);
        },
        setBodyClass(className) {
            if (typeof window !== 'undefined') {
                document.body.classList.add(className);
            }
        },
        removeBodyClass(className) {
            if (typeof window !== 'undefined') {
                document.body.classList.remove(className);
            }
        },
        checkIfFixedPropertiesAreColliding() {
            const areColliding = this.fixedTop && this.fixedBottom;
            if (areColliding) {
                throw new Error('You should choose if the BNavbar is fixed bottom or fixed top, but not both')
            }
        },
        genNavbar() {
            const navBarSlots = [
                this.genNavbarBrandNode(),
                this.genNavbarSlotsNode()
            ];

            if (!isFilled(this.wrapperClass)) {
                return this.genNavbarSlots(navBarSlots)
            }

            // It wraps the slots into a div with the provided wrapperClass prop
            const navWrapper = h(
                'div',
                { class: this.wrapperClass },
                navBarSlots
            );

            return this.genNavbarSlots([navWrapper])
        },
        genNavbarSlots(slots) {
            const vnode = h(
                'nav',
                {
                    class: ['navbar', this.computedClasses],
                    role: 'navigation',
                    'aria-label': 'main navigation'
                },
                slots
            );
            return withDirectives(vnode, [
                [resolveDirective('click-outside'), this.closeMenu]
            ])
        },
        genNavbarBrandNode() {
            const children = this.$slots.brand != null
                ? [this.$slots.brand(), this.genBurgerNode()]
                : this.genBurgerNode();
            return h(
                'div',
                { class: 'navbar-brand' },
                children
            )
        },
        genBurgerNode() {
            if (this.mobileBurger) {
                const defaultBurgerNode = h(
                    resolveComponent('navbar-burger'),
                    {
                        isOpened: this.isOpened,
                        onClick: this.toggleActive,
                        onKeyup: (event) => {
                            if (event.keyCode !== 13) return
                            this.toggleActive();
                        }
                    }
                );

                const hasBurgerSlot = !!this.$slots.burger;
                return hasBurgerSlot
                    ? this.$slots.burger({
                        isOpened: this.isOpened,
                        toggleActive: this.toggleActive
                    })
                    : defaultBurgerNode
            }
        },
        genNavbarSlotsNode() {
            return h(
                'div',
                { class: ['navbar-menu', { 'is-active': this.isOpened }] },
                [
                    this.genMenuPosition('start'),
                    this.genMenuPosition('end')
                ]
            )
        },
        genMenuPosition(positionName) {
            return h(
                'div',
                { class: `navbar-${positionName}` },
                this.$slots[positionName] != null
                    ? this.$slots[positionName]()
                    : []
            )
        },
        setBodyFixedTopClass(isSet) {
            this.checkIfFixedPropertiesAreColliding();
            if (isSet) {
                // TODO Apply only one of the classes once PR is merged in Bulma:
                // https://github.com/jgthms/bulma/pull/2737
                this.setBodyClass(BODY_FIXED_TOP_CLASS);
                this.spaced && this.setBodyClass(BODY_SPACED_FIXED_TOP_CLASS);
            } else {
                this.removeBodyClass(BODY_FIXED_TOP_CLASS);
                this.removeBodyClass(BODY_SPACED_FIXED_TOP_CLASS);
            }
        },
        setBodyFixedBottomClass(isSet) {
            this.checkIfFixedPropertiesAreColliding();
            if (isSet) {
                // TODO Apply only one of the classes once PR is merged in Bulma:
                // https://github.com/jgthms/bulma/pull/2737
                this.setBodyClass(BODY_FIXED_BOTTOM_CLASS);
                this.spaced && this.setBodyClass(BODY_SPACED_FIXED_BOTTOM_CLASS);
            } else {
                this.removeBodyClass(BODY_FIXED_BOTTOM_CLASS);
                this.removeBodyClass(BODY_SPACED_FIXED_BOTTOM_CLASS);
            }
        }
    },
    beforeMount() {
        this.fixedTop && this.setBodyFixedTopClass(true);
        this.fixedBottom && this.setBodyFixedBottomClass(true);
    },
    beforeUnmount() {
        if (this.fixedTop) {
            const className = this.spaced
                ? BODY_SPACED_FIXED_TOP_CLASS
                : BODY_FIXED_TOP_CLASS;
            this.removeBodyClass(className);
        } else if (this.fixedBottom) {
            const className = this.spaced
                ? BODY_SPACED_FIXED_BOTTOM_CLASS
                : BODY_FIXED_BOTTOM_CLASS;
            this.removeBodyClass(className);
        }
    },
    render() {
        return this.genNavbar()
    }
};

script$2$3.__file = "src/components/navbar/Navbar.vue";

const clickableWhiteList = ['div', 'span', 'input'];

var script$1$7 = {
    name: 'BNavbarItem',
    inheritAttrs: false,
    props: {
        tag: {
            type: String,
            default: 'a'
        },
        active: Boolean
    },
    methods: {
        /**
         * Keypress event that is bound to the document
         */
        keyPress({ key }) {
            if (key === 'Escape' || key === 'Esc') {
                this.closeMenuRecursive(this, ['NavBar']);
            }
        },
        /**
         * Close parent if clicked outside.
         */
        handleClickEvent(event) {
            const isOnWhiteList = clickableWhiteList.some((item) => item === event.target.localName);
            if (!isOnWhiteList) {
                const parent = this.closeMenuRecursive(this, ['NavbarDropdown', 'NavBar']);
                if (parent && parent.$data._isNavbarDropdown) this.closeMenuRecursive(parent, ['NavBar']);
            }
        },
        /**
         * Close parent recursively
         */
        closeMenuRecursive(current, targetComponents) {
            if (!current.$parent) return null
            const foundItem = targetComponents.reduce((acc, item) => {
                if (current.$parent.$data[`_is${item}`]) {
                    current.$parent.closeMenu();
                    return current.$parent
                }
                return acc
            }, null);
            return foundItem || this.closeMenuRecursive(current.$parent, targetComponents)
        }
    },
    mounted() {
        if (typeof window !== 'undefined') {
            this.$el.addEventListener('click', this.handleClickEvent);
            document.addEventListener('keyup', this.keyPress);
        }
    },
    beforeUnmount() {
        if (typeof window !== 'undefined') {
            this.$el.removeEventListener('click', this.handleClickEvent);
            document.removeEventListener('keyup', this.keyPress);
        }
    }
};

function render$1$5(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock(resolveDynamicComponent($props.tag), mergeProps({
    class: ["navbar-item", {
            'is-active': $props.active
        }]
  }, _ctx.$attrs), {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3 /* FORWARDED */
  }, 16 /* FULL_PROPS */, ["class"]))
}

script$1$7.render = render$1$5;
script$1$7.__file = "src/components/navbar/NavbarItem.vue";

var script$i = {
    name: 'BNavbarDropdown',
    directives: {
        clickOutside
    },
    mixins: [CompatFallthroughMixin],
    props: {
        label: String,
        hoverable: Boolean,
        active: Boolean,
        right: Boolean,
        arrowless: Boolean,
        boxed: Boolean,
        closeOnClick: {
            type: Boolean,
            default: true
        },
        collapsible: Boolean,
        tag: {
            type: String,
            default: 'a'
        }
    },
    emits: ['active-change'],
    data() {
        return {
            newActive: this.active,
            isHoverable: this.hoverable,
            _isNavbarDropdown: true // Used internally by NavbarItem
        }
    },
    watch: {
        active(value) {
            this.newActive = value;
        },

        newActive(value) {
            this.$emit('active-change', value);
        }
    },
    methods: {
        toggleMenu() {
            this.newActive = !this.newActive;
        },
        showMenu() {
            this.newActive = true;
        },
        /**
        * See naming convetion of navbaritem
        */
        closeMenu() {
            this.newActive = !this.closeOnClick;
            if (this.hoverable && this.closeOnClick) {
                this.isHoverable = false;
            }
        },
        checkHoverable() {
            if (this.hoverable) {
                this.isHoverable = true;
            }
        }
    }
};

function render$h(_ctx, _cache, $props, $setup, $data, $options) {
  const _directive_click_outside = resolveDirective("click-outside");

  return withDirectives((openBlock(), createElementBlock("div", mergeProps({
    class: ["navbar-item has-dropdown", {
            'is-hoverable': $data.isHoverable,
            'is-active': $data.newActive
        }],
    onMouseenter: _cache[0] || (_cache[0] = (...args) => ($options.checkHoverable && $options.checkHoverable(...args)))
  }, _ctx.rootAttrs), [
    (openBlock(), createBlock(resolveDynamicComponent($props.tag), mergeProps({
      class: ["navbar-link", {
                'is-arrowless': $props.arrowless,
                'is-active': $data.newActive && $props.collapsible
            }]
    }, _ctx.fallthroughAttrs, {
      "aria-haspopup": "true",
      onClick: withModifiers($options.toggleMenu, ["prevent"]),
      onKeyup: withKeys($options.toggleMenu, ["enter"]),
      tabindex: "0"
    }), {
      default: withCtx(() => [
        ($props.label)
          ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createTextVNode(toDisplayString($props.label), 1 /* TEXT */)
            ], 64 /* STABLE_FRAGMENT */))
          : renderSlot(_ctx.$slots, "label", { key: 1 })
      ]),
      _: 3 /* FORWARDED */
    }, 16 /* FULL_PROPS */, ["class", "onClick", "onKeyup"])),
    createBaseVNode("div", {
      class: normalizeClass(["navbar-dropdown", {
                'is-right': $props.right,
                'is-boxed': $props.boxed,
                'is-hidden-touch': $props.collapsible && !$data.newActive
            }])
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 2 /* CLASS */)
  ], 16 /* FULL_PROPS */)), [
    [_directive_click_outside, $options.closeMenu]
  ])
}

script$i.render = render$h;
script$i.__file = "src/components/navbar/NavbarDropdown.vue";

var Plugin$k = {
  install: function install(Vue) {
    registerComponent(Vue, script$2$3);
    registerComponent(Vue, script$1$7);
    registerComponent(Vue, script$i);
  }
};

var script$h = {
    name: 'BNumberinput',
    components: {
        [script$I.name]: script$I,
        [script$H.name]: script$H
    },
    mixins: [CompatFallthroughMixin, FormElementMixin],
    inject: {
        field: {
            from: 'BField',
            default: false
        }
    },
    props: {
        modelValue: Number,
        min: {
            type: [Number, String]
        },
        max: [Number, String],
        step: [Number, String],
        minStep: [Number, String],
        exponential: [Boolean, Number],
        disabled: Boolean,
        type: {
            type: String,
            default: 'is-primary'
        },
        editable: {
            type: Boolean,
            default: true
        },
        controls: {
            type: Boolean,
            default: true
        },
        controlsAlignment: {
            type: String,
            default: 'center',
            validator: (value) => {
                return [
                    'left',
                    'right',
                    'center'
                ].indexOf(value) >= 0
            }
        },
        controlsRounded: {
            type: Boolean,
            default: false
        },
        controlsPosition: String,
        placeholder: [Number, String],
        ariaMinusLabel: String,
        ariaPlusLabel: String,
        longPress: {
            type: Boolean,
            default: true
        }
    },
    emits: ['blur', 'focus', 'update:modelValue'],
    data() {
        return {
            newValue: this.modelValue,
            newStep: this.step || 1,
            newMinStep: this.minStep,
            timesPressed: 1,
            _elementRef: 'input'
        }
    },
    computed: {
        computedValue: {
            get() {
                return this.newValue
            },
            set(value) {
                // Parses the number, so that "0" => 0, and "invalid" => null
                let newValue = (Number(value) === 0) ? 0 : (Number(value) || null);
                if (value === '' || value === undefined || value === null) {
                    newValue = null;
                }
                this.newValue = newValue;
                if (newValue === null) {
                    this.$emit('update:modelValue', newValue);
                } else if (!isNaN(newValue) && newValue !== '-0') {
                    this.$emit('update:modelValue', Number(newValue));
                }
                this.$nextTick(() => {
                    if (this.$refs.input) {
                        this.$refs.input.checkHtml5Validity();
                    }
                });
            }
        },
        controlsLeft() {
            if (this.controls && this.controlsAlignment !== 'right') {
                return this.controlsAlignment === 'left' ? ['minus', 'plus'] : ['minus']
            }
            return []
        },
        controlsRight() {
            if (this.controls && this.controlsAlignment !== 'left') {
                return this.controlsAlignment === 'right' ? ['minus', 'plus'] : ['plus']
            }
            return []
        },
        fieldClasses() {
            return [
                { 'has-addons': this.controlsPosition === 'compact' },
                { 'is-grouped': this.controlsPosition !== 'compact' },
                { 'is-expanded': this.expanded }
            ]
        },
        buttonClasses() {
            return [this.type, this.size, { 'is-rounded': this.controlsRounded }]
        },
        minNumber() {
            return typeof this.min === 'string' ? parseFloat(this.min) : this.min
        },
        maxNumber() {
            return typeof this.max === 'string' ? parseFloat(this.max) : this.max
        },
        stepNumber() {
            if (this.newStep === 'any') {
                return 1
            }
            return typeof this.newStep === 'string' ? parseFloat(this.newStep) : this.newStep
        },
        minStepNumber() {
            if (this.newStep === 'any' && typeof this.newMinStep === 'undefined') {
                return 'any'
            }
            const step = typeof this.newMinStep !== 'undefined' ? this.newMinStep : this.newStep;
            return typeof step === 'string' ? parseFloat(step) : step
        },
        disabledMin() {
            return this.computedValue - this.stepNumber < this.minNumber
        },
        disabledMax() {
            return this.computedValue + this.stepNumber > this.maxNumber
        },
        stepDecimals() {
            const step = this.minStepNumber.toString();
            const index = step.indexOf('.');
            if (index >= 0) {
                return step.substring(index + 1).length
            }
            return 0
        },

        disabledOrUndefined() {
            // On Vue 3, setting a boolean attribute `false` does not remove it,
            // `null` or `undefined` has to be given to remove it.
            return this.disabled || undefined
        }
    },
    watch: {
    /**
     * When v-model is changed:
     *   1. Set internal value.
     */
        modelValue: {
            immediate: true,
            handler(value) {
                this.newValue = value;
            }
        },
        step(value) {
            this.newStep = value;
        },
        minStep(value) {
            this.newMinStep = value;
        }
    },
    methods: {
        isDisabled(control) {
            return this.disabled || (control === 'plus' ? this.disabledMax : this.disabledMin)
        },
        decrement() {
            if (this.computedValue === null || typeof this.computedValue === 'undefined') {
                if (this.maxNumber !== null && typeof this.maxNumber !== 'undefined') {
                    this.computedValue = this.maxNumber;
                    return
                }
                this.computedValue = 0;
            }
            if (typeof this.minNumber === 'undefined' || (this.computedValue - this.stepNumber) >= this.minNumber) {
                const value = this.computedValue - this.stepNumber;
                this.computedValue = parseFloat(value.toFixed(this.stepDecimals));
            }
        },
        increment() {
            if (this.computedValue === null || typeof this.computedValue === 'undefined' || this.computedValue < this.minNumber) {
                if (this.minNumber !== null && typeof this.minNumber !== 'undefined') {
                    this.computedValue = this.minNumber;
                    return
                }
                this.computedValue = 0;
            }
            if (typeof this.maxNumber === 'undefined' || (this.computedValue + this.stepNumber) <= this.maxNumber) {
                const value = this.computedValue + this.stepNumber;
                this.computedValue = parseFloat(value.toFixed(this.stepDecimals));
            }
        },
        onControlClick(event, inc) {
            // IE 11 -> filter click event
            if (event.detail !== 0 || event.type !== 'click') return
            if (inc) this.increment();
            else this.decrement();
        },
        longPressTick(inc) {
            if (inc) this.increment();
            else this.decrement();

            if (!this.longPress) return
            this._$intervalRef = setTimeout(() => {
                this.longPressTick(inc);
            }, this.exponential ? (250 / (this.exponential * this.timesPressed++)) : 250);
        },
        onStartLongPress(event, inc) {
            if (event.button !== 0 && event.type !== 'touchstart') return
            clearTimeout(this._$intervalRef);
            this.longPressTick(inc);
        },
        onStopLongPress() {
            if (!this._$intervalRef) return
            this.timesPressed = 1;
            clearTimeout(this._$intervalRef);
            this._$intervalRef = null;
        }
    },
    mounted() {
        // tells the field that it is wrapping a number input
        // if the field is the direct parent.
        if (this.field === this.$parent) {
            this.$parent.wrapNumberinput({
                controlsPosition: this.controlsPosition,
                size: this.size
            });
        }
    },

    beforeUnmount() {
        clearTimeout(this._$intervalRef);
    }
};

const _hoisted_1$f = ["disabled", "aria-label", "onMousedown", "onTouchstart", "onClick"];
const _hoisted_2$e = ["disabled", "aria-label", "onMousedown", "onTouchstart", "onClick"];

function render$g(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_b_icon = resolveComponent("b-icon");
  const _component_b_input = resolveComponent("b-input");

  return (openBlock(), createElementBlock("div", mergeProps({
    class: ["b-numberinput field", $options.fieldClasses]
  }, _ctx.rootAttrs), [
    (openBlock(true), createElementBlock(Fragment, null, renderList($options.controlsLeft, (control) => {
      return (openBlock(), createElementBlock("p", {
        key: control,
        class: normalizeClass(['control', control]),
        onMouseup: _cache[0] || (_cache[0] = (...args) => ($options.onStopLongPress && $options.onStopLongPress(...args))),
        onMouseleave: _cache[1] || (_cache[1] = (...args) => ($options.onStopLongPress && $options.onStopLongPress(...args))),
        onTouchend: _cache[2] || (_cache[2] = (...args) => ($options.onStopLongPress && $options.onStopLongPress(...args))),
        onTouchcancel: _cache[3] || (_cache[3] = (...args) => ($options.onStopLongPress && $options.onStopLongPress(...args)))
      }, [
        createBaseVNode("button", {
          type: "button",
          class: normalizeClass(["button", $options.buttonClasses]),
          disabled: $options.isDisabled(control) || undefined,
          "aria-label": control === 'plus' ? $props.ariaPlusLabel : $props.ariaMinusLabel,
          onMousedown: $event => (
                    !$options.isDisabled(control) && $options.onStartLongPress($event, control === 'plus')
                ),
          onTouchstart: withModifiers($event => (
                    !$options.isDisabled(control) && $options.onStartLongPress($event, control === 'plus')
                ), ["prevent"]),
          onClick: $event => (
                    !$options.isDisabled(control) && $options.onControlClick($event, control === 'plus')
                )
        }, [
          createVNode(_component_b_icon, {
            both: "",
            icon: control,
            pack: _ctx.iconPack,
            size: _ctx.iconSize
          }, null, 8 /* PROPS */, ["icon", "pack", "size"])
        ], 42 /* CLASS, PROPS, HYDRATE_EVENTS */, _hoisted_1$f)
      ], 34 /* CLASS, HYDRATE_EVENTS */))
    }), 128 /* KEYED_FRAGMENT */)),
    createVNode(_component_b_input, mergeProps({
      type: "number",
      ref: "input",
      modelValue: $options.computedValue,
      "onUpdate:modelValue": _cache[4] || (_cache[4] = $event => (($options.computedValue) = $event))
    }, _ctx.fallthroughAttrs, {
      step: $options.minStepNumber,
      max: $props.max,
      min: $props.min,
      size: _ctx.size,
      disabled: $options.disabledOrUndefined,
      readonly: !$props.editable,
      loading: _ctx.loading,
      rounded: _ctx.rounded,
      icon: _ctx.icon,
      "icon-pack": _ctx.iconPack,
      autocomplete: _ctx.autocomplete,
      expanded: _ctx.expanded,
      placeholder: $props.placeholder,
      "use-html5-validation": _ctx.useHtml5Validation,
      onFocus: _cache[5] || (_cache[5] = $event => (_ctx.$emit('focus', $event))),
      onBlur: _cache[6] || (_cache[6] = $event => (_ctx.$emit('blur', $event)))
    }), null, 16 /* FULL_PROPS */, ["modelValue", "step", "max", "min", "size", "disabled", "readonly", "loading", "rounded", "icon", "icon-pack", "autocomplete", "expanded", "placeholder", "use-html5-validation"]),
    (openBlock(true), createElementBlock(Fragment, null, renderList($options.controlsRight, (control) => {
      return (openBlock(), createElementBlock("p", {
        key: control,
        class: normalizeClass(['control', control]),
        onMouseup: _cache[7] || (_cache[7] = (...args) => ($options.onStopLongPress && $options.onStopLongPress(...args))),
        onMouseleave: _cache[8] || (_cache[8] = (...args) => ($options.onStopLongPress && $options.onStopLongPress(...args))),
        onTouchend: _cache[9] || (_cache[9] = (...args) => ($options.onStopLongPress && $options.onStopLongPress(...args))),
        onTouchcancel: _cache[10] || (_cache[10] = (...args) => ($options.onStopLongPress && $options.onStopLongPress(...args)))
      }, [
        createBaseVNode("button", {
          type: "button",
          class: normalizeClass(["button", $options.buttonClasses]),
          disabled: $options.isDisabled(control) || undefined,
          "aria-label": control === 'plus' ? $props.ariaPlusLabel : $props.ariaMinusLabel,
          onMousedown: $event => (
                    !$options.isDisabled(control) && $options.onStartLongPress($event, control === 'plus')
                ),
          onTouchstart: withModifiers($event => (
                    !$options.isDisabled(control) && $options.onStartLongPress($event, control === 'plus')
                ), ["prevent"]),
          onClick: $event => (
                    !$options.isDisabled(control) && $options.onControlClick($event, control === 'plus')
                )
        }, [
          createVNode(_component_b_icon, {
            both: "",
            icon: control,
            pack: _ctx.iconPack,
            size: _ctx.iconSize
          }, null, 8 /* PROPS */, ["icon", "pack", "size"])
        ], 42 /* CLASS, PROPS, HYDRATE_EVENTS */, _hoisted_2$e)
      ], 34 /* CLASS, HYDRATE_EVENTS */))
    }), 128 /* KEYED_FRAGMENT */))
  ], 16 /* FULL_PROPS */))
}

script$h.render = render$g;
script$h.__file = "src/components/numberinput/Numberinput.vue";

var Plugin$j = {
  install: function install(Vue) {
    registerComponent(Vue, script$h);
  }
};

var script$1$6 = {
    name: 'BPaginationButton',
    props: {
        page: {
            type: Object,
            required: true
        },
        tag: {
            type: String,
            default: 'a',
            validator: (value) => {
                return config.defaultLinkTags.indexOf(value) >= 0
            }
        },
        disabled: {
            type: Boolean,
            default: false
        }
    },
    computed: {
        href() {
            if (this.tag === 'a') {
                return '#'
            } else {
                return undefined
            }
        },
        isDisabled() {
            return this.disabled || this.page.disabled
        },
        disabledOrUndefined() {
            return this.isDisabled || undefined
        }
    }
};

function render$1$4(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock(resolveDynamicComponent($props.tag), mergeProps({
    role: "button",
    href: $options.href,
    disabled: $options.disabledOrUndefined,
    class: ["pagination-link", { 'is-current': $props.page.isCurrent, [$props.page.class]: true }]
  }, _ctx.$attrs, {
    onClick: withModifiers($props.page.click, ["prevent"]),
    "aria-label": $props.page['aria-label'],
    "aria-current": $props.page.isCurrent || undefined
  }), {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default", {}, () => [
        createTextVNode(toDisplayString($props.page.number), 1 /* TEXT */)
      ])
    ]),
    _: 3 /* FORWARDED */
  }, 16 /* FULL_PROPS */, ["href", "disabled", "class", "onClick", "aria-label", "aria-current"]))
}

script$1$6.render = render$1$4;
script$1$6.__file = "src/components/pagination/PaginationButton.vue";

function debounce (func, wait, immediate) {
  var timeout;
  return function () {
    var context = this;
    var args = arguments;
    var later = function later() {
      timeout = null;
      func.apply(context, args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

var script$g = {
    name: 'BPagination',
    components: {
        [script$I.name]: script$I,
        [script$1$6.name]: script$1$6
    },
    props: {
        total: [Number, String],
        perPage: {
            type: [Number, String],
            default: 20
        },
        modelValue: {
            type: [Number, String],
            default: 1
        },
        rangeBefore: {
            type: [Number, String],
            default: 1
        },
        rangeAfter: {
            type: [Number, String],
            default: 1
        },
        size: String,
        simple: Boolean,
        rounded: Boolean,
        order: String,
        iconPack: String,
        iconPrev: {
            type: String,
            default: () => {
                return config.defaultIconPrev
            }
        },
        iconNext: {
            type: String,
            default: () => {
                return config.defaultIconNext
            }
        },
        ariaNextLabel: String,
        ariaPreviousLabel: String,
        ariaPageLabel: String,
        ariaCurrentLabel: String,
        pageInput: {
            type: Boolean,
            default: false
        },
        pageInputPosition: String,
        debouncePageInput: [Number, String]
    },
    data() {
        return {
            inputValue: this.modelValue
        }
    },
    emits: ['change', 'update:modelValue'],
    computed: {
        rootClasses() {
            return [
                this.order,
                this.size,
                this.pageInputPosition,
                {
                    'is-simple': this.simple,
                    'is-rounded': this.rounded,
                    'has-input': this.pageInput
                }
            ]
        },

        beforeCurrent() {
            return parseInt(this.rangeBefore)
        },

        afterCurrent() {
            return parseInt(this.rangeAfter)
        },

        /**
        * Total page size (count).
        */
        pageCount() {
            return Math.ceil(this.total / this.perPage)
        },

        /**
        * First item of the page (count).
        */
        firstItem() {
            const firstItem = this.modelValue * this.perPage - this.perPage + 1;
            return firstItem >= 0 ? firstItem : 0
        },

        /**
        * Check if previous button is available.
        */
        hasPrev() {
            return this.modelValue > 1
        },

        /**
         * Check if first page button should be visible.
        */
        hasFirst() {
            return this.modelValue >= 2 + this.beforeCurrent
        },

        /**
        * Check if first ellipsis should be visible.
        */
        hasFirstEllipsis() {
            return this.modelValue >= this.beforeCurrent + 4
        },

        /**
        * Check if last page button should be visible.
        */
        hasLast() {
            return this.modelValue <= this.pageCount - (1 + this.afterCurrent)
        },

        /**
        * Check if last ellipsis should be visible.
        */
        hasLastEllipsis() {
            return this.modelValue < this.pageCount - (2 + this.afterCurrent)
        },

        /**
        * Check if next button is available.
        */
        hasNext() {
            return this.modelValue < this.pageCount
        },

        /**
        * Get near pages, 1 before and 1 after the current.
        * Also add the click event to the array.
        */
        pagesInRange() {
            if (this.simple) return

            let left = Math.max(1, this.modelValue - this.beforeCurrent);
            if (left - 1 === 2) {
                left--; // Do not show the ellipsis if there is only one to hide
            }
            let right = Math.min(this.modelValue + this.afterCurrent, this.pageCount);
            if (this.pageCount - right === 2) {
                right++; // Do not show the ellipsis if there is only one to hide
            }

            const pages = [];
            for (let i = left; i <= right; i++) {
                pages.push(this.getPage(i));
            }
            return pages
        }
    },
    watch: {
        /**
        * If current page is trying to be greater than page count, set to last.
        */
        pageCount(value) {
            if (this.modelValue > value) this.last();
        },

        modelValue(value) {
            this.inputValue = value;
        },

        debouncePageInput: {
            handler(value) {
                this.debounceHandlePageInput = debounce(
                    this.handleOnInputPageChange,
                    value
                );
            },
            immediate: true
        }
    },
    methods: {
        /**
        * Previous button click listener.
        */
        prev(event) {
            this.changePage(this.modelValue - 1, event);
        },
        /**
         * Next button click listener.
        */
        next(event) {
            this.changePage(this.modelValue + 1, event);
        },
        /**
         * First button click listener.
        */
        first(event) {
            this.changePage(1, event);
        },
        /**
        * Last button click listener.
        */
        last(event) {
            this.changePage(this.pageCount, event);
        },

        changePage(num, event) {
            if (this.modelValue === num || num < 1 || num > this.pageCount) return

            this.$emit('update:modelValue', num);
            this.$emit('change', num);

            // Set focus on element to keep tab order
            if (event && event.target) {
                this.$nextTick(() => event.target.focus());
            }
        },

        getPage(num, options = {}) {
            return {
                number: num,
                isCurrent: this.modelValue === num,
                click: (event) => this.changePage(num, event),
                input: (event, inputNum) => this.changePage(+inputNum, event),
                disabled: options.disabled || false,
                class: options.class || '',
                'aria-label':
          options['aria-label'] ||
          this.getAriaPageLabel(num, this.modelValue === num)
            }
        },

        /**
        * Get text for aria-label according to page number.
        */
        getAriaPageLabel(pageNumber, isCurrent) {
            if (this.ariaPageLabel && (!isCurrent || !this.ariaCurrentLabel)) {
                return this.ariaPageLabel + ' ' + pageNumber + '.'
            } else if (this.ariaPageLabel && isCurrent && this.ariaCurrentLabel) {
                return (
                    this.ariaCurrentLabel +
          ', ' +
          this.ariaPageLabel +
          ' ' +
          pageNumber +
          '.'
                )
            }
            return null
        },

        handleOnInputPageChange(event) {
            this.getPage(this.inputValue).input(event, this.inputValue);
        },

        handleOnInputDebounce(event) {
            if (this.debouncePageInput) {
                this.debounceHandlePageInput(event);
            } else {
                this.handleOnInputPageChange(event);
            }
        },
        handleOnKeyPress(event) {
            // --- This is required to only allow numeric inputs for the page input - --- //
            // --- size attribute does not work with input type number. --- //
            const ASCIICode = event.which || event.keyCode;

            if (ASCIICode >= 48 && ASCIICode <= 57) {
                return true
            } else {
                return event.preventDefault()
            }
        },
        handleAllowableInputPageRange(event) {
            if (+event.target.value > 0 && +event.target.value <= this.pageCount) {
                this.handleOnInputValue(event);
            } else {
                // --- It is nessacery to set inputValue to 1 and then to '' so that the DOM- --- //
                // --- will update the input component even when Backspace is used and then-
                // --- 0 us entered. --- //
                this.inputValue = 1;
                this.inputValue = '';
            }
        },
        handleOnInputValue(event) {
            const inputValue = +event.target.value;
            this.inputValue = inputValue;
            if (Number.isInteger(this.inputValue)) {
                this.handleOnInputDebounce(event);
            } else {
                // --- if NaN, then set inputValue back to current --- //
                this.inputValue = this.modelValue;
            }
        }
    }
};

const _hoisted_1$e = { class: "control pagination-input" };
const _hoisted_2$d = ["value", "size", "maxlength"];
const _hoisted_3$8 = {
  key: 4,
  class: "info"
};
const _hoisted_4$5 = {
  key: 5,
  class: "pagination-list"
};
const _hoisted_5$3 = { key: 0 };
const _hoisted_6$2 = { key: 1 };
const _hoisted_7$2 = /*#__PURE__*/createBaseVNode("span", { class: "pagination-ellipsis" }, "…", -1 /* HOISTED */);
const _hoisted_8$2 = [
  _hoisted_7$2
];
const _hoisted_9$2 = { key: 2 };
const _hoisted_10$1 = /*#__PURE__*/createBaseVNode("span", { class: "pagination-ellipsis" }, "…", -1 /* HOISTED */);
const _hoisted_11$1 = [
  _hoisted_10$1
];
const _hoisted_12$1 = { key: 3 };

function render$f(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_b_icon = resolveComponent("b-icon");
  const _component_BPaginationButton = resolveComponent("BPaginationButton");

  return (openBlock(), createElementBlock("nav", {
    class: normalizeClass(["pagination", $options.rootClasses])
  }, [
    (_ctx.$slots.previous)
      ? renderSlot(_ctx.$slots, "previous", {
          key: 0,
          page: 
                $options.getPage($props.modelValue - 1, {
                    disabled: !$options.hasPrev,
                    class: 'pagination-previous',
                    'aria-label': $props.ariaPreviousLabel,
                })
            
        }, () => [
          createVNode(_component_b_icon, {
            icon: $props.iconPrev,
            pack: $props.iconPack,
            both: "",
            "aria-hidden": "true"
          }, null, 8 /* PROPS */, ["icon", "pack"])
        ])
      : (openBlock(), createBlock(_component_BPaginationButton, {
          key: 1,
          class: "pagination-previous",
          disabled: !$options.hasPrev,
          page: $options.getPage($props.modelValue - 1),
          "aria-label": $props.ariaPreviousLabel
        }, {
          default: withCtx(() => [
            createVNode(_component_b_icon, {
              icon: $props.iconPrev,
              pack: $props.iconPack,
              both: "",
              "aria-hidden": "true"
            }, null, 8 /* PROPS */, ["icon", "pack"])
          ]),
          _: 1 /* STABLE */
        }, 8 /* PROPS */, ["disabled", "page", "aria-label"])),
    (_ctx.$slots.next)
      ? renderSlot(_ctx.$slots, "next", {
          key: 2,
          page: 
                $options.getPage($props.modelValue + 1, {
                    disabled: !$options.hasNext,
                    class: 'pagination-next',
                    'aria-label': $props.ariaNextLabel,
                })
            
        }, () => [
          createVNode(_component_b_icon, {
            icon: $props.iconNext,
            pack: $props.iconPack,
            both: "",
            "aria-hidden": "true"
          }, null, 8 /* PROPS */, ["icon", "pack"])
        ])
      : (openBlock(), createBlock(_component_BPaginationButton, {
          key: 3,
          class: "pagination-next",
          disabled: !$options.hasNext,
          page: $options.getPage($props.modelValue + 1),
          "aria-label": $props.ariaNextLabel
        }, {
          default: withCtx(() => [
            createVNode(_component_b_icon, {
              icon: $props.iconNext,
              pack: $props.iconPack,
              both: "",
              "aria-hidden": "true"
            }, null, 8 /* PROPS */, ["icon", "pack"])
          ]),
          _: 1 /* STABLE */
        }, 8 /* PROPS */, ["disabled", "page", "aria-label"])),
    createBaseVNode("div", _hoisted_1$e, [
      ($props.pageInput)
        ? (openBlock(), createElementBlock("input", {
            key: 0,
            class: "input",
            value: $data.inputValue,
            onInput: _cache[0] || (_cache[0] = (...args) => ($options.handleAllowableInputPageRange && $options.handleAllowableInputPageRange(...args))),
            onKeypress: _cache[1] || (_cache[1] = (...args) => ($options.handleOnKeyPress && $options.handleOnKeyPress(...args))),
            size: $options.pageCount.toString().length,
            maxlength: $options.pageCount.toString().length
          }, null, 40 /* PROPS, HYDRATE_EVENTS */, _hoisted_2$d))
        : createCommentVNode("v-if", true)
    ]),
    ($props.simple)
      ? (openBlock(), createElementBlock("small", _hoisted_3$8, [
          ($props.perPage == 1)
            ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createTextVNode(toDisplayString($options.firstItem) + " / " + toDisplayString($props.total), 1 /* TEXT */)
              ], 64 /* STABLE_FRAGMENT */))
            : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createTextVNode(toDisplayString($options.firstItem) + "-" + toDisplayString(Math.min($props.modelValue * $props.perPage, $props.total)) + " / " + toDisplayString($props.total), 1 /* TEXT */)
              ], 64 /* STABLE_FRAGMENT */))
        ]))
      : (openBlock(), createElementBlock("ul", _hoisted_4$5, [
          createCommentVNode("First"),
          ($options.hasFirst)
            ? (openBlock(), createElementBlock("li", _hoisted_5$3, [
                (_ctx.$slots.default)
                  ? renderSlot(_ctx.$slots, "default", {
                      key: 0,
                      page: $options.getPage(1)
                    })
                  : (openBlock(), createBlock(_component_BPaginationButton, {
                      key: 1,
                      page: $options.getPage(1)
                    }, null, 8 /* PROPS */, ["page"]))
              ]))
            : createCommentVNode("v-if", true),
          ($options.hasFirstEllipsis)
            ? (openBlock(), createElementBlock("li", _hoisted_6$2, [..._hoisted_8$2]))
            : createCommentVNode("v-if", true),
          createCommentVNode("Pages"),
          (openBlock(true), createElementBlock(Fragment, null, renderList($options.pagesInRange, (page) => {
            return (openBlock(), createElementBlock("li", {
              key: page.number
            }, [
              (_ctx.$slots.default)
                ? renderSlot(_ctx.$slots, "default", {
                    key: 0,
                    page: page
                  })
                : (openBlock(), createBlock(_component_BPaginationButton, {
                    key: 1,
                    page: page
                  }, null, 8 /* PROPS */, ["page"]))
            ]))
          }), 128 /* KEYED_FRAGMENT */)),
          createCommentVNode("Last"),
          ($options.hasLastEllipsis)
            ? (openBlock(), createElementBlock("li", _hoisted_9$2, [..._hoisted_11$1]))
            : createCommentVNode("v-if", true),
          ($options.hasLast)
            ? (openBlock(), createElementBlock("li", _hoisted_12$1, [
                (_ctx.$slots.default)
                  ? renderSlot(_ctx.$slots, "default", {
                      key: 0,
                      page: $options.getPage($options.pageCount)
                    })
                  : (openBlock(), createBlock(_component_BPaginationButton, {
                      key: 1,
                      page: $options.getPage($options.pageCount)
                    }, null, 8 /* PROPS */, ["page"]))
              ]))
            : createCommentVNode("v-if", true)
        ]))
  ], 2 /* CLASS */))
}

script$g.render = render$f;
script$g.__file = "src/components/pagination/Pagination.vue";

var Plugin$i = {
  install: function install(Vue) {
    registerComponent(Vue, script$g);
    registerComponent(Vue, script$1$6);
  }
};

var script$f = {
    name: 'BProgressBar',
    inject: {
        parent: {
            from: PROGRESS_INJECTION_KEY,
            default: undefined
        }
    },
    props: {
        type: {
            type: [String, Object],
            default: undefined
        },
        value: {
            type: Number,
            default: undefined
        },
        showValue: {
            type: Boolean,
            default: false
        }
    },
    computed: {
        newType() {
            return [
                this.parent.size,
                this.type || this.parent.type
            ]
        },
        newShowValue() {
            return this.showValue || this.parent.showValue
        },
        newValue() {
            return this.parent.calculateValue(this.value)
        },
        barWidth() {
            return `${this.value * 100 / this.parent.max}%`
        }
    }
};

const _hoisted_1$d = ["aria-valuenow", "aria-valuemax"];
const _hoisted_2$c = {
  key: 0,
  class: "progress-value"
};

function render$e(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createElementBlock("div", {
    class: normalizeClass(["progress-bar", $options.newType]),
    role: "progressbar",
    "aria-valuenow": $props.value,
    "aria-valuemax": $options.parent.max,
    "aria-valuemin": "0",
    style: normalizeStyle({width: $options.barWidth})
  }, [
    ($options.newShowValue)
      ? (openBlock(), createElementBlock("p", _hoisted_2$c, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createTextVNode(toDisplayString($options.newValue), 1 /* TEXT */)
          ])
        ]))
      : createCommentVNode("v-if", true)
  ], 14 /* CLASS, STYLE, PROPS */, _hoisted_1$d))
}

script$f.render = render$e;
script$f.__file = "src/components/progress/ProgressBar.vue";

var Plugin$h = {
  install: function install(Vue) {
    registerComponent(Vue, script$l);
    registerComponent(Vue, script$f);
  }
};

var script$1$5 = {
    name: 'BRadio',
    mixins: [CheckRadioMixin]
};

const _hoisted_1$1$3 = ["disabled"];
const _hoisted_2$1$2 = ["disabled", "required", "name", "value"];
const _hoisted_3$7 = { class: "control-label" };

function render$1$3(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createElementBlock("label", {
    class: normalizeClass(["b-radio radio", [_ctx.size, { 'is-disabled': _ctx.disabled }]]),
    ref: "label",
    disabled: _ctx.disabledOrUndefined,
    onClick: _cache[2] || (_cache[2] = (...args) => (_ctx.focus && _ctx.focus(...args))),
    onKeydown: _cache[3] || (_cache[3] = withKeys(withModifiers($event => (_ctx.$refs.label.click()), ["prevent"]), ["enter"]))
  }, [
    withDirectives(createBaseVNode("input", {
      "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => ((_ctx.computedValue) = $event)),
      type: "radio",
      ref: "input",
      onClick: _cache[1] || (_cache[1] = withModifiers(() => {}, ["stop"])),
      disabled: _ctx.disabledOrUndefined,
      required: _ctx.requiredOrUndefined,
      name: _ctx.name,
      value: _ctx.nativeValue
    }, null, 8 /* PROPS */, _hoisted_2$1$2), [
      [vModelRadio, _ctx.computedValue]
    ]),
    createBaseVNode("span", {
      class: normalizeClass(["check", _ctx.type])
    }, null, 2 /* CLASS */),
    createBaseVNode("span", _hoisted_3$7, [
      renderSlot(_ctx.$slots, "default")
    ])
  ], 42 /* CLASS, PROPS, HYDRATE_EVENTS */, _hoisted_1$1$3))
}

script$1$5.render = render$1$3;
script$1$5.__file = "src/components/radio/Radio.vue";

var script$e = {
    name: 'BRadioButton',
    mixins: [CheckRadioMixin],
    props: {
        type: {
            type: String,
            default: 'is-primary'
        },
        expanded: Boolean
    },
    data() {
        return {
            isFocused: false
        }
    },
    computed: {
        isSelected() {
            return this.newValue === this.nativeValue
        },
        labelClass() {
            return [
                this.isSelected ? this.type : null,
                this.size,
                {
                    'is-selected': this.isSelected,
                    'is-disabled': this.disabled,
                    'is-focused': this.isFocused
                }
            ]
        }
    }
};

const _hoisted_1$c = ["disabled"];
const _hoisted_2$b = ["disabled", "required", "name", "value"];

function render$d(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createElementBlock("div", {
    class: normalizeClass(["control", { 'is-expanded': $props.expanded }])
  }, [
    createBaseVNode("label", {
      class: normalizeClass(["b-radio radio button", $options.labelClass]),
      ref: "label",
      disabled: _ctx.disabledOrUndefined,
      onClick: _cache[4] || (_cache[4] = (...args) => (_ctx.focus && _ctx.focus(...args))),
      onKeydown: _cache[5] || (_cache[5] = withKeys(withModifiers($event => (_ctx.$refs.label.click()), ["prevent"]), ["enter"]))
    }, [
      renderSlot(_ctx.$slots, "default"),
      withDirectives(createBaseVNode("input", {
        "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => ((_ctx.computedValue) = $event)),
        type: "radio",
        ref: "input",
        onClick: _cache[1] || (_cache[1] = withModifiers(() => {}, ["stop"])),
        disabled: _ctx.disabledOrUndefined,
        required: _ctx.requiredOrUndefined,
        name: _ctx.name,
        value: _ctx.nativeValue,
        onFocus: _cache[2] || (_cache[2] = $event => ($data.isFocused = true)),
        onBlur: _cache[3] || (_cache[3] = $event => ($data.isFocused = false))
      }, null, 40 /* PROPS, HYDRATE_EVENTS */, _hoisted_2$b), [
        [vModelRadio, _ctx.computedValue]
      ])
    ], 42 /* CLASS, PROPS, HYDRATE_EVENTS */, _hoisted_1$c)
  ], 2 /* CLASS */))
}

script$e.render = render$d;
script$e.__file = "src/components/radio/RadioButton.vue";

var Plugin$g = {
  install: function install(Vue) {
    registerComponent(Vue, script$1$5);
    registerComponent(Vue, script$e);
  }
};

var script$d = {
    name: 'BRate',
    components: {
        [script$I.name]: script$I
    },
    props: {
        modelValue: {
            type: Number,
            default: 0
        },
        max: {
            type: Number,
            default: 5
        },
        icon: {
            type: String,
            default: 'star'
        },
        iconPack: String,
        size: String,
        spaced: Boolean,
        rtl: Boolean,
        disabled: Boolean,
        showScore: Boolean,
        showText: Boolean,
        customText: String,
        texts: Array,
        locale: {
            type: [String, Array],
            default: () => {
                return config.defaultLocale
            }
        }
    },
    emits: ['change', 'update:modelValue'],
    data() {
        return {
            newValue: this.modelValue,
            hoverValue: 0
        }
    },
    computed: {
        halfStyle() {
            return `width:${this.valueDecimal}%`
        },
        showMe() {
            let result = '';
            if (this.showScore) {
                result = this.disabled ? this.modelValue : this.newValue;
                if (result === 0) {
                    result = '';
                } else {
                    result = new Intl.NumberFormat(this.locale).format(this.modelValue);
                }
            } else if (this.showText) {
                result = this.texts[Math.ceil(this.newValue) - 1];
            }
            return result
        },
        valueDecimal() {
            return this.modelValue * 100 - Math.floor(this.modelValue) * 100
        }
    },
    watch: {
        // When v-model is changed set the new value.
        modelValue(value) {
            this.newValue = value;
        }
    },
    methods: {
        resetNewValue() {
            if (this.disabled) return
            this.hoverValue = 0;
        },
        previewRate(index, event) {
            if (this.disabled) return
            this.hoverValue = index;
            event.stopPropagation();
        },
        confirmValue(index) {
            if (this.disabled) return
            this.newValue = index;
            this.$emit('change', this.newValue);
            this.$emit('update:modelValue', this.newValue);
        },
        checkHalf(index) {
            const showWhenDisabled = this.disabled && this.valueDecimal > 0 &&
            index - 1 < this.modelValue && index > this.modelValue;
            return showWhenDisabled
        },
        rateClass(index) {
            let output = '';
            const currentValue = this.hoverValue !== 0 ? this.hoverValue : this.newValue;
            if (index <= currentValue) {
                output = 'set-on';
            } else if (this.disabled && (Math.ceil(this.modelValue) === index)) {
                output = 'set-half';
            }
            return output
        }
    }
};

const _hoisted_1$b = ["onMousemove", "onClick"];
const _hoisted_2$a = { key: 0 };

function render$c(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_b_icon = resolveComponent("b-icon");

  return (openBlock(), createElementBlock("div", {
    class: normalizeClass(["rate", { 'is-disabled': $props.disabled, 'is-spaced': $props.spaced, 'is-rtl': $props.rtl }])
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList($props.max, (item, index) => {
      return (openBlock(), createElementBlock("div", {
        class: normalizeClass(["rate-item", $options.rateClass(item)]),
        key: index,
        onMousemove: $event => ($options.previewRate(item, $event)),
        onMouseleave: _cache[0] || (_cache[0] = (...args) => ($options.resetNewValue && $options.resetNewValue(...args))),
        onClick: withModifiers($event => ($options.confirmValue(item)), ["prevent"])
      }, [
        createVNode(_component_b_icon, {
          pack: $props.iconPack,
          icon: $props.icon,
          size: $props.size
        }, null, 8 /* PROPS */, ["pack", "icon", "size"]),
        ($options.checkHalf(item))
          ? (openBlock(), createBlock(_component_b_icon, {
              key: 0,
              class: "is-half",
              pack: $props.iconPack,
              icon: $props.icon,
              size: $props.size,
              style: normalizeStyle($options.halfStyle)
            }, null, 8 /* PROPS */, ["pack", "icon", "size", "style"]))
          : createCommentVNode("v-if", true)
      ], 42 /* CLASS, PROPS, HYDRATE_EVENTS */, _hoisted_1$b))
    }), 128 /* KEYED_FRAGMENT */)),
    ($props.showText || $props.showScore || $props.customText)
      ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(["rate-text", $props.size])
        }, [
          createBaseVNode("span", null, toDisplayString($options.showMe), 1 /* TEXT */),
          ($props.customText && !$props.showText)
            ? (openBlock(), createElementBlock("span", _hoisted_2$a, toDisplayString($props.customText), 1 /* TEXT */))
            : createCommentVNode("v-if", true)
        ], 2 /* CLASS */))
      : createCommentVNode("v-if", true)
  ], 2 /* CLASS */))
}

script$d.render = render$c;
script$d.__file = "src/components/rate/Rate.vue";

var Plugin$f = {
  install: function install(Vue) {
    registerComponent(Vue, script$d);
  }
};

var Plugin$e = {
  install: function install(Vue) {
    registerComponent(Vue, script$v);
  }
};

const BSkeleton = (props) => {
    if (!props.active) return
    const items = [];
    const width = props.width;
    const height = props.height;
    for (let i = 0; i < props.count; i++) {
        items.push(h('div', {
            class: [
                'b-skeleton-item',
                { 'is-rounded': props.rounded }
            ],
            key: i,
            style: {
                height: height === undefined
                    ? null
                    : (isNaN(height) ? height : height + 'px'),
                width: width === undefined
                    ? null
                    : (isNaN(width) ? width : width + 'px'),
                borderRadius: props.circle ? '50%' : null
            }
        }));
    }
    return h(
        'div',
        {
            class: [
                'b-skeleton',
                props.size,
                props.position,
                { 'is-animated': props.animated }
            ]
        },
        items
    )
};

BSkeleton.props = {
    active: {
        type: Boolean,
        default: true
    },
    animated: {
        type: Boolean,
        default: true
    },
    width: [Number, String],
    height: [Number, String],
    circle: Boolean,
    rounded: {
        type: Boolean,
        default: true
    },
    count: {
        type: Number,
        default: 1
    },
    position: {
        type: String,
        default: '',
        validator(value) {
            return [
                '',
                'is-centered',
                'is-right'
            ].indexOf(value) > -1
        }
    },
    size: String
};

var script$c = BSkeleton;

script$c.__file = "src/components/skeleton/Skeleton.vue";

var Plugin$d = {
  install: function install(Vue) {
    // explicit `name` is needed to avoid name mangling of
    // Functional Component in production
    registerComponent(Vue, script$c, 'BSkeleton');
  }
};

var script$b = {
    name: 'BSidebar',
    props: {
        modelValue: Boolean,
        type: [String, Object],
        overlay: Boolean,
        position: {
            type: String,
            default: 'fixed',
            validator: (value) => {
                return [
                    'fixed',
                    'absolute',
                    'static'
                ].indexOf(value) >= 0
            }
        },
        fullheight: Boolean,
        fullwidth: Boolean,
        right: Boolean,
        mobile: {
            type: String
        },
        reduce: Boolean,
        expandOnHover: Boolean,
        expandOnHoverFixed: Boolean,
        delay: {
            type: Number,
            default: () => config.defaultSidebarDelay
        },
        canCancel: {
            type: [Array, Boolean],
            default: () => ['escape', 'outside']
        },
        onCancel: {
            type: Function,
            default: () => {}
        },
        scroll: {
            type: String,
            default: () => {
                return config.defaultModalScroll
                    ? config.defaultModalScroll
                    : 'clip'
            },
            validator: (value) => {
                return [
                    'clip',
                    'keep'
                ].indexOf(value) >= 0
            }
        }
    },
    emits: ['close', 'update:modelValue'],
    data() {
        return {
            isOpen: this.modelValue,
            isDelayOver: false,
            transitionName: null,
            animating: true,
            savedScrollTop: null,
            hasLeaved: false
        }
    },
    computed: {
        rootClasses() {
            return [this.type, {
                'is-fixed': this.isFixed,
                'is-static': this.isStatic,
                'is-absolute': this.isAbsolute,
                'is-fullheight': this.fullheight,
                'is-fullwidth': this.fullwidth,
                'is-right': this.right,
                'is-mini': this.reduce && !this.isDelayOver,
                'is-mini-expand': this.expandOnHover || this.isDelayOver,
                'is-mini-expand-fixed': (this.expandOnHover && this.expandOnHoverFixed) || this.isDelayOver,
                'is-mini-delayed': this.delay !== null,
                'is-mini-mobile': this.mobile === 'reduce',
                'is-hidden-mobile': this.mobile === 'hide',
                'is-fullwidth-mobile': this.mobile === 'fullwidth'
            }]
        },
        cancelOptions() {
            return typeof this.canCancel === 'boolean'
                ? this.canCancel
                    ? ['escape', 'outside']
                    : []
                : this.canCancel
        },
        isStatic() {
            return this.position === 'static'
        },
        isFixed() {
            return this.position === 'fixed'
        },
        isAbsolute() {
            return this.position === 'absolute'
        }
    },
    watch: {
        modelValue: {
            handler(value) {
                this.isOpen = value;
                if (this.overlay) {
                    this.handleScroll();
                }
                const open = this.right ? !value : value;
                this.transitionName = !open ? 'slide-prev' : 'slide-next';
            },
            immediate: true
        }
    },
    methods: {
        /**
        * Keypress event that is bound to the document.
        */
        keyPress({ key }) {
            if (this.isFixed) {
                if (this.isOpen && (key === 'Escape' || key === 'Esc')) this.cancel('escape');
            }
        },

        /**
        * Close the Sidebar if canCancel and call the onCancel prop (function).
        */
        cancel(method) {
            if (this.cancelOptions.indexOf(method) < 0) return
            if (this.isStatic) return

            this.onCancel.apply(null, arguments);
            this.close();
        },

        /**
        * Call the onCancel prop (function) and emit events
        */
        close() {
            this.isOpen = false;
            this.$emit('close');
            this.$emit('update:modelValue', false);
        },

        /**
         * Close fixed sidebar if clicked outside.
         */
        clickedOutside(event) {
            if (!this.isFixed || !this.isOpen || this.animating) { return }

            if (!event.composedPath().includes(this.$refs.sidebarContent)) {
                this.cancel('outside');
            }
        },

        /**
        * Transition before-enter hook
        */
        beforeEnter() {
            this.animating = true;
        },

        /**
        * Transition after-leave hook
        */
        afterEnter() {
            this.animating = false;
        },

        handleScroll() {
            if (typeof window === 'undefined') return

            if (this.scroll === 'clip') {
                if (this.modelValue) {
                    document.documentElement.classList.add('is-clipped');
                } else {
                    document.documentElement.classList.remove('is-clipped');
                }
                return
            }

            this.savedScrollTop = !this.savedScrollTop
                ? document.documentElement.scrollTop
                : this.savedScrollTop;

            if (this.modelValue) {
                document.body.classList.add('is-noscroll');
            } else {
                document.body.classList.remove('is-noscroll');
            }

            if (this.modelValue) {
                document.body.style.top = `-${this.savedScrollTop}px`;
                return
            }

            document.documentElement.scrollTop = this.savedScrollTop;
            document.body.style.top = null;
            this.savedScrollTop = null;
        },
        onHover() {
            if (this.delay) {
                this.hasLeaved = false;
                this.timer = setTimeout(() => {
                    if (!this.hasLeaved) {
                        this.isDelayOver = true;
                    }
                    this.timer = null;
                }, this.delay);
            } else {
                this.isDelayOver = false;
            }
        },
        onHoverLeave() {
            this.hasLeaved = true;
            this.timer = null;
            this.isDelayOver = false;
        },
        /**
         * Close sidebar if close button is clicked.
         */
        clickedCloseButton() {
            if (this.isFixed) {
                if (this.isOpen && this.fullwidth) {
                    this.cancel('outside');
                }
            }
        }
    },
    created() {
        if (typeof window !== 'undefined') {
            document.addEventListener('keyup', this.keyPress);
            document.addEventListener('click', this.clickedOutside);
        }
    },
    mounted() {
        if (typeof window !== 'undefined') {
            if (this.isFixed) {
                document.body.appendChild(this.$el);
            }
        }
        if (this.overlay && this.modelValue) {
            this.handleScroll();
        }
    },
    beforeUnmount() {
        if (typeof window !== 'undefined') {
            document.removeEventListener('keyup', this.keyPress);
            document.removeEventListener('click', this.clickedOutside);
            if (this.overlay) {
                // reset scroll
                document.documentElement.classList.remove('is-clipped');
                const savedScrollTop = !this.savedScrollTop
                    ? document.documentElement.scrollTop
                    : this.savedScrollTop;
                document.body.classList.remove('is-noscroll');
                document.documentElement.scrollTop = savedScrollTop;
                document.body.style.top = null;
            }
        }
        if (this.isFixed) {
            removeElement(this.$el);
        }
        clearTimeout(this.timer);
    }
};

const _hoisted_1$a = { class: "b-sidebar" };
const _hoisted_2$9 = {
  key: 0,
  class: "sidebar-background"
};

function render$b(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createElementBlock("div", _hoisted_1$a, [
    ($props.overlay && $data.isOpen)
      ? (openBlock(), createElementBlock("div", _hoisted_2$9))
      : createCommentVNode("v-if", true),
    createVNode(Transition, {
      name: $data.transitionName,
      onBeforeEnter: $options.beforeEnter,
      onAfterEnter: $options.afterEnter,
      persisted: ""
    }, {
      default: withCtx(() => [
        withDirectives(createBaseVNode("div", {
          ref: "sidebarContent",
          class: normalizeClass(["sidebar-content", $options.rootClasses]),
          onMouseenter: _cache[1] || (_cache[1] = (...args) => ($options.onHover && $options.onHover(...args))),
          onMouseleave: _cache[2] || (_cache[2] = (...args) => ($options.onHoverLeave && $options.onHoverLeave(...args)))
        }, [
          ($props.fullwidth)
            ? (openBlock(), createElementBlock("button", {
                key: 0,
                type: "button",
                onClick: _cache[0] || (_cache[0] = (...args) => ($options.clickedCloseButton && $options.clickedCloseButton(...args))),
                class: "modal-close is-large sidebar-close",
                "aria-label": "Close"
              }))
            : createCommentVNode("v-if", true),
          renderSlot(_ctx.$slots, "default")
        ], 34 /* CLASS, HYDRATE_EVENTS */), [
          [vShow, $data.isOpen]
        ])
      ]),
      _: 3 /* FORWARDED */
    }, 8 /* PROPS */, ["name", "onBeforeEnter", "onAfterEnter"])
  ]))
}

script$b.render = render$b;
script$b.__file = "src/components/sidebar/Sidebar.vue";

var Plugin$c = {
  install: function install(Vue) {
    registerComponent(Vue, script$b);
  }
};

var script$2$2 = {
    name: 'BSliderThumb',
    components: {
        [script$u.name]: script$u
    },
    mixins: [CompatFallthroughMixin],
    props: {
        modelValue: {
            type: Number,
            default: 0
        },
        type: {
            type: String,
            default: ''
        },
        tooltip: {
            type: Boolean,
            default: true
        },
        indicator: {
            type: Boolean,
            default: false
        },
        customFormatter: Function,
        format: {
            type: String,
            default: 'raw',
            validator: (value) => {
                return [
                    'raw',
                    'percent'
                ].indexOf(value) >= 0
            }
        },
        locale: {
            type: [String, Array],
            default: () => {
                return config.defaultLocale
            }
        },
        tooltipAlways: {
            type: Boolean,
            default: false
        }
    },
    emits: ['dragend', 'dragstart', 'update:modelValue'],
    data() {
        return {
            isFocused: false,
            dragging: false,
            startX: 0,
            startPosition: 0,
            newPosition: null,
            oldValue: this.modelValue
        }
    },
    computed: {
        disabled() {
            return this.$parent.disabled
        },
        max() {
            return this.$parent.max
        },
        min() {
            return this.$parent.min
        },
        step() {
            return this.$parent.step
        },
        precision() {
            return this.$parent.precision
        },
        currentPosition() {
            return `${(this.modelValue - this.min) / (this.max - this.min) * 100}%`
        },
        wrapperStyle() {
            return { left: this.currentPosition }
        },
        formattedValue() {
            if (typeof this.customFormatter !== 'undefined') {
                return this.customFormatter(this.modelValue)
            }

            if (this.format === 'percent') {
                return new Intl.NumberFormat(
                    this.locale,
                    {
                        style: 'percent'
                    }
                ).format(((this.modelValue - this.min)) / (this.max - this.min))
            }

            return new Intl.NumberFormat(this.locale).format(this.modelValue)
        }
    },
    methods: {
        onFocus() {
            this.isFocused = true;
        },
        onBlur() {
            this.isFocused = false;
        },
        onButtonDown(event) {
            if (this.disabled) return
            event.preventDefault();
            this.onDragStart(event);
            if (typeof window !== 'undefined') {
                document.addEventListener('mousemove', this.onDragging);
                document.addEventListener('touchmove', this.onDragging);
                document.addEventListener('mouseup', this.onDragEnd);
                document.addEventListener('touchend', this.onDragEnd);
                document.addEventListener('contextmenu', this.onDragEnd);
            }
        },
        onLeftKeyDown() {
            if (this.disabled || this.modelValue === this.min) return
            this.newPosition = parseFloat(this.currentPosition) -
                this.step / (this.max - this.min) * 100;
            this.setPosition(this.newPosition);
            this.$parent.emitValue('change');
        },
        onRightKeyDown() {
            if (this.disabled || this.modelValue === this.max) return
            this.newPosition = parseFloat(this.currentPosition) +
                this.step / (this.max - this.min) * 100;
            this.setPosition(this.newPosition);
            this.$parent.emitValue('change');
        },
        onHomeKeyDown() {
            if (this.disabled || this.modelValue === this.min) return
            this.newPosition = 0;
            this.setPosition(this.newPosition);
            this.$parent.emitValue('change');
        },
        onEndKeyDown() {
            if (this.disabled || this.modelValue === this.max) return
            this.newPosition = 100;
            this.setPosition(this.newPosition);
            this.$parent.emitValue('change');
        },
        onDragStart(event) {
            this.dragging = true;
            this.$emit('dragstart');
            if (event.type === 'touchstart') {
                event.clientX = event.touches[0].clientX;
            }
            this.startX = event.clientX;
            this.startPosition = parseFloat(this.currentPosition);
            this.newPosition = this.startPosition;
        },
        onDragging(event) {
            if (this.dragging) {
                if (event.type === 'touchmove') {
                    event.clientX = event.touches[0].clientX;
                }
                const diff = (event.clientX - this.startX) / this.$parent.sliderSize() * 100;
                this.newPosition = this.startPosition + diff;
                this.setPosition(this.newPosition);
            }
        },
        onDragEnd() {
            this.dragging = false;
            this.$emit('dragend');
            if (this.modelValue !== this.oldValue) {
                this.$parent.emitValue('change');
            }
            this.setPosition(this.newPosition);
            if (typeof window !== 'undefined') {
                document.removeEventListener('mousemove', this.onDragging);
                document.removeEventListener('touchmove', this.onDragging);
                document.removeEventListener('mouseup', this.onDragEnd);
                document.removeEventListener('touchend', this.onDragEnd);
                document.removeEventListener('contextmenu', this.onDragEnd);
            }
        },
        setPosition(percent) {
            if (percent === null || isNaN(percent)) return
            if (percent < 0) {
                percent = 0;
            } else if (percent > 100) {
                percent = 100;
            }
            const stepLength = 100 / ((this.max - this.min) / this.step);
            const steps = Math.round(percent / stepLength);
            let value = steps * stepLength / 100 * (this.max - this.min) + this.min;
            value = parseFloat(value.toFixed(this.precision));
            this.$emit('update:modelValue', value);
            if (!this.dragging && value !== this.oldValue) {
                this.oldValue = value;
            }
        }
    },

    beforeUnmount() {
        document.removeEventListener('mousemove', this.onDragging);
        document.removeEventListener('touchmove', this.onDragging);
        document.removeEventListener('mouseup', this.onDragEnd);
        document.removeEventListener('touchend', this.onDragEnd);
        document.removeEventListener('contextmenu', this.onDragEnd);
    }
};

const _hoisted_1$2$2 = ["tabindex"];
const _hoisted_2$8 = { key: 0 };

function render$2$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_b_tooltip = resolveComponent("b-tooltip");

  return (openBlock(), createElementBlock("div", mergeProps({
    class: ["b-slider-thumb-wrapper", { 'is-dragging': $data.dragging, 'has-indicator': $props.indicator}],
    style: $options.wrapperStyle
  }, _ctx.rootAttrs), [
    createVNode(_component_b_tooltip, {
      label: $options.formattedValue,
      type: $props.type,
      always: $data.dragging || $data.isFocused || $props.tooltipAlways,
      active: !$options.disabled && $props.tooltip
    }, {
      default: withCtx(() => [
        createBaseVNode("div", mergeProps({
          class: "b-slider-thumb",
          tabindex: $options.disabled ? false : 0
        }, _ctx.fallthroughAttrs, {
          onMousedown: _cache[0] || (_cache[0] = (...args) => ($options.onButtonDown && $options.onButtonDown(...args))),
          onTouchstart: _cache[1] || (_cache[1] = (...args) => ($options.onButtonDown && $options.onButtonDown(...args))),
          onFocus: _cache[2] || (_cache[2] = (...args) => ($options.onFocus && $options.onFocus(...args))),
          onBlur: _cache[3] || (_cache[3] = (...args) => ($options.onBlur && $options.onBlur(...args))),
          onKeydown: [
            _cache[4] || (_cache[4] = withKeys(withModifiers((...args) => ($options.onLeftKeyDown && $options.onLeftKeyDown(...args)), ["prevent"]), ["left"])),
            _cache[5] || (_cache[5] = withKeys(withModifiers((...args) => ($options.onRightKeyDown && $options.onRightKeyDown(...args)), ["prevent"]), ["right"])),
            _cache[6] || (_cache[6] = withKeys(withModifiers((...args) => ($options.onLeftKeyDown && $options.onLeftKeyDown(...args)), ["prevent"]), ["down"])),
            _cache[7] || (_cache[7] = withKeys(withModifiers((...args) => ($options.onRightKeyDown && $options.onRightKeyDown(...args)), ["prevent"]), ["up"])),
            _cache[8] || (_cache[8] = withKeys(withModifiers((...args) => ($options.onHomeKeyDown && $options.onHomeKeyDown(...args)), ["prevent"]), ["home"])),
            _cache[9] || (_cache[9] = withKeys(withModifiers((...args) => ($options.onEndKeyDown && $options.onEndKeyDown(...args)), ["prevent"]), ["end"]))
          ]
        }), [
          ($props.indicator)
            ? (openBlock(), createElementBlock("span", _hoisted_2$8, toDisplayString($options.formattedValue), 1 /* TEXT */))
            : createCommentVNode("v-if", true)
        ], 16 /* FULL_PROPS */, _hoisted_1$2$2)
      ]),
      _: 1 /* STABLE */
    }, 8 /* PROPS */, ["label", "type", "always", "active"])
  ], 16 /* FULL_PROPS */))
}

script$2$2.render = render$2$2;
script$2$2.__file = "src/components/slider/SliderThumb.vue";

var script$1$4 = {
    name: 'BSliderTick',
    props: {
        value: {
            type: Number,
            default: 0
        }
    },
    computed: {
        position() {
            const pos = (this.value - this.$parent.min) /
                (this.$parent.max - this.$parent.min) * 100;
            return (pos >= 0 && pos <= 100) ? pos : 0
        },
        hidden() {
            return this.value === this.$parent.min || this.value === this.$parent.max
        }
    },
    methods: {
        getTickStyle(position) {
            return { left: position + '%' }
        }
    },
    created() {
        if (!this.$parent.$data._isSlider) {
            throw new Error('You should wrap bSliderTick on a bSlider')
        }
    }
};

const _hoisted_1$1$2 = {
  key: 0,
  class: "b-slider-tick-label"
};

function render$1$2(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createElementBlock("div", {
    class: normalizeClass(["b-slider-tick", { 'is-tick-hidden': $options.hidden }]),
    style: normalizeStyle($options.getTickStyle($options.position))
  }, [
    (_ctx.$slots.default)
      ? (openBlock(), createElementBlock("span", _hoisted_1$1$2, [
          renderSlot(_ctx.$slots, "default")
        ]))
      : createCommentVNode("v-if", true)
  ], 6 /* CLASS, STYLE */))
}

script$1$4.render = render$1$2;
script$1$4.__file = "src/components/slider/SliderTick.vue";

var script$a = {
    name: 'BSlider',
    components: {
        [script$2$2.name]: script$2$2,
        [script$1$4.name]: script$1$4
    },
    props: {
        modelValue: {
            type: [Number, Array],
            default: 0
        },
        min: {
            type: Number,
            default: 0
        },
        max: {
            type: Number,
            default: 100
        },
        step: {
            type: Number,
            default: 1
        },
        type: {
            type: String,
            default: 'is-primary'
        },
        size: String,
        ticks: {
            type: Boolean,
            default: false
        },
        tooltip: {
            type: Boolean,
            default: true
        },
        tooltipType: String,
        rounded: {
            type: Boolean,
            default: false
        },
        disabled: {
            type: Boolean,
            default: false
        },
        lazy: {
            type: Boolean,
            default: false
        },
        customFormatter: Function,
        ariaLabel: [String, Array],
        biggerSliderFocus: {
            type: Boolean,
            default: false
        },
        indicator: {
            type: Boolean,
            default: false
        },
        format: {
            type: String,
            default: 'raw',
            validator: (value) => {
                return [
                    'raw',
                    'percent'
                ].indexOf(value) >= 0
            }
        },
        locale: {
            type: [String, Array],
            default: () => {
                return config.defaultLocale
            }
        },
        tooltipAlways: {
            type: Boolean,
            default: false
        }
    },
    emits: ['change', 'dragend', 'dragging', 'dragstart', 'update:modelValue'],
    data() {
        return {
            value1: null,
            value2: null,
            // internal is used to update value1 and value2 with a single shot.
            // internal is also used to stop unnecessary propagation of update.
            internal: {
                value1: null,
                value2: null
            },
            dragging: false,
            isRange: false,
            _isSlider: true, // Used by Thumb and Tick
            timeOutID: null
        }
    },
    computed: {
        newTooltipType() {
            return this.tooltipType ? this.tooltipType : this.type
        },
        tickValues() {
            if (!this.ticks || this.min > this.max || this.step === 0) return []
            const result = [];
            for (let i = this.min + this.step; i < this.max; i = i + this.step) {
                result.push(i);
            }
            return result
        },
        minValue() {
            return Math.min(this.value1, this.value2)
        },
        maxValue() {
            return Math.max(this.value1, this.value2)
        },
        barSize() {
            return this.isRange
                ? `${100 * (this.maxValue - this.minValue) / (this.max - this.min)}%`
                : `${100 * (this.value1 - this.min) / (this.max - this.min)}%`
        },
        barStart() {
            return this.isRange
                ? `${100 * (this.minValue - this.min) / (this.max - this.min)}%`
                : '0%'
        },
        precision() {
            const precisions = [this.min, this.max, this.step].map((item) => {
                const decimal = ('' + item).split('.')[1];
                return decimal ? decimal.length : 0
            });
            return Math.max(...precisions)
        },
        barStyle() {
            return {
                width: this.barSize,
                left: this.barStart
            }
        },
        rootClasses() {
            return {
                'is-rounded': this.rounded,
                'is-dragging': this.dragging,
                'is-disabled': this.disabled,
                'slider-focus': this.biggerSliderFocus
            }
        }
    },
    watch: {
        /**
        * When v-model is changed set the new active step.
        */
        modelValue(value) {
            this.setValues(value);
        },
        internal({ value1, value2 }) {
            this.value1 = value1;
            this.value2 = value2;
        },
        value1(newValue) {
            if (this.internal.value1 !== newValue) {
                this.onInternalValueUpdate();
            }
        },
        value2(newValue) {
            if (this.internal.value2 !== newValue) {
                this.onInternalValueUpdate();
            }
        },
        min() {
            this.setValues(this.modelValue);
        },
        max() {
            this.setValues(this.modelValue);
        }
    },
    methods: {
        setValues(newValue) {
            if (this.min > this.max) {
                return
            }
            if (Array.isArray(newValue)) {
                this.isRange = true;
                const smallValue = typeof newValue[0] !== 'number' || isNaN(newValue[0])
                    ? this.min
                    : bound(newValue[0], this.min, this.max);
                const largeValue = typeof newValue[1] !== 'number' || isNaN(newValue[1])
                    ? this.max
                    : bound(newValue[1], this.min, this.max);
                // premature update will be triggered and end up with circular
                // update, if value1 and value2 are updated one by one
                this.internal = {
                    value1: this.isThumbReversed ? largeValue : smallValue,
                    value2: this.isThumbReversed ? smallValue : largeValue
                };
            } else {
                this.isRange = false;
                this.internal = {
                    value1: isNaN(newValue)
                        ? this.min
                        : bound(newValue, this.min, this.max),
                    value2: null
                };
            }
        },
        onInternalValueUpdate() {
            if (this.isRange) {
                this.isThumbReversed = this.value1 > this.value2;
            }
            if (!this.lazy || !this.dragging) {
                this.emitValue('update:modelValue');
            }
            if (this.dragging) {
                this.emitValue('dragging');
            }
        },
        sliderSize() {
            return this.$refs.slider.getBoundingClientRect().width
        },
        onSliderClick(event) {
            if (this.disabled || this.isTrackClickDisabled) return
            const sliderOffsetLeft = this.$refs.slider.getBoundingClientRect().left;
            const percent = (event.clientX - sliderOffsetLeft) / this.sliderSize() * 100;
            const targetValue = this.min + percent * (this.max - this.min) / 100;
            const diffFirst = Math.abs(targetValue - this.value1);
            if (!this.isRange) {
                if (diffFirst < this.step / 2) return
                this.$refs.button1.setPosition(percent);
            } else {
                const diffSecond = Math.abs(targetValue - this.value2);
                if (diffFirst <= diffSecond) {
                    if (diffFirst < this.step / 2) return
                    this.$refs.button1.setPosition(percent);
                } else {
                    if (diffSecond < this.step / 2) return
                    this.$refs.button2.setPosition(percent);
                }
            }
            this.emitValue('change');
        },
        onDragStart() {
            this.dragging = true;
            this.$emit('dragstart');
        },
        onDragEnd() {
            this.isTrackClickDisabled = true;
            this.timeOutID = setTimeout(() => {
                // avoid triggering onSliderClick after dragend
                this.isTrackClickDisabled = false;
            }, 0);
            this.dragging = false;
            this.$emit('dragend');
            if (this.lazy) {
                this.emitValue('update:modelValue');
            }
        },
        emitValue(type) {
            this.$emit(type, this.isRange
                ? [this.minValue, this.maxValue]
                : this.value1);
        }
    },
    created() {
        this.isThumbReversed = false;
        this.isTrackClickDisabled = false;
        this.setValues(this.modelValue);
    },

    beforeUnmount() {
        clearTimeout(this.timeOutID);
    }
};

const _hoisted_1$9 = {
  class: "b-slider-track",
  ref: "slider"
};

function render$a(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_b_slider_tick = resolveComponent("b-slider-tick");
  const _component_b_slider_thumb = resolveComponent("b-slider-thumb");

  return (openBlock(), createElementBlock("div", {
    class: normalizeClass(["b-slider", [$props.size, $props.type, $options.rootClasses ]]),
    onClick: _cache[2] || (_cache[2] = (...args) => ($options.onSliderClick && $options.onSliderClick(...args)))
  }, [
    createBaseVNode("div", _hoisted_1$9, [
      createBaseVNode("div", {
        class: "b-slider-fill",
        style: normalizeStyle($options.barStyle)
      }, null, 4 /* STYLE */),
      ($props.ticks)
        ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList($options.tickValues, (val, key) => {
            return (openBlock(), createBlock(_component_b_slider_tick, {
              key: key,
              value: val
            }, null, 8 /* PROPS */, ["value"]))
          }), 128 /* KEYED_FRAGMENT */))
        : createCommentVNode("v-if", true),
      renderSlot(_ctx.$slots, "default"),
      createVNode(_component_b_slider_thumb, {
        "tooltip-always": $props.tooltipAlways,
        modelValue: $data.value1,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => (($data.value1) = $event)),
        type: $options.newTooltipType,
        tooltip: $props.tooltip,
        "custom-formatter": $props.customFormatter,
        indicator: $props.indicator,
        format: $props.format,
        locale: $props.locale,
        ref: "button1",
        role: "slider",
        "aria-valuenow": $data.value1,
        "aria-valuemin": $props.min,
        "aria-valuemax": $props.max,
        "aria-orientation": "horizontal",
        "aria-label": Array.isArray($props.ariaLabel) ? $props.ariaLabel[0] : $props.ariaLabel,
        "aria-disabled": $props.disabled || undefined,
        onDragstart: $options.onDragStart,
        onDragend: $options.onDragEnd
      }, null, 8 /* PROPS */, ["tooltip-always", "modelValue", "type", "tooltip", "custom-formatter", "indicator", "format", "locale", "aria-valuenow", "aria-valuemin", "aria-valuemax", "aria-label", "aria-disabled", "onDragstart", "onDragend"]),
      ($data.isRange)
        ? (openBlock(), createBlock(_component_b_slider_thumb, {
            key: 1,
            "tooltip-always": $props.tooltipAlways,
            modelValue: $data.value2,
            "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => (($data.value2) = $event)),
            type: $options.newTooltipType,
            tooltip: $props.tooltip,
            "custom-formatter": $props.customFormatter,
            indicator: $props.indicator,
            format: $props.format,
            locale: $props.locale,
            ref: "button2",
            role: "slider",
            "aria-valuenow": $data.value2,
            "aria-valuemin": $props.min,
            "aria-valuemax": $props.max,
            "aria-orientation": "horizontal",
            "aria-label": Array.isArray($props.ariaLabel) ? $props.ariaLabel[1] : '',
            "aria-disabled": $props.disabled || undefined,
            onDragstart: $options.onDragStart,
            onDragend: $options.onDragEnd
          }, null, 8 /* PROPS */, ["tooltip-always", "modelValue", "type", "tooltip", "custom-formatter", "indicator", "format", "locale", "aria-valuenow", "aria-valuemin", "aria-valuemax", "aria-label", "aria-disabled", "onDragstart", "onDragend"]))
        : createCommentVNode("v-if", true)
    ], 512 /* NEED_PATCH */)
  ], 2 /* CLASS */))
}

script$a.render = render$a;
script$a.__file = "src/components/slider/Slider.vue";

var Plugin$b = {
  install: function install(Vue) {
    registerComponent(Vue, script$a);
    registerComponent(Vue, script$1$4);
  }
};

var script$9 = {
    name: 'BSnackbar',
    mixins: [NoticeMixin],
    props: {
        actionText: {
            type: String,
            default: 'OK'
        },
        onAction: {
            type: Function,
            default: () => {}
        },
        cancelText: {
            type: String,
            default: null
        }
    },
    data() {
        return {
            newDuration: this.duration || config.defaultSnackbarDuration
        }
    },
    methods: {
        /**
        * Click listener.
        * Call action prop before closing (from Mixin).
        */
        action() {
            this.onAction();
            this.close();
        }
    }
};

const _hoisted_1$8 = ["role"];
const _hoisted_2$7 = ["innerHTML"];
const _hoisted_3$6 = { class: "button" };
const _hoisted_4$4 = { class: "button" };

function render$9(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock(Transition, {
    "enter-active-class": _ctx.transition.enter,
    "leave-active-class": _ctx.transition.leave,
    persisted: ""
  }, {
    default: withCtx(() => [
      withDirectives(createBaseVNode("div", {
        class: normalizeClass(["snackbar", [_ctx.type,_ctx.position]]),
        onMouseenter: _cache[2] || (_cache[2] = (...args) => (_ctx.pause && _ctx.pause(...args))),
        onMouseleave: _cache[3] || (_cache[3] = (...args) => (_ctx.removePause && _ctx.removePause(...args))),
        role: $props.actionText ? 'alertdialog' : 'alert'
      }, [
        (_ctx.$slots.default)
          ? renderSlot(_ctx.$slots, "default", { key: 0 })
          : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createCommentVNode(" eslint-disable-next-line vue/no-v-html "),
              createBaseVNode("div", {
                class: "text",
                innerHTML: _ctx.message
              }, null, 8 /* PROPS */, _hoisted_2$7)
            ], 64 /* STABLE_FRAGMENT */)),
        ($props.cancelText)
          ? (openBlock(), createElementBlock("div", {
              key: 2,
              class: "action is-light is-cancel",
              onClick: _cache[0] || (_cache[0] = (...args) => (_ctx.close && _ctx.close(...args)))
            }, [
              createBaseVNode("button", _hoisted_3$6, toDisplayString($props.cancelText), 1 /* TEXT */)
            ]))
          : createCommentVNode("v-if", true),
        ($props.actionText)
          ? (openBlock(), createElementBlock("div", {
              key: 3,
              class: normalizeClass(["action", _ctx.type]),
              onClick: _cache[1] || (_cache[1] = (...args) => ($options.action && $options.action(...args)))
            }, [
              createBaseVNode("button", _hoisted_4$4, toDisplayString($props.actionText), 1 /* TEXT */)
            ], 2 /* CLASS */))
          : createCommentVNode("v-if", true)
      ], 42 /* CLASS, PROPS, HYDRATE_EVENTS */, _hoisted_1$8), [
        [vShow, _ctx.isActive]
      ])
    ]),
    _: 3 /* FORWARDED */
  }, 8 /* PROPS */, ["enter-active-class", "leave-active-class"]))
}

script$9.render = render$9;
script$9.__file = "src/components/snackbar/Snackbar.vue";

function ownKeys$2(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$2(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$2(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var SnackbarProgrammatic = /*#__PURE__*/function () {
  function SnackbarProgrammatic(app) {
    _classCallCheck(this, SnackbarProgrammatic);
    this.app = app; // may be undefined in the testing environment
  }
  _createClass(SnackbarProgrammatic, [{
    key: "open",
    value: function open(params) {
      if (typeof params === 'string') {
        params = {
          message: params
        };
      }
      var defaultParam = {
        type: 'is-success',
        position: config.defaultSnackbarPosition || 'is-bottom-right',
        queue: true
      };
      if (params.parent) {
        delete params.parent;
      }
      var slot;
      if (Array.isArray(params.message)) {
        slot = params.message;
        delete params.message;
      }
      var propsData = merge(defaultParam, params);
      var container = document.createElement('div');
      // Vue 3 requires a new app to mount another component
      var vueInstance = createApp({
        data: function data() {
          return {
            snackbarVNode: null
          };
        },
        methods: {
          close: function close() {
            var snackbar = getComponentFromVNode(this.snackbarVNode);
            if (snackbar) {
              snackbar.close();
            }
          }
        },
        render: function render() {
          this.snackbarVNode = h(script$9, _objectSpread$2(_objectSpread$2({}, propsData), {}, {
            onClose: function onClose() {
              if (typeof propsData.onClose === 'function') {
                propsData.onClose();
              }
              // timeout for the animation complete
              // before unmounting
              setTimeout(function () {
                vueInstance.unmount();
              }, 150);
            }
          }), slot != null ? {
            "default": function _default() {
              return slot;
            }
          } : undefined);
          return this.snackbarVNode;
        }
      });
      if (this.app) {
        copyAppContext(this.app, vueInstance);
      } else {
        // adds $buefy global property so that
        // this.$buefy.globalNoticeInterval is available
        vueInstance.config.globalProperties.$buefy = {};
      }
      return vueInstance.mount(container);
    }
  }]);
  return SnackbarProgrammatic;
}();
var Plugin$a = {
  install: function install(Vue) {
    registerComponentProgrammatic(Vue, 'snackbar', new SnackbarProgrammatic(Vue));
  }
};

var _PatchFlagNames, _slotFlagsText;
var cacheStringFunction = function cacheStringFunction(fn) {
  var cache = /* @__PURE__ */Object.create(null);
  return function (str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
var camelizeRE = /-(\w)/g;
var camelize = cacheStringFunction(function (str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : "";
  });
});
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cacheStringFunction(function (str) {
  return str.replace(hyphenateRE, "-$1").toLowerCase();
});
var capitalize = cacheStringFunction(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
var toHandlerKey = cacheStringFunction(function (str) {
  var s = str ? "on".concat(capitalize(str)) : "";
  return s;
});
(_PatchFlagNames = {}, _defineProperty(_PatchFlagNames, 1, "TEXT"), _defineProperty(_PatchFlagNames, 2, "CLASS"), _defineProperty(_PatchFlagNames, 4, "STYLE"), _defineProperty(_PatchFlagNames, 8, "PROPS"), _defineProperty(_PatchFlagNames, 16, "FULL_PROPS"), _defineProperty(_PatchFlagNames, 32, "HYDRATE_EVENTS"), _defineProperty(_PatchFlagNames, 64, "STABLE_FRAGMENT"), _defineProperty(_PatchFlagNames, 128, "KEYED_FRAGMENT"), _defineProperty(_PatchFlagNames, 256, "UNKEYED_FRAGMENT"), _defineProperty(_PatchFlagNames, 512, "NEED_PATCH"), _defineProperty(_PatchFlagNames, 1024, "DYNAMIC_SLOTS"), _defineProperty(_PatchFlagNames, 2048, "DEV_ROOT_FRAGMENT"), _defineProperty(_PatchFlagNames, -1, "HOISTED"), _defineProperty(_PatchFlagNames, -2, "BAIL"));
(_slotFlagsText = {}, _defineProperty(_slotFlagsText, 1, "STABLE"), _defineProperty(_slotFlagsText, 2, "DYNAMIC"), _defineProperty(_slotFlagsText, 3, "FORWARDED"));

var SlotComponent = {
  name: 'BSlotComponent',
  props: {
    component: {
      type: Object,
      required: true
    },
    name: {
      type: String,
      "default": 'default'
    },
    scoped: {
      type: Boolean
    },
    props: {
      type: Object
    },
    tag: {
      type: String,
      "default": 'div'
    },
    event: {
      type: String,
      "default": 'vue:updated'
    }
  },
  data: function data() {
    return {
      updatedHook: undefined,
      handlerKey: undefined
    };
  },
  methods: {
    refresh: function refresh() {
      this.$forceUpdate();
    }
  },
  created: function created() {
    if (isVueComponent(this.component)) {
      if (this.event === 'vue:updated') {
        // lifecycle event cannot be captured as an ordinary event
        this.updatedHook = onUpdated(this.refresh, this.component.$);
      } else {
        // directly manipuates the VNode
        // because Vue 3 no longer provides $on
        var vnode = this.component.$.vnode;
        var handlerKey = toHandlerKey(this.event);
        if (vnode.props == null) {
          vnode.props = _defineProperty({}, handlerKey, this.refresh);
        } else {
          var props = vnode.props;
          if (props[this.handlerKey] == null) {
            // tries camelCase
            handlerKey = toHandlerKey(camelize(this.event));
            if (props[handlerKey] == null) {
              // tries kebab-case
              handlerKey = toHandlerKey(hyphenate(this.event));
            }
          }
          if (props[handlerKey] == null) {
            handlerKey = toHandlerKey(this.event);
            props[handlerKey] = this.refresh;
          } else {
            // multiple handlers may be specified in an array
            if (Array.isArray(props[handlerKey])) {
              props[handlerKey].push(this.refresh);
            } else {
              props[handlerKey] = [props[handlerKey], this.refresh];
            }
          }
        }
        this.handlerKey = handlerKey;
      }
    }
  },
  beforeUnmount: function beforeUnmount() {
    if (isVueComponent(this.component)) {
      if (this.updatedHook != null) {
        // unfortunately, there is no counterpart of `onUpdated`.
        // so directly manipulates the internal instance.
        // see https://github.com/vuejs/core/blob/2ffe3d5b3e953b63d4743b1e2bc242d50916b545/packages/runtime-core/src/apiLifecycle.ts#L17-L64
        var index = this.component.$.u.indexOf(this.updatedHook);
        if (index !== -1) {
          this.component.$.u.splice(index, 1);
        }
      } else if (this.handlerKey != null) {
        // directly maniputates VNode
        // because Vue 3 no longer provides $off
        var props = this.component.$.vnode.props;
        if (props != null) {
          if (Array.isArray(props[this.handlerKey])) {
            var _index = props[this.handlerKey].indexOf(this.refresh);
            if (_index > -1) {
              props[this.handlerKey].splice(_index, 1);
              if (props[this.handlerKey].length === 1) {
                props[this.handlerKey] = props[this.handlerKey][0];
              }
            }
          } else {
            delete props[this.handlerKey];
          }
        }
      }
    }
  },
  render: function render() {
    return h(this.tag, {}, this.component.$slots ? this.scoped ? this.component.$slots[this.name](this.props) : this.component.$slots[this.name]() : undefined);
  }
};

var TabbedMixin = (function (cmp) {
  var _components;
  return {
    mixins: [ProviderParentMixin(cmp, Sorted$1)],
    components: (_components = {}, _defineProperty(_components, script$I.name, script$I), _defineProperty(_components, SlotComponent.name, SlotComponent), _components),
    props: {
      modelValue: {
        type: [String, Number],
        "default": undefined
      },
      size: String,
      animated: {
        type: Boolean,
        "default": true
      },
      animation: String,
      animateInitially: Boolean,
      vertical: {
        type: Boolean,
        "default": false
      },
      position: String,
      destroyOnHide: {
        type: Boolean,
        "default": false
      }
    },
    emits: ['update:modelValue'],
    data: function data() {
      return {
        activeId: this.modelValue,
        // Internal state
        defaultSlots: [],
        contentHeight: 0,
        isTransitioning: false
      };
    },
    mounted: function mounted() {
      if (typeof this.modelValue === 'number') {
        // Backward compatibility: converts the index value to an id
        var value = bound(this.modelValue, 0, this.items.length - 1);
        this.activeId = this.items[value].uniqueValue;
      } else {
        this.activeId = this.modelValue;
      }
    },
    computed: {
      activeItem: function activeItem() {
        var _this = this;
        return this.activeId === undefined ? this.items[0] : this.activeId === null ? null : this.childItems.find(function (i) {
          return i.uniqueValue === _this.activeId;
        });
      },
      items: function items() {
        return this.sortedItems;
      }
    },
    watch: {
      /**
       * When v-model is changed set the new active tab.
       */
      modelValue: function modelValue(value) {
        if (typeof value === 'number') {
          // Backward compatibility: converts the index value to an id
          value = bound(value, 0, this.items.length - 1);
          this.activeId = this.items[value].uniqueValue;
        } else {
          this.activeId = value;
        }
      },
      /**
       * Sync internal state with external state
       */
      activeId: function activeId(val, oldValue) {
        var oldTab = oldValue !== undefined && oldValue !== null ? this.childItems.find(function (i) {
          return i.uniqueValue === oldValue;
        }) : null;
        if (oldTab && this.activeItem) {
          oldTab.deactivate(this.activeItem.index);
          this.activeItem.activate(oldTab.index);
        }
        val = this.activeItem ? typeof this.modelValue === 'number' ? this.items.indexOf(this.activeItem) : this.activeItem.uniqueValue : undefined;
        if (val !== this.modelValue) {
          this.$emit('update:modelValue', val);
        }
      }
    },
    methods: {
      /**
      * Child click listener, emit input event and change active child.
      */
      childClick: function childClick(child) {
        this.activeId = child.uniqueValue;
      },
      getNextItemIdx: function getNextItemIdx(fromIdx) {
        var skipDisabled = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var nextItemIdx = null;
        for (var i = 0; i < this.items.length; i++) {
          var item = this.items[i];
          if (fromIdx < item.index && item.visible && (!skipDisabled || skipDisabled && !item.disabled)) {
            nextItemIdx = item.index;
            break;
          }
        }
        return nextItemIdx;
      },
      getPrevItemIdx: function getPrevItemIdx(fromIdx) {
        var skipDisabled = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var prevItemIdx = null;
        for (var i = this.items.length - 1; i >= 0; i--) {
          var item = this.items[i];
          if (item.index < fromIdx && item.visible && (!skipDisabled || skipDisabled && !item.disabled)) {
            prevItemIdx = item.index;
            break;
          }
        }
        return prevItemIdx;
      }
    }
  };
});

var TabbedChildMixin = (function (parentCmp) {
  return {
    mixins: [InjectedChildMixin(parentCmp, Sorted)],
    props: {
      label: String,
      icon: String,
      iconPack: String,
      visible: {
        type: Boolean,
        "default": true
      },
      headerClass: {
        type: [String, Array, Object],
        "default": null
      }
    },
    data: function data() {
      return {
        transitionName: null,
        elementClass: 'item',
        elementRole: null
      };
    },
    computed: {
      isActive: function isActive() {
        return this.parent.activeItem === this;
      }
    },
    methods: {
      /**
       * Activate element, alter animation name based on the index.
       */
      activate: function activate(oldIndex) {
        this.transitionName = this.index < oldIndex ? this.parent.vertical ? 'slide-down' : 'slide-next' : this.parent.vertical ? 'slide-up' : 'slide-prev';
      },
      /**
       * Deactivate element, alter animation name based on the index.
       */
      deactivate: function deactivate(newIndex) {
        this.transitionName = newIndex < this.index ? this.parent.vertical ? 'slide-down' : 'slide-next' : this.parent.vertical ? 'slide-up' : 'slide-prev';
      }
    },
    render: function render() {
      var _this = this;
      // if destroy apply v-if
      if (this.parent.destroyOnHide) {
        if (!this.isActive || !this.visible) {
          return;
        }
      }
      var vnode = withDirectives(h('div', {
        // NOTE: possible regression of #3272
        // https://github.com/buefy/buefy/issues/3272
        "class": this.elementClass,
        role: this.elementRole,
        id: "".concat(this.uniqueValue, "-content"),
        'aria-labelledby': this.elementRole ? "".concat(this.uniqueValue, "-label") : null,
        tabindex: this.isActive ? 0 : -1
      }, this.$slots), [[vShow, this.isActive && this.visible]]);
      // check animated prop
      if (this.parent.animated) {
        return h(Transition, {
          name: this.parent.animation || this.transitionName,
          appear: this.parent.animateInitially === true || undefined,
          onBeforeEnter: function onBeforeEnter() {
            _this.parent.isTransitioning = true;
          },
          onAfterEnter: function onAfterEnter() {
            _this.parent.isTransitioning = false;
          }
        }, {
          "default": function _default() {
            return vnode;
          }
        });
      }
      return vnode;
    }
  };
});

var script$1$3 = {
    name: 'BSteps',
    components: {
        [script$I.name]: script$I
    },
    mixins: [TabbedMixin('step')],
    props: {
        type: [String, Object],
        iconPack: String,
        iconPrev: {
            type: String,
            default: () => {
                return config.defaultIconPrev
            }
        },
        iconNext: {
            type: String,
            default: () => {
                return config.defaultIconNext
            }
        },
        hasNavigation: {
            type: Boolean,
            default: true
        },
        labelPosition: {
            type: String,
            validator(value) {
                return [
                    'bottom',
                    'right',
                    'left'
                ].indexOf(value) > -1
            },
            default: 'bottom'
        },
        rounded: {
            type: Boolean,
            default: true
        },
        mobileMode: {
            type: String,
            validator(value) {
                return [
                    'minimalist',
                    'compact'
                ].indexOf(value) > -1
            },
            default: 'minimalist'
        },
        ariaNextLabel: String,
        ariaPreviousLabel: String
    },
    computed: {
        // Override mixin implementation to always have a value
        activeItem() {
            return this.childItems.filter((i) => i.uniqueValue === this.activeId)[0] ||
                this.items[0]
        },
        wrapperClasses() {
            return [
                this.size,
                {
                    'is-vertical': this.vertical,
                    [this.position]: this.position && this.vertical
                }
            ]
        },
        mainClasses() {
            return [
                this.type,
                {
                    'has-label-right': this.labelPosition === 'right',
                    'has-label-left': this.labelPosition === 'left',
                    'is-animated': this.animated,
                    'is-rounded': this.rounded,
                    [`mobile-${this.mobileMode}`]: this.mobileMode !== null
                }
            ]
        },

        /**
         * Check if previous button is available.
         */
        hasPrev() {
            return this.prevItemIdx !== null
        },

        /**
         * Retrieves the next visible item index
         */
        nextItemIdx() {
            const idx = this.activeItem ? this.activeItem.index : 0;
            return this.getNextItemIdx(idx)
        },

        /**
         * Retrieves the next visible item
         */
        nextItem() {
            let nextItem = null;
            if (this.nextItemIdx !== null) {
                nextItem = this.items.find((i) => i.index === this.nextItemIdx);
            }
            return nextItem
        },

        /**
        * Retrieves the next visible item index
        */
        prevItemIdx() {
            if (!this.activeItem) { return null }
            const idx = this.activeItem.index;
            return this.getPrevItemIdx(idx)
        },

        /**
         * Retrieves the previous visible item
         */
        prevItem() {
            if (!this.activeItem) { return null }

            let prevItem = null;
            if (this.prevItemIdx !== null) {
                prevItem = this.items.find((i) => i.index === this.prevItemIdx);
            }
            return prevItem
        },

        /**
         * Check if next button is available.
         */
        hasNext() {
            return this.nextItemIdx !== null
        },

        navigationProps() {
            return {
                previous: {
                    disabled: !this.hasPrev,
                    action: this.prev
                },
                next: {
                    disabled: !this.hasNext,
                    action: this.next
                }
            }
        }
    },
    methods: {
        /**
         * Return if the step should be clickable or not.
         */
        isItemClickable(stepItem) {
            if (stepItem.clickable === undefined) {
                return stepItem.index < this.activeItem.index
            }
            return stepItem.clickable
        },

        /**
         * Previous button click listener.
         */
        prev() {
            if (this.hasPrev) {
                this.activeId = this.prevItem.uniqueValue;
            }
        },

        /**
         * Previous button click listener.
         */
        next() {
            if (this.hasNext) {
                this.activeId = this.nextItem.uniqueValue;
            }
        }
    }
};

const _hoisted_1$7 = { class: "step-items" };
const _hoisted_2$6 = ["onClick"];
const _hoisted_3$5 = { class: "step-marker" };
const _hoisted_4$3 = { key: 1 };
const _hoisted_5$2 = { class: "step-details" };
const _hoisted_6$1 = { class: "step-title" };
const _hoisted_7$1 = {
  key: 0,
  class: "step-navigation"
};
const _hoisted_8$1 = ["disabled", "aria-label"];
const _hoisted_9$1 = ["disabled", "aria-label"];

function render$8(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_b_icon = resolveComponent("b-icon");

  return (openBlock(), createElementBlock("div", {
    class: normalizeClass(["b-steps", $options.wrapperClasses])
  }, [
    createBaseVNode("nav", {
      class: normalizeClass(["steps", $options.mainClasses])
    }, [
      createBaseVNode("ul", _hoisted_1$7, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.items, (childItem) => {
          return withDirectives((openBlock(), createElementBlock("li", {
            key: childItem.uniqueValue,
            class: normalizeClass(["step-item", [childItem.type || $props.type, childItem.headerClass, {
                        'is-active': childItem.isActive,
                        'is-previous': $options.activeItem.index > childItem.index
                    }]])
          }, [
            createBaseVNode("a", {
              class: normalizeClass(["step-link", {'is-clickable': $options.isItemClickable(childItem)}]),
              onClick: $event => ($options.isItemClickable(childItem) && _ctx.childClick(childItem))
            }, [
              createBaseVNode("div", _hoisted_3$5, [
                (childItem.icon)
                  ? (openBlock(), createBlock(_component_b_icon, {
                      key: 0,
                      icon: childItem.icon,
                      pack: childItem.iconPack,
                      size: _ctx.size
                    }, null, 8 /* PROPS */, ["icon", "pack", "size"]))
                  : (childItem.step)
                    ? (openBlock(), createElementBlock("span", _hoisted_4$3, toDisplayString(childItem.step), 1 /* TEXT */))
                    : createCommentVNode("v-if", true)
              ]),
              createBaseVNode("div", _hoisted_5$2, [
                createBaseVNode("span", _hoisted_6$1, toDisplayString(childItem.label), 1 /* TEXT */)
              ])
            ], 10 /* CLASS, PROPS */, _hoisted_2$6)
          ], 2 /* CLASS */)), [
            [vShow, childItem.visible]
          ])
        }), 128 /* KEYED_FRAGMENT */))
      ])
    ], 2 /* CLASS */),
    createBaseVNode("section", {
      class: normalizeClass(["step-content", {'is-transitioning': _ctx.isTransitioning}])
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 2 /* CLASS */),
    renderSlot(_ctx.$slots, "navigation", {
      previous: $options.navigationProps.previous,
      next: $options.navigationProps.next
    }, () => [
      ($props.hasNavigation)
        ? (openBlock(), createElementBlock("nav", _hoisted_7$1, [
            createBaseVNode("a", {
              role: "button",
              class: "pagination-previous",
              disabled: $options.navigationProps.previous.disabled || undefined,
              onClick: _cache[0] || (_cache[0] = withModifiers((...args) => ($options.navigationProps.previous.action && $options.navigationProps.previous.action(...args)), ["prevent"])),
              "aria-label": $props.ariaPreviousLabel
            }, [
              createVNode(_component_b_icon, {
                icon: $props.iconPrev,
                pack: $props.iconPack,
                both: "",
                "aria-hidden": "true"
              }, null, 8 /* PROPS */, ["icon", "pack"])
            ], 8 /* PROPS */, _hoisted_8$1),
            createBaseVNode("a", {
              role: "button",
              class: "pagination-next",
              disabled: $options.navigationProps.next.disabled || undefined,
              onClick: _cache[1] || (_cache[1] = withModifiers((...args) => ($options.navigationProps.next.action && $options.navigationProps.next.action(...args)), ["prevent"])),
              "aria-label": $props.ariaNextLabel
            }, [
              createVNode(_component_b_icon, {
                icon: $props.iconNext,
                pack: $props.iconPack,
                both: "",
                "aria-hidden": "true"
              }, null, 8 /* PROPS */, ["icon", "pack"])
            ], 8 /* PROPS */, _hoisted_9$1)
          ]))
        : createCommentVNode("v-if", true)
    ])
  ], 2 /* CLASS */))
}

script$1$3.render = render$8;
script$1$3.__file = "src/components/steps/Steps.vue";

var script$8 = {
    name: 'BStepItem',
    mixins: [TabbedChildMixin('step')],
    props: {
        step: [String, Number],
        type: [String, Object],
        clickable: {
            type: Boolean,
            default: undefined
        }
    },
    data() {
        return {
            elementClass: 'step-item'
        }
    }
};

script$8.__file = "src/components/steps/StepItem.vue";

var Plugin$9 = {
  install: function install(Vue) {
    registerComponent(Vue, script$1$3);
    registerComponent(Vue, script$8);
  }
};

var script$7 = {
    name: 'BSwitch',
    props: {
        modelValue: [String, Number, Boolean, Function, Object, Array, Date],
        nativeValue: [String, Number, Boolean, Function, Object, Array, Date],
        disabled: Boolean,
        type: String,
        passiveType: String,
        name: String,
        required: Boolean,
        size: String,
        ariaLabelledby: String,
        trueValue: {
            type: [String, Number, Boolean, Function, Object, Array, Date],
            default: true
        },
        falseValue: {
            type: [String, Number, Boolean, Function, Object, Array, Date],
            default: false
        },
        rounded: {
            type: Boolean,
            default: () => {
                return config.defaultSwitchRounded
            }
        },
        outlined: {
            type: Boolean,
            default: false
        },
        leftLabel: {
            type: Boolean,
            default: false
        }
    },
    emits: ['update:modelValue'],
    data() {
        return {
            newValue: this.modelValue,
            isMouseDown: false
        }
    },
    computed: {
        computedValue: {
            get() {
                return this.newValue
            },
            set(value) {
                this.newValue = value;
                this.$emit('update:modelValue', value);
            }
        },
        newClass() {
            return [
                this.size,
                {
                    'is-disabled': this.disabled,
                    'is-rounded': this.rounded,
                    'is-outlined': this.outlined,
                    'has-left-label': this.leftLabel
                }
            ]
        },
        checkClasses() {
            return [
                { 'is-elastic': this.isMouseDown && !this.disabled },
                (this.passiveType && `${this.passiveType}-passive`),
                this.type
            ]
        },
        showControlLabel() {
            return !!this.$slots.default
        },
        disabledOrUndefined() {
            // On Vue 3, setting boolean attribute `false` does not remove it.
            // To do so, `null` or `undefined` has to be specified instead.
            // Setting `disabled="false"` ends up with a grayed out switch.
            return this.disabled || undefined
        }
    },
    watch: {
        /**
        * When v-model change, set internal value.
        */
        modelValue(value) {
            this.newValue = value;
        }
    },
    methods: {
        focus() {
            // MacOS FireFox and Safari do not focus when clicked
            this.$refs.input.focus();
        }
    }
};

const _hoisted_1$6 = ["disabled"];
const _hoisted_2$5 = ["disabled", "name", "required", "value", "true-value", "false-value", "aria-labelledby"];
const _hoisted_3$4 = ["id"];

function render$7(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createElementBlock("label", {
    class: normalizeClass(["switch", $options.newClass]),
    ref: "label",
    disabled: $options.disabledOrUndefined,
    onClick: _cache[2] || (_cache[2] = (...args) => ($options.focus && $options.focus(...args))),
    onKeydown: _cache[3] || (_cache[3] = withKeys(withModifiers($event => (_ctx.$refs.label.click()), ["prevent"]), ["enter"])),
    onMousedown: _cache[4] || (_cache[4] = $event => ($data.isMouseDown = true)),
    onMouseup: _cache[5] || (_cache[5] = $event => ($data.isMouseDown = false)),
    onMouseout: _cache[6] || (_cache[6] = $event => ($data.isMouseDown = false)),
    onBlur: _cache[7] || (_cache[7] = $event => ($data.isMouseDown = false))
  }, [
    withDirectives(createBaseVNode("input", {
      "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => (($options.computedValue) = $event)),
      type: "checkbox",
      ref: "input",
      onClick: _cache[1] || (_cache[1] = withModifiers(() => {}, ["stop"])),
      disabled: $options.disabledOrUndefined,
      name: $props.name,
      required: $props.required,
      value: $props.nativeValue,
      "true-value": $props.trueValue,
      "false-value": $props.falseValue,
      "aria-labelledby": $props.ariaLabelledby
    }, null, 8 /* PROPS */, _hoisted_2$5), [
      [vModelCheckbox, $options.computedValue]
    ]),
    createBaseVNode("span", {
      class: normalizeClass(["check", $options.checkClasses])
    }, null, 2 /* CLASS */),
    ($options.showControlLabel)
      ? (openBlock(), createElementBlock("span", {
          key: 0,
          id: $props.ariaLabelledby,
          class: "control-label"
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 8 /* PROPS */, _hoisted_3$4))
      : createCommentVNode("v-if", true)
  ], 42 /* CLASS, PROPS, HYDRATE_EVENTS */, _hoisted_1$6))
}

script$7.render = render$7;
script$7.__file = "src/components/switch/Switch.vue";

var Plugin$8 = {
  install: function install(Vue) {
    registerComponent(Vue, script$7);
  }
};

var script$3$1 = {
    name: 'BTableMobileSort',
    components: {
        [script$v.name]: script$v,
        [script$I.name]: script$I
    },
    props: {
        currentSortColumn: Object,
        sortMultipleData: Array,
        isAsc: Boolean,
        columns: Array,
        placeholder: String,
        iconPack: String,
        sortIcon: {
            type: String,
            default: 'arrow-up'
        },
        sortIconSize: {
            type: String,
            default: 'is-small'
        },
        sortMultiple: {
            type: Boolean,
            default: false
        }
    },
    emits: ['removePriority', 'sort'],
    data() {
        return {
            sortMultipleSelect: '',
            sortMultipleSelectIndex: -1,
            mobileSort: this.currentSortColumn,
            mobileSortIndex: this.columns ? this.columns.indexOf(this.currentSortColumn) : -1,
            defaultEvent: {
                shiftKey: true,
                altKey: true,
                ctrlKey: true
            },
            ignoreSort: false
        }
    },
    computed: {
        showPlaceholder() {
            return !this.columns || !this.columns.some((column) => column === this.mobileSort)
        },
        sortableColumns() {
            return this.columns && this.columns.filter((column) => column.sortable)
        }
    },
    watch: {
        sortMultipleSelect(column) {
            if (this.ignoreSort) {
                this.ignoreSort = false;
            } else {
                this.$emit('sort', column, this.defaultEvent);
            }
        },
        sortMultipleSelectIndex(index) {
            if (index !== -1) {
                this.sortMultipleSelect = this.columns[index];
            } else {
                this.sortMultipleSelect = null;
            }
        },
        mobileSort(column) {
            if (this.currentSortColumn === column) return

            this.$emit('sort', column, this.defaultEvent);
        },
        mobileSortIndex(index) {
            if (index !== -1) {
                this.mobileSort = this.columns[index];
            }
            // `index` becomes -1 if `currentSortColumn` is not in `columns`
            // never resets to null but retains `mobileSort` in that case
        },
        currentSortColumn(column) {
            // replaces `mobileSort` whether `column` is in `columns` or not
            this.mobileSort = column;
            this.mobileSortIndex = this.columns ? this.columns.indexOf(column) : -1;
        },
        columns(newColumns) {
            if (this.sortMultiple) {
                this.sortMultipleSelectIndex = newColumns.indexOf(
                    this.sortMultipleSelect
                );
            } else {
                this.mobileSortIndex = newColumns.indexOf(this.mobileSort);
            }
        }
    },
    methods: {
        removePriority() {
            this.$emit('removePriority', this.sortMultipleSelect);
            // ignore the watcher to sort when we just change whats displayed in the select
            // otherwise the direction will be flipped
            // The sort event is already triggered by the emit
            this.ignoreSort = true;
            // Select one of the other options when we reset one
            const remainingFields = this.sortMultipleData.filter((data) =>
                data.field !== this.sortMultipleSelect.field)
                .map((data) => data.field);
            this.sortMultipleSelectIndex = this.columns.findIndex((column) =>
                remainingFields.includes(column.field));
        },
        getSortingObjectOfColumn(column) {
            return this.sortMultipleData.filter((i) =>
                i.field === column.field)[0]
        },
        columnIsDesc(column) {
            const sortingObject = this.getSortingObjectOfColumn(column);
            if (sortingObject) {
                return !!(sortingObject.order && sortingObject.order === 'desc')
            }
            return true
        },
        getLabel(column) {
            const sortingObject = this.getSortingObjectOfColumn(column);
            if (sortingObject) {
                return column.label + '(' + (this.sortMultipleData.indexOf(sortingObject) + 1) + ')'
            }
            return column.label
        },
        sort() {
            this.$emit('sort', (this.sortMultiple ? this.sortMultipleSelect : this.mobileSort), this.defaultEvent);
        }
    }
};

const _hoisted_1$2$1 = { class: "field table-mobile-sort" };
const _hoisted_2$2$1 = { class: "field has-addons" };
const _hoisted_3$2 = ["value"];
const _hoisted_4$2 = ["value"];
const _hoisted_5$1 = { class: "control" };

function render$2$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_b_select = resolveComponent("b-select");
  const _component_b_icon = resolveComponent("b-icon");

  return (openBlock(), createElementBlock("div", _hoisted_1$2$1, [
    createBaseVNode("div", _hoisted_2$2$1, [
      ($props.sortMultiple)
        ? (openBlock(), createBlock(_component_b_select, {
            key: 0,
            modelValue: $data.sortMultipleSelectIndex,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => (($data.sortMultipleSelectIndex) = $event)),
            expanded: ""
          }, {
            default: withCtx(() => [
              (openBlock(true), createElementBlock(Fragment, null, renderList($options.sortableColumns, (column, index) => {
                return (openBlock(), createElementBlock("option", {
                  key: index,
                  value: index
                }, [
                  createTextVNode(toDisplayString($options.getLabel(column)) + " ", 1 /* TEXT */),
                  ($options.getSortingObjectOfColumn(column))
                    ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                        ($options.columnIsDesc(column))
                          ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                              createTextVNode(" ↓ ")
                            ], 64 /* STABLE_FRAGMENT */))
                          : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                              createTextVNode(" ↑ ")
                            ], 64 /* STABLE_FRAGMENT */))
                      ], 64 /* STABLE_FRAGMENT */))
                    : createCommentVNode("v-if", true)
                ], 8 /* PROPS */, _hoisted_3$2))
              }), 128 /* KEYED_FRAGMENT */))
            ]),
            _: 1 /* STABLE */
          }, 8 /* PROPS */, ["modelValue"]))
        : (openBlock(), createBlock(_component_b_select, {
            key: 1,
            modelValue: $data.mobileSortIndex,
            "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => (($data.mobileSortIndex) = $event)),
            expanded: ""
          }, {
            default: withCtx(() => [
              ($props.placeholder)
                ? withDirectives((openBlock(), createElementBlock("option", {
                    key: 0,
                    value: {},
                    selected: "",
                    disabled: "",
                    hidden: ""
                  }, toDisplayString($props.placeholder), 513 /* TEXT, NEED_PATCH */)), [
                    [vShow, $options.showPlaceholder]
                  ])
                : createCommentVNode("v-if", true),
              (openBlock(true), createElementBlock(Fragment, null, renderList($options.sortableColumns, (column, index) => {
                return (openBlock(), createElementBlock("option", {
                  key: index,
                  value: index
                }, toDisplayString(column.label), 9 /* TEXT, PROPS */, _hoisted_4$2))
              }), 128 /* KEYED_FRAGMENT */))
            ]),
            _: 1 /* STABLE */
          }, 8 /* PROPS */, ["modelValue"])),
      createBaseVNode("div", _hoisted_5$1, [
        ($props.sortMultiple && $props.sortMultipleData.length > 0)
          ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createBaseVNode("button", {
                class: "button is-primary",
                onClick: _cache[2] || (_cache[2] = (...args) => ($options.sort && $options.sort(...args)))
              }, [
                createVNode(_component_b_icon, {
                  class: normalizeClass({ 'is-desc': $options.columnIsDesc($data.sortMultipleSelect) }),
                  icon: $props.sortIcon,
                  pack: $props.iconPack,
                  size: $props.sortIconSize,
                  both: ""
                }, null, 8 /* PROPS */, ["class", "icon", "pack", "size"])
              ]),
              createBaseVNode("button", {
                class: "button is-primary",
                onClick: _cache[3] || (_cache[3] = (...args) => ($options.removePriority && $options.removePriority(...args)))
              }, [
                createVNode(_component_b_icon, {
                  icon: "delete",
                  size: $props.sortIconSize,
                  both: ""
                }, null, 8 /* PROPS */, ["size"])
              ])
            ], 64 /* STABLE_FRAGMENT */))
          : (!$props.sortMultiple)
            ? (openBlock(), createElementBlock("button", {
                key: 1,
                class: "button is-primary",
                onClick: _cache[4] || (_cache[4] = (...args) => ($options.sort && $options.sort(...args)))
              }, [
                withDirectives(createVNode(_component_b_icon, {
                  class: normalizeClass({ 'is-desc': !$props.isAsc }),
                  icon: $props.sortIcon,
                  pack: $props.iconPack,
                  size: $props.sortIconSize,
                  both: ""
                }, null, 8 /* PROPS */, ["class", "icon", "pack", "size"]), [
                  [vShow, $props.currentSortColumn === $data.mobileSort]
                ])
              ]))
            : createCommentVNode("v-if", true)
      ])
    ])
  ]))
}

script$3$1.render = render$2$1;
script$3$1.__file = "src/components/table/TableMobileSort.vue";

var script$2$1 = {
    name: 'BTableColumn',
    inject: {
        $table: { name: '$table', default: false }
    },
    props: {
        label: String,
        customKey: [String, Number],
        field: String,
        meta: [String, Number, Boolean, Function, Object, Array],
        width: [Number, String],
        numeric: Boolean,
        centered: Boolean,
        searchable: Boolean,
        sortable: Boolean,
        visible: {
            type: Boolean,
            default: true
        },
        subheading: [String, Number],
        customSort: Function,
        customSearch: Function,
        sticky: Boolean,
        headerSelectable: Boolean,
        headerClass: String,
        cellClass: String,
        thAttrs: {
            type: Function,
            default: () => ({})
        },
        tdAttrs: {
            type: Function,
            default: () => ({})
        }
    },
    data() {
        return {
            newKey: this.customKey || this.label,
            _isTableColumn: true
        }
    },
    computed: {
        thClasses() {
            const attrs = this.thAttrs(this);
            const classes = [this.headerClass, {
                'is-sortable': this.sortable,
                'is-sticky': this.sticky,
                'is-unselectable': this.isHeaderUnSelectable
            }];
            if (attrs && attrs.class) {
                classes.push(attrs.class);
            }
            return classes
        },
        thStyle() {
            const attrs = this.thAttrs(this);
            const style = [this.style];
            if (attrs && attrs.style) {
                style.push(attrs.style);
            }
            return style
        },
        thWrapStyle() {
            const width = toCssWidth(this.width);
            // interestingly, percentage width on the th element has effect
            // so we won't apply it to .th-wrap
            if (width != null && !width.trim().endsWith('%')) {
                return { width }
            } else {
                return {}
            }
        },
        rootClasses() {
            return [this.cellClass, {
                'has-text-right': this.numeric && !this.centered,
                'has-text-centered': this.centered,
                'is-sticky': this.sticky
            }]
        },
        style() {
            return {
                width: toCssWidth(this.width)
            }
        },
        hasDefaultSlot() {
            return !!this.$slots.default
        },
        /**
         * Return if column header is un-selectable
         */
        isHeaderUnSelectable() {
            return !this.headerSelectable && this.sortable
        }
    },
    methods: {
        getRootClasses(row) {
            const attrs = this.tdAttrs(row, this);
            const classes = [this.rootClasses];
            if (attrs && attrs.class) {
                classes.push(attrs.class);
            }
            return classes
        },
        getRootStyle(row) {
            const attrs = this.tdAttrs(row, this);
            const style = [];
            if (attrs && attrs.style) {
                style.push(attrs.style);
            }
            return style
        }
    },
    created() {
        if (!this.$table) {
            throw new Error('You should wrap bTableColumn on a bTable')
        }
        this.$table._registerTableColumn(this);
    },
    beforeUnmount() {
        this.$table._unregisterTableColumn(this);
    },
    render(createElement) {
        // renderless
        return null
    }
};

script$2$1.__file = "src/components/table/TableColumn.vue";

var script$1$2 = {
    name: 'BTablePagination',
    components: {
        [script$g.name]: script$g
    },
    props: {
        paginated: Boolean,
        total: [Number, String],
        perPage: [Number, String],
        currentPage: [Number, String],
        paginationSimple: Boolean,
        paginationSize: String,
        rounded: Boolean,
        iconPack: String,
        ariaNextLabel: String,
        ariaPreviousLabel: String,
        ariaPageLabel: String,
        ariaCurrentLabel: String,
        pageInput: Boolean,
        paginationOrder: String,
        pageInputPosition: String,
        debouncePageInput: [Number, String]
    },
    emits: ['page-change', 'update:currentPage'],
    data() {
        return {
            newCurrentPage: this.currentPage
        }
    },
    watch: {
        currentPage(newVal) {
            this.newCurrentPage = newVal;
        }
    },
    methods: {
        /**
        * Paginator change listener.
        */
        pageChanged(page) {
            this.newCurrentPage = page > 0 ? page : 1;
            this.$emit('update:currentPage', this.newCurrentPage);
            this.$emit('page-change', this.newCurrentPage);
        }
    }
};

const _hoisted_1$1$1 = { class: "top level" };
const _hoisted_2$1$1 = { class: "level-left" };
const _hoisted_3$1$1 = { class: "level-right" };
const _hoisted_4$1 = {
  key: 0,
  class: "level-item"
};

function render$1$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_b_pagination = resolveComponent("b-pagination");

  return (openBlock(), createElementBlock("div", _hoisted_1$1$1, [
    createBaseVNode("div", _hoisted_2$1$1, [
      renderSlot(_ctx.$slots, "default")
    ]),
    createBaseVNode("div", _hoisted_3$1$1, [
      ($props.paginated)
        ? (openBlock(), createElementBlock("div", _hoisted_4$1, [
            createVNode(_component_b_pagination, {
              "icon-pack": $props.iconPack,
              total: $props.total,
              "per-page": $props.perPage,
              simple: $props.paginationSimple,
              size: $props.paginationSize,
              "model-value": $data.newCurrentPage,
              rounded: $props.rounded,
              onChange: $options.pageChanged,
              "aria-next-label": $props.ariaNextLabel,
              "aria-previous-label": $props.ariaPreviousLabel,
              "aria-page-label": $props.ariaPageLabel,
              "aria-current-label": $props.ariaCurrentLabel,
              "page-input": $props.pageInput,
              order: $props.paginationOrder,
              "page-input-position": $props.pageInputPosition,
              "debounce-page-input": $props.debouncePageInput
            }, null, 8 /* PROPS */, ["icon-pack", "total", "per-page", "simple", "size", "model-value", "rounded", "onChange", "aria-next-label", "aria-previous-label", "aria-page-label", "aria-current-label", "page-input", "order", "page-input-position", "debounce-page-input"])
          ]))
        : createCommentVNode("v-if", true)
    ])
  ]))
}

script$1$2.render = render$1$1;
script$1$2.__file = "src/components/table/TablePagination.vue";

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var tinyEmitter = {exports: {}};

function E() {
  // Keep this empty so it's easier to inherit from
  // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)
}
E.prototype = {
  on: function on(name, callback, ctx) {
    var e = this.e || (this.e = {});
    (e[name] || (e[name] = [])).push({
      fn: callback,
      ctx: ctx
    });
    return this;
  },
  once: function once(name, callback, ctx) {
    var self = this;
    function listener() {
      self.off(name, listener);
      callback.apply(ctx, arguments);
    }
    listener._ = callback;
    return this.on(name, listener, ctx);
  },
  emit: function emit(name) {
    var data = [].slice.call(arguments, 1);
    var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
    var i = 0;
    var len = evtArr.length;
    for (i; i < len; i++) {
      evtArr[i].fn.apply(evtArr[i].ctx, data);
    }
    return this;
  },
  off: function off(name, callback) {
    var e = this.e || (this.e = {});
    var evts = e[name];
    var liveEvents = [];
    if (evts && callback) {
      for (var i = 0, len = evts.length; i < len; i++) {
        if (evts[i].fn !== callback && evts[i].fn._ !== callback) liveEvents.push(evts[i]);
      }
    }

    // Remove event from queue to prevent memory leak
    // Suggested by https://github.com/lazd
    // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910

    liveEvents.length ? e[name] = liveEvents : delete e[name];
    return this;
  }
};
tinyEmitter.exports = E;
tinyEmitter.exports.TinyEmitter = E;

var tinyEmitterExports = tinyEmitter.exports;
var Emitter = /*@__PURE__*/getDefaultExportFromCjs(tinyEmitterExports);

function ownKeys$1(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$1(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$1(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function mockTableColumn(table, column) {
  var eventEmitter = new Emitter();
  var defaultProps = {
    label: undefined,
    customKey: undefined,
    field: undefined,
    meta: undefined,
    width: undefined,
    numeric: undefined,
    centered: undefined,
    searchable: undefined,
    sortable: undefined,
    visible: true,
    subheading: undefined,
    customSort: undefined,
    customSearch: undefined,
    sticky: undefined,
    headerSelectable: undefined,
    headerClass: undefined,
    thAttrs: function thAttrs() {
      return {};
    },
    tdAttrs: function tdAttrs() {
      return {};
    }
  };
  return _objectSpread$1(_objectSpread$1(_objectSpread$1({}, defaultProps), column), {}, {
    // data
    parent: table,
    newKey: column.customKey || column.label,
    _isTableColumn: true,
    // inject
    $table: table,
    // computed
    get thClasses() {
      var attrs = this.thAttrs(this);
      var classes = [this.headerClass, {
        'is-sortable': this.sortable,
        'is-sticky': this.sticky,
        'is-unselectable': this.isHeaderUnSelectable
      }];
      if (attrs && attrs["class"]) {
        classes.push(attrs["class"]);
      }
      return classes;
    },
    get thStyle() {
      var attrs = this.thAttrs(this);
      var style = [this.style];
      if (attrs && attrs.style) {
        style.push(attrs.style);
      }
      return style;
    },
    get thWrapStyle() {
      return this.style;
    },
    get rootClasses() {
      return [this.cellClass, {
        'has-text-right': this.numeric && !this.centered,
        'has-text-centered': this.centered,
        'is-sticky': this.sticky
      }];
    },
    get style() {
      return {
        width: toCssWidth(this.width)
      };
    },
    get hasDefaultSlot() {
      return !!this.$scopedSlots["default"];
    },
    get isHeaderUnSelectable() {
      return !this.headerSelectable && this.sortable;
    },
    // methods
    getRootClasses: function getRootClasses(row) {
      var attrs = this.tdAttrs(row, this);
      var classes = [this.rootClasses];
      if (attrs && attrs["class"]) {
        classes.push(attrs["class"]);
      }
      return classes;
    },
    getRootStyle: function getRootStyle(row) {
      var attrs = this.tdAttrs(row, this);
      var style = [];
      if (attrs && attrs.style) {
        style.push(attrs.style);
      }
      return style;
    },
    $on: function $on() {
      return eventEmitter.on.apply(eventEmitter, arguments);
    },
    $once: function $once() {
      return eventEmitter.once.apply(eventEmitter, arguments);
    },
    $off: function $off() {
      return eventEmitter.off.apply(eventEmitter, arguments);
    },
    $emit: function $emit() {
      return eventEmitter.emit.apply(eventEmitter, arguments);
    },
    // special fields
    _isVue: true,
    $slots: {
      "default": function _default(props) {
        var vnode = h('span', {
          innerHTML: getValueByPath(props.row, column.field)
        });
        return [vnode];
      }
    }
  });
}

var script$6 = {
    name: 'BTable',
    components: {
        [script$B.name]: script$B,
        [script$I.name]: script$I,
        [script$H.name]: script$H,
        [script$n.name]: script$n,
        [SlotComponent.name]: SlotComponent,
        [script$3$1.name]: script$3$1,
        [script$2$1.name]: script$2$1,
        [script$1$2.name]: script$1$2
    },
    mixins: [CompatFallthroughMixin],
    provide() {
        return {
            $table: this
        }
    },
    props: {
        data: {
            type: Array,
            default: () => []
        },
        columns: {
            type: Array,
            default: () => []
        },
        bordered: Boolean,
        striped: Boolean,
        narrowed: Boolean,
        hoverable: Boolean,
        loading: Boolean,
        detailed: Boolean,
        checkable: Boolean,
        headerCheckable: {
            type: Boolean,
            default: true
        },
        checkboxType: {
            type: String,
            default: 'is-primary'
        },
        checkboxPosition: {
            type: String,
            default: 'left',
            validator: (value) => {
                return [
                    'left',
                    'right'
                ].indexOf(value) >= 0
            }
        },
        stickyCheckbox: {
            type: Boolean,
            default: false
        },
        selected: Object,
        isRowSelectable: {
            type: Function,
            default: () => true
        },
        focusable: Boolean,
        customIsChecked: Function,
        isRowCheckable: {
            type: Function,
            default: () => true
        },
        checkedRows: {
            type: Array,
            default: () => []
        },
        mobileCards: {
            type: Boolean,
            default: true
        },
        defaultSort: [String, Array],
        defaultSortDirection: {
            type: String,
            default: 'asc'
        },
        sortIcon: {
            type: String,
            default: 'arrow-up'
        },
        sortIconSize: {
            type: String,
            default: 'is-small'
        },
        sortMultiple: {
            type: Boolean,
            default: false
        },
        sortMultipleData: {
            type: Array,
            default: () => []
        },
        sortMultipleKey: {
            type: String,
            default: null
        },
        paginated: Boolean,
        currentPage: {
            type: Number,
            default: 1
        },
        perPage: {
            type: [Number, String],
            default: 20
        },
        showDetailIcon: {
            type: Boolean,
            default: true
        },
        detailIcon: {
            type: String,
            default: 'chevron-right'
        },
        paginationPosition: {
            type: String,
            default: 'bottom',
            validator: (value) => {
                return [
                    'bottom',
                    'top',
                    'both'
                ].indexOf(value) >= 0
            }
        },
        paginationRounded: Boolean,
        backendSorting: Boolean,
        backendFiltering: Boolean,
        rowClass: {
            type: Function,
            default: () => ''
        },
        openedDetailed: {
            type: Array,
            default: () => []
        },
        hasDetailedVisible: {
            type: Function,
            default: () => true
        },
        detailKey: {
            type: String,
            default: ''
        },
        detailTransition: {
            type: String,
            default: ''
        },
        customDetailRow: {
            type: Boolean,
            default: false
        },
        backendPagination: Boolean,
        total: {
            type: [Number, String],
            default: 0
        },
        iconPack: String,
        mobileSortPlaceholder: String,
        customRowKey: String,
        draggable: {
            type: Boolean,
            default: false
        },
        draggableColumn: {
            type: Boolean,
            default: false
        },
        scrollable: Boolean,
        ariaNextLabel: String,
        ariaPreviousLabel: String,
        ariaPageLabel: String,
        ariaCurrentLabel: String,
        stickyHeader: Boolean,
        height: [Number, String],
        filtersEvent: {
            type: String,
            default: ''
        },
        cardLayout: Boolean,
        showHeader: {
            type: Boolean,
            default: true
        },
        debounceSearch: Number,
        caption: String,
        showCaption: {
            type: Boolean,
            default: true
        },
        pageInput: {
            type: Boolean,
            default: false
        },
        paginationOrder: String,
        pageInputPosition: String,
        debouncePageInput: [Number, String]
    },
    emits: [
        'cellclick',
        'check',
        'check-all',
        'click',
        'columndragend',
        'columndragleave',
        'columndragover',
        'columndragstart',
        'columndrop',
        'contextmenu',
        'dblclick',
        'details-close',
        'details-open',
        'dragend',
        'dragleave',
        'dragover',
        'dragstart',
        'drop',
        'filters-change',
        'page-change',
        'select',
        'sort',
        'sorting-priority-removed',
        'update:checkedRows',
        'update:currentPage',
        'update:openedDetailed',
        'update:selected'
    ],
    data() {
        return {
            sortMultipleDataLocal: [],
            getValueByPath,
            visibleDetailRows: this.openedDetailed,
            newData: this.data,
            newDataTotal: this.backendPagination ? this.total : this.data.length,
            newCheckedRows: [...this.checkedRows],
            lastCheckedRowIndex: null,
            newCurrentPage: this.currentPage,
            currentSortColumn: {},
            isAsc: true,
            filters: {},
            defaultSlots: [],
            firstTimeSort: true, // Used by first time initSort
            _isTable: true, // Used by TableColumn
            isDraggingRow: false,
            isDraggingColumn: false,
            // for touch-enabled devices
            _selectedRow: null,
            mayBeTouchDragging: false,
            touchDragoverTarget: null,
            _draggedCellEl: undefined,
            draggedCellContent: ''
        }
    },
    computed: {
        sortMultipleDataComputed() {
            return this.backendSorting ? this.sortMultipleData : this.sortMultipleDataLocal
        },
        tableClasses() {
            return {
                'is-bordered': this.bordered,
                'is-striped': this.striped,
                'is-narrow': this.narrowed,
                'is-hoverable': (
                    (this.hoverable || this.focusable) &&
                    this.visibleData.length
                )
            }
        },
        tableWrapperClasses() {
            return {
                'has-mobile-cards': this.mobileCards,
                'has-sticky-header': this.stickyHeader,
                'is-card-list': this.cardLayout,
                'table-container': this.isScrollable
            }
        },
        tableStyle() {
            return {
                height: toCssWidth(this.height)
            }
        },
        touchDraggedCellClasses() {
            return {
                'has-mobile-cards': this.mobileCards
            }
        },

        /**
        * Splitted data based on the pagination.
        */
        visibleData() {
            if (!this.paginated) return this.newData

            const currentPage = this.newCurrentPage;
            const perPage = this.perPage;

            if (this.newData.length <= perPage) {
                return this.newData
            } else {
                const start = (currentPage - 1) * perPage;
                const end = parseInt(start, 10) + parseInt(perPage, 10);
                return this.newData.slice(start, end)
            }
        },

        visibleColumns() {
            if (!this.newColumns) return this.newColumns
            return this.newColumns.filter((column) => {
                return column.visible || column.visible === undefined
            })
        },

        /**
        * Check if all rows in the page are checked.
        */
        isAllChecked() {
            const validVisibleData = this.visibleData.filter(
                (row) => this.isRowCheckable(row));
            if (validVisibleData.length === 0) return false
            const isAllChecked = validVisibleData.some((currentVisibleRow) => {
                return indexOf(this.newCheckedRows, currentVisibleRow, this.customIsChecked) < 0
            });
            return !isAllChecked
        },

        /**
        * Check if all rows in the page are checkable.
        */
        isAllUncheckable() {
            const validVisibleData = this.visibleData.filter(
                (row) => this.isRowCheckable(row));
            return validVisibleData.length === 0
        },

        /**
        * Check if has any sortable column.
        */
        hasSortablenewColumns() {
            return this.newColumns.some((column) => {
                return column.sortable
            })
        },

        /**
        * Check if has any searchable column.
        */
        hasSearchablenewColumns() {
            return this.newColumns.some((column) => {
                return column.searchable
            })
        },

        /**
        * Check if has any column using subheading.
        */
        hasCustomSubheadings() {
            if (this.$slots && this.$slots.subheading) return true
            return this.newColumns.some((column) => {
                return column.subheading || column.$slots.subheading
            })
        },

        /**
        * Return total column count based if it's checkable or expanded
        */
        columnCount() {
            let count = this.visibleColumns.length;
            count += this.checkable ? 1 : 0;
            count += (this.detailed && this.showDetailIcon) ? 1 : 0;

            return count
        },

        /**
        * return if detailed row tabled
        * will be with chevron column & icon or not
        */
        showDetailRowIcon() {
            return this.detailed && this.showDetailIcon
        },

        /**
        * return if scrollable table
        */
        isScrollable() {
            if (this.scrollable) return true
            if (!this.newColumns) return false
            return this.newColumns.some((column) => {
                return column.sticky
            })
        },

        newColumns() {
            if (this.columns && this.columns.length) {
                return this.columns.map((column) => {
                    return mockTableColumn(this, column)
                })
            }
            return this.defaultSlots
        },
        canDragRow() {
            return this.draggable && !this.isDraggingColumn
        },
        canDragColumn() {
            return this.draggableColumn && !this.isDraggingRow
        }
    },
    watch: {
        /**
        * When data prop change:
        *   1. Update internal value.
        *   2. Filter data if it's not backend-filtered.
        *   3. Sort again if it's not backend-sorted.
        *   4. Set new total if it's not backend-paginated.
        */
        data(value) {
            this.newData = value;
            if (!this.backendFiltering) {
                this.newData = value.filter(
                    (row) => this.isRowFiltered(row));
            }
            if (!this.backendSorting) {
                this.sort(this.currentSortColumn, true);
            }
            if (!this.backendPagination) {
                this.newDataTotal = this.newData.length;
            }
        },

        /**
        * When Pagination total change, update internal total
        * only if it's backend-paginated.
        */
        total(newTotal) {
            if (!this.backendPagination) return

            this.newDataTotal = newTotal;
        },

        currentPage(newVal) {
            this.newCurrentPage = newVal;
        },

        newCurrentPage(newVal) {
            this.$emit('update:currentPage', newVal);
        },

        /**
        * When checkedRows prop change, update internal value without
        * mutating original data.
        */
        checkedRows(rows) {
            this.newCheckedRows = [...rows];
        },

        /*
        newColumns(value) {
            this.checkSort()
        },
        */

        debounceSearch: {
            handler(value) {
                this.debouncedHandleFiltersChange = debounce(this.handleFiltersChange, value);
            },
            immediate: true
        },

        filters: {
            handler(value) {
                if (this.debounceSearch) {
                    this.debouncedHandleFiltersChange(value);
                } else {
                    this.handleFiltersChange(value);
                }
            },
            deep: true
        },

        /**
        * When the user wants to control the detailed rows via props.
        * Or wants to open the details of certain row with the router for example.
        */
        openedDetailed(expandedRows) {
            this.visibleDetailRows = expandedRows;
        }
    },
    methods: {
        onFiltersEvent(event) {
            this.$emit(`filters-event-${this.filtersEvent}`, { event, filters: this.filters });
        },
        handleFiltersChange(value) {
            if (this.backendFiltering) {
                this.$emit('filters-change', value);
            } else {
                this.newData = this.data.filter(
                    (row) => this.isRowFiltered(row));
                if (!this.backendPagination) {
                    this.newDataTotal = this.newData.length;
                }
                if (!this.backendSorting) {
                    if (this.sortMultiple &&
                        this.sortMultipleDataLocal && this.sortMultipleDataLocal.length > 0) {
                        this.doSortMultiColumn();
                    } else if (Object.keys(this.currentSortColumn).length > 0) {
                        this.doSortSingleColumn(this.currentSortColumn);
                    }
                }
            }
        },
        findIndexOfSortData(column) {
            const sortObj = this.sortMultipleDataComputed.filter((i) =>
                i.field === column.field)[0];
            return this.sortMultipleDataComputed.indexOf(sortObj) + 1
        },
        removeSortingPriority(column) {
            if (this.backendSorting) {
                this.$emit('sorting-priority-removed', column.field);
            } else {
                this.sortMultipleDataLocal = this.sortMultipleDataLocal.filter(
                    (priority) => priority.field !== column.field);

                if (this.sortMultipleDataLocal.length === 0) {
                    this.resetMultiSorting();
                } else {
                    this.newData = multiColumnSort(this.newData, this.sortMultipleDataLocal);
                }
            }
        },
        resetMultiSorting() {
            this.sortMultipleDataLocal = [];
            this.currentSortColumn = {};
            this.newData = this.data;
        },
        /**
        * Sort an array by key without mutating original data.
        * Call the user sort function if it was passed.
        */
        sortBy(array, key, fn, isAsc) {
            let sorted = [];
            // Sorting without mutating original data
            if (fn && typeof fn === 'function') {
                sorted = [...array].sort((a, b) => fn(a, b, isAsc));
            } else {
                sorted = [...array].sort((a, b) => {
                    // Get nested values from objects
                    let newA = getValueByPath(a, key);
                    let newB = getValueByPath(b, key);

                    // sort boolean type
                    if (typeof newA === 'boolean' && typeof newB === 'boolean') {
                        return isAsc ? newA - newB : newB - newA
                    }

                    // sort null values to the bottom when in asc order
                    // and to the top when in desc order
                    if (!isNil(newB) && isNil(newA)) return isAsc ? 1 : -1
                    if (!isNil(newA) && isNil(newB)) return isAsc ? -1 : 1
                    if (newA === newB) return 0

                    newA = (typeof newA === 'string')
                        ? newA.toUpperCase()
                        : newA;
                    newB = (typeof newB === 'string')
                        ? newB.toUpperCase()
                        : newB;

                    return isAsc
                        ? newA > newB ? 1 : -1
                        : newA > newB ? -1 : 1
                });
            }

            return sorted
        },

        sortMultiColumn(column) {
            this.currentSortColumn = {};
            if (!this.backendSorting) {
                const existingPriority = this.sortMultipleDataLocal.filter((i) =>
                    i.field === column.field)[0];
                if (existingPriority) {
                    existingPriority.order = existingPriority.order === 'desc' ? 'asc' : 'desc';
                } else {
                    this.sortMultipleDataLocal.push({
                        field: column.field,
                        order: column.isAsc,
                        customSort: column.customSort
                    });
                }
                this.doSortMultiColumn();
            }
        },

        doSortMultiColumn() {
            this.newData = multiColumnSort(this.newData, this.sortMultipleDataLocal);
        },

        /**
        * Sort the column.
        * Toggle current direction on column if it's sortable
        * and not just updating the prop.
        */
        sort(column, updatingData = false, event = null) {
            if (!column || !column.sortable) return
            if (
                // if backend sorting is enabled, just emit the sort press like usual
                // if the correct key combination isnt pressed, sort like usual
                !this.backendSorting &&
                this.sortMultiple &&
                ((this.sortMultipleKey && event[this.sortMultipleKey]) || !this.sortMultipleKey)
            ) {
                if (updatingData) {
                    this.doSortMultiColumn();
                } else {
                    this.sortMultiColumn(column);
                }
            } else {
                // sort multiple is enabled but the correct key combination isnt pressed so reset
                if (this.sortMultiple) {
                    this.sortMultipleDataLocal = [];
                }

                if (!updatingData) {
                    this.isAsc = toRaw(column) === toRaw(this.currentSortColumn)
                        ? !this.isAsc
                        : (this.defaultSortDirection.toLowerCase() !== 'desc');
                }
                if (!this.firstTimeSort) {
                    this.$emit('sort', column.field, this.isAsc ? 'asc' : 'desc', event);
                }
                if (!this.backendSorting) {
                    this.doSortSingleColumn(column);
                }
                this.currentSortColumn = column;
            }
        },

        doSortSingleColumn(column) {
            this.newData = this.sortBy(
                this.newData,
                column.field,
                column.customSort,
                this.isAsc
            );
        },

        isRowSelected(row, selected) {
            if (!selected) {
                return false
            }
            if (this.customRowKey) {
                return row[this.customRowKey] === selected[this.customRowKey]
            }
            return row === selected
        },

        /**
        * Check if the row is checked (is added to the array).
        */
        isRowChecked(row) {
            return indexOf(this.newCheckedRows, row, this.customIsChecked) >= 0
        },

        /**
        * Remove a checked row from the array.
        */
        removeCheckedRow(row) {
            const index = indexOf(this.newCheckedRows, row, this.customIsChecked);
            if (index >= 0) {
                this.newCheckedRows.splice(index, 1);
            }
        },

        /**
        * Header checkbox click listener.
        * Add or remove all rows in current page.
        */
        checkAll() {
            const isAllChecked = this.isAllChecked;
            this.visibleData.forEach((currentRow) => {
                if (this.isRowCheckable(currentRow)) {
                    this.removeCheckedRow(currentRow);
                }
                if (!isAllChecked) {
                    if (this.isRowCheckable(currentRow)) {
                        this.newCheckedRows.push(currentRow);
                    }
                }
            });

            this.$emit('check', this.newCheckedRows);
            this.$emit('check-all', this.newCheckedRows);

            // Emit checked rows to update user variable
            this.$emit('update:checkedRows', this.newCheckedRows);
        },

        /**
        * Row checkbox click listener.
        */
        checkRow(row, index, event) {
            if (!this.isRowCheckable(row)) return
            const lastIndex = this.lastCheckedRowIndex;
            this.lastCheckedRowIndex = index;

            if (event.shiftKey && lastIndex !== null && index !== lastIndex) {
                this.shiftCheckRow(row, index, lastIndex);
            } else if (!this.isRowChecked(row)) {
                this.newCheckedRows.push(row);
            } else {
                this.removeCheckedRow(row);
            }

            this.$emit('check', this.newCheckedRows, row);

            // Emit checked rows to update user variable
            this.$emit('update:checkedRows', this.newCheckedRows);
        },

        /**
         * Check row when shift is pressed.
         */
        shiftCheckRow(row, index, lastCheckedRowIndex) {
            // Get the subset of the list between the two indicies
            const subset = this.visibleData.slice(
                Math.min(index, lastCheckedRowIndex),
                Math.max(index, lastCheckedRowIndex) + 1
            );

            // Determine the operation based on the state of the clicked checkbox
            const shouldCheck = !this.isRowChecked(row);

            subset.forEach((item) => {
                this.removeCheckedRow(item);
                if (shouldCheck && this.isRowCheckable(item)) {
                    this.newCheckedRows.push(item);
                }
            });
        },

        /**
        * Row click listener.
        * Emit all necessary events.
        */
        selectRow(row, index) {
            this.$emit('click', row);

            this._selectedRow = row; // row must be clicked before dragging by touch
            if (this.selected === row) return
            if (!this.isRowSelectable(row)) return

            // Emit new and old row
            this.$emit('select', row, this.selected);

            // Emit new row to update user variable
            this.$emit('update:selected', row);
        },

        /**
        * Toggle to show/hide details slot
        */
        toggleDetails(obj) {
            const found = this.isVisibleDetailRow(obj);

            if (found) {
                this.closeDetailRow(obj);
                this.$emit('details-close', obj);
            } else {
                this.openDetailRow(obj);
                this.$emit('details-open', obj);
            }

            // Syncs the detailed rows with the parent component
            this.$emit('update:openedDetailed', this.visibleDetailRows);
        },

        openDetailRow(obj) {
            const index = this.handleDetailKey(obj);
            this.visibleDetailRows.push(index);
        },

        closeDetailRow(obj) {
            const index = this.handleDetailKey(obj);
            const i = this.visibleDetailRows.indexOf(index);
            if (i >= 0) {
                this.visibleDetailRows.splice(i, 1);
            }
        },

        isVisibleDetailRow(obj) {
            const index = this.handleDetailKey(obj);
            return this.visibleDetailRows.indexOf(index) >= 0
        },

        isActiveDetailRow(row) {
            return this.detailed && !this.customDetailRow && this.isVisibleDetailRow(row)
        },

        isActiveCustomDetailRow(row) {
            return this.detailed && this.customDetailRow && this.isVisibleDetailRow(row)
        },

        isRowFiltered(row) {
            for (const key in this.filters) {
                if (!this.filters[key]) continue
                const input = this.filters[key];
                const column = this.newColumns.filter((c) => c.field === key)[0];
                if (column && column.customSearch && typeof column.customSearch === 'function') {
                    if (!column.customSearch(row, input)) return false
                } else {
                    const value = this.getValueByPath(row, key);
                    if (value == null) return false
                    if (Number.isInteger(value)) {
                        if (value !== Number(input)) return false
                    } else {
                        const re = new RegExp(escapeRegExpChars(input), 'i');
                        if (Array.isArray(value)) {
                            const valid = value.some((val) =>
                                re.test(removeDiacriticsFromString(val)) || re.test(val)
                            );
                            if (!valid) return false
                        } else {
                            if (!re.test(removeDiacriticsFromString(value)) && !re.test(value)) {
                                return false
                            }
                        }
                    }
                }
            }
            return true
        },

        /**
        * When the detailKey is defined we use the object[detailKey] as index.
        * If not, use the object reference by default.
        */
        handleDetailKey(index) {
            const key = this.detailKey;
            return !key.length || !index
                ? index
                : index[key]
        },

        checkPredefinedDetailedRows() {
            const defaultExpandedRowsDefined = this.openedDetailed.length > 0;
            if (defaultExpandedRowsDefined && !this.detailKey.length) {
                throw new Error('If you set a predefined opened-detailed, you must provide a unique key using the prop "detail-key"')
            }
        },

        /**
        * Call initSort only first time (For example async data).
        */
        checkSort() {
            if (this.newColumns.length && this.firstTimeSort) {
                this.initSort();
                this.firstTimeSort = false;
            } else if (this.newColumns.length) {
                if (Object.keys(this.currentSortColumn).length > 0) {
                    for (let i = 0; i < this.newColumns.length; i++) {
                        if (this.newColumns[i].field === this.currentSortColumn.field) {
                            this.currentSortColumn = this.newColumns[i];
                            break
                        }
                    }
                }
            }
        },

        /**
        * Check if footer slot has custom content.
        *
        * Assumes that `$slots.footer` is specified.
        */
        hasCustomFooterSlot() {
            const footer = this.$slots.footer();
            if (footer.length > 1) return true

            // if a template is specified to `footer`, `footer.length` is 1
            // but should contain multiple elements.
            if (isFragment(footer[0])) return true

            const tag = footer[0].tag;
            if (tag !== 'th' && tag !== 'td') return false

            return true
        },

        /**
        * Check if bottom-left slot exists.
        */
        hasBottomLeftSlot() {
            return typeof this.$slots['bottom-left'] !== 'undefined'
        },

        /**
        * Table arrow keys listener, change selection.
        */
        pressedArrow(pos) {
            if (!this.visibleData.length) return

            let index = this.visibleData.indexOf(this.selected) + pos;

            // Prevent from going up from first and down from last
            index = index < 0
                ? 0
                : index > this.visibleData.length - 1
                    ? this.visibleData.length - 1
                    : index;

            const row = this.visibleData[index];

            if (!this.isRowSelectable(row)) {
                let newIndex = null;
                if (pos > 0) {
                    for (let i = index; i < this.visibleData.length && newIndex === null; i++) {
                        if (this.isRowSelectable(this.visibleData[i])) newIndex = i;
                    }
                } else {
                    for (let i = index; i >= 0 && newIndex === null; i--) {
                        if (this.isRowSelectable(this.visibleData[i])) newIndex = i;
                    }
                }
                if (newIndex >= 0) {
                    this.selectRow(this.visibleData[newIndex]);
                }
            } else {
                this.selectRow(row);
            }
        },

        /**
        * Focus table element if has selected prop.
        */
        focus() {
            if (!this.focusable) return

            this.$el.querySelector('table').focus();
        },

        /**
        * Initial sorted column based on the default-sort prop.
        */
        initSort() {
            if (this.sortMultiple && this.sortMultipleData) {
                this.sortMultipleData.forEach((column) => {
                    this.sortMultiColumn(column);
                });
            } else {
                if (!this.defaultSort) return

                let sortField = '';
                let sortDirection = this.defaultSortDirection;

                if (Array.isArray(this.defaultSort)) {
                    sortField = this.defaultSort[0];
                    if (this.defaultSort[1]) {
                        sortDirection = this.defaultSort[1];
                    }
                } else {
                    sortField = this.defaultSort;
                }

                const sortColumn = this.newColumns.filter(
                    (column) => (column.field === sortField))[0];
                if (sortColumn) {
                    this.isAsc = sortDirection.toLowerCase() !== 'desc';
                    this.sort(sortColumn, true);
                }
            }
        },
        /**
        * Emits drag start event (row)
        */
        handleDragStart(event, row, index) {
            if (!this.canDragRow) return
            this.isDraggingRow = true;
            this.$emit('dragstart', { event, row, index });
        },
        /**
        * Emits drag leave event (row)
        */
        handleDragEnd(event, row, index) {
            if (!this.canDragRow) return
            this.isDraggingRow = false;
            this.$emit('dragend', { event, row, index });
        },
        /**
        * Emits drop event (row)
        */
        handleDrop(event, row, index) {
            if (!this.canDragRow) return
            this.$emit('drop', { event, row, index });
        },
        /**
        * Emits drag over event (row)
        */
        handleDragOver(event, row, index) {
            if (!this.canDragRow) return
            this.$emit('dragover', { event, row, index });
        },
        /**
        * Emits drag leave event (row)
        */
        handleDragLeave(event, row, index) {
            if (!this.canDragRow) return
            this.$emit('dragleave', { event, row, index });
        },

        emitEventForRow(eventName, event, row) {
            // eventName should not be in `emits` because it is never included
            // in `$attrs` if it is listed in `emits`.
            return this.$attrs[`on${eventName}`] ? this.$emit(eventName, row, event) : null
        },

        /**
        * Emits drag start event (column)
        */
        handleColumnDragStart(event, column, index) {
            if (!this.canDragColumn) return
            this.isDraggingColumn = true;
            this.$emit('columndragstart', { event, column, index });
        },

        /**
        * Emits drag leave event (column)
        */
        handleColumnDragEnd(event, column, index) {
            if (!this.canDragColumn) return
            this.isDraggingColumn = false;
            this.$emit('columndragend', { event, column, index });
        },

        /**
        * Emits drop event (column)
        */
        handleColumnDrop(event, column, index) {
            if (!this.canDragColumn) return
            this.$emit('columndrop', { event, column, index });
        },

        /**
        * Emits drag over event (column)
        */
        handleColumnDragOver(event, column, index) {
            if (!this.canDragColumn) return
            this.$emit('columndragover', { event, column, index });
        },

        /**
        * Emits drag leave event (column)
        */
        handleColumnDragLeave(event, column, index) {
            if (!this.canDragColumn) return
            this.$emit('columndragleave', { event, column, index });
        },

        /**
        * Starts monitoring drag-by-touch events (row on touch-enabled devices)
        */
        handleTouchStart(event, row, index) {
            if (!this.canDragRow) return
            if (this.isDraggingColumn) return
            // drag won't start unless the row has been clicked (tapped)
            // I think trapping touch-scrolling is annoying
            if (this._selectedRow !== row) return
            event.preventDefault();
            this.mayBeTouchDragging = true;
        },
        /**
        * Emits dragover and dragleave events (row on touch-enabled devices)
        *
        * Emits also dragstart if this is the first touchmove after touchstart.
        */
        handleTouchMove(event, row, index) {
            if (!this.canDragRow) return
            if (!this.mayBeTouchDragging) return
            if (!this.isDraggingRow) {
                const tr = event.target.closest('tr');
                this.draggedCellContent = tr
                    ? `<table class="table"><tr>${tr.innerHTML}</tr></table>`
                    : event.target.innerHTML;
                this.$refs.draggedCell.style.width = tr
                    ? `${tr.offsetWidth}px`
                    : `${event.target.offsetWidth}px`;
                event.target.dispatchEvent(translateTouchAsDragEvent(event, {
                    type: 'dragstart'
                }));
            }
            const touch = event.touches[0];
            const target = document.elementFromPoint(touch.clientX, touch.clientY);
            if (target != null) {
                if (target !== this.touchDragoverTarget) {
                    if (this.touchDragoverTarget != null) {
                        this.touchDragoverTarget.dispatchEvent(
                            translateTouchAsDragEvent(event, {
                                type: 'dragleave',
                                target: this.touchDragoverTarget
                            })
                        );
                    }
                    this.touchDragoverTarget = target;
                    target.dispatchEvent(
                        translateTouchAsDragEvent(event, {
                            type: 'dragover',
                            target
                        })
                    );
                }
            } else if (this.touchDragoverTarget != null) {
                this.touchDragoverTarget.dispatchEvent(
                    translateTouchAsDragEvent(event, {
                        type: 'dragleave',
                        target: this.touchDragoverTarget
                    })
                );
                this.touchDragoverTarget = null;
            }
            this.updateDraggedCell(touch);
        },
        /**
        * Emits drop and dragend events (row on touch-enabled devices)
        */
        handleTouchEnd(event, row, index) {
            if (!this.canDragRow) return
            if (this.isDraggingRow) {
                const touch = event.changedTouches[0];
                const target = document.elementFromPoint(touch.clientX, touch.clientY);
                if (target != null) {
                    target.dispatchEvent(translateTouchAsDragEvent(event, {
                        type: 'drop',
                        target
                    }));
                }
                event.target.dispatchEvent(translateTouchAsDragEvent(event, {
                    type: 'dragend'
                }));
                this._selectedRow = null;
            }
            this.mayBeTouchDragging = false;
        },

        /**
        * Starts monitoring drag-by-touch events (column on touch-enabled devices)
        */
        handleColumnTouchStart(event, column, index) {
            if (!this.canDragColumn) return
            if (this.isDraggingRow) return
            event.preventDefault(); // otherwise triggers touch-scrolling
            this.mayBeTouchDragging = true;
        },
        /**
        * Emits dragover and dragleave events (column on touch-enabled devices)
        *
        * Also emits dragstart if this is the first touchmove after touchstart.
        */
        handleColumnTouchMove(event, column, index) {
            if (!this.canDragColumn) return
            if (!this.mayBeTouchDragging) return
            if (!this.isDraggingColumn) {
                this.draggedCellContent = event.target.innerHTML;
                this.$refs.draggedCell.style.width = `${event.target.offsetWidth}px`;
                event.target.dispatchEvent(translateTouchAsDragEvent(event, {
                    type: 'dragstart'
                }));
            }
            const touch = event.touches[0];
            const target = document.elementFromPoint(touch.clientX, touch.clientY);
            if (target != null) {
                if (target !== this.touchDragoverTarget) {
                    if (this.touchDragoverTarget != null) {
                        this.touchDragoverTarget.dispatchEvent(
                            translateTouchAsDragEvent(event, {
                                type: 'dragleave',
                                target: this.touchDragoverTarget
                            })
                        );
                    }
                    this.touchDragoverTarget = target;
                    target.dispatchEvent(
                        translateTouchAsDragEvent(event, {
                            type: 'dragover',
                            target
                        })
                    );
                }
            } else if (this.touchDragoverTarget != null) {
                this.touchDragoverTarget.dispatchEvent(
                    translateTouchAsDragEvent(event, {
                        type: 'dragleave',
                        target: this.touchDragoverTarget
                    })
                );
                this.touchDragoverTarget = null;
            }
            this.updateDraggedCell(touch);
        },
        /**
        * Emits drop and dragend events (column on touch-enabled devices)
        */
        handleColumnTouchEnd(event, column, index) {
            if (!this.canDragColumn) return
            if (this.isDraggingColumn) {
                const touch = event.changedTouches[0];
                const target = document.elementFromPoint(touch.clientX, touch.clientY);
                if (target != null) {
                    target.dispatchEvent(translateTouchAsDragEvent(event, {
                        type: 'drop',
                        target
                    }));
                }
                event.target.dispatchEvent(translateTouchAsDragEvent(event, {
                    type: 'dragend'
                }));
            }
            this.mayBeTouchDragging = false;
        },

        updateDraggedCell({ clientX, clientY }) {
            const cellRect = this.$refs.draggedCell.getBoundingClientRect();
            const top = clientY + window.scrollY - cellRect.height / 2;
            const left = clientX + window.scrollX - cellRect.width / 2;
            this.$refs.draggedCell.style.top = `calc(${top}px)`;
            this.$refs.draggedCell.style.left = `calc(${left}px)`;
        },

        _registerTableColumn(column) {
            if (column._isTableColumn) {
                this.defaultSlots.push(column);
            }
        },
        _unregisterTableColumn(column) {
            const index = this.defaultSlots.indexOf(column);
            if (index !== -1) {
                this.defaultSlots.splice(index, 1);
            }
        }
    },
    mounted() {
        this.checkPredefinedDetailedRows();
        this.checkSort();
        // appends `draggedCell` to the body whenever `draggable` or
        // `draggableColumn` becomes true
        // starts watching here to make sure the DOM is ready
        function prepareDraggedCell(isDraggable) {
            if (isDraggable && this.$data._draggedCellEl == null) {
                this.$data._draggedCellEl = createAbsoluteElement(this.$refs.draggedCell);
            }
        }
        this.$watch('draggable', prepareDraggedCell, { immediate: true });
        this.$watch('draggableColumn', prepareDraggedCell, { immediate: true });
    },
    beforeUnmount() {
        if (this.$data._draggedCellEl) {
            removeElement(this.$data._draggedCellEl);
        }
    }
};

const _hoisted_1$5 = ["tabindex"];
const _hoisted_2$4 = { key: 1 };
const _hoisted_3$3 = {
  key: 0,
  width: "40px"
};
const _hoisted_4 = ["onClick", "draggable", "onDragstart", "onDragend", "onDrop", "onDragover", "onDragleave", "onTouchstart", "onTouchmove", "onTouchend"];
const _hoisted_5 = {
  key: 0,
  class: "multi-sort-icons"
};
const _hoisted_6 = ["onClick"];
const _hoisted_7 = {
  key: 0,
  class: "is-subheading"
};
const _hoisted_8 = {
  key: 0,
  width: "40px"
};
const _hoisted_9 = { key: 1 };
const _hoisted_10 = { key: 2 };
const _hoisted_11 = { key: 1 };
const _hoisted_12 = {
  key: 0,
  width: "40px"
};
const _hoisted_13 = { key: 1 };
const _hoisted_14 = { key: 2 };
const _hoisted_15 = ["onClick", "onDblclick", "onMouseenter", "onMouseleave", "onContextmenu", "draggable", "onDragstart", "onDragend", "onDrop", "onDragover", "onDragleave", "onTouchstart", "onTouchmove", "onTouchend"];
const _hoisted_16 = {
  key: 0,
  class: "chevron-cell"
};
const _hoisted_17 = ["onClick"];
const _hoisted_18 = {
  key: 0,
  class: "detail"
};
const _hoisted_19 = ["colspan"];
const _hoisted_20 = { class: "detail-container" };
const _hoisted_21 = {
  key: 0,
  class: "is-empty"
};
const _hoisted_22 = ["colspan"];
const _hoisted_23 = { key: 2 };
const _hoisted_24 = { class: "table-footer" };
const _hoisted_25 = ["colspan"];
const _hoisted_26 = ["innerHTML"];

function render$6(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_b_table_mobile_sort = resolveComponent("b-table-mobile-sort");
  const _component_b_table_pagination = resolveComponent("b-table-pagination");
  const _component_b_checkbox = resolveComponent("b-checkbox");
  const _component_b_slot_component = resolveComponent("b-slot-component");
  const _component_b_icon = resolveComponent("b-icon");
  const _component_b_input = resolveComponent("b-input");
  const _component_b_loading = resolveComponent("b-loading");

  return (openBlock(), createElementBlock("div", mergeProps({ class: "b-table" }, _ctx.rootAttrs), [
    renderSlot(_ctx.$slots, "default"),
    ($props.mobileCards && $options.hasSortablenewColumns)
      ? (openBlock(), createBlock(_component_b_table_mobile_sort, {
          key: 0,
          "current-sort-column": $data.currentSortColumn,
          "sort-multiple": $props.sortMultiple,
          "sort-multiple-data": $options.sortMultipleDataComputed,
          "is-asc": $data.isAsc,
          columns: $options.newColumns,
          placeholder: $props.mobileSortPlaceholder,
          "icon-pack": $props.iconPack,
          "sort-icon": $props.sortIcon,
          "sort-icon-size": $props.sortIconSize,
          onSort: _cache[0] || (_cache[0] = (column, event) => $options.sort(column, null, event)),
          onRemovePriority: _cache[1] || (_cache[1] = (column) => $options.removeSortingPriority(column))
        }, null, 8 /* PROPS */, ["current-sort-column", "sort-multiple", "sort-multiple-data", "is-asc", "columns", "placeholder", "icon-pack", "sort-icon", "sort-icon-size"]))
      : createCommentVNode("v-if", true),
    ($props.paginated && ($props.paginationPosition === 'top' || $props.paginationPosition === 'both'))
      ? renderSlot(_ctx.$slots, "pagination", { key: 1 }, () => [
          createVNode(_component_b_table_pagination, mergeProps(_ctx.fallthroughAttrs, {
            "per-page": $props.perPage,
            paginated: $props.paginated,
            rounded: $props.paginationRounded,
            "icon-pack": $props.iconPack,
            total: $data.newDataTotal,
            "current-page": $data.newCurrentPage,
            "onUpdate:currentPage": _cache[2] || (_cache[2] = $event => (($data.newCurrentPage) = $event)),
            "aria-next-label": $props.ariaNextLabel,
            "aria-previous-label": $props.ariaPreviousLabel,
            "aria-page-label": $props.ariaPageLabel,
            "aria-current-label": $props.ariaCurrentLabel,
            onPageChange: _cache[3] || (_cache[3] = (event) => _ctx.$emit('page-change', event)),
            "page-input": $props.pageInput,
            "pagination-order": $props.paginationOrder,
            "page-input-position": $props.pageInputPosition,
            "debounce-page-input": $props.debouncePageInput
          }), {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "top-left")
            ]),
            _: 3 /* FORWARDED */
          }, 16 /* FULL_PROPS */, ["per-page", "paginated", "rounded", "icon-pack", "total", "current-page", "aria-next-label", "aria-previous-label", "aria-page-label", "aria-current-label", "page-input", "pagination-order", "page-input-position", "debounce-page-input"])
        ])
      : createCommentVNode("v-if", true),
    createBaseVNode("div", {
      class: normalizeClass(["table-wrapper", $options.tableWrapperClasses]),
      style: normalizeStyle($options.tableStyle)
    }, [
      createBaseVNode("table", {
        class: normalizeClass(["table", $options.tableClasses]),
        tabindex: !$props.focusable ? undefined : 0,
        onKeydown: [
          _cache[4] || (_cache[4] = withKeys(withModifiers($event => ($options.pressedArrow(-1)), ["self","prevent"]), ["up"])),
          _cache[5] || (_cache[5] = withKeys(withModifiers($event => ($options.pressedArrow(1)), ["self","prevent"]), ["down"]))
        ]
      }, [
        ($props.caption)
          ? withDirectives((openBlock(), createElementBlock("caption", { key: 0 }, toDisplayString($props.caption), 513 /* TEXT, NEED_PATCH */)), [
              [vShow, $props.showCaption]
            ])
          : createCommentVNode("v-if", true),
        ($options.newColumns.length && $props.showHeader)
          ? (openBlock(), createElementBlock("thead", _hoisted_2$4, [
              createBaseVNode("tr", null, [
                ($options.showDetailRowIcon)
                  ? (openBlock(), createElementBlock("th", _hoisted_3$3))
                  : createCommentVNode("v-if", true),
                ($props.checkable && $props.checkboxPosition === 'left')
                  ? (openBlock(), createElementBlock("th", {
                      key: 1,
                      class: normalizeClass(['checkbox-cell', { 'is-sticky': $props.stickyCheckbox } ])
                    }, [
                      ($props.headerCheckable)
                        ? renderSlot(_ctx.$slots, "check-all", {
                            key: 0,
                            isAllChecked: $options.isAllChecked,
                            isAllUncheckable: $options.isAllUncheckable,
                            checkAll: $options.checkAll
                          }, () => [
                            createVNode(_component_b_checkbox, {
                              autocomplete: "off",
                              "model-value": $options.isAllChecked,
                              type: $props.checkboxType,
                              disabled: $options.isAllUncheckable,
                              onChange: $options.checkAll
                            }, null, 8 /* PROPS */, ["model-value", "type", "disabled", "onChange"])
                          ])
                        : createCommentVNode("v-if", true)
                    ], 2 /* CLASS */))
                  : createCommentVNode("v-if", true),
                (openBlock(true), createElementBlock(Fragment, null, renderList($options.visibleColumns, (column, index) => {
                  return (openBlock(), createElementBlock("th", mergeProps({
                    key: column.newKey + ':' + index + 'header'
                  }, column.thAttrs(column), {
                    class: [column.thClasses, {
                                'is-current-sort': !$props.sortMultiple && $data.currentSortColumn === column,
                            }],
                    style: column.thStyle,
                    onClick: withModifiers($event => ($options.sort(column, null, $event)), ["stop"]),
                    draggable: $options.canDragColumn,
                    onDragstart: $event => ($options.handleColumnDragStart($event, column, index)),
                    onDragend: $event => ($options.handleColumnDragEnd($event, column, index)),
                    onDrop: $event => ($options.handleColumnDrop($event, column, index)),
                    onDragover: $event => ($options.handleColumnDragOver($event, column, index)),
                    onDragleave: $event => ($options.handleColumnDragLeave($event, column, index)),
                    onTouchstart: $event => ($options.handleColumnTouchStart($event, column, index)),
                    onTouchmove: $event => ($options.handleColumnTouchMove($event, column, index)),
                    onTouchend: $event => ($options.handleColumnTouchEnd($event, column, index))
                  }), [
                    createBaseVNode("div", {
                      class: normalizeClass(["th-wrap is-relative", {
                                    'is-numeric': column.numeric,
                                    'is-centered': column.centered
                                }]),
                      style: normalizeStyle(column.thWrapStyle)
                    }, [
                      (column.$slots.header)
                        ? (openBlock(), createBlock(_component_b_slot_component, {
                            key: 0,
                            component: column,
                            scoped: "",
                            name: "header",
                            tag: "span",
                            props: { column, index }
                          }, null, 8 /* PROPS */, ["component", "props"]))
                        : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                            createTextVNode(toDisplayString(column.label) + " ", 1 /* TEXT */),
                            ($props.sortMultiple &&
                                            $options.sortMultipleDataComputed &&
                                            $options.sortMultipleDataComputed.length > 0 &&
                                            $options.sortMultipleDataComputed.filter(i =>
                                                i.field === column.field).length > 0)
                              ? (openBlock(), createElementBlock("span", _hoisted_5, [
                                  createVNode(_component_b_icon, {
                                    icon: $props.sortIcon,
                                    pack: $props.iconPack,
                                    both: "",
                                    size: $props.sortIconSize,
                                    class: normalizeClass({
                                                    'is-desc': $options.sortMultipleDataComputed
                                                        .filter(i => i.field === column.field)[0]
                                                        .order === 'desc'})
                                  }, null, 8 /* PROPS */, ["icon", "pack", "size", "class"]),
                                  createTextVNode(" " + toDisplayString($options.findIndexOfSortData(column)) + " ", 1 /* TEXT */),
                                  createBaseVNode("button", {
                                    class: "delete is-small multi-sort-cancel-icon",
                                    type: "button",
                                    onClick: withModifiers($event => ($options.removeSortingPriority(column)), ["stop"])
                                  }, null, 8 /* PROPS */, _hoisted_6)
                                ]))
                              : (openBlock(), createBlock(_component_b_icon, {
                                  key: 1,
                                  icon: $props.sortIcon,
                                  pack: $props.iconPack,
                                  both: "",
                                  size: $props.sortIconSize,
                                  class: normalizeClass(["sort-icon", {
                                            'is-desc': !$data.isAsc,
                                            'is-invisible': $data.currentSortColumn !== column
                                        }])
                                }, null, 8 /* PROPS */, ["icon", "pack", "size", "class"]))
                          ], 64 /* STABLE_FRAGMENT */))
                    ], 6 /* CLASS, STYLE */)
                  ], 16 /* FULL_PROPS */, _hoisted_4))
                }), 128 /* KEYED_FRAGMENT */)),
                ($props.checkable && $props.checkboxPosition === 'right')
                  ? (openBlock(), createElementBlock("th", {
                      key: 2,
                      class: normalizeClass(['checkbox-cell', { 'is-sticky': $props.stickyCheckbox } ])
                    }, [
                      ($props.headerCheckable)
                        ? renderSlot(_ctx.$slots, "check-all", {
                            key: 0,
                            isAllChecked: $options.isAllChecked,
                            isAllUncheckable: $options.isAllUncheckable,
                            checkAll: $options.checkAll
                          }, () => [
                            createVNode(_component_b_checkbox, {
                              autocomplete: "off",
                              "model-value": $options.isAllChecked,
                              type: $props.checkboxType,
                              disabled: $options.isAllUncheckable,
                              onChange: $options.checkAll
                            }, null, 8 /* PROPS */, ["model-value", "type", "disabled", "onChange"])
                          ])
                        : createCommentVNode("v-if", true)
                    ], 2 /* CLASS */))
                  : createCommentVNode("v-if", true)
              ]),
              ($options.hasCustomSubheadings)
                ? (openBlock(), createElementBlock("tr", _hoisted_7, [
                    ($options.showDetailRowIcon)
                      ? (openBlock(), createElementBlock("th", _hoisted_8))
                      : createCommentVNode("v-if", true),
                    ($props.checkable && $props.checkboxPosition === 'left')
                      ? (openBlock(), createElementBlock("th", _hoisted_9))
                      : createCommentVNode("v-if", true),
                    (openBlock(true), createElementBlock(Fragment, null, renderList($options.visibleColumns, (column, index) => {
                      return (openBlock(), createElementBlock("th", {
                        key: column.newKey + ':' + index + 'subheading',
                        style: normalizeStyle(column.style)
                      }, [
                        createBaseVNode("div", {
                          class: normalizeClass(["th-wrap", {
                                    'is-numeric': column.numeric,
                                    'is-centered': column.centered
                                }]),
                          style: normalizeStyle(column.thWrapStyle)
                        }, [
                          (column.$slots.subheading)
                            ? (openBlock(), createBlock(_component_b_slot_component, {
                                key: 0,
                                component: column,
                                scoped: "",
                                name: "subheading",
                                tag: "span",
                                props: { column, index }
                              }, null, 8 /* PROPS */, ["component", "props"]))
                            : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                                createTextVNode(toDisplayString(column.subheading), 1 /* TEXT */)
                              ], 64 /* STABLE_FRAGMENT */))
                        ], 6 /* CLASS, STYLE */)
                      ], 4 /* STYLE */))
                    }), 128 /* KEYED_FRAGMENT */)),
                    ($props.checkable && $props.checkboxPosition === 'right')
                      ? (openBlock(), createElementBlock("th", _hoisted_10))
                      : createCommentVNode("v-if", true)
                  ]))
                : createCommentVNode("v-if", true),
              ($options.hasSearchablenewColumns)
                ? (openBlock(), createElementBlock("tr", _hoisted_11, [
                    ($options.showDetailRowIcon)
                      ? (openBlock(), createElementBlock("th", _hoisted_12))
                      : createCommentVNode("v-if", true),
                    ($props.checkable && $props.checkboxPosition === 'left')
                      ? (openBlock(), createElementBlock("th", _hoisted_13))
                      : createCommentVNode("v-if", true),
                    (openBlock(true), createElementBlock(Fragment, null, renderList($options.visibleColumns, (column, index) => {
                      return (openBlock(), createElementBlock("th", mergeProps({
                        key: column.newKey + ':' + index + 'searchable'
                      }, column.thAttrs(column), {
                        style: column.thStyle,
                        class: {'is-sticky': column.sticky}
                      }), [
                        createBaseVNode("div", {
                          class: "th-wrap",
                          style: normalizeStyle(column.thWrapStyle)
                        }, [
                          (column.searchable)
                            ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                                (column.$slots.searchable)
                                  ? (openBlock(), createBlock(_component_b_slot_component, {
                                      key: 0,
                                      component: column,
                                      scoped: true,
                                      name: "searchable",
                                      tag: "span",
                                      props: { column, filters: $data.filters }
                                    }, null, 8 /* PROPS */, ["component", "props"]))
                                  : (openBlock(), createBlock(_component_b_input, mergeProps({
                                      key: 1,
                                      [toHandlerKey$1($props.filtersEvent)]: $options.onFiltersEvent
                                    }, {
                                      modelValue: $data.filters[column.field],
                                      "onUpdate:modelValue": $event => (($data.filters[column.field]) = $event),
                                      type: column.numeric ? 'number' : 'text'
                                    }), null, 16 /* FULL_PROPS */, ["modelValue", "onUpdate:modelValue", "type"]))
                              ], 64 /* STABLE_FRAGMENT */))
                            : createCommentVNode("v-if", true)
                        ], 4 /* STYLE */)
                      ], 16 /* FULL_PROPS */))
                    }), 128 /* KEYED_FRAGMENT */)),
                    ($props.checkable && $props.checkboxPosition === 'right')
                      ? (openBlock(), createElementBlock("th", _hoisted_14))
                      : createCommentVNode("v-if", true)
                  ]))
                : createCommentVNode("v-if", true)
            ]))
          : createCommentVNode("v-if", true),
        createBaseVNode("tbody", null, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($options.visibleData, (row, index) => {
            return (openBlock(), createElementBlock(Fragment, {
              key: $props.customRowKey ? row[$props.customRowKey] : index
            }, [
              createBaseVNode("tr", {
                class: normalizeClass([$props.rowClass(row, index), {
                                'is-selected': $options.isRowSelected(row, $props.selected),
                                'is-checked': $options.isRowChecked(row),
                            }]),
                onClick: $event => ($options.selectRow(row)),
                onDblclick: $event => (_ctx.$emit('dblclick', row)),
                onMouseenter: $event => ($options.emitEventForRow('mouseenter', $event, row)),
                onMouseleave: $event => ($options.emitEventForRow('mouseleave', $event, row)),
                onContextmenu: $event => (_ctx.$emit('contextmenu', row, $event)),
                draggable: $options.canDragRow,
                onDragstart: $event => ($options.handleDragStart($event, row, index)),
                onDragend: $event => ($options.handleDragEnd($event, row, index)),
                onDrop: $event => ($options.handleDrop($event, row, index)),
                onDragover: $event => ($options.handleDragOver($event, row, index)),
                onDragleave: $event => ($options.handleDragLeave($event, row, index)),
                onTouchstart: $event => ($options.handleTouchStart($event, row, index)),
                onTouchmove: $event => ($options.handleTouchMove($event, row, index)),
                onTouchend: $event => ($options.handleTouchEnd($event, row, index))
              }, [
                ($options.showDetailRowIcon)
                  ? (openBlock(), createElementBlock("td", _hoisted_16, [
                      ($props.hasDetailedVisible(row))
                        ? (openBlock(), createElementBlock("a", {
                            key: 0,
                            role: "button",
                            onClick: withModifiers($event => ($options.toggleDetails(row)), ["stop"])
                          }, [
                            createVNode(_component_b_icon, {
                              icon: $props.detailIcon,
                              pack: $props.iconPack,
                              both: "",
                              class: normalizeClass({'is-expanded': $options.isVisibleDetailRow(row)})
                            }, null, 8 /* PROPS */, ["icon", "pack", "class"])
                          ], 8 /* PROPS */, _hoisted_17))
                        : createCommentVNode("v-if", true)
                    ]))
                  : createCommentVNode("v-if", true),
                ($props.checkable && $props.checkboxPosition === 'left')
                  ? (openBlock(), createElementBlock("td", {
                      key: 1,
                      class: normalizeClass(['checkbox-cell', { 'is-sticky': $props.stickyCheckbox } ])
                    }, [
                      createVNode(_component_b_checkbox, {
                        autocomplete: "off",
                        "model-value": $options.isRowChecked(row),
                        type: $props.checkboxType,
                        disabled: !$props.isRowCheckable(row),
                        onClick: withModifiers($event => ($options.checkRow(row, index, $event)), ["prevent","stop"])
                      }, null, 8 /* PROPS */, ["model-value", "type", "disabled", "onClick"])
                    ], 2 /* CLASS */))
                  : createCommentVNode("v-if", true),
                (openBlock(true), createElementBlock(Fragment, null, renderList($options.visibleColumns, (column, colindex) => {
                  return (openBlock(), createElementBlock(Fragment, {
                    key: column.newKey + ':' + index + ':' + colindex
                  }, [
                    (column.$slots.default)
                      ? (openBlock(), createBlock(_component_b_slot_component, mergeProps({
                          key: 0,
                          component: column
                        }, column.tdAttrs(row, column), {
                          scoped: "",
                          name: "default",
                          tag: "td",
                          class: column.getRootClasses(row),
                          style: column.getRootStyle(row),
                          "data-label": column.label,
                          props: {
                                            row, column, index, colindex,
                                            toggleDetails: $options.toggleDetails, isActiveDetailRow: $options.isActiveDetailRow
                                        },
                          onClick: $event => (_ctx.$emit('cellclick',row,column,index,colindex))
                        }), null, 16 /* FULL_PROPS */, ["component", "class", "style", "data-label", "props", "onClick"]))
                      : createCommentVNode("v-if", true)
                  ], 64 /* STABLE_FRAGMENT */))
                }), 128 /* KEYED_FRAGMENT */)),
                ($props.checkable && $props.checkboxPosition === 'right')
                  ? (openBlock(), createElementBlock("td", {
                      key: 2,
                      class: normalizeClass(['checkbox-cell', { 'is-sticky': $props.stickyCheckbox } ])
                    }, [
                      createVNode(_component_b_checkbox, {
                        autocomplete: "off",
                        "model-value": $options.isRowChecked(row),
                        type: $props.checkboxType,
                        disabled: !$props.isRowCheckable(row),
                        onClick: withModifiers($event => ($options.checkRow(row, index, $event)), ["prevent","stop"])
                      }, null, 8 /* PROPS */, ["model-value", "type", "disabled", "onClick"])
                    ], 2 /* CLASS */))
                  : createCommentVNode("v-if", true)
              ], 42 /* CLASS, PROPS, HYDRATE_EVENTS */, _hoisted_15),
              createVNode(Transition, { name: $props.detailTransition }, {
                default: withCtx(() => [
                  ($options.isActiveDetailRow(row))
                    ? (openBlock(), createElementBlock("tr", _hoisted_18, [
                        createBaseVNode("td", { colspan: $options.columnCount }, [
                          createBaseVNode("div", _hoisted_20, [
                            renderSlot(_ctx.$slots, "detail", {
                              row: row,
                              index: index
                            })
                          ])
                        ], 8 /* PROPS */, _hoisted_19)
                      ]))
                    : createCommentVNode("v-if", true)
                ]),
                _: 2 /* DYNAMIC */
              }, 1032 /* PROPS, DYNAMIC_SLOTS */, ["name"]),
              ($options.isActiveCustomDetailRow(row))
                ? renderSlot(_ctx.$slots, "detail", {
                    key: 0,
                    row: row,
                    index: index
                  })
                : createCommentVNode("v-if", true)
            ], 64 /* STABLE_FRAGMENT */))
          }), 128 /* KEYED_FRAGMENT */)),
          (!$options.visibleData.length)
            ? (openBlock(), createElementBlock("tr", _hoisted_21, [
                createBaseVNode("td", { colspan: $options.columnCount }, [
                  renderSlot(_ctx.$slots, "empty")
                ], 8 /* PROPS */, _hoisted_22)
              ]))
            : createCommentVNode("v-if", true)
        ]),
        (_ctx.$slots.footer !== undefined)
          ? (openBlock(), createElementBlock("tfoot", _hoisted_23, [
              createBaseVNode("tr", _hoisted_24, [
                ($options.hasCustomFooterSlot())
                  ? renderSlot(_ctx.$slots, "footer", { key: 0 })
                  : (openBlock(), createElementBlock("th", {
                      key: 1,
                      colspan: $options.columnCount
                    }, [
                      renderSlot(_ctx.$slots, "footer")
                    ], 8 /* PROPS */, _hoisted_25))
              ])
            ]))
          : createCommentVNode("v-if", true)
      ], 42 /* CLASS, PROPS, HYDRATE_EVENTS */, _hoisted_1$5),
      ($props.loading)
        ? renderSlot(_ctx.$slots, "loading", { key: 0 }, () => [
            createVNode(_component_b_loading, {
              "is-full-page": false,
              "model-value": $props.loading
            }, null, 8 /* PROPS */, ["model-value"])
          ])
        : createCommentVNode("v-if", true)
    ], 6 /* CLASS, STYLE */),
    (($props.checkable && $options.hasBottomLeftSlot()) ||
                ($props.paginated && ($props.paginationPosition === 'bottom' || $props.paginationPosition === 'both')))
      ? renderSlot(_ctx.$slots, "pagination", { key: 2 }, () => [
          createVNode(_component_b_table_pagination, mergeProps(_ctx.fallthroughAttrs, {
            "per-page": $props.perPage,
            paginated: $props.paginated,
            rounded: $props.paginationRounded,
            "icon-pack": $props.iconPack,
            total: $data.newDataTotal,
            "current-page": $data.newCurrentPage,
            "onUpdate:currentPage": _cache[6] || (_cache[6] = $event => (($data.newCurrentPage) = $event)),
            "aria-next-label": $props.ariaNextLabel,
            "aria-previous-label": $props.ariaPreviousLabel,
            "aria-page-label": $props.ariaPageLabel,
            "aria-current-label": $props.ariaCurrentLabel,
            onPageChange: _cache[7] || (_cache[7] = (event) => _ctx.$emit('page-change', event)),
            "page-input": $props.pageInput,
            "pagination-order": $props.paginationOrder,
            "page-input-position": $props.pageInputPosition,
            "debounce-page-input": $props.debouncePageInput
          }), {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "bottom-left")
            ]),
            _: 3 /* FORWARDED */
          }, 16 /* FULL_PROPS */, ["per-page", "paginated", "rounded", "icon-pack", "total", "current-page", "aria-next-label", "aria-previous-label", "aria-page-label", "aria-current-label", "page-input", "pagination-order", "page-input-position", "debounce-page-input"])
        ])
      : createCommentVNode("v-if", true),
    createCommentVNode(" eslint-disable vue/no-v-html "),
    withDirectives(createBaseVNode("div", {
      ref: "draggedCell",
      class: normalizeClass(["touch-dragged-cell", $options.touchDraggedCellClasses]),
      innerHTML: $data.draggedCellContent
    }, null, 10 /* CLASS, PROPS */, _hoisted_26), [
      [vShow, $data.mayBeTouchDragging && ($data.isDraggingRow || $data.isDraggingColumn)]
    ]),
    createCommentVNode(" eslint-enable vue/no-v-html ")
  ], 16 /* FULL_PROPS */))
}

script$6.render = render$6;
script$6.__file = "src/components/table/Table.vue";

var Plugin$7 = {
  install: function install(Vue) {
    registerComponent(Vue, script$6);
    registerComponent(Vue, script$2$1);
  }
};

var script$1$1 = {
    name: 'BTabs',
    mixins: [TabbedMixin('tab')],
    props: {
        expanded: {
            type: Boolean,
            default: () => {
                return config.defaultTabsExpanded
            }
        },
        type: {
            type: [String, Object],
            default: () => {
                return config.defaultTabsType
            }
        },
        animated: {
            type: Boolean,
            default: () => {
                return config.defaultTabsAnimated
            }
        },
        multiline: Boolean
    },
    data() {
        return {
            currentFocus: null
        }
    },
    computed: {
        mainClasses() {
            return {
                'is-fullwidth': this.expanded,
                'is-vertical': this.vertical,
                'is-multiline': this.multiline,
                [this.position]: this.position && this.vertical
            }
        },
        navClasses() {
            return [
                this.type,
                this.size,
                {
                    [this.position]: this.position && !this.vertical,
                    'is-fullwidth': this.expanded,
                    'is-toggle': this.type === 'is-toggle-rounded'
                }
            ]
        }
    },
    methods: {
        giveFocusToTab(tab) {
            if (Array.isArray(tab)) {
                // Vue ≥ v3.0 < v3.2.25, refs in v-for are stored as a single object,
                // but ≥ v3.2.25, refs in v-for are stored in an array (same as Vue 2)
                tab = tab[0];
                if (tab == null) {
                    return
                }
            }
            if (tab.$el && tab.$el.focus) {
                tab.$el.focus();
            } else if (tab.focus) {
                tab.focus();
            }
        },
        manageTablistKeydown(event) {
            // https://developer.mozilla.org/fr/docs/Web/API/KeyboardEvent/key/Key_Values#Navigation_keys
            const { key } = event;
            switch (key) {
                case this.vertical ? 'ArrowUp' : 'ArrowLeft':
                case this.vertical ? 'Up' : 'Left': {
                    let prevIdx = this.getPrevItemIdx(this.currentFocus, true);
                    if (prevIdx === null) {
                        // We try to give focus back to the last visible element
                        prevIdx = this.getPrevItemIdx(Infinity, true);
                    }
                    const prevItem = this.items.find((i) => i.index === prevIdx);
                    if (
                        prevItem &&
                        this.$refs[`tabLink${prevIdx}`] &&
                        !prevItem.disabled
                    ) {
                        this.giveFocusToTab(this.$refs[`tabLink${prevIdx}`]);
                    }
                    event.preventDefault();
                    break
                }
                case this.vertical ? 'ArrowDown' : 'ArrowRight':
                case this.vertical ? 'Down' : 'Right': {
                    let nextIdx = this.getNextItemIdx(this.currentFocus, true);
                    if (nextIdx === null) {
                        // We try to give focus back to the first visible element
                        nextIdx = this.getNextItemIdx(-1, true);
                    }
                    const nextItem = this.items.find((i) => i.index === nextIdx);
                    if (
                        nextItem &&
                        this.$refs[`tabLink${nextIdx}`] &&
                        !nextItem.disabled
                    ) {
                        this.giveFocusToTab(this.$refs[`tabLink${nextIdx}`]);
                    }
                    event.preventDefault();
                    break
                }
            }
        },

        manageTabKeydown(event, childItem) {
            // https://developer.mozilla.org/fr/docs/Web/API/KeyboardEvent/key/Key_Values#Navigation_keys
            const { key } = event;
            switch (key) {
                case ' ':
                case 'Space':
                case 'Spacebar':
                case 'Enter': {
                    this.childClick(childItem);
                    event.preventDefault();
                    break
                }
            }
        }
    }
};

const _hoisted_1$4 = ["aria-orientation"];
const _hoisted_2$3 = ["aria-controls", "aria-selected"];
const _hoisted_3$1 = ["id", "tabindex", "onFocus", "onClick", "onKeydown"];

function render$5(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_b_slot_component = resolveComponent("b-slot-component");
  const _component_b_icon = resolveComponent("b-icon");

  return (openBlock(), createElementBlock("div", {
    class: normalizeClass(["b-tabs", $options.mainClasses])
  }, [
    createBaseVNode("nav", {
      class: normalizeClass(["tabs", $options.navClasses]),
      onKeydown: _cache[0] || (_cache[0] = (...args) => ($options.manageTablistKeydown && $options.manageTablistKeydown(...args)))
    }, [
      renderSlot(_ctx.$slots, "start"),
      createBaseVNode("ul", {
        "aria-orientation": _ctx.vertical ? 'vertical' : 'horizontal',
        role: "tablist"
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.items, (childItem) => {
          return withDirectives((openBlock(), createElementBlock("li", {
            key: childItem.uniqueValue,
            class: normalizeClass([ childItem.headerClass, { 'is-active': childItem.isActive,
                                                       'is-disabled': childItem.disabled }]),
            role: "tab",
            "aria-controls": `${childItem.uniqueValue}-content`,
            "aria-selected": `${childItem.isActive}`
          }, [
            (childItem.$slots.header)
              ? (openBlock(), createBlock(_component_b_slot_component, {
                  key: 0,
                  ref_for: true,
                  ref: `tabLink${childItem.index}`,
                  component: childItem,
                  name: "header",
                  tag: "a",
                  id: `${childItem.uniqueValue}-label`,
                  tabindex: childItem.isActive ? 0 : -1,
                  onFocus: $event => ($data.currentFocus = childItem.index),
                  onClick: $event => (_ctx.childClick(childItem)),
                  onKeydown: $event => ($options.manageTabKeydown($event, childItem))
                }, null, 8 /* PROPS */, ["component", "id", "tabindex", "onFocus", "onClick", "onKeydown"]))
              : (openBlock(), createElementBlock("a", {
                  key: 1,
                  ref_for: true,
                  ref: `tabLink${childItem.index}`,
                  id: `${childItem.uniqueValue}-label`,
                  tabindex: childItem.isActive ? 0 : -1,
                  onFocus: $event => ($data.currentFocus = childItem.index),
                  onClick: $event => (_ctx.childClick(childItem)),
                  onKeydown: $event => ($options.manageTabKeydown($event, childItem))
                }, [
                  (childItem.icon)
                    ? (openBlock(), createBlock(_component_b_icon, {
                        key: 0,
                        icon: childItem.icon,
                        pack: childItem.iconPack,
                        size: _ctx.size
                      }, null, 8 /* PROPS */, ["icon", "pack", "size"]))
                    : createCommentVNode("v-if", true),
                  createBaseVNode("span", null, toDisplayString(childItem.label), 1 /* TEXT */)
                ], 40 /* PROPS, HYDRATE_EVENTS */, _hoisted_3$1))
          ], 10 /* CLASS, PROPS */, _hoisted_2$3)), [
            [vShow, childItem.visible]
          ])
        }), 128 /* KEYED_FRAGMENT */))
      ], 8 /* PROPS */, _hoisted_1$4),
      renderSlot(_ctx.$slots, "end")
    ], 34 /* CLASS, HYDRATE_EVENTS */),
    createBaseVNode("section", {
      class: normalizeClass(["tab-content", {'is-transitioning': _ctx.isTransitioning}])
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 2 /* CLASS */)
  ], 2 /* CLASS */))
}

script$1$1.render = render$5;
script$1$1.__file = "src/components/tabs/Tabs.vue";

var script$5 = {
    name: 'BTabItem',
    mixins: [TabbedChildMixin('tab')],
    props: {
        disabled: Boolean
    },
    data() {
        return {
            elementClass: 'tab-item',
            elementRole: 'tabpanel'
        }
    }
};

script$5.__file = "src/components/tabs/TabItem.vue";

var Plugin$6 = {
  install: function install(Vue) {
    registerComponent(Vue, script$1$1);
    registerComponent(Vue, script$5);
  }
};

var script$4 = {
    name: 'BTag',
    components: {
        [script$I.name]: script$I
    },
    props: {
        attached: Boolean,
        closable: Boolean,
        type: [String, Object],
        size: String,
        rounded: Boolean,
        disabled: Boolean,
        ellipsis: Boolean,
        tabstop: {
            type: Boolean,
            default: true
        },
        ariaCloseLabel: String,
        icon: String,
        iconType: String,
        iconPack: String,
        closeType: String,
        closeIcon: String,
        closeIconPack: String,
        closeIconType: String
    },
    emits: ['click', 'close'],
    computed: {
        // setting a boolean attribute `false` does not remove it on Vue 3.
        // `null` or `undefined` has to be given to remove it.
        disabledOrUndefined() {
            return this.disabled || undefined
        }
    },
    methods: {
        /**
        * Emit close event when delete button is clicked
        * or delete key is pressed.
        */
        close(event) {
            if (this.disabled) return

            this.$emit('close', event);
        },
        /**
        * Emit click event when tag is clicked.
        */
        click(event) {
            if (this.disabled) return

            this.$emit('click', event);
        }
    }
};

const _hoisted_1$3 = {
  key: 0,
  class: "tags has-addons inline-tags"
};
const _hoisted_2$2 = ["aria-label", "tabindex", "disabled"];
const _hoisted_3 = ["aria-label", "disabled", "tabindex"];

function render$4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_b_icon = resolveComponent("b-icon");

  return ($props.attached && $props.closable)
    ? (openBlock(), createElementBlock("div", _hoisted_1$3, [
        createBaseVNode("span", {
          class: normalizeClass(["tag", [$props.type, $props.size, { 'is-rounded': $props.rounded }]])
        }, [
          ($props.icon)
            ? (openBlock(), createBlock(_component_b_icon, {
                key: 0,
                icon: $props.icon,
                size: $props.size,
                type: $props.iconType,
                pack: $props.iconPack
              }, null, 8 /* PROPS */, ["icon", "size", "type", "pack"]))
            : createCommentVNode("v-if", true),
          createBaseVNode("span", {
            class: normalizeClass({ 'has-ellipsis': $props.ellipsis }),
            onClick: _cache[0] || (_cache[0] = (...args) => ($options.click && $options.click(...args)))
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 2 /* CLASS */)
        ], 2 /* CLASS */),
        createBaseVNode("a", {
          class: normalizeClass(["tag", [$props.size,
                     $props.closeType,
                     {'is-rounded': $props.rounded},
                     $props.closeIcon ? 'has-delete-icon' : 'is-delete']]),
          role: "button",
          "aria-label": $props.ariaCloseLabel,
          tabindex: $props.tabstop ? 0 : false,
          disabled: $options.disabledOrUndefined,
          onClick: _cache[1] || (_cache[1] = (...args) => ($options.close && $options.close(...args))),
          onKeyup: _cache[2] || (_cache[2] = withKeys(withModifiers((...args) => ($options.close && $options.close(...args)), ["prevent"]), ["delete"]))
        }, [
          ($props.closeIcon)
            ? (openBlock(), createBlock(_component_b_icon, {
                key: 0,
                "custom-class": "",
                icon: $props.closeIcon,
                size: $props.size,
                type: $props.closeIconType,
                pack: $props.closeIconPack
              }, null, 8 /* PROPS */, ["icon", "size", "type", "pack"]))
            : createCommentVNode("v-if", true)
        ], 42 /* CLASS, PROPS, HYDRATE_EVENTS */, _hoisted_2$2)
      ]))
    : (openBlock(), createElementBlock("span", {
        key: 1,
        class: normalizeClass(["tag", [$props.type, $props.size, { 'is-rounded': $props.rounded }]])
      }, [
        ($props.icon)
          ? (openBlock(), createBlock(_component_b_icon, {
              key: 0,
              icon: $props.icon,
              size: $props.size,
              type: $props.iconType,
              pack: $props.iconPack
            }, null, 8 /* PROPS */, ["icon", "size", "type", "pack"]))
          : createCommentVNode("v-if", true),
        createBaseVNode("span", {
          class: normalizeClass({ 'has-ellipsis': $props.ellipsis }),
          onClick: _cache[3] || (_cache[3] = (...args) => ($options.click && $options.click(...args)))
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 2 /* CLASS */),
        ($props.closable)
          ? (openBlock(), createElementBlock("a", {
              key: 1,
              role: "button",
              "aria-label": $props.ariaCloseLabel,
              class: normalizeClass(["delete is-small", $props.closeType]),
              disabled: $options.disabledOrUndefined,
              tabindex: $props.tabstop ? 0 : false,
              onClick: _cache[4] || (_cache[4] = (...args) => ($options.close && $options.close(...args))),
              onKeyup: _cache[5] || (_cache[5] = withKeys(withModifiers((...args) => ($options.close && $options.close(...args)), ["prevent"]), ["delete"]))
            }, null, 42 /* CLASS, PROPS, HYDRATE_EVENTS */, _hoisted_3))
          : createCommentVNode("v-if", true)
      ], 2 /* CLASS */))
}

script$4.render = render$4;
script$4.__file = "src/components/tag/Tag.vue";

var script$3 = {
    name: 'BTaglist',
    props: {
        attached: Boolean
    }
};

function render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createElementBlock("div", {
    class: normalizeClass(["tags", { 'has-addons': $props.attached }])
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2 /* CLASS */))
}

script$3.render = render$3;
script$3.__file = "src/components/tag/Taglist.vue";

var Plugin$5 = {
  install: function install(Vue) {
    registerComponent(Vue, script$4);
    registerComponent(Vue, script$3);
  }
};

var script$2 = {
    name: 'BTaginput',
    components: {
        [script$G.name]: script$G,
        [script$4.name]: script$4
    },
    mixins: [CompatFallthroughMixin, FormElementMixin],
    props: {
        modelValue: {
            type: Array,
            default: () => []
        },
        data: {
            type: Array,
            default: () => []
        },
        type: String,
        closeType: String,
        rounded: {
            type: Boolean,
            default: false
        },
        attached: {
            type: Boolean,
            default: false
        },
        maxtags: {
            type: [Number, String],
            required: false
        },
        hasCounter: {
            type: Boolean,
            default: () => config.defaultTaginputHasCounter
        },
        field: {
            type: String,
            default: 'value'
        },
        autocomplete: Boolean,
        groupField: String,
        groupOptions: String,
        nativeAutocomplete: String,
        openOnFocus: Boolean,
        keepOpen: {
            type: Boolean,
            default: true
        },
        keepFirst: Boolean,
        disabled: Boolean,
        ellipsis: Boolean,
        closable: {
            type: Boolean,
            default: true
        },
        ariaCloseLabel: String,
        confirmKeys: {
            type: Array,
            default: () => [',', 'Tab', 'Enter']
        },
        removeOnKeys: {
            type: Array,
            default: () => ['Backspace']
        },
        allowNew: Boolean,
        onPasteSeparators: {
            type: Array,
            default: () => [',']
        },
        beforeAdding: {
            type: Function,
            default: () => true
        },
        allowDuplicates: {
            type: Boolean,
            default: false
        },
        checkInfiniteScroll: {
            type: Boolean,
            default: false
        },
        createTag: {
            type: Function,
            default: (tag) => tag
        },
        appendToBody: Boolean
    },
    emits: [
        'add',
        'infinite-scroll',
        'remove',
        'typing',
        'update:modelValue'
    ],
    data() {
        return {
            tags: Array.isArray(this.modelValue)
                ? this.modelValue.slice(0)
                : (this.modelValue || []),
            newTag: '',
            isComposing: false,
            _elementRef: 'autocomplete',
            _isTaginput: true,
            requestID: null
        }
    },
    computed: {
        rootClasses() {
            return {
                'is-expanded': this.expanded
            }
        },

        containerClasses() {
            return {
                'is-focused': this.isFocused,
                'is-focusable': this.hasInput
            }
        },

        valueLength() {
            return this.newTag.trim().length
        },

        hasDefaultSlot() {
            return !!this.$slots.default
        },

        hasEmptySlot() {
            return !!this.$slots.empty
        },

        hasHeaderSlot() {
            return !!this.$slots.header
        },

        hasFooterSlot() {
            return !!this.$slots.footer
        },

        /**
         * Show the input field if a maxtags hasn't been set or reached.
         */
        hasInput() {
            return this.maxtags == null || this.maxtags === 1 || this.tagsLength < this.maxtags
        },

        tagsLength() {
            return this.tags.length
        },

        /**
         * If Taginput has onPasteSeparators prop,
         * returning new RegExp used to split pasted string.
         */
        separatorsAsRegExp() {
            const sep = this.onPasteSeparators;

            return sep.length
                ? new RegExp(sep.map((s) => {
                    return s ? s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&') : null
                }).join('|'), 'g')
                : null
        },

        disabledOrUndefined() {
            // On Vue 3, setting a boolean attribute `false` does not remove it.
            // `null` or `undefined` has to be given to remove it.
            return this.disabled || undefined
        }
    },
    watch: {
        /**
         * When v-model is changed set internal value.
         */
        modelValue(value) {
            this.tags = Array.isArray(value) ? value.slice(0) : (value || []);
        },

        hasInput() {
            if (!this.hasInput) this.onBlur();
        }
    },
    methods: {
        addTag(tag) {
            const tagToAdd = tag || this.newTag.trim();

            if (tagToAdd) {
                if (!this.autocomplete) {
                    const reg = this.separatorsAsRegExp;
                    if (reg && tagToAdd.match(reg)) {
                        tagToAdd.split(reg)
                            .map((t) => t.trim())
                            .filter((t) => t.length !== 0)
                            .map(this.addTag);
                        return
                    }
                }
                // Add the tag input if it is not blank
                // or previously added (if not allowDuplicates).
                const add = !this.allowDuplicates ? this.tags.indexOf(tagToAdd) === -1 : true;
                if (add && this.beforeAdding(tagToAdd)) {
                    if (this.maxtags === 1) {
                        this.tags = []; // replace existing tag if only 1 is allowed
                    }
                    this.tags.push(this.createTag(tagToAdd));
                    this.$emit('update:modelValue', this.tags);
                    this.$emit('add', tagToAdd);
                }

                // after autocomplete events
                this.requestID = requestAnimationFrame(() => {
                    this.newTag = '';
                    this.$emit('typing', '');
                });
            }
        },

        getNormalizedTagText(tag) {
            if (typeof tag === 'object') {
                tag = getValueByPath(tag, this.field);
            }

            return `${tag}`
        },

        customOnBlur(event) {
            // Add tag on-blur if not select only
            if (!this.autocomplete) this.addTag();

            this.onBlur(event);
        },

        onSelect(option) {
            if (!option) return

            this.addTag(option);
            this.$nextTick(() => {
                this.newTag = '';
            });
        },

        removeTag(index, event) {
            const tag = this.tags.splice(index, 1)[0];
            this.$emit('update:modelValue', this.tags);
            this.$emit('remove', tag);
            if (event) event.stopPropagation();
            if (this.openOnFocus && this.$refs.autocomplete) {
                this.$refs.autocomplete.focus();
            }
            return tag
        },

        removeLastTag() {
            if (this.tagsLength > 0) {
                this.removeTag(this.tagsLength - 1);
            }
        },

        keydown(event) {
            const { key } = event; // cannot destructure preventDefault (https://stackoverflow.com/a/49616808/2774496)
            if (this.removeOnKeys.indexOf(key) !== -1 && !this.newTag.length) {
                this.removeLastTag();
            }
            // Stop if is to accept select only
            if (this.autocomplete && !this.allowNew) return

            if (this.confirmKeys.indexOf(key) >= 0) {
                // Allow Tab to advance to next field regardless
                if (key !== 'Tab') event.preventDefault();
                if (key === 'Enter' && this.isComposing) return
                this.addTag();
            }
        },

        onTyping(event) {
            this.$emit('typing', event.trim());
        },

        emitInfiniteScroll() {
            this.$emit('infinite-scroll');
        }
    },

    beforeUnmount() {
        cancelAnimationFrame(this.requestID);
    }
};

const _hoisted_1$2 = ["disabled"];
const _hoisted_2$1 = {
  key: 0,
  class: "help counter"
};

function render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_b_tag = resolveComponent("b-tag");
  const _component_b_autocomplete = resolveComponent("b-autocomplete");

  return (openBlock(), createElementBlock("div", mergeProps({
    class: ["taginput control", $options.rootClasses]
  }, _ctx.rootAttrs), [
    createBaseVNode("div", {
      class: normalizeClass(["taginput-container", [_ctx.statusType, _ctx.size, $options.containerClasses]]),
      disabled: $options.disabledOrUndefined,
      onClick: _cache[3] || (_cache[3] = $event => ($options.hasInput && _ctx.focus($event)))
    }, [
      renderSlot(_ctx.$slots, "selected", { tags: $data.tags }, () => [
        (openBlock(true), createElementBlock(Fragment, null, renderList($data.tags, (tag, index) => {
          return (openBlock(), createBlock(_component_b_tag, {
            key: $options.getNormalizedTagText(tag) + index,
            type: $props.type,
            "close-type": $props.closeType,
            size: _ctx.size,
            rounded: $props.rounded,
            attached: $props.attached,
            tabstop: false,
            disabled: $options.disabledOrUndefined,
            ellipsis: $props.ellipsis,
            closable: $props.closable,
            "aria-close-label": $props.ariaCloseLabel,
            title: $props.ellipsis && $options.getNormalizedTagText(tag),
            onClose: $event => ($options.removeTag(index, $event))
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "tag", { tag: tag }, () => [
                createTextVNode(toDisplayString($options.getNormalizedTagText(tag)), 1 /* TEXT */)
              ])
            ]),
            _: 2 /* DYNAMIC */
          }, 1032 /* PROPS, DYNAMIC_SLOTS */, ["type", "close-type", "size", "rounded", "attached", "disabled", "ellipsis", "closable", "aria-close-label", "title", "onClose"]))
        }), 128 /* KEYED_FRAGMENT */))
      ]),
      ($options.hasInput)
        ? (openBlock(), createBlock(_component_b_autocomplete, mergeProps({
            key: 0,
            ref: "autocomplete",
            modelValue: $data.newTag,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => (($data.newTag) = $event))
          }, _ctx.fallthroughAttrs, {
            data: $props.data,
            field: $props.field,
            icon: _ctx.icon,
            "icon-pack": _ctx.iconPack,
            maxlength: _ctx.maxlength,
            "has-counter": false,
            size: _ctx.size,
            disabled: $options.disabledOrUndefined,
            loading: _ctx.loading,
            autocomplete: $props.nativeAutocomplete,
            "open-on-focus": $props.openOnFocus,
            "keep-open": $props.keepOpen,
            "keep-first": $props.keepFirst,
            "group-field": $props.groupField,
            "group-options": $props.groupOptions,
            "use-html5-validation": _ctx.useHtml5Validation,
            "check-infinite-scroll": $props.checkInfiniteScroll,
            "append-to-body": $props.appendToBody,
            "confirm-keys": $props.confirmKeys,
            onTyping: $options.onTyping,
            onFocus: _ctx.onFocus,
            onBlur: $options.customOnBlur,
            onKeydown: $options.keydown,
            onCompositionstart: _cache[1] || (_cache[1] = $event => ($data.isComposing = true)),
            onCompositionend: _cache[2] || (_cache[2] = $event => ($data.isComposing = false)),
            onSelect: $options.onSelect,
            onInfiniteScroll: $options.emitInfiniteScroll
          }), createSlots({ _: 2 /* DYNAMIC */ }, [
            ($options.hasHeaderSlot)
              ? {
                  name: "header",
                  fn: withCtx(() => [
                    renderSlot(_ctx.$slots, "header")
                  ]),
                  key: "0"
                }
              : undefined,
            ($options.hasDefaultSlot)
              ? {
                  name: "default",
                  fn: withCtx((props) => [
                    renderSlot(_ctx.$slots, "default", {
                      option: props.option,
                      index: props.index
                    })
                  ]),
                  key: "1"
                }
              : undefined,
            ($options.hasEmptySlot)
              ? {
                  name: "empty",
                  fn: withCtx(() => [
                    renderSlot(_ctx.$slots, "empty")
                  ]),
                  key: "2"
                }
              : undefined,
            ($options.hasFooterSlot)
              ? {
                  name: "footer",
                  fn: withCtx(() => [
                    renderSlot(_ctx.$slots, "footer")
                  ]),
                  key: "3"
                }
              : undefined
          ]), 1040 /* FULL_PROPS, DYNAMIC_SLOTS */, ["modelValue", "data", "field", "icon", "icon-pack", "maxlength", "size", "disabled", "loading", "autocomplete", "open-on-focus", "keep-open", "keep-first", "group-field", "group-options", "use-html5-validation", "check-infinite-scroll", "append-to-body", "confirm-keys", "onTyping", "onFocus", "onBlur", "onKeydown", "onSelect", "onInfiniteScroll"]))
        : createCommentVNode("v-if", true)
    ], 10 /* CLASS, PROPS */, _hoisted_1$2),
    ($props.hasCounter && ($props.maxtags || _ctx.maxlength))
      ? (openBlock(), createElementBlock("small", _hoisted_2$1, [
          (_ctx.maxlength && $options.valueLength > 0)
            ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createTextVNode(toDisplayString($options.valueLength) + " / " + toDisplayString(_ctx.maxlength), 1 /* TEXT */)
              ], 64 /* STABLE_FRAGMENT */))
            : ($props.maxtags)
              ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  createTextVNode(toDisplayString($options.tagsLength) + " / " + toDisplayString($props.maxtags), 1 /* TEXT */)
                ], 64 /* STABLE_FRAGMENT */))
              : createCommentVNode("v-if", true)
        ]))
      : createCommentVNode("v-if", true)
  ], 16 /* FULL_PROPS */))
}

script$2.render = render$2;
script$2.__file = "src/components/taginput/Taginput.vue";

var Plugin$4 = {
  install: function install(Vue) {
    registerComponent(Vue, script$2);
  }
};

var Plugin$3 = {
  install: function install(Vue) {
    registerComponent(Vue, script$r);
  }
};

var script$1 = {
    name: 'BToast',
    mixins: [NoticeMixin],
    data() {
        return {
            newDuration: this.duration || config.defaultToastDuration
        }
    }
};

const _hoisted_1$1 = ["aria-hidden"];
const _hoisted_2 = ["innerHTML"];

function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock(Transition, {
    "enter-active-class": _ctx.transition.enter,
    "leave-active-class": _ctx.transition.leave,
    persisted: ""
  }, {
    default: withCtx(() => [
      withDirectives(createBaseVNode("div", {
        onMouseenter: _cache[0] || (_cache[0] = (...args) => (_ctx.pause && _ctx.pause(...args))),
        onMouseleave: _cache[1] || (_cache[1] = (...args) => (_ctx.removePause && _ctx.removePause(...args))),
        class: normalizeClass(["toast", [_ctx.type, _ctx.position]]),
        "aria-hidden": !_ctx.isActive,
        role: "alert"
      }, [
        (_ctx.$slots.default)
          ? renderSlot(_ctx.$slots, "default", { key: 0 })
          : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createCommentVNode(" eslint-disable-next-line vue/no-v-html "),
              createBaseVNode("div", { innerHTML: _ctx.message }, null, 8 /* PROPS */, _hoisted_2)
            ], 64 /* STABLE_FRAGMENT */))
      ], 42 /* CLASS, PROPS, HYDRATE_EVENTS */, _hoisted_1$1), [
        [vShow, _ctx.isActive]
      ])
    ]),
    _: 3 /* FORWARDED */
  }, 8 /* PROPS */, ["enter-active-class", "leave-active-class"]))
}

script$1.render = render$1;
script$1.__file = "src/components/toast/Toast.vue";

function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var ToastProgrammatic = /*#__PURE__*/function () {
  function ToastProgrammatic(app) {
    _classCallCheck(this, ToastProgrammatic);
    this.app = app; // may be undefined in the testing environment
  }
  _createClass(ToastProgrammatic, [{
    key: "open",
    value: function open(params) {
      if (typeof params === 'string') {
        params = {
          message: params
        };
      }
      var defaultParam = {
        position: config.defaultToastPosition || 'is-top'
      };
      if (params.parent) {
        delete params.parent;
      }
      var slot;
      if (Array.isArray(params.message)) {
        slot = params.message;
        delete params.message;
      }
      var propsData = merge(defaultParam, params);
      var container = document.createElement('div');
      // Vue 3 requires a new app to mount another component
      var vueInstance = createApp({
        data: function data() {
          return {
            toastVNode: null
          };
        },
        methods: {
          close: function close() {
            var toast = getComponentFromVNode(this.toastVNode);
            if (toast) {
              toast.close();
            }
          }
        },
        render: function render() {
          this.toastVNode = h(script$1, _objectSpread(_objectSpread({}, propsData), {}, {
            // On Vue 3, $destroy is no longer available.
            // A toast has to be unmounted manually.
            onClose: function onClose() {
              if (typeof propsData.onClose === 'function') {
                propsData.onClose();
              }
              // timeout for the animation complete
              // before unmounting
              setTimeout(function () {
                vueInstance.unmount();
              }, 150);
            }
          }), slot != null ? {
            "default": function _default() {
              return slot;
            }
          } : undefined);
          // we are interested in `toastVNode.component` but
          // at this point `toastVNode.component` should be null
          return this.toastVNode;
        }
      });
      if (this.app) {
        copyAppContext(this.app, vueInstance);
      } else {
        // adds $buefy global property
        // so that $buefy.globalNoticeInterval is available on the new Vue app
        vueInstance.config.globalProperties.$buefy = {};
      }
      return vueInstance.mount(container);
    }
  }]);
  return ToastProgrammatic;
}();
var Plugin$2 = {
  install: function install(Vue) {
    registerComponentProgrammatic(Vue, 'toast', new ToastProgrammatic(Vue));
  }
};

var Plugin$1 = {
  install: function install(Vue) {
    registerComponent(Vue, script$u);
  }
};

var script = {
    name: 'BUpload',
    mixins: [CompatFallthroughMixin, FormElementMixin],
    props: {
        modelValue: {
            type: [Object, Function, File$1, Array]
        },
        multiple: Boolean,
        disabled: Boolean,
        accept: String,
        dragDrop: Boolean,
        type: {
            type: String,
            default: 'is-primary'
        },
        native: {
            type: Boolean,
            default: false
        },
        expanded: {
            type: Boolean,
            default: false
        },
        rounded: {
            type: Boolean,
            default: false
        }
    },
    emits: ['invalid', 'update:modelValue'],
    data() {
        return {
            newValue: this.modelValue,
            dragDropFocus: false,
            _elementRef: 'input'
        }
    },
    computed: {
        disabledOrUndefined() {
            // On Vue 3, setting a boolean attribute `false` does not remove it,
            // `true` or `undefined` has to be given to remove it.
            return this.disabled || undefined
        }
    },
    watch: {
        /**
         *   When v-model is changed:
         *   1. Set internal value.
         *   2. Reset internal input file value
         *   3. If it's invalid, validate again.
         */
        modelValue(value) {
            this.newValue = value;
            if (!value || (Array.isArray(value) && value.length === 0)) {
                this.$refs.input.value = null;
            }
            !this.isValid && !this.dragDrop && this.checkHtml5Validity();
        }
    },
    methods: {
        /**
        * Listen change event on input type 'file',
        * emit 'input' event and validate
        */
        onFileChange(event) {
            if (this.disabled || this.loading) return
            if (this.dragDrop) this.updateDragDropFocus(false);
            const value = event.target.files || event.dataTransfer.files;
            if (value.length === 0) {
                if (!this.newValue) return
                if (this.native) this.newValue = null;
            } else if (!this.multiple) {
                // only one element in case drag drop mode and isn't multiple
                if (this.dragDrop && value.length !== 1) return
                else {
                    const file = value[0];
                    if (this.checkType(file)) this.newValue = file;
                    else if (this.newValue) {
                        this.newValue = null;
                        this.clearInput();
                    } else {
                        // Force input back to empty state and recheck validity
                        this.clearInput();
                        this.checkHtml5Validity();
                        return
                    }
                }
            } else {
                // always new values if native or undefined local
                let newValues = false;
                if (this.native || !this.newValue) {
                    this.newValue = [];
                    newValues = true;
                }
                for (let i = 0; i < value.length; i++) {
                    const file = value[i];
                    if (this.checkType(file)) {
                        this.newValue.push(file);
                        newValues = true;
                    }
                }
                if (!newValues) return
            }
            this.$emit('update:modelValue', this.newValue);
            !this.dragDrop && this.checkHtml5Validity();
        },

        /*
        * Reset file input value
        */
        clearInput() {
            this.$refs.input.value = null;
        },

        /**
        * Listen drag-drop to update internal variable
        */
        updateDragDropFocus(focus) {
            if (!this.disabled && !this.loading) {
                this.dragDropFocus = focus;
            }
        },

        /**
        * Check mime type of file
        */
        checkType(file) {
            if (!this.accept) return true
            const types = this.accept.split(',');
            if (types.length === 0) return true
            let valid = false;
            for (let i = 0; i < types.length && !valid; i++) {
                const type = types[i].trim();
                if (type) {
                    if (type.substring(0, 1) === '.') {
                        // check extension
                        const extension = file.name.toLowerCase().slice(-type.length);
                        if (extension === type.toLowerCase()) {
                            valid = true;
                        }
                    } else {
                        // check mime type
                        if (file.type.match(type)) {
                            valid = true;
                        }
                    }
                }
            }
            if (!valid) this.$emit('invalid');
            return valid
        }
    }
};

const _hoisted_1 = ["multiple", "accept", "disabled"];

function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createElementBlock("label", mergeProps({ class: "upload control" }, _ctx.rootAttrs, {
    class: [{'is-expanded' : $props.expanded, 'is-rounded' : $props.rounded}]
  }), [
    (!$props.dragDrop)
      ? renderSlot(_ctx.$slots, "default", { key: 0 })
      : (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass(["upload-draggable", [$props.type, {
                'is-loading': _ctx.loading,
                'is-disabled': $props.disabled,
                'is-hovered': $data.dragDropFocus,
                'is-expanded': $props.expanded,
            }]]),
          onDragover: _cache[0] || (_cache[0] = withModifiers($event => ($options.updateDragDropFocus(true)), ["prevent"])),
          onDragleave: _cache[1] || (_cache[1] = withModifiers($event => ($options.updateDragDropFocus(false)), ["prevent"])),
          onDragenter: _cache[2] || (_cache[2] = withModifiers($event => ($options.updateDragDropFocus(true)), ["prevent"])),
          onDrop: _cache[3] || (_cache[3] = withModifiers((...args) => ($options.onFileChange && $options.onFileChange(...args)), ["prevent"]))
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 34 /* CLASS, HYDRATE_EVENTS */)),
    createBaseVNode("input", mergeProps({
      ref: "input",
      type: "file"
    }, _ctx.fallthroughAttrs, {
      multiple: $props.multiple,
      accept: $props.accept,
      disabled: $options.disabledOrUndefined,
      onChange: _cache[4] || (_cache[4] = (...args) => ($options.onFileChange && $options.onFileChange(...args)))
    }), null, 16 /* FULL_PROPS */, _hoisted_1)
  ], 16 /* FULL_PROPS */))
}

script.render = render;
script.__file = "src/components/upload/Upload.vue";

var Plugin = {
  install: function install(Vue) {
    registerComponent(Vue, script);
  }
};

var ConfigComponent = {
  getOptions: function getOptions() {
    return config;
  },
  setOptions: function setOptions$1(options) {
    setOptions(merge(config, options, true));
  }
};

var components = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Autocomplete: Plugin$F,
    Breadcrumb: Plugin$E,
    Button: Plugin$D,
    Carousel: Plugin$C,
    Checkbox: Plugin$B,
    Clockpicker: Plugin$z,
    Collapse: Plugin$A,
    Colorpicker: Plugin$y,
    Datepicker: Plugin$x,
    Datetimepicker: Plugin$w,
    Dialog: Plugin$v,
    Dropdown: Plugin$u,
    Field: Plugin$t,
    Icon: Plugin$s,
    Image: Plugin$r,
    Input: Plugin$q,
    Loading: Plugin$p,
    Menu: Plugin$o,
    Message: Plugin$n,
    Modal: Plugin$m,
    Navbar: Plugin$k,
    Notification: Plugin$l,
    Numberinput: Plugin$j,
    Pagination: Plugin$i,
    Progress: Plugin$h,
    Radio: Plugin$g,
    Rate: Plugin$f,
    Select: Plugin$e,
    Sidebar: Plugin$c,
    Skeleton: Plugin$d,
    Slider: Plugin$b,
    Snackbar: Plugin$a,
    Steps: Plugin$9,
    Switch: Plugin$8,
    Table: Plugin$7,
    Tabs: Plugin$6,
    Tag: Plugin$5,
    Taginput: Plugin$4,
    Timepicker: Plugin$3,
    Toast: Plugin$2,
    Tooltip: Plugin$1,
    Upload: Plugin
});

var Buefy = {
  install: function install(Vue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    // Options
    setOptions(merge(config, options, true));
    // Components
    for (var componentKey in components) {
      Vue.use(components[componentKey]);
    }
    // Config component
    registerComponentProgrammatic(Vue, 'config', ConfigComponent);
    Vue.config.globalProperties.$buefy.globalNoticeInterval = null;
  }
};

const appCreated = vue_cjs.createApp({
    data() {
        return {
            modelChanged: new Subject(),
            flavourChanged: new Subject(),
            sceneChanged: new Subject(),
            cameraChanged: new Subject(),
            
            debugchannelChanged: new Subject(),
            tonemapChanged: new Subject(),
            skinningChanged: new Subject(),
            punctualLightsChanged: new Subject(),

            iblChanged: new Subject(),
            blurEnvChanged: new Subject(),
            morphingChanged: new Subject(),
            colorChanged: new Subject(),

            environmentRotationChanged: new Subject(),
            animationPlayChanged: new Subject(),
            variantChanged: new Subject(),
            exposureChanged: new Subject(),

            clearcoatChanged: new Subject(),
            sheenChanged: new Subject(),
            transmissionChanged: new Subject(),
            diffuseTransmissionChanged: new Subject(),
            cameraExport: new Subject(),

            captureCanvas: new Subject(),
            iblIntensityChanged: new Subject(),

            volumeChanged: new Subject(),
            iorChanged: new Subject(),
            iridescenceChanged: new Subject(),
            anisotropyChanged: new Subject(),
            dispersionChanged: new Subject(),
            specularChanged: new Subject(),
            emissiveStrengthChanged: new Subject(),
            renderEnvChanged: new Subject(),
            addEnvironmentChanged: new Subject(),
            selectedAnimationsChanged: new Subject(),
            selectedEnvironmentChanged: new Subject(),

            validatorChanged: new Subject(),

            fullheight: true,
            right: true,
            models: ["DamagedHelmet"],
            flavours: ["glTF", "glTF-Binary", "glTF-Quantized", "glTF-Draco", "glTF-pbrSpecularGlossiness"],
            scenes: [{title: "0"}, {title: "1"}],
            cameras: [{title: "User Camera", index: -1}],
            materialVariants: ["None"],

            animations: [{title: "None"}],
            tonemaps: [{title: "None"}],
            debugchannels: [{title: "None"}],
            xmp: [{title: "xmp"}],
            assetCopyright: "",
            assetGenerator: "",
            statistics: [],

            selectedModel: "DamagedHelmet",
            selectedFlavour: "",
            selectedScene: {},
            selectedCamera: {},
            selectedVariant: "None",
            selectedAnimations: [],
            disabledAnimations: [],

            validationReport: {},

            ibl: true,
            iblIntensity: 0.0,
            punctualLights: true,
            renderEnv: true,
            blurEnv: true,
            clearColor: "",
            environmentRotations: [{title: "+Z"}, {title: "-X"}, {title: "-Z"}, {title: "+X"}],
            selectedEnvironmentRotation: "+Z",
            environments: [{index: 0, name: ""}],
            selectedEnvironment: 0,

            debugChannel: "None",
            exposureSetting: 0,
            toneMap: "Khronos PBR Neutral",
            skinning: true,
            morphing: true,
            clearcoatEnabled: true,
            sheenEnabled: true,
            transmissionEnabled: true,
            volumeEnabled: true,
            iorEnabled: true,
            iridescenceEnabled: true,
            diffuseTransmissionEnabled: true,
            anisotropyEnabled: true,
            dispersionEnabled: true,
            specularEnabled: true,
            emissiveStrengthEnabled: true,

            activeTab: 0,
            tabContentHidden: true,
            loadingComponent: undefined,
            showDropDownOverlay: false,
            uploadedHDR: undefined,
            uiVisible: false,
            isMobile: false,
            noUi: false,
            

            // these are handles for certain ui change related things
            environmentVisiblePrefState: true,
            volumeEnabledPrefState: true,
        };
    },
    watch: {
        selectedAnimations: function (newValue) {
            this.selectedAnimationsChanged.next(newValue);
        }
    },
    beforeMount: function(){
        // Definition of mobile: https://bulma.io/documentation/start/responsiveness/
        if(document.documentElement.clientWidth > 768) { 
            this.uiVisible = true;
            this.isMobile = false;
        } else {
            this.uiVisible=false;
            this.isMobile = true;
        }
        const queryString = window.location.search;
        const urlParams = new URLSearchParams(queryString);
        const noUI = urlParams.get("noUI");
        if (noUI !== null) {
            this.uiVisible = false;
            this.noUI = true;
        }
    },
    mounted: function()
    {
        // remove input class from color picker (added by default by buefy)
        const colorPicker = document.getElementById("clearColorPicker");
        colorPicker.classList.remove("input");

        // test if webgl is present
        const canvas = document.getElementById("canvas");
        const context = canvas.getContext("webgl2", { alpha: false, antialias: true });
        if (context === undefined || context === null) {
            this.error("The sample viewer requires WebGL 2.0, which is not supported by this browser or device. " + 
            "Please try again with another browser, or check https://get.webgl.org/webgl2/ " +
            "if you believe you are seeing this message in error.", 15000);
        }

        // change styling of tab-bar
        this.$nextTick(function () {
            // Code that will run only after the
            // entire view has been rendered

            let navElement = document.getElementById("tabsContainer").childNodes[0];

            if(!this.isMobile){
                navElement.style.width = "100px";
            }

            let ulElement = navElement.childNodes[0];
            while (ulElement) {
                if (ulElement.nodeName === "UL") {
                    break;
                }
                ulElement = ulElement.nextElementSibling;
            }

            // Avoid margin on top for mobile devices
            if(this.isMobile) { 
                let liElement =ulElement.childNodes[0];
                while (liElement) {
                    if (liElement.nodeName === "LI") {
                        break;
                    }
                    liElement = liElement.nextElementSibling;
                }
                liElement.style.marginTop = "0px";
            }

            // add github logo to tab-bar
            var a = document.createElement('a');
            a.href = "https://github.com/KhronosGroup/glTF-Sample-Viewer";
            var img = document.createElement('img');
            img.src ="assets/ui/GitHub-Mark-Light-32px.png";
            img.style.width = "22px";
            img.style.height = "22px";
            ulElement.appendChild(a);
            a.appendChild(img);
        });

    },
    methods:
    {
        async copyToClipboard(text) {
            try {
                await navigator.clipboard.writeText(text);
                this.$buefy.toast.open({
                    message: "Copied to clipboard",
                    type: 'is-success'
                });
            } catch (err) {
                this.error("Error copying to clipboard.");
            }
        },
        downloadJSON(filename, json) {
            const text = JSON.stringify(json, undefined, 4);
            const dataURL = "data:application/json;charset=utf-8," + encodeURIComponent(text);
            const element = document.createElement("a");
            element.setAttribute("href", dataURL);
            element.setAttribute("download", filename);
            element.style.display = "none";
            document.body.appendChild(element);
            element.click();
            document.body.removeChild(element);
        },
        getValidationCounter: function(){
            let number = 0;
            let color = "white";
            if (this.validationReport?.issues?.numErrors > 0) {
                number = this.validationReport?.issues?.numErrors;
                color = "red";
            } else if (this.validationReport?.issues?.numWarnings > 0) {
                number = this.validationReport?.issues?.numWarnings;
                color = "yellow";
            } else if (this.validationReport?.issues?.numInfos > 0) {
                number = this.validationReport?.issues?.numInfos;
            }
            if (number !== 0) {
                return `<div style="display:flex;color:black; font-weight:bold; background-color:${color}; border-radius:50%; width:fit-content; min-width:2rem; align-items:center;aspect-ratio:1/1;justify-content:center;">${number}</div>`;
            }
            if (this.tabsHidden === false && this.activeTab === 2) {
                return `<img src="assets/ui/Capture 50X50.svg" width="50px" height="100%">`;
            }
            return '<img src="assets/ui/Capture 30X30.svg" width="30px">';
        },
        setAnimationState: function(value)
        {
            this.$refs.animationState.setState(value);
        },
        iblTriggered: function(value)
        {
            if(value == false) {
                this.environmentVisiblePrefState = this.renderEnv;
                this.renderEnv = false;
                this.renderEnvChanged.next(false);
            } else {
                this.renderEnv = this.environmentVisiblePrefState;
                this.renderEnvChanged.next(this.renderEnv);
            }
        },
        transmissionTriggered: function(value)
        {
            if (value == false && this.diffuseTransmissionEnabled == false) {
                this.volumeEnabledPrefState = this.volumeEnabled;
                this.volumeEnabled = false;
            } else if (value == true && this.diffuseTransmissionEnabled == false) {
                this.volumeEnabled = this.volumeEnabledPrefState;
            }
        },
        diffuseTransmissionTriggered: function(value)
        {
            if (value == false && this.transmissionEnabled == false) {
                this.volumeEnabledPrefState = this.volumeEnabled;
                this.volumeEnabled = false;
            } else if (value == true && this.transmissionEnabled == false) {
                this.volumeEnabled = this.volumeEnabledPrefState;
            }
        },
        collapseActiveTab : function(event, item) {
            if (item === this.activeTab) {
                this.tabContentHidden = !this.tabContentHidden;
                
                if(this.tabContentHidden) {
                    // remove is-active class if tabs are hidden
                    event.stopPropagation();
                    
                    let navElements = document.getElementById("tabsContainer").children[0].children[0].children;
                    for(let elem of navElements) {
                        elem.classList.remove('is-active');
                    }
                } else {
                    // add is-active class to correct element
                    let activeNavElement = document.getElementById("tabsContainer").children[0].children[0].children[item];
                    activeNavElement.classList.add('is-active');
                }
                return;
            } else {
                // reset tab visibility
                this.tabContentHidden = false;
            }
            
        },
        warn(message) {
            this.$buefy.toast.open({
                message: message,
                type: 'is-warning'
            });
        },
        error(message, duration = 5000) {
            this.$buefy.toast.open({
                message: message,
                type: 'is-danger',
                duration: duration
            });
        },
        goToLoadingState() {
            if(this.loadingComponent !== undefined)
            {
                return;
            }
            this.loadingComponent = this.$buefy.loading.open({
                container: null
            });
        },
        exitLoadingState()
        {
            if(this.loadingComponent === undefined)
            {
                return;
            }
            this.loadingComponent.close();
            this.loadingComponent = undefined;
        },
        onFileChange(e) {
            const file = e.target.files[0];
            this.addEnvironmentChanged.next({hdr_path: file});
        },

        toggleUI() {
            this.uiVisible = !this.uiVisible;
        },
    }
});

appCreated.use(Buefy);

// general components
appCreated.component('toggle-button', {
    props: ['ontext', 'offtext'],
    template:'#toggleButtonTemplate',
    data(){
        return {
            name: "Play",
            isOn: false
        };
    },
    mounted(){
        this.name = this.ontext;
    },
    methods:
    {
        buttonclicked: function()
        {
            this.isOn = !this.isOn;
            this.name = this.isOn ? this.ontext : this.offtext;
            this.$emit('buttonclicked', this.isOn);
        },
        setState: function(value)
        {
            this.isOn = value;
            this.name = this.isOn ? this.ontext : this.offtext;
        }
    }
});
appCreated.component('json-to-ui-template', {
    props: ['data', 'isinner'],
    template:'#jsonToUITemplate'
});

const app = appCreated.mount('#app');

const canvasUI = vue_cjs.createApp({
    data() {
        return {
            timer: null
        };
    },
    methods:
    {
    }

});

canvasUI.use(Buefy);

canvasUI.mount('#canvasUI');

// pipe error messages to UI
(() => {
    const originalWarn = console.warn;
    const originalError = console.error;

    console.warn = function(txt) {
        app.warn(txt);
        originalWarn.apply(console, arguments);
    };
    console.error = function(txt) {
        app.error(txt);
        originalError.apply(console, arguments);
    };

    window.onerror = function(msg, url, lineNo, columnNo, error) {
        app.error([
            'Message: ' + msg,
            'URL: ' + url,
            'Line: ' + lineNo,
            'Column: ' + columnNo,
            'Error object: ' + JSON.stringify(error)
        ].join(' - '));
    };
})();

class GltfModelPathProvider
{
    constructor(url, ignoredVariants = [])
    {
        this.url = url;
        this.ignoredVariants = ignoredVariants;
        this.modelsDictionary = undefined;
    }

    async initialize()
    {
        const response = await fetch(this.url + "/Models/model-index.json");
        this.populateDictionary(await response.json());
    }

    resolve(modelKey, flavour)
    {
        return this.modelsDictionary[modelKey][flavour];
    }

    getAllKeys()
    {
        return Object.keys(this.modelsDictionary);
    }

    populateDictionary(modelIndexer)
    {
        const modelsFolder = this.url + "/Models";
        this.modelsDictionary = {};
        for (const entry of modelIndexer)
        {
            if (entry.variants === undefined || entry.name === undefined)
            {
                continue;
            }

            let variants = [];

            for (const variant of Object.keys(entry.variants))
            {
                if (this.ignoredVariants.includes(variant))
                {
                    continue;
                }

                const fileName = entry.variants[variant];
                variants[variant] = modelsFolder + "/" + entry.name + "/" + variant + "/" + fileName;
            }
            this.modelsDictionary[entry.name] = variants;
        }
    }

    getModelFlavours(modelName)
    {
        if(this.modelsDictionary[modelName] === undefined)
        {
            return ["glTF"];
        }
        return Object.keys(this.modelsDictionary[modelName]);
    }
}

function fillEnvironmentWithPaths(environmentNames, environmentsBasePath)
{
    Object.keys(environmentNames).map(function(name, index) {
        const title = environmentNames[name];
        environmentNames[name] = {
            index: index,
            title: title,
            hdr_path: environmentsBasePath + name + ".hdr",
            jpg_path: environmentsBasePath + name + ".jpg",
            license_path: environmentsBasePath + name + ".hdr.license",
            base_path: environmentsBasePath
        };
    });
    return environmentNames;
}

function commonjsRequire(path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

var gltf_validator_dart$1 = {};

(function (exports) {
	var dartNodeIsActuallyNode="undefined"!=typeof process&&(process.versions||{}).hasOwnProperty("node"),self=dartNodeIsActuallyNode?Object.create(globalThis):globalThis;if(self.scheduleImmediate="undefined"!=typeof setImmediate?function(e){setImmediate(e);}:function(e){setTimeout(e,0);},"undefined"!=typeof commonjsRequire)self.require=commonjsRequire;self.exports=exports;if("undefined"!=typeof process)self.process=process;if("undefined"!=typeof __dirname)self.__dirname=__dirname;if("undefined"!=typeof __filename)self.__filename=__filename;if("undefined"!=typeof Buffer)self.Buffer=Buffer;if(dartNodeIsActuallyNode){var url=("undefined"!=typeof __webpack_require__?__non_webpack_require__:commonjsRequire)("url");Object.defineProperty(self,"location",{value:{get href(){if(url.pathToFileURL)return url.pathToFileURL(process.cwd()).href+"/";else return "file://"+function(){var e=process.cwd();if("win32"!=process.platform)return e;else return "/"+e.replace(/\\/g,"/")}()+"/"}}}),function(){function e(){try{throw new Error}catch(n){var e=n.stack,r=new RegExp("^ *at [^(]*\\((.*):[0-9]*:[0-9]*\\)$","mg"),f=null;do{var t=r.exec(e);if(null!=t)f=t;}while(null!=t);return f[1]}}var r=null;Object.defineProperty(self,"document",{value:{get currentScript(){if(null==r)r={src:e()};return r}}});}(),self.dartDeferredLibraryLoader=function(e,r,f){try{load(e),r();}catch(e){f(e);}};}(function dartProgram(){function copyProperties(a,b){var s=Object.keys(a);
	for(var r=0;r<s.length;r++){var q=s[r];
	b[q]=a[q];}}function mixinPropertiesHard(a,b){var s=Object.keys(a);
	for(var r=0;r<s.length;r++){var q=s[r];
	if(!b.hasOwnProperty(q))b[q]=a[q];}}function mixinPropertiesEasy(a,b){Object.assign(b,a);}var z=function(){var s=function(){};
	s.prototype={p:{}};
	var r=new s();
	if(!(r.__proto__&&r.__proto__.p===s.prototype.p))return false
	try{if(typeof navigator!="undefined"&&typeof navigator.userAgent=="string"&&navigator.userAgent.indexOf("Chrome/")>=0)return true
	if(typeof version=="function"&&version.length==0){var q=version();
	if(/^\d+\.\d+\.\d+\.\d+$/.test(q))return true}}catch(p){}return false}();
	function inherit(a,b){a.prototype.constructor=a;
	a.prototype["$i"+a.name]=a;
	if(b!=null){if(z){a.prototype.__proto__=b.prototype;
	return}var s=Object.create(b.prototype);
	copyProperties(a.prototype,s);
	a.prototype=s;}}function inheritMany(a,b){for(var s=0;s<b.length;s++)inherit(b[s],a);}function mixinEasy(a,b){mixinPropertiesEasy(b.prototype,a.prototype);
	a.prototype.constructor=a;}function mixinHard(a,b){mixinPropertiesHard(b.prototype,a.prototype);
	a.prototype.constructor=a;}function lazyOld(a,b,c,d){var s=a;
	a[b]=s;
	a[c]=function(){a[c]=function(){A.xP(b);};
	var r;
	var q=d;
	try{if(a[b]===s){r=a[b]=q;
	r=a[b]=d();}else r=a[b];}finally{if(r===q)a[b]=null;
	a[c]=function(){return this[b]};}return r};}function lazy(a,b,c,d){var s=a;
	a[b]=s;
	a[c]=function(){if(a[b]===s)a[b]=d();
	a[c]=function(){return this[b]};
	return a[b]};}function lazyFinal(a,b,c,d){var s=a;
	a[b]=s;
	a[c]=function(){if(a[b]===s){var r=d();
	if(a[b]!==s)A.nU(b);
	a[b]=r;}var q=a[b];
	a[c]=function(){return q};
	return q};}function makeConstList(a){a.immutable$list=Array;
	a.fixed$length=Array;
	return a}function convertToFastObject(a){	return a}function convertAllToFastObject(a){for(var s=0;s<a.length;++s)convertToFastObject(a[s]);}	function instanceTearOffGetter(a,b){var s=null;
	return a?function(c){if(s===null)s=A.nO(b);
	return new s(c,this)}:function(){if(s===null)s=A.nO(b);
	return new s(this,null)}}function staticTearOffGetter(a){var s=null;
	return function(){if(s===null)s=A.nO(a).prototype;
	return s}}var x=0;
	function tearOffParameters(a,b,c,d,e,f,g,h,i,j){if(typeof h=="number")h+=x;
	return {co:a,iS:b,iI:c,rC:d,dV:e,cs:f,fs:g,fT:h,aI:i||0,nDA:j}}function installStaticTearOff(a,b,c,d,e,f,g,h){var s=tearOffParameters(a,true,false,c,d,e,f,g,h,false);
	var r=staticTearOffGetter(s);
	a[b]=r;}function installInstanceTearOff(a,b,c,d,e,f,g,h,i,j){c=!!c;
	var s=tearOffParameters(a,false,c,d,e,f,g,h,i,!!j);
	var r=instanceTearOffGetter(c,s);
	a[b]=r;}function setOrUpdateInterceptorsByTag(a){var s=v.interceptorsByTag;
	if(!s){v.interceptorsByTag=a;
	return}copyProperties(a,s);}function setOrUpdateLeafTags(a){var s=v.leafTags;
	if(!s){v.leafTags=a;
	return}copyProperties(a,s);}function updateTypes(a){var s=v.types;
	var r=s.length;
	s.push.apply(s,a);
	return r}function updateHolder(a,b){copyProperties(b,a);
	return a}var hunkHelpers=function(){var s=function(a,b,c,d,e){return function(f,g,h,i){return installInstanceTearOff(f,g,a,b,c,d,[h],i,e,false)}},r=function(a,b,c,d){return function(e,f,g,h){return installStaticTearOff(e,f,a,b,c,[g],h,d)}};
	return {inherit:inherit,inheritMany:inheritMany,mixin:mixinEasy,mixinHard:mixinHard,installStaticTearOff:installStaticTearOff,installInstanceTearOff:installInstanceTearOff,_instance_0u:s(0,0,null,["$0"],0),_instance_1u:s(0,1,null,["$1"],0),_instance_2u:s(0,2,null,["$2"],0),_instance_0i:s(1,0,null,["$0"],0),_instance_1i:s(1,1,null,["$1"],0),_instance_2i:s(1,2,null,["$2"],0),_static_0:r(0,null,["$0"],0),_static_1:r(1,null,["$1"],0),_static_2:r(2,null,["$2"],0),makeConstList:makeConstList,lazy:lazy,lazyFinal:lazyFinal,lazyOld:lazyOld,updateHolder:updateHolder,convertToFastObject:convertToFastObject,updateTypes:updateTypes,setOrUpdateInterceptorsByTag:setOrUpdateInterceptorsByTag,setOrUpdateLeafTags:setOrUpdateLeafTags}}();
var A={ns:function ns(){},
	he(a,b,c){if(b.h("q<0>").b(a))return new A.dZ(a,b.h("@<0>").I(c).h("dZ<1,2>"))
	return new A.c5(a,b.h("@<0>").I(c).h("c5<1,2>"))},
	uG(a){return new A.f1("Field '"+A.b(a)+"' has been assigned during initialization.")},
	bg(a){return new A.fm(a)},
	mW(a){var s,r=a^48;
	if(r<=9)return r
	s=a|32;
	if(97<=s&&s<=102)return s-87
	return -1},
	pW(a,b){var s=A.mW(B.a.B(a,b)),r=A.mW(B.a.B(a,b+1));
	return s*16+r-(r&256)},
	bU(a,b,c){if(a==null)throw A.d(new A.dI(b,c.h("dI<0>")))
	return a},
	dQ(a,b,c,d){A.aW(b,"start");
	if(c!=null){A.aW(c,"end");
	if(b>c)A.Z(A.Y(b,0,c,"start",null));}return new A.dP(a,b,c,d.h("dP<0>"))},
	jQ(a,b,c,d){if(t.O.b(a))return new A.c9(a,b,c.h("@<0>").I(d).h("c9<1,2>"))
	return new A.bd(a,b,c.h("@<0>").I(d).h("bd<1,2>"))},
	p0(a,b,c){var s="count";
	if(t.O.b(a)){A.h8(b,s);
	A.aW(b,s);
	return new A.cR(a,b,c.h("cR<0>"))}A.h8(b,s);
	A.aW(b,s);
	return new A.bh(a,b,c.h("bh<0>"))},
	nq(){return new A.bJ("No element")},
	ui(){return new A.bJ("Too few elements")},
	bM:function bM(){},
	dm:function dm(a,b){this.a=a;
	this.$ti=b;},
	c5:function c5(a,b){this.a=a;
	this.$ti=b;},
	dZ:function dZ(a,b){this.a=a;
	this.$ti=b;},
	dU:function dU(){},
	b5:function b5(a,b){this.a=a;
	this.$ti=b;},
	c6:function c6(a,b){this.a=a;
	this.$ti=b;},
	hf:function hf(a,b){this.a=a;
	this.b=b;},
	f1:function f1(a){this.a=a;},
	fm:function fm(a){this.a=a;},
	c8:function c8(a){this.a=a;},
	nd:function nd(){},
	dI:function dI(a,b){this.a=a;
	this.$ti=b;},
	q:function q(){},
	ah:function ah(){},
	dP:function dP(a,b,c,d){var _=this;
	_.a=a;
	_.b=b;
	_.c=c;
	_.$ti=d;},
	aa:function aa(a,b,c){var _=this;
	_.a=a;
	_.b=b;
	_.c=0;
	_.d=null;
	_.$ti=c;},
	bd:function bd(a,b,c){this.a=a;
	this.b=b;
	this.$ti=c;},
	c9:function c9(a,b,c){this.a=a;
	this.b=b;
	this.$ti=c;},
	dD:function dD(a,b,c){var _=this;
	_.a=null;
	_.b=a;
	_.c=b;
	_.$ti=c;},
	ab:function ab(a,b,c){this.a=a;
	this.b=b;
	this.$ti=c;},
	lK:function lK(a,b,c){this.a=a;
	this.b=b;
	this.$ti=c;},
	cF:function cF(a,b,c){this.a=a;
	this.b=b;
	this.$ti=c;},
	bh:function bh(a,b,c){this.a=a;
	this.b=b;
	this.$ti=c;},
	cR:function cR(a,b,c){this.a=a;
	this.b=b;
	this.$ti=c;},
	dN:function dN(a,b,c){this.a=a;
	this.b=b;
	this.$ti=c;},
	b7:function b7(a){this.$ti=a;},
	dq:function dq(a){this.$ti=a;},
	ds:function ds(){},
	fy:function fy(){},
	d4:function d4(){},
	d3:function d3(a){this.a=a;},
	ep:function ep(){},
	u2(){throw A.d(A.ad("Cannot modify unmodifiable Map"))},
	ub(a){if(typeof a=="number")return B.c1.gE(a)
	if(t.fo.b(a))return a.gE(a)
	if(t.dd.b(a))return A.d0(a)
	return A.fZ(a)},
	uc(a){return new A.hY(a)},
	q2(a){var s=v.mangledGlobalNames[a];
	if(s!=null)return s
	return "minified:"+a},
	pU(a,b){var s;
	if(b!=null){s=b.x;
	if(s!=null)return s}return t.aU.b(a)},
	b(a){var s;
	if(typeof a=="string")return a
	if(typeof a=="number"){if(a!==0)return ""+a}else if(!0===a)return "true"
	else if(!1===a)return "false"
	else if(a==null)return "null"
	s=J.as(a);
	if(typeof s!="string")throw A.d(A.h7(a,"object","toString method returned 'null'"))
	return s},
	d0(a){var s,r=$.oR;
	if(r==null)r=$.oR=Symbol("identityHashCode");
	s=a[r];
	if(s==null){s=Math.random()*0x3fffffff|0;
	a[r]=s;}return s},
	oY(a,b){var s,r,q,p,o,n,m=null;
	if(typeof a!="string")A.Z(A.cL(a));
	s=/^\s*[+-]?((0x[a-f0-9]+)|(\d+)|([a-z0-9]+))\s*$/i.exec(a);
	if(s==null)return m
	r=s[3];
	if(b==null){if(r!=null)return parseInt(a,10)
	if(s[2]!=null)return parseInt(a,16)
	return m}if(b<2||b>36)throw A.d(A.Y(b,2,36,"radix",m))
	if(b===10&&r!=null)return parseInt(a,10)
	if(b<10||r==null){q=b<=10?47+b:86+b;
	p=s[1];
	for(o=p.length,n=0;n<o;++n)if((B.a.J(p,n)|32)>q)return m}return parseInt(a,b)},
	ka(a){return A.uZ(a)},
	uZ(a){var s,r,q,p;
	if(a instanceof A.c)return A.ar(A.ak(a),null)
	s=J.bV(a);
	if(s===B.bW||s===B.c3||t.ak.b(a)){r=B.a9(a);
	if(r!=="Object"&&r!=="")return r
	q=a.constructor;
	if(typeof q=="function"){p=q.name;
	if(typeof p=="string"&&p!=="Object"&&p!=="")return p}}return A.ar(A.ak(a),null)},
	oQ(a){var s,r,q,p,o=a.length;
	if(o<=500)return String.fromCharCode.apply(null,a)
	for(s="",r=0;r<o;r=q){q=r+500;
	p=q<o?q:o;
	s+=String.fromCharCode.apply(null,a.slice(r,p));}return s},
	v1(a){var s,r,q,p=A.a([],t.Z);
	for(s=a.length,r=0;r<a.length;a.length===s||(0, A.cN)(a),++r){q=a[r];
	if(!A.aI(q))throw A.d(A.cL(q))
	if(q<=65535)p.push(q);
	else if(q<=1114111){p.push(55296+(B.c.ai(q-65536,10)&1023));
	p.push(56320+(q&1023));}else throw A.d(A.cL(q))}return A.oQ(p)},
	v0(a){var s,r,q;
	for(s=a.length,r=0;r<s;++r){q=a[r];
	if(!A.aI(q))throw A.d(A.cL(q))
	if(q<0)throw A.d(A.cL(q))
	if(q>65535)return A.v1(a)}return A.oQ(a)},
	v2(a,b,c){var s,r,q,p;
	if(c<=500&&b===0&&c===a.length)return String.fromCharCode.apply(null,a)
	for(s=b,r="";s<c;s=q){q=s+500;
	p=q<c?q:c;
	r+=String.fromCharCode.apply(null,a.subarray(s,p));}return r},
	be(a){var s;
	if(0<=a){if(a<=65535)return String.fromCharCode(a)
	if(a<=1114111){s=a-65536;
	return String.fromCharCode((B.c.ai(s,10)|55296)>>>0,s&1023|56320)}}throw A.d(A.Y(a,0,1114111,null,null))},
	ax(a){if(a.date===void 0)a.date=new Date(a.a);
	return a.date},
	fk(a){return a.b?A.ax(a).getUTCFullYear()+0:A.ax(a).getFullYear()+0},
	oW(a){return a.b?A.ax(a).getUTCMonth()+1:A.ax(a).getMonth()+1},
	oS(a){return a.b?A.ax(a).getUTCDate()+0:A.ax(a).getDate()+0},
	oT(a){return a.b?A.ax(a).getUTCHours()+0:A.ax(a).getHours()+0},
	oV(a){return a.b?A.ax(a).getUTCMinutes()+0:A.ax(a).getMinutes()+0},
	oX(a){return a.b?A.ax(a).getUTCSeconds()+0:A.ax(a).getSeconds()+0},
	oU(a){return a.b?A.ax(a).getUTCMilliseconds()+0:A.ax(a).getMilliseconds()+0},
	bE(a,b,c){var s,r,q={};
	q.a=0;
	s=[];
	r=[];
	q.a=b.length;
	B.d.D(s,b);
	q.b="";
	if(c!=null&&c.a!==0)c.M(0,new A.k9(q,r,s));
	return J.tB(a,new A.iJ(B.dM,0,s,r,0))},
	v_(a,b,c){var s,r,q;
	if(Array.isArray(b))s=c==null||c.a===0;
	else s=!1;
	if(s){r=b.length;
	if(r===0){if(!!a.$0)return a.$0()}else if(r===1){if(!!a.$1)return a.$1(b[0])}else if(r===2){if(!!a.$2)return a.$2(b[0],b[1])}else if(r===3){if(!!a.$3)return a.$3(b[0],b[1],b[2])}else if(r===4){if(!!a.$4)return a.$4(b[0],b[1],b[2],b[3])}else if(r===5)if(!!a.$5)return a.$5(b[0],b[1],b[2],b[3],b[4])
	q=a[""+"$"+r];
	if(q!=null)return q.apply(a,b)}return A.uY(a,b,c)},
	uY(a,b,c){var s,r,q,p,o,n,m,l,k,j,i,h,g,f,e;
	if(b!=null)s=Array.isArray(b)?b:A.bc(b,!0,t.z);
	else s=[];
	r=s.length;
	q=a.$R;
	if(r<q)return A.bE(a,s,c)
	p=a.$D;
	o=p==null;
	n=!o?p():null;
	m=J.bV(a);
	l=m.$C;
	if(typeof l=="string")l=m[l];
	if(o){if(c!=null&&c.a!==0)return A.bE(a,s,c)
	if(r===q)return l.apply(a,s)
	return A.bE(a,s,c)}if(Array.isArray(n)){if(c!=null&&c.a!==0)return A.bE(a,s,c)
	k=q+n.length;
	if(r>k)return A.bE(a,s,null)
	if(r<k){j=n.slice(r-q);
	if(s===b)s=A.bc(s,!0,t.z);
	B.d.D(s,j);}return l.apply(a,s)}else {if(r>q)return A.bE(a,s,c)
	if(s===b)s=A.bc(s,!0,t.z);
	i=Object.keys(n);
	if(c==null)for(o=i.length,h=0;h<i.length;i.length===o||(0, A.cN)(i),++h){g=n[i[h]];
	if(B.ad===g)return A.bE(a,s,c)
	B.d.C(s,g);}else {for(o=i.length,f=0,h=0;h<i.length;i.length===o||(0, A.cN)(i),++h){e=i[h];
	if(c.v(e)){++f;
	B.d.C(s,c.i(0,e));}else {g=n[e];
	if(B.ad===g)return A.bE(a,s,c)
	B.d.C(s,g);}}if(f!==c.a)return A.bE(a,s,c)}return l.apply(a,s)}},
	eA(a,b){var s,r="index",q=null;
	if(!A.aI(b))return new A.at(!0,b,r,q)
	s=J.a3(a);
	if(b<0||b>=s)return A.eW(b,s,a,q,r)
	return new A.dL(q,q,!0,b,r,"Value not in range")},
	x0(a,b,c){if(a<0||a>c)return A.Y(a,0,c,"start",null)
	if(b!=null)if(b<a||b>c)return A.Y(b,a,c,"end",null)
	return new A.at(!0,b,"end",null)},
	cL(a){return new A.at(!0,a,null,null)},
	d(a){var s,r;
	if(a==null)a=new A.fg();
	s=new Error();
	s.dartException=a;
	r=A.xQ;
	if("defineProperty" in Object){Object.defineProperty(s,"message",{get:r});
	s.name="";}else s.toString=r;
	return s},
	xQ(){return J.as(this.dartException)},
	Z(a){throw A.d(a)},
	cN(a){throw A.d(A.ag(a))},
	bl(a){var s,r,q,p,o,n;
	a=A.pZ(a.replace(String({}),"$receiver$"));
	s=a.match(/\\\$[a-zA-Z]+\\\$/g);
	if(s==null)s=A.a([],t.s);
	r=s.indexOf("\\$arguments\\$");
	q=s.indexOf("\\$argumentsExpr\\$");
	p=s.indexOf("\\$expr\\$");
	o=s.indexOf("\\$method\\$");
	n=s.indexOf("\\$receiver\\$");
	return new A.lt(a.replace(new RegExp("\\\\\\$arguments\\\\\\$","g"),"((?:x|[^x])*)").replace(new RegExp("\\\\\\$argumentsExpr\\\\\\$","g"),"((?:x|[^x])*)").replace(new RegExp("\\\\\\$expr\\\\\\$","g"),"((?:x|[^x])*)").replace(new RegExp("\\\\\\$method\\\\\\$","g"),"((?:x|[^x])*)").replace(new RegExp("\\\\\\$receiver\\\\\\$","g"),"((?:x|[^x])*)"),r,q,p,o,n)},
	lu(a){return function($expr$){var $argumentsExpr$="$arguments$";
	try{$expr$.$method$($argumentsExpr$);}catch(s){return s.message}}(a)},
	p3(a){return function($expr$){try{$expr$.$method$;}catch(s){return s.message}}(a)},
	nt(a,b){var s=b==null,r=s?null:b.method;
	return new A.f0(a,r,s?null:b.receiver)},
	M(a){if(a==null)return new A.fh(a)
	if(a instanceof A.dr)return A.bW(a,a.a)
	if(typeof a!=="object")return a
	if("dartException" in a)return A.bW(a,a.dartException)
	return A.wH(a)},
	bW(a,b){if(t.Q.b(b))if(b.$thrownJsError==null)b.$thrownJsError=a;
	return b},
	wH(a){var s,r,q,p,o,n,m,l,k,j,i,h,g,f,e=null;
	if(!("message" in a))return a
	s=a.message;
	if("number" in a&&typeof a.number=="number"){r=a.number;
	q=r&65535;
	if((B.c.ai(r,16)&8191)===10)switch(q){case 438:return A.bW(a,A.nt(A.b(s)+" (Error "+q+")",e))
	case 445:case 5007:p=A.b(s);
	return A.bW(a,new A.dJ(p+" (Error "+q+")",e))}}if(a instanceof TypeError){o=$.tb();
	n=$.tc();
	m=$.td();
	l=$.te();
	k=$.th();
	j=$.ti();
	i=$.tg();
	$.tf();
	h=$.tk();
	g=$.tj();
	f=o.a9(s);
	if(f!=null)return A.bW(a,A.nt(s,f))
	else {f=n.a9(s);
	if(f!=null){f.method="call";
	return A.bW(a,A.nt(s,f))}else {f=m.a9(s);
	if(f==null){f=l.a9(s);
	if(f==null){f=k.a9(s);
	if(f==null){f=j.a9(s);
	if(f==null){f=i.a9(s);
	if(f==null){f=l.a9(s);
	if(f==null){f=h.a9(s);
	if(f==null){f=g.a9(s);
	p=f!=null;}else p=!0;}else p=!0;}else p=!0;}else p=!0;}else p=!0;}else p=!0;}else p=!0;
	if(p)return A.bW(a,new A.dJ(s,f==null?e:f.method))}}return A.bW(a,new A.fx(typeof s=="string"?s:""))}if(a instanceof RangeError){if(typeof s=="string"&&s.indexOf("call stack")!==-1)return new A.dO()
	s=function(b){try{return String(b)}catch(d){}return null}(a);
	return A.bW(a,new A.at(!1,e,e,typeof s=="string"?s.replace(/^RangeError:\s*/,""):s))}if(typeof InternalError=="function"&&a instanceof InternalError)if(typeof s=="string"&&s==="too much recursion")return new A.dO()
	return a},
	aS(a){var s;
	if(a instanceof A.dr)return a.b
	if(a==null)return new A.ed(a)
	s=a.$cachedTrace;
	if(s!=null)return s
	return a.$cachedTrace=new A.ed(a)},
	fZ(a){if(a==null||typeof a!="object")return J.bY(a)
	else return A.d0(a)},
	pN(a,b){var s,r,q,p=a.length;
	for(s=0;s<p;s=q){r=s+1;
	q=r+1;
	b.m(0,a[s],a[r]);}return b},
	x4(a,b){var s,r=a.length;
	for(s=0;s<r;++s)b.C(0,a[s]);
	return b},
	xg(a,b,c,d,e,f){switch(b){case 0:return a.$0()
	case 1:return a.$1(c)
	case 2:return a.$2(c,d)
	case 3:return a.$3(c,d,e)
	case 4:return a.$4(c,d,e,f)}throw A.d(A.u9("Unsupported number of arguments for wrapped closure"))},
	mO(a,b){var s;
	if(a==null)return null
	s=a.$identity;
	if(!!s)return s
	s=function(c,d,e){return function(f,g,h,i){return e(c,d,f,g,h,i)}}(a,b,A.xg);
	a.$identity=s;
	return s},
	u1(a2){var s,r,q,p,o,n,m,l,k,j,i=a2.co,h=a2.iS,g=a2.iI,f=a2.nDA,e=a2.aI,d=a2.fs,c=a2.cs,b=d[0],a=c[0],a0=i[b],a1=a2.fT;
	a1.toString;
	s=h?Object.create(new A.fq().constructor.prototype):Object.create(new A.cP(null,null).constructor.prototype);
	s.$initialize=s.constructor;
	if(h)r=function static_tear_off(){this.$initialize();};
	else r=function tear_off(a3,a4){this.$initialize(a3,a4);};
	s.constructor=r;
	r.prototype=s;
	s.$_name=b;
	s.$_target=a0;
	q=!h;
	if(q)p=A.ox(b,a0,g,f);
	else {s.$static_name=b;
	p=a0;}s.$S=A.tY(a1,h,g);
	s[a]=p;
	for(o=p,n=1;n<d.length;++n){m=d[n];
	if(typeof m=="string"){l=i[m];
	k=m;
	m=l;}else k="";
	j=c[n];
	if(j!=null){if(q)m=A.ox(k,m,g,f);
	s[j]=m;}if(n===e)o=m;}s.$C=o;
	s.$R=a2.rC;
	s.$D=a2.dV;
	return r},
	tY(a,b,c){if(typeof a=="number")return a
	if(typeof a=="string"){if(b)throw A.d("Cannot compute signature for static tearoff.")
	return function(d,e){return function(){return e(this,d)}}(a,A.tR)}throw A.d("Error in functionType of tearoff")},
	tZ(a,b,c,d){var s=A.ow;
	switch(b?-1:a){case 0:return function(e,f){return function(){return f(this)[e]()}}(c,s)
	case 1:return function(e,f){return function(g){return f(this)[e](g)}}(c,s)
	case 2:return function(e,f){return function(g,h){return f(this)[e](g,h)}}(c,s)
	case 3:return function(e,f){return function(g,h,i){return f(this)[e](g,h,i)}}(c,s)
	case 4:return function(e,f){return function(g,h,i,j){return f(this)[e](g,h,i,j)}}(c,s)
	case 5:return function(e,f){return function(g,h,i,j,k){return f(this)[e](g,h,i,j,k)}}(c,s)
	default:return function(e,f){return function(){return e.apply(f(this),arguments)}}(d,s)}},
	ox(a,b,c,d){var s,r;
	if(c)return A.u0(a,b,d)
	s=b.length;
	r=A.tZ(s,d,a,b);
	return r},
	u_(a,b,c,d){var s=A.ow,r=A.tS;
	switch(b?-1:a){case 0:throw A.d(new A.fp("Intercepted function with no arguments."))
	case 1:return function(e,f,g){return function(){return f(this)[e](g(this))}}(c,r,s)
	case 2:return function(e,f,g){return function(h){return f(this)[e](g(this),h)}}(c,r,s)
	case 3:return function(e,f,g){return function(h,i){return f(this)[e](g(this),h,i)}}(c,r,s)
	case 4:return function(e,f,g){return function(h,i,j){return f(this)[e](g(this),h,i,j)}}(c,r,s)
	case 5:return function(e,f,g){return function(h,i,j,k){return f(this)[e](g(this),h,i,j,k)}}(c,r,s)
	case 6:return function(e,f,g){return function(h,i,j,k,l){return f(this)[e](g(this),h,i,j,k,l)}}(c,r,s)
	default:return function(e,f,g){return function(){var q=[g(this)];
	Array.prototype.push.apply(q,arguments);
	return e.apply(f(this),q)}}(d,r,s)}},
	u0(a,b,c){var s,r;
	if($.ou==null)$.ou=A.ot("interceptor");
	if($.ov==null)$.ov=A.ot("receiver");
	s=b.length;
	r=A.u_(s,c,a,b);
	return r},
	nO(a){return A.u1(a)},
	tR(a,b){return A.mt(v.typeUniverse,A.ak(a.a),b)},
	ow(a){return a.a},
	tS(a){return a.b},
	ot(a){var s,r,q,p=new A.cP("receiver","interceptor"),o=J.nr(Object.getOwnPropertyNames(p));
	for(s=o.length,r=0;r<s;++r){q=o[r];
	if(p[q]===a)return q}throw A.d(A.K("Field name "+a+" not found.",null))},
	xP(a){throw A.d(new A.eQ(a))},
	xa(a){return v.getIsolateTag(a)},
	uH(a,b,c){var s=new A.cx(a,b,c.h("cx<0>"));
	s.c=a.e;
	return s},
	Bh(a,b,c){Object.defineProperty(a,b,{value:c,enumerable:false,writable:true,configurable:true});},
	xC(a){var s,r,q,p,o,n=$.pR.$1(a),m=$.mP[n];
	if(m!=null){Object.defineProperty(a,v.dispatchPropertyName,{value:m,enumerable:false,writable:true,configurable:true});
	return m.i}s=$.n_[n];
	if(s!=null)return s
	r=v.interceptorsByTag[n];
	if(r==null){q=$.pJ.$2(a,n);
	if(q!=null){m=$.mP[q];
	if(m!=null){Object.defineProperty(a,v.dispatchPropertyName,{value:m,enumerable:false,writable:true,configurable:true});
	return m.i}s=$.n_[q];
	if(s!=null)return s
	r=v.interceptorsByTag[q];
	n=q;}}if(r==null)return null
	s=r.prototype;
	p=n[0];
	if(p==="!"){m=A.nc(s);
	$.mP[n]=m;
	Object.defineProperty(a,v.dispatchPropertyName,{value:m,enumerable:false,writable:true,configurable:true});
	return m.i}if(p==="~"){$.n_[n]=s;
	return s}if(p==="-"){o=A.nc(s);
	Object.defineProperty(Object.getPrototypeOf(a),v.dispatchPropertyName,{value:o,enumerable:false,writable:true,configurable:true});
	return o.i}if(p==="+")return A.pX(a,s)
	if(p==="*")throw A.d(A.p4(n))
	if(v.leafTags[n]===true){o=A.nc(s);
	Object.defineProperty(Object.getPrototypeOf(a),v.dispatchPropertyName,{value:o,enumerable:false,writable:true,configurable:true});
	return o.i}else return A.pX(a,s)},
	pX(a,b){var s=Object.getPrototypeOf(a);
	Object.defineProperty(s,v.dispatchPropertyName,{value:J.nS(b,s,null,null),enumerable:false,writable:true,configurable:true});
	return b},
	nc(a){return J.nS(a,!1,null,!!a.$iav)},
	xE(a,b,c){var s=b.prototype;
	if(v.leafTags[a]===true)return A.nc(s)
	else return J.nS(s,c,null,null)},
	xe(){if(!0===$.nQ)return
	$.nQ=!0;
	A.xf();},
	xf(){var s,r,q,p,o,n,m,l;
	$.mP=Object.create(null);
	$.n_=Object.create(null);
	A.xd();
	s=v.interceptorsByTag;
	r=Object.getOwnPropertyNames(s);
	if(typeof window!="undefined"){	q=function(){};
	for(p=0;p<r.length;++p){o=r[p];
	n=$.pY.$1(o);
	if(n!=null){m=A.xE(o,s[o],n);
	if(m!=null){Object.defineProperty(n,v.dispatchPropertyName,{value:m,enumerable:false,writable:true,configurable:true});
	q.prototype=n;}}}}for(p=0;p<r.length;++p){o=r[p];
	if(/^[A-Za-z_]/.test(o)){l=s[o];
	s["!"+o]=l;
	s["~"+o]=l;
	s["-"+o]=l;
	s["+"+o]=l;
	s["*"+o]=l;}}},
	xd(){var s,r,q,p,o,n,m=B.bb();
	m=A.di(B.bc,A.di(B.bd,A.di(B.aa,A.di(B.aa,A.di(B.be,A.di(B.bf,A.di(B.bg(B.a9),m)))))));
	if(typeof dartNativeDispatchHooksTransformer!="undefined"){s=dartNativeDispatchHooksTransformer;
	if(typeof s=="function")s=[s];
	if(s.constructor==Array)for(r=0;r<s.length;++r){q=s[r];
	if(typeof q=="function")m=q(m)||m;}}p=m.getTag;
	o=m.getUnknownTag;
	n=m.prototypeForTag;
	$.pR=new A.mX(p);
	$.pJ=new A.mY(o);
	$.pY=new A.mZ(n);},
	di(a,b){return a(b)||b},
	uk(a,b,c,d,e,f){var s=b?"m":"",r=c?"":"i",q=d?"u":"",p=e?"s":"",o=f?"g":"",n=function(g,h){try{return new RegExp(g,h)}catch(m){return m}}(a,s+r+q+p+o);
	if(n instanceof RegExp)return n
	throw A.d(A.R("Illegal RegExp pattern ("+String(n)+")",a,null))},
	x1(a){if(a.indexOf("$",0)>=0)return a.replace(/\$/g,"$$$$")
	return a},
	pZ(a){if(/[[\]{}()*+?.\\^$|]/.test(a))return a.replace(/[[\]{}()*+?.\\^$|]/g,"\\$&")
	return a},
	q0(a,b,c){var s=A.xN(a,b,c);
	return s},
	xN(a,b,c){var s,r,q,p;
	if(b===""){if(a==="")return c
	s=a.length;
	for(r=c,q=0;q<s;++q)r=r+a[q]+c;
	return r.charCodeAt(0)==0?r:r}p=a.indexOf(b,0);
	if(p<0)return a
	if(a.length<500||c.indexOf("$",0)>=0)return a.split(b).join(c)
	return a.replace(new RegExp(A.pZ(b),"g"),A.x1(c))},
	dn:function dn(a,b){this.a=a;
	this.$ti=b;},
	cQ:function cQ(){},
	aJ:function aJ(a,b,c,d){var _=this;
	_.a=a;
	_.b=b;
	_.c=c;
	_.$ti=d;},
	dW:function dW(a,b){this.a=a;
	this.$ti=b;},
	X:function X(a,b){this.a=a;
	this.$ti=b;},
	hY:function hY(a){this.a=a;},
	iJ:function iJ(a,b,c,d,e){var _=this;
	_.a=a;
	_.c=b;
	_.d=c;
	_.e=d;
	_.f=e;},
	k9:function k9(a,b,c){this.a=a;
	this.b=b;
	this.c=c;},
	lt:function lt(a,b,c,d,e,f){var _=this;
	_.a=a;
	_.b=b;
	_.c=c;
	_.d=d;
	_.e=e;
	_.f=f;},
	dJ:function dJ(a,b){this.a=a;
	this.b=b;},
	f0:function f0(a,b,c){this.a=a;
	this.b=b;
	this.c=c;},
	fx:function fx(a){this.a=a;},
	fh:function fh(a){this.a=a;},
	dr:function dr(a,b){this.a=a;
	this.b=b;},
	ed:function ed(a){this.a=a;
	this.b=null;},
	c7:function c7(){},
	eL:function eL(){},
	eM:function eM(){},
	ft:function ft(){},
	fq:function fq(){},
	cP:function cP(a,b){this.a=a;
	this.b=b;},
	fp:function fp(a){this.a=a;},
	mm:function mm(){},
	aC:function aC(a){var _=this;
	_.a=0;
	_.f=_.e=_.d=_.c=_.b=null;
	_.r=0;
	_.$ti=a;},
	iP:function iP(a){this.a=a;},
	jN:function jN(a,b){this.a=a;
	this.b=b;
	this.c=null;},
	aO:function aO(a,b){this.a=a;
	this.$ti=b;},
	cx:function cx(a,b,c){var _=this;
	_.a=a;
	_.b=b;
	_.d=_.c=null;
	_.$ti=c;},
	mX:function mX(a){this.a=a;},
	mY:function mY(a){this.a=a;},
	mZ:function mZ(a){this.a=a;},
	iK:function iK(a,b){var _=this;
	_.a=a;
	_.b=b;
	_.d=_.c=null;},
	mk:function mk(a){this.b=a;},
	de(a,b,c){if(!A.aI(b))throw A.d(A.K("Invalid view offsetInBytes "+A.b(b),null))},
	w8(a){return a},
	f7(a,b,c){A.de(a,b,c);
	return c==null?new DataView(a,b):new DataView(a,b,c)},
	uQ(a){return new Float32Array(a)},
	uR(a){return new Int8Array(a)},
	oO(a,b,c){A.de(a,b,c);
	return new Uint16Array(a,b,c)},
	oP(a,b,c){A.de(a,b,c);
	return new Uint32Array(a,b,c)},
	uS(a){return new Uint8Array(a)},
	nw(a,b,c){var s;
	A.de(a,b,c);
	s=new Uint8Array(a,b,c);
	return s},
	bo(a,b,c){if(a>>>0!==a||a>=c)throw A.d(A.eA(b,a))},
	bR(a,b,c){var s;
	if(!(a>>>0!==a))s=b>>>0!==b||a>b||b>c;
	else s=!0;
	if(s)throw A.d(A.x0(a,b,c))
	return b},
	dF:function dF(){},
	d_:function d_(){},
	dE:function dE(){},
	aw:function aw(){},
	f8:function f8(){},
	f9:function f9(){},
	fa:function fa(){},
	fb:function fb(){},
	fc:function fc(){},
	fd:function fd(){},
	fe:function fe(){},
	dG:function dG(){},
	cy:function cy(){},
	e7:function e7(){},
	e8:function e8(){},
	e9:function e9(){},
	ea:function ea(){},
	v5(a,b){var s=b.c;
	return s==null?b.c=A.nG(a,b.y,!0):s},
	oZ(a,b){var s=b.c;
	return s==null?b.c=A.ek(a,"a5",[b.y]):s},
	p_(a){var s=a.x;
	if(s===6||s===7||s===8)return A.p_(a.y)
	return s===12||s===13},
	v4(a){return a.at},
	aR(a){return A.fT(v.typeUniverse,a,!1)},
	bT(a,b,a0,a1){var s,r,q,p,o,n,m,l,k,j,i,h,g,f,e,d,c=b.x;
	switch(c){case 5:case 1:case 2:case 3:case 4:return b
	case 6:s=b.y;
	r=A.bT(a,s,a0,a1);
	if(r===s)return b
	return A.pl(a,r,!0)
	case 7:s=b.y;
	r=A.bT(a,s,a0,a1);
	if(r===s)return b
	return A.nG(a,r,!0)
	case 8:s=b.y;
	r=A.bT(a,s,a0,a1);
	if(r===s)return b
	return A.pk(a,r,!0)
	case 9:q=b.z;
	p=A.ey(a,q,a0,a1);
	if(p===q)return b
	return A.ek(a,b.y,p)
	case 10:o=b.y;
	n=A.bT(a,o,a0,a1);
	m=b.z;
	l=A.ey(a,m,a0,a1);
	if(n===o&&l===m)return b
	return A.nE(a,n,l)
	case 12:k=b.y;
	j=A.bT(a,k,a0,a1);
	i=b.z;
	h=A.wE(a,i,a0,a1);
	if(j===k&&h===i)return b
	return A.pj(a,j,h)
	case 13:g=b.z;
	a1+=g.length;
	f=A.ey(a,g,a0,a1);
	o=b.y;
	n=A.bT(a,o,a0,a1);
	if(f===g&&n===o)return b
	return A.nF(a,n,f,!0)
	case 14:e=b.y;
	if(e<a1)return b
	d=a0[e-a1];
	if(d==null)return b
	return d
	default:throw A.d(A.eG("Attempted to substitute unexpected RTI kind "+c))}},
	ey(a,b,c,d){var s,r,q,p,o=b.length,n=A.mv(o);
	for(s=!1,r=0;r<o;++r){q=b[r];
	p=A.bT(a,q,c,d);
	if(p!==q)s=!0;
	n[r]=p;}return s?n:b},
	wF(a,b,c,d){var s,r,q,p,o,n,m=b.length,l=A.mv(m);
	for(s=!1,r=0;r<m;r+=3){q=b[r];
	p=b[r+1];
	o=b[r+2];
	n=A.bT(a,o,c,d);
	if(n!==o)s=!0;
	l.splice(r,3,q,p,n);}return s?l:b},
	wE(a,b,c,d){var s,r=b.a,q=A.ey(a,r,c,d),p=b.b,o=A.ey(a,p,c,d),n=b.c,m=A.wF(a,n,c,d);
	if(q===r&&o===p&&m===n)return b
	s=new A.fK();
	s.a=q;
	s.b=o;
	s.c=m;
	return s},
	a(a,b){a[v.arrayRti]=b;
	return a},
	wY(a){var s,r=a.$S;
	if(r!=null){if(typeof r=="number")return A.xb(r)
	s=a.$S();
	return s}return null},
	pT(a,b){var s;
	if(A.p_(b))if(a instanceof A.c7){s=A.wY(a);
	if(s!=null)return s}return A.ak(a)},
	ak(a){var s;
	if(a instanceof A.c){s=a.$ti;
	return s!=null?s:A.nJ(a)}if(Array.isArray(a))return A.a_(a)
	return A.nJ(J.bV(a))},
	a_(a){var s=a[v.arrayRti],r=t.b;
	if(s==null)return r
	if(s.constructor!==r.constructor)return r
	return s},
	A(a){var s=a.$ti;
	return s!=null?s:A.nJ(a)},
	nJ(a){var s=a.constructor,r=s.$ccache;
	if(r!=null)return r
	return A.wj(a,s)},
	wj(a,b){var s=a instanceof A.c7?a.__proto__.__proto__.constructor:b,r=A.vH(v.typeUniverse,s.name);
	b.$ccache=r;
	return r},
	xb(a){var s,r=v.types,q=r[a];
	if(typeof q=="string"){s=A.fT(v.typeUniverse,q,!1);
	r[a]=s;
	return s}return q},
	pL(a){var s,r,q,p=a.w;
	if(p!=null)return p
	s=a.at;
	r=s.replace(/\*/g,"");
	if(r===s)return a.w=new A.eh(a)
	q=A.fT(v.typeUniverse,r,!0);
	p=q.w;
	return a.w=p==null?q.w=new A.eh(q):p},
	u(a){return A.pL(A.fT(v.typeUniverse,a,!1))},
	wi(a){var s,r,q,p=this,o=t.K;
	if(p===o)return A.df(p,a,A.wn)
	if(!A.bq(p))if(!(p===t._))o=p===o;
	else o=!0;
	else o=!0;
	if(o)return A.df(p,a,A.wr)
	o=p.x;
	s=o===6?p.y:p;
	if(s===t.S)r=A.aI;
	else if(s===t.gR||s===t.di)r=A.wm;
	else if(s===t.R)r=A.wp;
	else r=s===t.y?A.eu:null;
	if(r!=null)return A.df(p,a,r)
	if(s.x===9){q=s.y;
	if(s.z.every(A.xh)){p.r="$i"+q;
	if(q==="o")return A.df(p,a,A.wl)
	return A.df(p,a,A.wq)}}else if(o===7)return A.df(p,a,A.wb)
	return A.df(p,a,A.w9)},
	df(a,b,c){a.b=c;
	return a.b(b)},
	wh(a){var s,r,q=this;
	if(!A.bq(q))if(!(q===t._))s=q===t.K;
	else s=!0;
	else s=!0;
	if(s)r=A.w1;
	else if(q===t.K)r=A.w_;
	else r=A.wa;
	q.a=r;
	return q.a(a)},
	fX(a){var s,r=a.x;
	if(!A.bq(a))if(!(a===t._))if(!(a===t.A))if(r!==7)if(!(r===6&&A.fX(a.y)))s=r===8&&A.fX(a.y)||a===t.P||a===t.T;
	else s=!0;
	else s=!0;
	else s=!0;
	else s=!0;
	else s=!0;
	return s},
	w9(a){var s=this;
	if(a==null)return A.fX(s)
	return A.a7(v.typeUniverse,A.pT(a,s),null,s,null)},
	wb(a){if(a==null)return !0
	return this.y.b(a)},
	wq(a){var s,r=this;
	if(a==null)return A.fX(r)
	s=r.r;
	if(a instanceof A.c)return !!a[s]
	return !!J.bV(a)[s]},
	wl(a){var s,r=this;
	if(a==null)return A.fX(r)
	if(typeof a!="object")return !1
	if(Array.isArray(a))return !0
	s=r.r;
	if(a instanceof A.c)return !!a[s]
	return !!J.bV(a)[s]},
	Ba(a){var s=this;
	if(a==null)return a
	else if(s.b(a))return a
	A.pw(a,s);},
	wa(a){var s=this;
	if(a==null)return a
	else if(s.b(a))return a
	A.pw(a,s);},
	pw(a,b){throw A.d(A.vw(A.pd(a,A.pT(a,b),A.ar(b,null))))},
	pd(a,b,c){var s=A.cS(a);
	return s+": type '"+A.b(A.ar(b==null?A.ak(a):b,null))+"' is not a subtype of type '"+A.b(c)+"'"},
	vw(a){return new A.ei("TypeError: "+a)},
	aq(a,b){return new A.ei("TypeError: "+A.pd(a,null,b))},
	wn(a){return a!=null},
	w_(a){return a},
	wr(a){return !0},
	w1(a){return a},
	eu(a){return !0===a||!1===a},
	AW(a){if(!0===a)return !0
	if(!1===a)return !1
	throw A.d(A.aq(a,"bool"))},
	AY(a){if(!0===a)return !0
	if(!1===a)return !1
	if(a==null)return a
	throw A.d(A.aq(a,"bool"))},
	AX(a){if(!0===a)return !0
	if(!1===a)return !1
	if(a==null)return a
	throw A.d(A.aq(a,"bool?"))},
	AZ(a){if(typeof a=="number")return a
	throw A.d(A.aq(a,"double"))},
	B0(a){if(typeof a=="number")return a
	if(a==null)return a
	throw A.d(A.aq(a,"double"))},
	B_(a){if(typeof a=="number")return a
	if(a==null)return a
	throw A.d(A.aq(a,"double?"))},
	aI(a){return typeof a=="number"&&Math.floor(a)===a},
	B1(a){if(typeof a=="number"&&Math.floor(a)===a)return a
	throw A.d(A.aq(a,"int"))},
	B3(a){if(typeof a=="number"&&Math.floor(a)===a)return a
	if(a==null)return a
	throw A.d(A.aq(a,"int"))},
	B2(a){if(typeof a=="number"&&Math.floor(a)===a)return a
	if(a==null)return a
	throw A.d(A.aq(a,"int?"))},
	wm(a){return typeof a=="number"},
	B4(a){if(typeof a=="number")return a
	throw A.d(A.aq(a,"num"))},
	B6(a){if(typeof a=="number")return a
	if(a==null)return a
	throw A.d(A.aq(a,"num"))},
	B5(a){if(typeof a=="number")return a
	if(a==null)return a
	throw A.d(A.aq(a,"num?"))},
	wp(a){return typeof a=="string"},
	B7(a){if(typeof a=="string")return a
	throw A.d(A.aq(a,"String"))},
	w0(a){if(typeof a=="string")return a
	if(a==null)return a
	throw A.d(A.aq(a,"String"))},
	B8(a){if(typeof a=="string")return a
	if(a==null)return a
	throw A.d(A.aq(a,"String?"))},
	pF(a,b){var s,r,q;
	for(s="",r="",q=0;q<a.length;++q,r=", ")s+=B.a.ae(r,A.ar(a[q],b));
	return s},
	wz(a,b){var s,r,q,p,o,n,m=a.y,l=a.z;
	if(""===m)return "("+A.pF(l,b)+")"
	s=l.length;
	r=m.split(",");
	q=r.length-s;
	for(p="(",o="",n=0;n<s;++n,o=", "){p+=o;
	if(q===0)p+="{";
	p=B.a.ae(p,A.ar(l[n],b));
	if(q>=0)p+=" "+r[q];++q;}return p+"})"},
	py(a4,a5,a6){var s,r,q,p,o,n,m,l,k,j,i,h,g,f,e,d,c,b,a,a0,a1,a2,a3=", ";
	if(a6!=null){s=a6.length;
	if(a5==null){a5=A.a([],t.s);
	r=null;}else r=a5.length;
	q=a5.length;
	for(p=s;p>0;--p)a5.push("T"+(q+p));
	for(o=t.cK,n=t._,m=t.K,l="<",k="",p=0;p<s;++p,k=a3){l=B.a.ae(l+k,a5[a5.length-1-p]);
	j=a6[p];
	i=j.x;
	if(!(i===2||i===3||i===4||i===5||j===o))if(!(j===n))h=j===m;
	else h=!0;
	else h=!0;
	if(!h)l+=B.a.ae(" extends ",A.ar(j,a5));}l+=">";}else {l="";
	r=null;}o=a4.y;
	g=a4.z;
	f=g.a;
	e=f.length;
	d=g.b;
	c=d.length;
	b=g.c;
	a=b.length;
	a0=A.ar(o,a5);
	for(a1="",a2="",p=0;p<e;++p,a2=a3)a1+=B.a.ae(a2,A.ar(f[p],a5));
	if(c>0){a1+=a2+"[";
	for(a2="",p=0;p<c;++p,a2=a3)a1+=B.a.ae(a2,A.ar(d[p],a5));
	a1+="]";}if(a>0){a1+=a2+"{";
	for(a2="",p=0;p<a;p+=3,a2=a3){a1+=a2;
	if(b[p+1])a1+="required ";
	a1+=J.om(A.ar(b[p+2],a5)," ")+b[p];}a1+="}";}if(r!=null){a5.toString;
	a5.length=r;}return l+"("+a1+") => "+A.b(a0)},
	ar(a,b){var s,r,q,p,o,n,m=a.x;
	if(m===5)return "erased"
	if(m===2)return "dynamic"
	if(m===3)return "void"
	if(m===1)return "Never"
	if(m===4)return "any"
	if(m===6){s=A.ar(a.y,b);
	return s}if(m===7){r=a.y;
	s=A.ar(r,b);
	q=r.x;
	return J.om(q===12||q===13?B.a.ae("(",s)+")":s,"?")}if(m===8)return "FutureOr<"+A.b(A.ar(a.y,b))+">"
	if(m===9){p=A.wG(a.y);
	o=a.z;
	return o.length>0?p+("<"+A.pF(o,b)+">"):p}if(m===11)return A.wz(a,b)
	if(m===12)return A.py(a,b,null)
	if(m===13)return A.py(a.y,b,a.z)
	if(m===14){b.toString;
	n=a.y;
	return b[b.length-1-n]}return "?"},
	wG(a){var s=v.mangledGlobalNames[a];
	if(s!=null)return s
	return "minified:"+a},
	vI(a,b){var s=a.tR[b];
	for(;typeof s=="string";)s=a.tR[s];
	return s},
	vH(a,b){var s,r,q,p,o,n=a.eT,m=n[b];
	if(m==null)return A.fT(a,b,!1)
	else if(typeof m=="number"){s=m;
	r=A.el(a,5,"#");
	q=A.mv(s);
	for(p=0;p<s;++p)q[p]=r;
	o=A.ek(a,b,q);
	n[b]=o;
	return o}else return m},
	vF(a,b){return A.pt(a.tR,b)},
	vE(a,b){return A.pt(a.eT,b)},
	fT(a,b,c){var s,r=a.eC,q=r.get(b);
	if(q!=null)return q
	s=A.pi(A.pg(a,null,b,c));
	r.set(b,s);
	return s},
	mt(a,b,c){var s,r,q=b.Q;
	if(q==null)q=b.Q=new Map();
	s=q.get(c);
	if(s!=null)return s
	r=A.pi(A.pg(a,b,c,!0));
	q.set(c,r);
	return r},
	vG(a,b,c){var s,r,q,p=b.as;
	if(p==null)p=b.as=new Map();
	s=c.at;
	r=p.get(s);
	if(r!=null)return r
	q=A.nE(a,b,c.x===10?c.z:[c]);
	p.set(s,q);
	return q},
	bn(a,b){b.a=A.wh;
	b.b=A.wi;
	return b},
	el(a,b,c){var s,r,q=a.eC.get(c);
	if(q!=null)return q
	s=new A.aF(null,null);
	s.x=b;
	s.at=c;
	r=A.bn(a,s);
	a.eC.set(c,r);
	return r},
	pl(a,b,c){var s,r=b.at+"*",q=a.eC.get(r);
	if(q!=null)return q
	s=A.vB(a,b,r,c);
	a.eC.set(r,s);
	return s},
	vB(a,b,c,d){var s,r,q;
	if(d){s=b.x;
	if(!A.bq(b))r=b===t.P||b===t.T||s===7||s===6;
	else r=!0;
	if(r)return b}q=new A.aF(null,null);
	q.x=6;
	q.y=b;
	q.at=c;
	return A.bn(a,q)},
	nG(a,b,c){var s,r=b.at+"?",q=a.eC.get(r);
	if(q!=null)return q
	s=A.vA(a,b,r,c);
	a.eC.set(r,s);
	return s},
	vA(a,b,c,d){var s,r,q,p;
	if(d){s=b.x;
	if(!A.bq(b))if(!(b===t.P||b===t.T))if(s!==7)r=s===8&&A.n0(b.y);
	else r=!0;
	else r=!0;
	else r=!0;
	if(r)return b
	else if(s===1||b===t.A)return t.P
	else if(s===6){q=b.y;
	if(q.x===8&&A.n0(q.y))return q
	else return A.v5(a,b)}}p=new A.aF(null,null);
	p.x=7;
	p.y=b;
	p.at=c;
	return A.bn(a,p)},
	pk(a,b,c){var s,r=b.at+"/",q=a.eC.get(r);
	if(q!=null)return q
	s=A.vy(a,b,r,c);
	a.eC.set(r,s);
	return s},
	vy(a,b,c,d){var s,r,q;
	if(d){s=b.x;
	if(!A.bq(b))if(!(b===t._))r=b===t.K;
	else r=!0;
	else r=!0;
	if(r||b===t.K)return b
	else if(s===1)return A.ek(a,"a5",[b])
	else if(b===t.P||b===t.T)return t.eH}q=new A.aF(null,null);
	q.x=8;
	q.y=b;
	q.at=c;
	return A.bn(a,q)},
	vC(a,b){var s,r,q=""+b+"^",p=a.eC.get(q);
	if(p!=null)return p
	s=new A.aF(null,null);
	s.x=14;
	s.y=b;
	s.at=q;
	r=A.bn(a,s);
	a.eC.set(q,r);
	return r},
	ej(a){var s,r,q,p=a.length;
	for(s="",r="",q=0;q<p;++q,r=",")s+=r+a[q].at;
	return s},
	vx(a){var s,r,q,p,o,n=a.length;
	for(s="",r="",q=0;q<n;q+=3,r=","){p=a[q];
	o=a[q+1]?"!":":";
	s+=r+p+o+a[q+2].at;}return s},
	ek(a,b,c){var s,r,q,p=b;
	if(c.length>0)p+="<"+A.ej(c)+">";
	s=a.eC.get(p);
	if(s!=null)return s
	r=new A.aF(null,null);
	r.x=9;
	r.y=b;
	r.z=c;
	if(c.length>0)r.c=c[0];
	r.at=p;
	q=A.bn(a,r);
	a.eC.set(p,q);
	return q},
	nE(a,b,c){var s,r,q,p,o,n;
	if(b.x===10){s=b.y;
	r=b.z.concat(c);}else {r=c;
	s=b;}q=s.at+(";<"+A.ej(r)+">");
	p=a.eC.get(q);
	if(p!=null)return p
	o=new A.aF(null,null);
	o.x=10;
	o.y=s;
	o.z=r;
	o.at=q;
	n=A.bn(a,o);
	a.eC.set(q,n);
	return n},
	vD(a,b,c){var s,r,q="+"+(b+"("+A.ej(c)+")"),p=a.eC.get(q);
	if(p!=null)return p
	s=new A.aF(null,null);
	s.x=11;
	s.y=b;
	s.z=c;
	s.at=q;
	r=A.bn(a,s);
	a.eC.set(q,r);
	return r},
	pj(a,b,c){var s,r,q,p,o,n=b.at,m=c.a,l=m.length,k=c.b,j=k.length,i=c.c,h=i.length,g="("+A.ej(m);
	if(j>0){s=l>0?",":"";
	g+=s+"["+A.ej(k)+"]";}if(h>0){s=l>0?",":"";
	g+=s+"{"+A.vx(i)+"}";}r=n+(g+")");
	q=a.eC.get(r);
	if(q!=null)return q
	p=new A.aF(null,null);
	p.x=12;
	p.y=b;
	p.z=c;
	p.at=r;
	o=A.bn(a,p);
	a.eC.set(r,o);
	return o},
	nF(a,b,c,d){var s,r=b.at+("<"+A.ej(c)+">"),q=a.eC.get(r);
	if(q!=null)return q
	s=A.vz(a,b,c,r,d);
	a.eC.set(r,s);
	return s},
	vz(a,b,c,d,e){var s,r,q,p,o,n,m,l;
	if(e){s=c.length;
	r=A.mv(s);
	for(q=0,p=0;p<s;++p){o=c[p];
	if(o.x===1){r[p]=o;++q;}}if(q>0){n=A.bT(a,b,r,0);
	m=A.ey(a,c,r,0);
	return A.nF(a,n,m,c!==m)}}l=new A.aF(null,null);
	l.x=13;
	l.y=b;
	l.z=c;
	l.at=d;
	return A.bn(a,l)},
	pg(a,b,c,d){return {u:a,e:b,r:c,s:[],p:0,n:d}},
	pi(a){var s,r,q,p,o,n,m,l,k,j,i=a.r,h=a.s;
	for(s=i.length,r=0;r<s;){q=i.charCodeAt(r);
	if(q>=48&&q<=57)r=A.vr(r+1,q,i,h);
	else if((((q|32)>>>0)-97&65535)<26||q===95||q===36||q===124)r=A.ph(a,r,i,h,!1);
	else if(q===46)r=A.ph(a,r,i,h,!0);
	else {++r;
	switch(q){case 44:break
	case 58:h.push(!1);
	break
	case 33:h.push(!0);
	break
	case 59:h.push(A.bQ(a.u,a.e,h.pop()));
	break
	case 94:h.push(A.vC(a.u,h.pop()));
	break
	case 35:h.push(A.el(a.u,5,"#"));
	break
	case 64:h.push(A.el(a.u,2,"@"));
	break
	case 126:h.push(A.el(a.u,3,"~"));
	break
	case 60:h.push(a.p);
	a.p=h.length;
	break
	case 62:p=a.u;
	o=h.splice(a.p);
	A.nD(a.u,a.e,o);
	a.p=h.pop();
	n=h.pop();
	if(typeof n=="string")h.push(A.ek(p,n,o));
	else {m=A.bQ(p,a.e,n);
	switch(m.x){case 12:h.push(A.nF(p,m,o,a.n));
	break
	default:h.push(A.nE(p,m,o));
	break}}break
	case 38:A.vs(a,h);
	break
	case 42:l=a.u;
	h.push(A.pl(l,A.bQ(l,a.e,h.pop()),a.n));
	break
	case 63:l=a.u;
	h.push(A.nG(l,A.bQ(l,a.e,h.pop()),a.n));
	break
	case 47:l=a.u;
	h.push(A.pk(l,A.bQ(l,a.e,h.pop()),a.n));
	break
	case 40:h.push(-3);
	h.push(a.p);
	a.p=h.length;
	break
	case 41:A.vq(a,h);
	break
	case 91:h.push(a.p);
	a.p=h.length;
	break
	case 93:o=h.splice(a.p);
	A.nD(a.u,a.e,o);
	a.p=h.pop();
	h.push(o);
	h.push(-1);
	break
	case 123:h.push(a.p);
	a.p=h.length;
	break
	case 125:o=h.splice(a.p);
	A.vu(a.u,a.e,o);
	a.p=h.pop();
	h.push(o);
	h.push(-2);
	break
	case 43:k=i.indexOf("(",r);
	h.push(i.substring(r,k));
	h.push(-4);
	h.push(a.p);
	a.p=h.length;
	r=k+1;
	break
	default:throw "Bad character "+q}}}j=h.pop();
	return A.bQ(a.u,a.e,j)},
	vr(a,b,c,d){var s,r,q=b-48;
	for(s=c.length;a<s;++a){r=c.charCodeAt(a);
	if(!(r>=48&&r<=57))break
	q=q*10+(r-48);}d.push(q);
	return a},
	ph(a,b,c,d,e){var s,r,q,p,o,n,m=b+1;
	for(s=c.length;m<s;++m){r=c.charCodeAt(m);
	if(r===46){if(e)break
	e=!0;}else {if(!((((r|32)>>>0)-97&65535)<26||r===95||r===36||r===124))q=r>=48&&r<=57;
	else q=!0;
	if(!q)break}}p=c.substring(b,m);
	if(e){s=a.u;
	o=a.e;
	if(o.x===10)o=o.y;
	n=A.vI(s,o.y)[p];
	if(n==null)A.Z('No "'+p+'" in "'+A.v4(o)+'"');
	d.push(A.mt(s,o,n));}else d.push(p);
	return m},
	vq(a,b){var s,r,q,p,o,n=null,m=a.u,l=b.pop();
	if(typeof l=="number")switch(l){case-1:s=b.pop();
	r=n;
	break
	case-2:r=b.pop();
	s=n;
	break
	default:b.push(l);
	r=n;
	s=r;
	break}else {b.push(l);
	r=n;
	s=r;}q=A.vp(a,b);
	l=b.pop();
	switch(l){case-3:l=b.pop();
	if(s==null)s=m.sEA;
	if(r==null)r=m.sEA;
	p=A.bQ(m,a.e,l);
	o=new A.fK();
	o.a=q;
	o.b=s;
	o.c=r;
	b.push(A.pj(m,p,o));
	return
	case-4:b.push(A.vD(m,b.pop(),q));
	return
	default:throw A.d(A.eG("Unexpected state under `()`: "+A.b(l)))}},
	vs(a,b){var s=b.pop();
	if(0===s){b.push(A.el(a.u,1,"0&"));
	return}if(1===s){b.push(A.el(a.u,4,"1&"));
	return}throw A.d(A.eG("Unexpected extended operation "+A.b(s)))},
	vp(a,b){var s=b.splice(a.p);
	A.nD(a.u,a.e,s);
	a.p=b.pop();
	return s},
	bQ(a,b,c){if(typeof c=="string")return A.ek(a,c,a.sEA)
	else if(typeof c=="number"){b.toString;
	return A.vt(a,b,c)}else return c},
	nD(a,b,c){var s,r=c.length;
	for(s=0;s<r;++s)c[s]=A.bQ(a,b,c[s]);},
	vu(a,b,c){var s,r=c.length;
	for(s=2;s<r;s+=3)c[s]=A.bQ(a,b,c[s]);},
	vt(a,b,c){var s,r,q=b.x;
	if(q===10){if(c===0)return b.y
	s=b.z;
	r=s.length;
	if(c<=r)return s[c-1]
	c-=r;
	b=b.y;
	q=b.x;}else if(c===0)return b
	if(q!==9)throw A.d(A.eG("Indexed base must be an interface type"))
	s=b.z;
	if(c<=s.length)return s[c-1]
	throw A.d(A.eG("Bad index "+c+" for "+b.k(0)))},
	a7(a,b,c,d,e){var s,r,q,p,o,n,m,l,k,j;
	if(b===d)return !0
	if(!A.bq(d))if(!(d===t._))s=d===t.K;
	else s=!0;
	else s=!0;
	if(s)return !0
	r=b.x;
	if(r===4)return !0
	if(A.bq(b))return !1
	if(b.x!==1)s=b===t.P||b===t.T;
	else s=!0;
	if(s)return !0
	q=r===14;
	if(q)if(A.a7(a,c[b.y],c,d,e))return !0
	p=d.x;
	if(r===6)return A.a7(a,b.y,c,d,e)
	if(p===6){s=d.y;
	return A.a7(a,b,c,s,e)}if(r===8){if(!A.a7(a,b.y,c,d,e))return !1
	return A.a7(a,A.oZ(a,b),c,d,e)}if(r===7){s=A.a7(a,b.y,c,d,e);
	return s}if(p===8){if(A.a7(a,b,c,d.y,e))return !0
	return A.a7(a,b,c,A.oZ(a,d),e)}if(p===7){s=A.a7(a,b,c,d.y,e);
	return s}if(q)return !1
	s=r!==12;
	if((!s||r===13)&&d===t.b8)return !0
	if(p===13){if(b===t.g)return !0
	if(r!==13)return !1
	o=b.z;
	n=d.z;
	m=o.length;
	if(m!==n.length)return !1
	c=c==null?o:o.concat(c);
	e=e==null?n:n.concat(e);
	for(l=0;l<m;++l){k=o[l];
	j=n[l];
	if(!A.a7(a,k,c,j,e)||!A.a7(a,j,e,k,c))return !1}return A.pA(a,b.y,c,d.y,e)}if(p===12){if(b===t.g)return !0
	if(s)return !1
	return A.pA(a,b,c,d,e)}if(r===9){if(p!==9)return !1
	return A.wk(a,b,c,d,e)}s=r===11;
	if(s&&d===t.gT)return !0
	if(s&&p===11)return A.wo(a,b,c,d,e)
	return !1},
	pA(a2,a3,a4,a5,a6){var s,r,q,p,o,n,m,l,k,j,i,h,g,f,e,d,c,b,a,a0,a1;
	if(!A.a7(a2,a3.y,a4,a5.y,a6))return !1
	s=a3.z;
	r=a5.z;
	q=s.a;
	p=r.a;
	o=q.length;
	n=p.length;
	if(o>n)return !1
	m=n-o;
	l=s.b;
	k=r.b;
	j=l.length;
	i=k.length;
	if(o+j<n+i)return !1
	for(h=0;h<o;++h){g=q[h];
	if(!A.a7(a2,p[h],a6,g,a4))return !1}for(h=0;h<m;++h){g=l[h];
	if(!A.a7(a2,p[o+h],a6,g,a4))return !1}for(h=0;h<i;++h){g=l[m+h];
	if(!A.a7(a2,k[h],a6,g,a4))return !1}f=s.c;
	e=r.c;
	d=f.length;
	c=e.length;
	for(b=0,a=0;a<c;a+=3){a0=e[a];
	for(;!0;){if(b>=d)return !1
	a1=f[b];
	b+=3;
	if(a0<a1)return !1
	if(a1<a0)continue
	g=f[b-1];
	if(!A.a7(a2,e[a+2],a6,g,a4))return !1
	break}}return !0},
	wk(a,b,c,d,e){var s,r,q,p,o,n,m,l=b.y,k=d.y;
	for(;l!==k;){s=a.tR[l];
	if(s==null)return !1
	if(typeof s=="string"){l=s;
	continue}r=s[k];
	if(r==null)return !1
	q=r.length;
	p=q>0?new Array(q):v.typeUniverse.sEA;
	for(o=0;o<q;++o)p[o]=A.mt(a,b,r[o]);
	return A.pu(a,p,null,c,d.z,e)}n=b.z;
	m=d.z;
	return A.pu(a,n,null,c,m,e)},
	pu(a,b,c,d,e,f){var s,r,q,p=b.length;
	for(s=0;s<p;++s){r=b[s];
	q=e[s];
	if(!A.a7(a,r,d,q,f))return !1}return !0},
	wo(a,b,c,d,e){var s,r=b.z,q=d.z,p=r.length;
	if(p!==q.length)return !1
	if(b.y!==d.y)return !1
	for(s=0;s<p;++s)if(!A.a7(a,r[s],c,q[s],e))return !1
	return !0},
	n0(a){var s,r=a.x;
	if(!(a===t.P||a===t.T))if(!A.bq(a))if(r!==7)if(!(r===6&&A.n0(a.y)))s=r===8&&A.n0(a.y);
	else s=!0;
	else s=!0;
	else s=!0;
	else s=!0;
	return s},
	xh(a){var s;
	if(!A.bq(a))if(!(a===t._))s=a===t.K;
	else s=!0;
	else s=!0;
	return s},
	bq(a){var s=a.x;
	return s===2||s===3||s===4||s===5||a===t.cK},
	pt(a,b){var s,r,q=Object.keys(b),p=q.length;
	for(s=0;s<p;++s){r=q[s];
	a[r]=b[r];}},
	mv(a){return a>0?new Array(a):v.typeUniverse.sEA},
	aF:function aF(a,b){var _=this;
	_.a=a;
	_.b=b;
	_.w=_.r=_.c=null;
	_.x=0;
	_.at=_.as=_.Q=_.z=_.y=null;},
	fK:function fK(){this.c=this.b=this.a=null;},
	eh:function eh(a){this.a=a;},
	fJ:function fJ(){},
	ei:function ei(a){this.a=a;},
	vg(){var s,r,q={};
	if(self.scheduleImmediate!=null)return A.wP()
	if(self.MutationObserver!=null&&self.document!=null){s=self.document.createElement("div");
	r=self.document.createElement("span");
	q.a=null;
	new self.MutationObserver(A.mO(new A.lW(q),1)).observe(s,{childList:true});
	return new A.lV(q,s,r)}else if(self.setImmediate!=null)return A.wQ()
	return A.wR()},
	vh(a){self.scheduleImmediate(A.mO(new A.lX(a),0));},
	vi(a){self.setImmediate(A.mO(new A.lY(a),0));},
	vj(a){A.vv(0,a);},
	vv(a,b){var s=new A.mr();
	s.dg(a,b);
	return s},
	ex(a){return new A.fD(new A.C($.B,a.h("C<0>")),a.h("fD<0>"))},
	et(a,b){a.$2(0,null);
	b.b=!0;
	return b.a},
	dd(a,b){A.w2(a,b);},
	es(a,b){b.a3(a);},
	er(a,b){b.bK(A.M(a),A.aS(a));},
	w2(a,b){var s,r,q=new A.mx(b),p=new A.my(b);
	if(a instanceof A.C)a.cz(q,p,t.z);
	else {s=t.z;
	if(t.d.b(a))a.au(0,q,p,s);
	else {r=new A.C($.B,t.eI);
	r.a=8;
	r.c=a;
	r.cz(q,p,s);}}},
	ez(a){var s=function(b,c){return function(d,e){while(true)try{b(d,e);
	break}catch(r){e=r;
	d=c;}}}(a,1);
	return $.B.c1(new A.mN(s))},
	mf(a){return new A.d7(a,1)},
	bO(){return B.eo},
	bP(a){return new A.d7(a,3)},
	bS(a,b){return new A.eg(a,b.h("eg<0>"))},
	h9(a,b){var s=A.bU(a,"error",t.K);
	return new A.eH(s,b==null?A.eI(a):b)},
	eI(a){var s;
	if(t.Q.b(a)){s=a.gb2();
	if(s!=null)return s}return B.bk},
	nz(a,b){var s,r;
	for(;s=a.a,(s&4)!==0;)a=a.c;
	if((s&24)!==0){r=b.bb();
	b.by(a);
	A.d6(b,r);}else {r=b.c;
	b.a=b.a&1|4;
	b.c=a;
	a.cs(r);}},
	d6(a,b){var s,r,q,p,o,n,m,l,k,j,i,h,g,f={},e=f.a=a;
	for(s=t.d;!0;){r={};
	q=e.a;
	p=(q&16)===0;
	o=!p;
	if(b==null){if(o&&(q&1)===0){e=e.c;
	A.dh(e.a,e.b);}return}r.a=b;
	n=b.a;
	for(e=b;n!=null;e=n,n=m){e.a=null;
	A.d6(f.a,e);
	r.a=n;
	m=n.a;}q=f.a;
	l=q.c;
	r.b=o;
	r.c=l;
	if(p){k=e.c;
	k=(k&1)!==0||(k&15)===8;}else k=!0;
	if(k){j=e.b.b;
	if(o){q=q.b===j;
	q=!(q||q);}else q=!1;
	if(q){A.dh(l.a,l.b);
	return}i=$.B;
	if(i!==j)$.B=j;
	else i=null;
	e=e.c;
	if((e&15)===8)new A.md(r,f,o).$0();
	else if(p){if((e&1)!==0)new A.mc(r,l).$0();}else if((e&2)!==0)new A.mb(f,r).$0();
	if(i!=null)$.B=i;
	e=r.c;
	if(s.b(e)){q=r.a.$ti;
	q=q.h("a5<2>").b(e)||!q.z[1].b(e);}else q=!1;
	if(q){h=r.a.b;
	if(e instanceof A.C)if((e.a&24)!==0){g=h.c;
	h.c=null;
	b=h.bc(g);
	h.a=e.a&30|h.a&1;
	h.c=e.c;
	f.a=e;
	continue}else A.nz(e,h);
	else h.ce(e);
	return}}h=r.a.b;
	g=h.c;
	h.c=null;
	b=h.bc(g);
	e=r.b;
	q=r.c;
	if(!e){h.a=8;
	h.c=q;}else {h.a=h.a&1|16;
	h.c=q;}f.a=h;
	e=h;}},
	wA(a,b){if(t.C.b(a))return b.c1(a)
	if(t.v.b(a))return a
	throw A.d(A.h7(a,"onError",u.c))},
	wv(){var s,r;
	for(s=$.dg;s!=null;s=$.dg){$.ew=null;
	r=s.b;
	$.dg=r;
	if(r==null)$.ev=null;
	s.a.$0();}},
	wC(){$.nK=!0;
	try{A.wv();}finally{$.ew=null;
	$.nK=!1;
	if($.dg!=null)$.oj().$1(A.pK());}},
	pH(a){var s=new A.fE(a),r=$.ev;
	if(r==null){$.dg=$.ev=s;
	if(!$.nK)$.oj().$1(A.pK());}else $.ev=r.b=s;},
	wB(a){var s,r,q,p=$.dg;
	if(p==null){A.pH(a);
	$.ew=$.ev;
	return}s=new A.fE(a);
	r=$.ew;
	if(r==null){s.b=p;
	$.dg=$.ew=s;}else {q=r.b;
	s.b=q;
	$.ew=r.b=s;
	if(q==null)$.ev=s;}},
	q_(a){var s,r=null,q=$.B;
	if(B.i===q){A.cI(r,r,B.i,a);
	return}s=!1;
	if(s){A.cI(r,r,q,a);
	return}A.cI(r,r,q,q.cB(a));},
	fs(a,b){var s=null,r=b.h("aZ<0>"),q=new A.aZ(s,s,s,s,r);
	q.aJ(a);
	q.aK();
	return new A.aj(q,r.h("aj<1>"))},
	v9(a,b){var s=null,r=b.h("db<0>"),q=new A.db(s,s,s,s,r);
	a.au(0,new A.ln(q,b),new A.lo(q),t.P);
	return new A.aj(q,r.h("aj<1>"))},
	AG(a){A.bU(a,"stream",t.K);
	return new A.fQ()},
	p1(a,b,c,d){return new A.aZ(null,b,c,a,d.h("aZ<0>"))},
	nM(a){var s,r;
	if(a==null)return
	try{a.$0();}catch(q){s=A.M(q);
	r=A.aS(q);
	A.dh(s,r);}},
	vn(a,b){if(b==null)b=A.wS();
	if(t.k.b(b))return a.c1(b)
	if(t.d5.b(b))return b
	throw A.d(A.K("handleError callback must take either an Object (the error), or both an Object (the error) and a StackTrace.",null))},
	ww(a,b){A.dh(a,b);},
	dh(a,b){A.wB(new A.mK(a,b));},
	pC(a,b,c,d){var s,r=$.B;
	if(r===c)return d.$0()
	$.B=c;
	s=r;
	try{r=d.$0();
	return r}finally{$.B=s;}},
	pE(a,b,c,d,e){var s,r=$.B;
	if(r===c)return d.$1(e)
	$.B=c;
	s=r;
	try{r=d.$1(e);
	return r}finally{$.B=s;}},
	pD(a,b,c,d,e,f){var s,r=$.B;
	if(r===c)return d.$2(e,f)
	$.B=c;
	s=r;
	try{r=d.$2(e,f);
	return r}finally{$.B=s;}},
	cI(a,b,c,d){if(B.i!==c)d=c.cB(d);
	A.pH(d);},
	lW:function lW(a){this.a=a;},
	lV:function lV(a,b,c){this.a=a;
	this.b=b;
	this.c=c;},
	lX:function lX(a){this.a=a;},
	lY:function lY(a){this.a=a;},
	mr:function mr(){},
	ms:function ms(a,b){this.a=a;
	this.b=b;},
	fD:function fD(a,b){this.a=a;
	this.b=!1;
	this.$ti=b;},
	mx:function mx(a){this.a=a;},
	my:function my(a){this.a=a;},
	mN:function mN(a){this.a=a;},
	d7:function d7(a,b){this.a=a;
	this.b=b;},
	aH:function aH(a,b){var _=this;
	_.a=a;
	_.d=_.c=_.b=null;
	_.$ti=b;},
	eg:function eg(a,b){this.a=a;
	this.$ti=b;},
	eH:function eH(a,b){this.a=a;
	this.b=b;},
	fG:function fG(){},
	ay:function ay(a,b){this.a=a;
	this.$ti=b;},
	bN:function bN(a,b,c,d,e){var _=this;
	_.a=null;
	_.b=a;
	_.c=b;
	_.d=c;
	_.e=d;
	_.$ti=e;},
	C:function C(a,b){var _=this;
	_.a=0;
	_.b=a;
	_.c=null;
	_.$ti=b;},
	m3:function m3(a,b){this.a=a;
	this.b=b;},
	ma:function ma(a,b){this.a=a;
	this.b=b;},
	m6:function m6(a){this.a=a;},
	m7:function m7(a){this.a=a;},
	m8:function m8(a,b,c){this.a=a;
	this.b=b;
	this.c=c;},
	m5:function m5(a,b){this.a=a;
	this.b=b;},
	m9:function m9(a,b){this.a=a;
	this.b=b;},
	m4:function m4(a,b,c){this.a=a;
	this.b=b;
	this.c=c;},
	md:function md(a,b,c){this.a=a;
	this.b=b;
	this.c=c;},
	me:function me(a){this.a=a;},
	mc:function mc(a,b){this.a=a;
	this.b=b;},
	mb:function mb(a,b){this.a=a;
	this.b=b;},
	fE:function fE(a){this.a=a;
	this.b=null;},
	bi:function bi(){},
	ln:function ln(a,b){this.a=a;
	this.b=b;},
	lo:function lo(a){this.a=a;},
	lp:function lp(a,b){this.a=a;
	this.b=b;},
	lq:function lq(a,b){this.a=a;
	this.b=b;},
	fr:function fr(){},
	da:function da(){},
	mq:function mq(a){this.a=a;},
	mp:function mp(a){this.a=a;},
	fS:function fS(){},
	fF:function fF(){},
	aZ:function aZ(a,b,c,d,e){var _=this;
	_.a=null;
	_.b=0;
	_.c=null;
	_.d=a;
	_.e=b;
	_.f=c;
	_.r=d;
	_.$ti=e;},
	db:function db(a,b,c,d,e){var _=this;
	_.a=null;
	_.b=0;
	_.c=null;
	_.d=a;
	_.e=b;
	_.f=c;
	_.r=d;
	_.$ti=e;},
	aj:function aj(a,b){this.a=a;
	this.$ti=b;},
	dX:function dX(a,b,c,d,e,f){var _=this;
	_.w=a;
	_.a=b;
	_.b=c;
	_.c=d;
	_.d=e;
	_.e=f;
	_.r=_.f=null;},
	dT:function dT(){},
	m0:function m0(a,b,c){this.a=a;
	this.b=b;
	this.c=c;},
	m_:function m_(a){this.a=a;},
	ee:function ee(){},
	fI:function fI(){},
	cG:function cG(a){this.b=a;
	this.a=null;},
	dY:function dY(a,b){this.b=a;
	this.c=b;
	this.a=null;},
	m1:function m1(){},
	eb:function eb(){this.a=0;
	this.c=this.b=null;},
	ml:function ml(a,b){this.a=a;
	this.b=b;},
	fQ:function fQ(){},
	mw:function mw(){},
	mK:function mK(a,b){this.a=a;
	this.b=b;},
	mn:function mn(){},
	mo:function mo(a,b){this.a=a;
	this.b=b;},
	pe(a,b){var s=a[b];
	return s===a?null:s},
	nA(a,b,c){if(c==null)a[b]=a;
	else a[b]=c;},
	pf(){var s=Object.create(null);
	A.nA(s,"<non-identifier-key>",s);
	delete s["<non-identifier-key>"];
	return s},
	uI(a,b,c,d){return A.vo(A.wZ(),a,b,c,d)},
	nu(a,b,c){return A.pN(a,new A.aC(b.h("@<0>").I(c).h("aC<1,2>")))},
	a9(a,b){return new A.aC(a.h("@<0>").I(b).h("aC<1,2>"))},
	vo(a,b,c,d,e){var s=c!=null?c:new A.mi(d);
	return new A.e5(a,b,s,d.h("@<0>").I(e).h("e5<1,2>"))},
	oH(a){return new A.b_(a.h("b_<0>"))},
	aD(a){return new A.b_(a.h("b_<0>"))},
	aP(a,b){return A.x4(a,new A.b_(b.h("b_<0>")))},
	nC(){var s=Object.create(null);
	s["<non-identifier-key>"]=s;
	delete s["<non-identifier-key>"];
	return s},
	nB(a,b,c){var s=new A.cH(a,b,c.h("cH<0>"));
	s.c=a.e;
	return s},
	w7(a,b){return J.af(a,b)},
	uh(a,b,c){var s,r;
	if(A.nL(a)){if(b==="("&&c===")")return "(...)"
	return b+"..."+c}s=A.a([],t.s);
	$.cJ.push(a);
	try{A.ws(a,s);}finally{$.cJ.pop();}r=A.ny(b,s,", ")+c;
	return r.charCodeAt(0)==0?r:r},
	iI(a,b,c){var s,r;
	if(A.nL(a))return b+"..."+c
	s=new A.ac(b);
	$.cJ.push(a);
	try{r=s;
	r.a=A.ny(r.a,a,", ");}finally{$.cJ.pop();}s.a+=c;
	r=s.a;
	return r.charCodeAt(0)==0?r:r},
	nL(a){var s,r;
	for(s=$.cJ.length,r=0;r<s;++r)if(a===$.cJ[r])return !0
	return !1},
	ws(a,b){var s,r,q,p,o,n,m,l=a.gH(a),k=0,j=0;
	while(!0){if(!(k<80||j<3))break
	if(!l.q())return
	s=A.b(l.gt());
	b.push(s);
	k+=s.length+2;++j;}if(!l.q()){if(j<=5)return
	r=b.pop();
	q=b.pop();}else {p=l.gt();++j;
	if(!l.q()){if(j<=4){b.push(A.b(p));
	return}r=A.b(p);
	q=b.pop();
	k+=r.length+2;}else {o=l.gt();++j;
	for(;l.q();p=o,o=n){n=l.gt();++j;
	if(j>100){while(!0){if(!(k>75&&j>3))break
	k-=b.pop().length+2;--j;}b.push("...");
	return}}q=A.b(p);
	r=A.b(o);
	k+=r.length+q.length+4;}}if(j>b.length+2){k+=5;
	m="...";}else m=null;
	while(!0){if(!(k>80&&b.length>3))break
	k-=b.pop().length+2;
	if(m==null){k+=5;
	m="...";}}if(m!=null)b.push(m);
	b.push(q);
	b.push(r);},
	uJ(a,b){var s,r,q=A.oH(b);
	for(s=a.length,r=0;r<a.length;a.length===s||(0, A.cN)(a),++r)q.C(0,b.a(a[r]));
	return q},
	nv(a){var s,r={};
	if(A.nL(a))return "{...}"
	s=new A.ac("");
	try{$.cJ.push(a);
	s.a+="{";
	r.a=!0;
	a.M(0,new A.jO(r,s));
	s.a+="}";}finally{$.cJ.pop();}r=s.a;
	return r.charCodeAt(0)==0?r:r},
	e1:function e1(){},
	e4:function e4(a){var _=this;
	_.a=0;
	_.e=_.d=_.c=_.b=null;
	_.$ti=a;},
	e2:function e2(a,b){this.a=a;
	this.$ti=b;},
	e3:function e3(a,b,c){var _=this;
	_.a=a;
	_.b=b;
	_.c=0;
	_.d=null;
	_.$ti=c;},
	e5:function e5(a,b,c,d){var _=this;
	_.w=a;
	_.x=b;
	_.y=c;
	_.a=0;
	_.f=_.e=_.d=_.c=_.b=null;
	_.r=0;
	_.$ti=d;},
	mi:function mi(a){this.a=a;},
	b_:function b_(a){var _=this;
	_.a=0;
	_.f=_.e=_.d=_.c=_.b=null;
	_.r=0;
	_.$ti=a;},
	mj:function mj(a){this.a=a;
	this.c=this.b=null;},
	cH:function cH(a,b,c){var _=this;
	_.a=a;
	_.b=b;
	_.d=_.c=null;
	_.$ti=c;},
	aX:function aX(a,b){this.a=a;
	this.$ti=b;},
	dw:function dw(){},
	dA:function dA(){},
	p:function p(){},
	dB:function dB(){},
	jO:function jO(a,b){this.a=a;
	this.b=b;},
	I:function I(){},
	jP:function jP(a){this.a=a;},
	fU:function fU(){},
	dC:function dC(){},
	bm:function bm(a,b){this.a=a;
	this.$ti=b;},
	dM:function dM(){},
	ec:function ec(){},
	e6:function e6(){},
	em:function em(){},
	eq:function eq(){},
	pB(a,b){var s,q,p=null;
	try{p=JSON.parse(a);}catch(r){s=A.M(r);
	q=A.R(String(s),null,null);
	throw A.d(q)}q=A.mA(p);
	return q},
	mA(a){var s;
	if(a==null)return null
	if(typeof a!="object")return a
	if(Object.getPrototypeOf(a)!==Array.prototype)return new A.fM(a,Object.create(null))
	for(s=0;s<a.length;++s)a[s]=A.mA(a[s]);
	return a},
	ve(a,b,c,d){var s,r;
	if(b instanceof Uint8Array){s=b;
	d=s.length;
	if(d-c<15)return null
	r=A.vf(a,s,c,d);
	if(r!=null&&a)if(r.indexOf("\ufffd")>=0)return null
	return r}return null},
	vf(a,b,c,d){var s=a?$.tm():$.tl();
	if(s==null)return null
	if(0===c&&d===b.length)return A.p8(s,b)
	return A.p8(s,b.subarray(c,A.aQ(c,d,b.length)))},
	p8(a,b){var s;
	try{s=a.decode(b);
	return s}catch(r){}return null},
	os(a,b,c,d,e,f){if(B.c.br(f,4)!==0)throw A.d(A.R("Invalid base64 padding, padded length must be multiple of four, is "+f,a,c))
	if(d+e!==f)throw A.d(A.R("Invalid base64 padding, '=' not at the end",a,b))
	if(e>2)throw A.d(A.R("Invalid base64 padding, more than two '=' characters",a,b))},
	vm(a,b,c,d,e,f){var s,r,q,p,o,n,m="Invalid encoding before padding",l="Invalid character",k=B.c.ai(f,2),j=f&3,i=$.ok();
	for(s=b,r=0;s<c;++s){q=B.a.B(a,s);
	r|=q;
	p=i[q&127];
	if(p>=0){k=(k<<6|p)&16777215;
	j=j+1&3;
	if(j===0){o=e+1;
	d[e]=k>>>16&255;
	e=o+1;
	d[o]=k>>>8&255;
	o=e+1;
	d[e]=k&255;
	e=o;
	k=0;}continue}else if(p===-1&&j>1){if(r>127)break
	if(j===3){if((k&3)!==0)throw A.d(A.R(m,a,s))
	d[e]=k>>>10;
	d[e+1]=k>>>2;}else {if((k&15)!==0)throw A.d(A.R(m,a,s))
	d[e]=k>>>4;}n=(3-j)*3;
	if(q===37)n+=2;
	return A.pc(a,s+1,c,-n-1)}throw A.d(A.R(l,a,s))}if(r>=0&&r<=127)return (k<<2|j)>>>0
	for(s=b;s<c;++s){q=B.a.B(a,s);
	if(q>127)break}throw A.d(A.R(l,a,s))},
	vk(a,b,c,d){var s=A.vl(a,b,c),r=(d&3)+(s-b),q=B.c.ai(r,2)*3,p=r&3;
	if(p!==0&&s<c)q+=p-1;
	if(q>0)return new Uint8Array(q)
	return $.tn()},
	vl(a,b,c){var s,r=c,q=r,p=0;
	while(!0){if(!(q>b&&p<2))break
	c$0:{--q;
	s=B.a.B(a,q);
	if(s===61){++p;
	r=q;
	break c$0}if((s|32)===100){if(q===b)break;--q;
	s=B.a.B(a,q);}if(s===51){if(q===b)break;--q;
	s=B.a.B(a,q);}if(s===37){++p;
	r=q;
	break c$0}break}}return r},
	pc(a,b,c,d){var s,r;
	if(b===c)return d
	s=-d-1;
	for(;s>0;){r=B.a.B(a,b);
	if(s===3){if(r===61){s-=3;++b;
	break}if(r===37){--s;++b;
	if(b===c)break
	r=B.a.B(a,b);}else break}if((s>3?s-3:s)===2){if(r!==51)break;++b;--s;
	if(b===c)break
	r=B.a.B(a,b);}if((r|32)!==100)break;++b;--s;
	if(b===c)break}if(b!==c)throw A.d(A.R("Invalid padding character",a,b))
	return -s-1},
	ps(a){switch(a){case 65:return "Missing extension byte"
	case 67:return "Unexpected extension byte"
	case 69:return "Invalid UTF-8 byte"
	case 71:return "Overlong encoding"
	case 73:return "Out of unicode range"
	case 75:return "Encoded surrogate"
	case 77:return "Unfinished UTF-8 octet sequence"
	default:return ""}},
	vZ(a,b,c){var s,r,q,p=c-b,o=new Uint8Array(p);
	for(s=J.V(a),r=0;r<p;++r){q=s.i(a,b+r);
	o[r]=(q&4294967040)>>>0!==0?255:q;}return o},
	fM:function fM(a,b){this.a=a;
	this.b=b;
	this.c=null;},
	fN:function fN(a){this.a=a;},
	mh:function mh(a,b,c){this.b=a;
	this.c=b;
	this.a=c;},
	lD:function lD(){},
	lC:function lC(){},
	ha:function ha(){},
	hc:function hc(){},
	hb:function hb(){},
	lZ:function lZ(){this.a=0;},
	hd:function hd(){},
	eJ:function eJ(){},
	fO:function fO(a,b,c){this.a=a;
	this.b=b;
	this.$ti=c;},
	eN:function eN(){},
	eP:function eP(){},
	hW:function hW(){},
	iQ:function iQ(){},
	iR:function iR(a){this.a=a;},
	lr:function lr(){},
	ls:function ls(){},
	ef:function ef(){},
	mu:function mu(a,b,c){this.a=a;
	this.b=b;
	this.c=c;},
	lA:function lA(){},
	lB:function lB(a){this.a=a;},
	fV:function fV(a){this.a=a;
	this.b=16;
	this.c=0;},
	cM(a,b){var s=A.oY(a,b);
	if(s!=null)return s
	throw A.d(A.R(a,null,null))},
	u6(a){if(a instanceof A.c7)return a.k(0)
	return "Instance of '"+A.b(A.ka(a))+"'"},
	u7(a,b){a=A.d(a);
	a.stack=J.as(b);
	throw a
},
	U(a,b,c,d){var s,r=J.b8(a,d);
	if(a!==0&&b!=null)for(s=0;s<a;++s)r[s]=b;
	return r},
	uK(a,b){var s,r=A.a([],b.h("D<0>"));
	for(s=a.gH(a);s.q();)r.push(s.gt());
	return r},
	bc(a,b,c){var s;
	if(b)return A.oI(a,c)
	s=J.nr(A.oI(a,c));
	return s},
	oI(a,b){var s,r;
	if(Array.isArray(a))return A.a(a.slice(0),b.h("D<0>"))
	s=A.a([],b.h("D<0>"));
	for(r=J.aA(a);r.q();)s.push(r.gt());
	return s},
	oJ(a,b,c,d){var s,r=J.b8(a,d);
	for(s=0;s<a;++s)r[s]=b.$1(s);
	return r},
	p2(a,b,c){if(t.bm.b(a))return A.v2(a,b,A.aQ(b,c,a.length))
	return A.va(a,b,c)},
	va(a,b,c){var s,r,q,p,o=null;
	if(b<0)throw A.d(A.Y(b,0,a.length,o,o))
	s=c==null;
	if(!s&&c<b)throw A.d(A.Y(c,b,a.length,o,o))
	r=new A.aa(a,a.length,A.ak(a).h("aa<p.E>"));
	for(q=0;q<b;++q)if(!r.q())throw A.d(A.Y(b,0,q,o,o))
	p=[];
	if(s)for(;r.q();)p.push(r.d);
	else for(q=b;q<c;++q){if(!r.q())throw A.d(A.Y(c,b,q,o,o))
	p.push(r.d);}return A.v0(p)},
	nx(a){return new A.iK(a,A.uk(a,!1,!0,!1,!1,!1))},
	ny(a,b,c){var s=J.aA(b);
	if(!s.q())return a
	if(c.length===0){do a+=A.b(s.gt());
	while(s.q())}else {a+=A.b(s.gt());
	for(;s.q();)a=a+c+A.b(s.gt());}return a},
	uT(a,b,c,d,e){return new A.dH(a,b,c,d,e)},
	oy(a){var s=Math.abs(a),r=a<0?"-":"";
	if(s>=1000)return ""+a
	if(s>=100)return r+"0"+s
	if(s>=10)return r+"00"+s
	return r+"000"+s},
	u5(a){var s=Math.abs(a),r=a<0?"-":"+";
	if(s>=1e5)return r+s
	return r+"0"+s},
	oz(a){if(a>=100)return ""+a
	if(a>=10)return "0"+a
	return "00"+a},
	b6(a){if(a>=10)return ""+a
	return "0"+a},
	cS(a){if(typeof a=="number"||A.eu(a)||a==null)return J.as(a)
	if(typeof a=="string")return JSON.stringify(a)
	return A.u6(a)},
	u8(a,b){A.bU(a,"error",t.K);
	A.bU(b,"stackTrace",t.gm);
	A.u7(a,b);
	A.bg(u.g);},
	eG(a){return new A.eF(a)},
	K(a,b){return new A.at(!1,null,b,a)},
	h7(a,b,c){return new A.at(!0,a,b,c)},
	h8(a,b){return a},
	Y(a,b,c,d,e){return new A.dL(b,c,!0,a,d,"Invalid value")},
	aQ(a,b,c){if(0>a||a>c)throw A.d(A.Y(a,0,c,"start",null))
	if(b!=null){if(a>b||b>c)throw A.d(A.Y(b,a,c,"end",null))
	return b}return c},
	aW(a,b){if(a<0)throw A.d(A.Y(a,0,null,b,null))
	return a},
	eW(a,b,c,d,e){return new A.eV(b,!0,a,e,"Index out of range")},
	ad(a){return new A.fz(a)},
	p4(a){return new A.fu(a)},
	d2(a){return new A.bJ(a)},
	ag(a){return new A.eO(a)},
	u9(a){return new A.e_(a)},
	R(a,b,c){return new A.aK(a,b,c)},
	oE(a,b,c){if(a<=0)return new A.b7(c.h("b7<0>"))
	return new A.e0(a,b,c.h("e0<0>"))},
	oK(a,b,c,d,e){return new A.c6(a,b.h("@<0>").I(c).I(d).I(e).h("c6<1,2,3,4>"))},
	k6(a){var s,r,q=$.to();
	for(s=a.length,r=0;r<s;++r){q=q+J.bY(a[r])&536870911;
	q=q+((q&524287)<<10)&536870911;
	q^=q>>>6;}q=q+((q&67108863)<<3)&536870911;
	q^=q>>>11;
	return q+((q&16383)<<15)&536870911},
	p6(a6){var s,r,q,p,o,n,m,l,k,j,i,h,g,f,e,d,c,b,a,a0,a1,a2,a3,a4=null,a5=a6.length;
	if(a5>=5){s=A.pI(a6,0);
	if(s===0){r=A.lw(a5<a5?B.a.u(a6,0,a5):a6,5,a4);
	return r.gbo(r)}else if(s===32){r=A.lw(B.a.u(a6,5,a5),0,a4);
	return r.gbo(r)}}q=A.U(8,0,!1,t.S);
	q[0]=0;
	q[1]=-1;
	q[2]=-1;
	q[7]=-1;
	q[3]=0;
	q[4]=0;
	q[5]=a5;
	q[6]=a5;
	if(A.pG(a6,0,a5,0,q)>=14)q[7]=a5;
	p=q[1];
	if(p>=0)if(A.pG(a6,0,p,20,q)===20)q[7]=p;
	o=q[2]+1;
	n=q[3];
	m=q[4];
	l=q[5];
	k=q[6];
	if(k<l)l=k;
	if(m<o)m=l;
	else if(m<=p)m=p+1;
	if(n<o)n=m;
	j=q[7]<0;
	if(j)if(o>p+3){i=a4;
	j=!1;}else {r=n>0;
	if(r&&n+1===m){i=a4;
	j=!1;}else {if(!B.a.U(a6,"\\",m))if(o>0)h=B.a.U(a6,"\\",o-1)||B.a.U(a6,"\\",o-2);
	else h=!1;
	else h=!0;
	if(h){i=a4;
	j=!1;}else {if(!(l<a5&&l===m+2&&B.a.U(a6,"..",m)))h=l>m+2&&B.a.U(a6,"/..",l-3);
	else h=!0;
	if(h){i=a4;
	j=!1;}else {if(p===4)if(B.a.U(a6,"file",0)){if(o<=0){if(!B.a.U(a6,"/",m)){g="file:///";
	f=3;}else {g="file://";
	f=2;}a6=g+B.a.u(a6,m,a5);
	p-=0;
	r=f-0;
	l+=r;
	k+=r;
	a5=a6.length;
	o=7;
	n=7;
	m=7;}else if(m===l){++k;
	e=l+1;
	a6=B.a.aH(a6,m,l,"/");++a5;
	l=e;}i="file";}else if(B.a.U(a6,"http",0)){if(r&&n+3===m&&B.a.U(a6,"80",n+1)){k-=3;
	d=m-3;
	l-=3;
	a6=B.a.aH(a6,n,m,"");
	a5-=3;
	m=d;}i="http";}else i=a4;
	else if(p===5&&B.a.U(a6,"https",0)){if(r&&n+4===m&&B.a.U(a6,"443",n+1)){k-=4;
	d=m-4;
	l-=4;
	a6=B.a.aH(a6,n,m,"");
	a5-=3;
	m=d;}i="https";}else i=a4;
	j=!0;}}}}else i=a4;
	if(j){if(a5<a6.length){a6=B.a.u(a6,0,a5);
	p-=0;
	o-=0;
	n-=0;
	m-=0;
	l-=0;
	k-=0;}return new A.fP(a6,p,o,n,m,l,k,i)}if(i==null)if(p>0)i=A.vS(a6,0,p);
	else {if(p===0){A.dc(a6,0,"Invalid empty scheme");
	A.bg(u.g);}i="";}if(o>0){c=p+3;
	b=c<o?A.vT(a6,c,o-1):"";
	a=A.vO(a6,o,n,!1);
	r=n+1;
	if(r<m){a0=A.oY(B.a.u(a6,r,m),a4);
	a1=A.vQ(a0==null?A.Z(A.R("Invalid port",a6,r)):a0,i);}else a1=a4;}else {a1=a4;
	a=a1;
	b="";}a2=A.vP(a6,m,l,a4,i,a!=null);
	a3=l<k?A.vR(a6,l+1,k,a4):a4;
	return A.vJ(i,b,a,a1,a2,a3,k<a5?A.vN(a6,k+1,a5):a4)},
	vd(a,b,c){var s,r,q,p,o,n,m="IPv4 address should contain exactly 4 parts",l="each part must be in the range 0..255",k=new A.lx(a),j=new Uint8Array(4);
	for(s=b,r=s,q=0;s<c;++s){p=B.a.B(a,s);
	if(p!==46){if((p^48)>9)k.$2("invalid character",s);}else {if(q===3)k.$2(m,s);
	o=A.cM(B.a.u(a,r,s),null);
	if(o>255)k.$2(l,r);
	n=q+1;
	j[q]=o;
	r=s+1;
	q=n;}}if(q!==3)k.$2(m,c);
	o=A.cM(B.a.u(a,r,c),null);
	if(o>255)k.$2(l,r);
	j[q]=o;
	return j},
	p7(a,b,a0){var s,r,q,p,o,n,m,l,k,j,i,h,g,f,e=null,d=new A.ly(a),c=new A.lz(d,a);
	if(a.length<2)d.$2("address is too short",e);
	s=A.a([],t.Z);
	for(r=b,q=r,p=!1,o=!1;r<a0;++r){n=B.a.B(a,r);
	if(n===58){if(r===b){++r;
	if(B.a.B(a,r)!==58)d.$2("invalid start colon.",r);
	q=r;}if(r===q){if(p)d.$2("only one wildcard `::` is allowed",r);
	s.push(-1);
	p=!0;}else s.push(c.$2(q,r));
	q=r+1;}else if(n===46)o=!0;}if(s.length===0)d.$2("too few parts",e);
	m=q===a0;
	l=B.d.gaV(s);
	if(m&&l!==-1)d.$2("expected a part after last `:`",a0);
	if(!m)if(!o)s.push(c.$2(q,a0));
	else {k=A.vd(a,q,a0);
	s.push((k[0]<<8|k[1])>>>0);
	s.push((k[2]<<8|k[3])>>>0);}if(p){if(s.length>7)d.$2("an address with a wildcard must have less than 7 parts",e);}else if(s.length!==8)d.$2("an address without a wildcard must contain exactly 8 parts",e);
	j=new Uint8Array(16);
	for(l=s.length,i=9-l,r=0,h=0;r<l;++r){g=s[r];
	if(g===-1)for(f=0;f<i;++f){j[h]=0;
	j[h+1]=0;
	h+=2;}else {j[h]=B.c.ai(g,8);
	j[h+1]=g&255;
	h+=2;}}return j},
	vJ(a,b,c,d,e,f,g){return new A.en(a,b,c,d,e,f,g)},
	pm(a){if(a==="http")return 80
	if(a==="https")return 443
	return 0},
	dc(a,b,c){throw A.d(A.R(c,a,b))},
	vQ(a,b){var s=A.pm(b);
	if(a===s)return null
	return a},
	vO(a,b,c,d){var s,r,q,p,o,n;
	if(b===c)return ""
	if(B.a.B(a,b)===91){s=c-1;
	if(B.a.B(a,s)!==93){A.dc(a,b,"Missing end `]` to match `[` in host");
	A.bg(u.g);}r=b+1;
	q=A.vL(a,r,s);
	if(q<s){p=q+1;
	o=A.pr(a,B.a.U(a,"25",p)?q+3:p,s,"%25");}else o="";
	A.p7(a,r,q);
	return B.a.u(a,b,q).toLowerCase()+o+"]"}for(n=b;n<c;++n)if(B.a.B(a,n)===58){q=B.a.bg(a,"%",b);
	q=q>=b&&q<c?q:c;
	if(q<c){p=q+1;
	o=A.pr(a,B.a.U(a,"25",p)?q+3:p,c,"%25");}else o="";
	A.p7(a,b,q);
	return "["+B.a.u(a,b,q)+o+"]"}return A.vV(a,b,c)},
	vL(a,b,c){var s=B.a.bg(a,"%",b);
	return s>=b&&s<c?s:c},
	pr(a,b,c,d){var s,r,q,p,o,n,m,l,k,j,i=d!==""?new A.ac(d):null;
	for(s=b,r=s,q=!0;s<c;){p=B.a.B(a,s);
	if(p===37){o=A.nI(a,s,!0);
	n=o==null;
	if(n&&q){s+=3;
	continue}if(i==null)i=new A.ac("");
	m=i.a+=B.a.u(a,r,s);
	if(n)o=B.a.u(a,s,s+3);
	else if(o==="%"){A.dc(a,s,"ZoneID should not contain % anymore");
	A.bg(u.g);}i.a=m+o;
	s+=3;
	r=s;
	q=!0;}else if(p<127&&(B.av[p>>>4]&1<<(p&15))!==0){if(q&&65<=p&&90>=p){if(i==null)i=new A.ac("");
	if(r<s){i.a+=B.a.u(a,r,s);
	r=s;}q=!1;}++s;}else {if((p&64512)===55296&&s+1<c){l=B.a.B(a,s+1);
	if((l&64512)===56320){p=(p&1023)<<10|l&1023|65536;
	k=2;}else k=1;}else k=1;
	j=B.a.u(a,r,s);
	if(i==null){i=new A.ac("");
	n=i;}else n=i;
	n.a+=j;
	n.a+=A.nH(p);
	s+=k;
	r=s;}}if(i==null)return B.a.u(a,b,c)
	if(r<c)i.a+=B.a.u(a,r,c);
	n=i.a;
	return n.charCodeAt(0)==0?n:n},
	vV(a,b,c){var s,r,q,p,o,n,m,l,k,j,i;
	for(s=b,r=s,q=null,p=!0;s<c;){o=B.a.B(a,s);
	if(o===37){n=A.nI(a,s,!0);
	m=n==null;
	if(m&&p){s+=3;
	continue}if(q==null)q=new A.ac("");
	l=B.a.u(a,r,s);
	k=q.a+=!p?l.toLowerCase():l;
	if(m){n=B.a.u(a,s,s+3);
	j=3;}else if(n==="%"){n="%25";
	j=1;}else j=3;
	q.a=k+n;
	s+=j;
	r=s;
	p=!0;}else if(o<127&&(B.db[o>>>4]&1<<(o&15))!==0){if(p&&65<=o&&90>=o){if(q==null)q=new A.ac("");
	if(r<s){q.a+=B.a.u(a,r,s);
	r=s;}p=!1;}++s;}else if(o<=93&&(B.an[o>>>4]&1<<(o&15))!==0){A.dc(a,s,"Invalid character");
	A.bg(u.g);}else {if((o&64512)===55296&&s+1<c){i=B.a.B(a,s+1);
	if((i&64512)===56320){o=(o&1023)<<10|i&1023|65536;
	j=2;}else j=1;}else j=1;
	l=B.a.u(a,r,s);
	if(!p)l=l.toLowerCase();
	if(q==null){q=new A.ac("");
	m=q;}else m=q;
	m.a+=l;
	m.a+=A.nH(o);
	s+=j;
	r=s;}}if(q==null)return B.a.u(a,b,c)
	if(r<c){l=B.a.u(a,r,c);
	q.a+=!p?l.toLowerCase():l;}m=q.a;
	return m.charCodeAt(0)==0?m:m},
	vS(a,b,c){var s,r,q,p=u.g;
	if(b===c)return ""
	if(!A.po(B.a.J(a,b))){A.dc(a,b,"Scheme not starting with alphabetic character");
	A.bg(p);}for(s=b,r=!1;s<c;++s){q=B.a.J(a,s);
	if(!(q<128&&(B.as[q>>>4]&1<<(q&15))!==0)){A.dc(a,s,"Illegal scheme character");
	A.bg(p);}if(65<=q&&q<=90)r=!0;}a=B.a.u(a,b,c);
	return A.vK(r?a.toLowerCase():a)},
	vK(a){if(a==="http")return "http"
	if(a==="file")return "file"
	if(a==="https")return "https"
	if(a==="package")return "package"
	return a},
	vT(a,b,c){return A.eo(a,b,c,B.cQ,!1,!1)},
	vP(a,b,c,d,e,f){var s=e==="file",r=s||f,q=A.eo(a,b,c,B.ax,!0,!0);
	if(q.length===0){if(s)return "/"}else if(r&&!B.a.Y(q,"/"))q="/"+q;
	return A.vU(q,e,f)},
	vU(a,b,c){var s=b.length===0;
	if(s&&!c&&!B.a.Y(a,"/")&&!B.a.Y(a,"\\"))return A.vW(a,!s||c)
	return A.vX(a)},
	vR(a,b,c,d){return A.eo(a,b,c,B.D,!0,!1)},
	vN(a,b,c){return A.eo(a,b,c,B.D,!0,!1)},
	nI(a,b,c){var s,r,q,p,o,n=b+2;
	if(n>=a.length)return "%"
	s=B.a.B(a,b+1);
	r=B.a.B(a,n);
	q=A.mW(s);
	p=A.mW(r);
	if(q<0||p<0)return "%"
	o=q*16+p;
	if(o<127&&(B.av[B.c.ai(o,4)]&1<<(o&15))!==0)return A.be(c&&65<=o&&90>=o?(o|32)>>>0:o)
	if(s>=97||r>=97)return B.a.u(a,b,b+3).toUpperCase()
	return null},
	nH(a){var s,r,q,p,o,n="0123456789ABCDEF";
	if(a<128){s=new Uint8Array(3);
	s[0]=37;
	s[1]=B.a.J(n,a>>>4);
	s[2]=B.a.J(n,a&15);}else {if(a>2047)if(a>65535){r=240;
	q=4;}else {r=224;
	q=3;}else {r=192;
	q=2;}s=new Uint8Array(3*q);
	for(p=0;--q,q>=0;r=128){o=B.c.dT(a,6*q)&63|r;
	s[p]=37;
	s[p+1]=B.a.J(n,o>>>4);
	s[p+2]=B.a.J(n,o&15);
	p+=3;}}return A.p2(s,0,null)},
	eo(a,b,c,d,e,f){var s=A.pq(a,b,c,d,e,f);
	return s==null?B.a.u(a,b,c):s},
	pq(a,b,c,d,e,f){var s,r,q,p,o,n,m,l,k,j,i=null;
	for(s=!e,r=b,q=r,p=i;r<c;){o=B.a.B(a,r);
	if(o<127&&(d[o>>>4]&1<<(o&15))!==0)++r;
	else {if(o===37){n=A.nI(a,r,!1);
	if(n==null){r+=3;
	continue}if("%"===n){n="%25";
	m=1;}else m=3;}else if(o===92&&f){n="/";
	m=1;}else if(s&&o<=93&&(B.an[o>>>4]&1<<(o&15))!==0){A.dc(a,r,"Invalid character");
	A.bg(u.g);
	m=i;
	n=m;}else {if((o&64512)===55296){l=r+1;
	if(l<c){k=B.a.B(a,l);
	if((k&64512)===56320){o=(o&1023)<<10|k&1023|65536;
	m=2;}else m=1;}else m=1;}else m=1;
	n=A.nH(o);}if(p==null){p=new A.ac("");
	l=p;}else l=p;
	j=l.a+=B.a.u(a,q,r);
	l.a=j+A.b(n);
	r+=m;
	q=r;}}if(p==null)return i
	if(q<c)p.a+=B.a.u(a,q,c);
	s=p.a;
	return s.charCodeAt(0)==0?s:s},
	pp(a){if(B.a.Y(a,"."))return !0
	return B.a.bR(a,"/.")!==-1},
	vX(a){var s,r,q,p,o,n;
	if(!A.pp(a))return a
	s=A.a([],t.s);
	for(r=a.split("/"),q=r.length,p=!1,o=0;o<q;++o){n=r[o];
	if(J.af(n,"..")){if(s.length!==0){s.pop();
	if(s.length===0)s.push("");}p=!0;}else if("."===n)p=!0;
	else {s.push(n);
	p=!1;}}if(p)s.push("");
	return B.d.cQ(s,"/")},
	vW(a,b){var s,r,q,p,o,n;
	if(!A.pp(a))return !b?A.pn(a):a
	s=A.a([],t.s);
	for(r=a.split("/"),q=r.length,p=!1,o=0;o<q;++o){n=r[o];
	if(".."===n)if(s.length!==0&&B.d.gaV(s)!==".."){s.pop();
	p=!0;}else {s.push("..");
	p=!1;}else if("."===n)p=!0;
	else {s.push(n);
	p=!1;}}r=s.length;
	if(r!==0)r=r===1&&s[0].length===0;
	else r=!0;
	if(r)return "./"
	if(p||B.d.gaV(s)==="..")s.push("");
	if(!b)s[0]=A.pn(s[0]);
	return B.d.cQ(s,"/")},
	pn(a){var s,r,q=a.length;
	if(q>=2&&A.po(B.a.J(a,0)))for(s=1;s<q;++s){r=B.a.J(a,s);
	if(r===58)return B.a.u(a,0,s)+"%3A"+B.a.bu(a,s+1)
	if(r>127||(B.as[r>>>4]&1<<(r&15))===0)break}return a},
	vM(a,b){var s,r,q;
	for(s=0,r=0;r<2;++r){q=B.a.B(a,b+r);
	if(48<=q&&q<=57)s=s*16+q-48;
	else {q|=32;
	if(97<=q&&q<=102)s=s*16+q-87;
	else throw A.d(A.K("Invalid URL encoding",null))}}return s},
	vY(a,b,c,d,e){var s,r,q,p,o=b;
	while(!0){if(!(o<c)){s=!0;
	break}r=B.a.B(a,o);
	if(r<=127)if(r!==37)q=!1;
	else q=!0;
	else q=!0;
	if(q){s=!1;
	break}++o;}if(s){if(B.ac!==d)q=!1;
	else q=!0;
	if(q)return B.a.u(a,b,c)
	else p=new A.c8(B.a.u(a,b,c));}else {p=A.a([],t.Z);
	for(q=a.length,o=b;o<c;++o){r=B.a.B(a,o);
	if(r>127)throw A.d(A.K("Illegal percent encoding in URI",null))
	if(r===37){if(o+3>q)throw A.d(A.K("Truncated URI",null))
	p.push(A.vM(a,o+1));
	o+=2;}else p.push(r);}}return B.em.e_(p)},
	po(a){var s=a|32;
	return 97<=s&&s<=122},
	p5(a){var s;
	if(a.length>=5){s=A.pI(a,0);
	if(s===0)return A.lw(a,5,null)
	if(s===32)return A.lw(B.a.bu(a,5),0,null)}throw A.d(A.R("Does not start with 'data:'",a,0))},
	lw(a,b,c){var s,r,q,p,o,n,m,l,k="Invalid MIME type",j=A.a([b-1],t.Z);
	for(s=a.length,r=b,q=-1,p=null;r<s;++r){p=B.a.J(a,r);
	if(p===44||p===59)break
	if(p===47){if(q<0){q=r;
	continue}throw A.d(A.R(k,a,r))}}if(q<0&&r>b)throw A.d(A.R(k,a,r))
	for(;p!==44;){j.push(r);++r;
	for(o=-1;r<s;++r){p=B.a.J(a,r);
	if(p===61){if(o<0)o=r;}else if(p===59||p===44)break}if(o>=0)j.push(o);
	else {n=B.d.gaV(j);
	if(p!==44||r!==n+7||!B.a.U(a,"base64",n+1))throw A.d(A.R("Expecting '='",a,r))
	break}}j.push(r);
	m=r+1;
	if((j.length&1)===1)a=B.b7.ee(a,m,s);
	else {l=A.pq(a,m,s,B.D,!0,!1);
	if(l!=null)a=B.a.aH(a,m,s,l);}return new A.lv(a,j,c)},
	w6(){var s,r,q,p,o,n="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=",m=".",l=":",k="/",j="\\",i="?",h="#",g="/\\",f=A.a(new Array(22),t.gN);
	for(s=0;s<22;++s)f[s]=new Uint8Array(96);
	r=new A.mB(f);
	q=new A.mC();
	p=new A.mD();
	o=r.$2(0,225);
	q.$3(o,n,1);
	q.$3(o,m,14);
	q.$3(o,l,34);
	q.$3(o,k,3);
	q.$3(o,j,227);
	q.$3(o,i,172);
	q.$3(o,h,205);
	o=r.$2(14,225);
	q.$3(o,n,1);
	q.$3(o,m,15);
	q.$3(o,l,34);
	q.$3(o,g,234);
	q.$3(o,i,172);
	q.$3(o,h,205);
	o=r.$2(15,225);
	q.$3(o,n,1);
	q.$3(o,"%",225);
	q.$3(o,l,34);
	q.$3(o,k,9);
	q.$3(o,j,233);
	q.$3(o,i,172);
	q.$3(o,h,205);
	o=r.$2(1,225);
	q.$3(o,n,1);
	q.$3(o,l,34);
	q.$3(o,k,10);
	q.$3(o,j,234);
	q.$3(o,i,172);
	q.$3(o,h,205);
	o=r.$2(2,235);
	q.$3(o,n,139);
	q.$3(o,k,131);
	q.$3(o,j,131);
	q.$3(o,m,146);
	q.$3(o,i,172);
	q.$3(o,h,205);
	o=r.$2(3,235);
	q.$3(o,n,11);
	q.$3(o,k,68);
	q.$3(o,j,68);
	q.$3(o,m,18);
	q.$3(o,i,172);
	q.$3(o,h,205);
	o=r.$2(4,229);
	q.$3(o,n,5);
	p.$3(o,"AZ",229);
	q.$3(o,l,102);
	q.$3(o,"@",68);
	q.$3(o,"[",232);
	q.$3(o,k,138);
	q.$3(o,j,138);
	q.$3(o,i,172);
	q.$3(o,h,205);
	o=r.$2(5,229);
	q.$3(o,n,5);
	p.$3(o,"AZ",229);
	q.$3(o,l,102);
	q.$3(o,"@",68);
	q.$3(o,k,138);
	q.$3(o,j,138);
	q.$3(o,i,172);
	q.$3(o,h,205);
	o=r.$2(6,231);
	p.$3(o,"19",7);
	q.$3(o,"@",68);
	q.$3(o,k,138);
	q.$3(o,j,138);
	q.$3(o,i,172);
	q.$3(o,h,205);
	o=r.$2(7,231);
	p.$3(o,"09",7);
	q.$3(o,"@",68);
	q.$3(o,k,138);
	q.$3(o,j,138);
	q.$3(o,i,172);
	q.$3(o,h,205);
	q.$3(r.$2(8,8),"]",5);
	o=r.$2(9,235);
	q.$3(o,n,11);
	q.$3(o,m,16);
	q.$3(o,g,234);
	q.$3(o,i,172);
	q.$3(o,h,205);
	o=r.$2(16,235);
	q.$3(o,n,11);
	q.$3(o,m,17);
	q.$3(o,g,234);
	q.$3(o,i,172);
	q.$3(o,h,205);
	o=r.$2(17,235);
	q.$3(o,n,11);
	q.$3(o,k,9);
	q.$3(o,j,233);
	q.$3(o,i,172);
	q.$3(o,h,205);
	o=r.$2(10,235);
	q.$3(o,n,11);
	q.$3(o,m,18);
	q.$3(o,k,10);
	q.$3(o,j,234);
	q.$3(o,i,172);
	q.$3(o,h,205);
	o=r.$2(18,235);
	q.$3(o,n,11);
	q.$3(o,m,19);
	q.$3(o,g,234);
	q.$3(o,i,172);
	q.$3(o,h,205);
	o=r.$2(19,235);
	q.$3(o,n,11);
	q.$3(o,g,234);
	q.$3(o,i,172);
	q.$3(o,h,205);
	o=r.$2(11,235);
	q.$3(o,n,11);
	q.$3(o,k,10);
	q.$3(o,j,234);
	q.$3(o,i,172);
	q.$3(o,h,205);
	o=r.$2(12,236);
	q.$3(o,n,12);
	q.$3(o,i,12);
	q.$3(o,h,205);
	o=r.$2(13,237);
	q.$3(o,n,13);
	q.$3(o,i,13);
	p.$3(r.$2(20,245),"az",21);
	o=r.$2(21,245);
	p.$3(o,"az",21);
	p.$3(o,"09",21);
	q.$3(o,"+-.",21);
	return f},
	pG(a,b,c,d,e){var s,r,q,p,o=$.ts();
	for(s=b;s<c;++s){r=o[d];
	q=B.a.J(a,s)^96;
	p=r[q>95?31:q];
	d=p&31;
	e[p>>>5]=s;}return d},
	pI(a,b){return ((B.a.J(a,b+4)^58)*3|B.a.J(a,b)^100|B.a.J(a,b+1)^97|B.a.J(a,b+2)^116|B.a.J(a,b+3)^97)>>>0},
	k2:function k2(a,b){this.a=a;
	this.b=b;},
	dp:function dp(a,b){this.a=a;
	this.b=b;},
	m2:function m2(){},
	H:function H(){},
	eF:function eF(a){this.a=a;},
	aG:function aG(){},
	fg:function fg(){},
	at:function at(a,b,c,d){var _=this;
	_.a=a;
	_.b=b;
	_.c=c;
	_.d=d;},
	dL:function dL(a,b,c,d,e,f){var _=this;
	_.e=a;
	_.f=b;
	_.a=c;
	_.b=d;
	_.c=e;
	_.d=f;},
	eV:function eV(a,b,c,d,e){var _=this;
	_.f=a;
	_.a=b;
	_.b=c;
	_.c=d;
	_.d=e;},
	dH:function dH(a,b,c,d,e){var _=this;
	_.a=a;
	_.b=b;
	_.c=c;
	_.d=d;
	_.e=e;},
	fz:function fz(a){this.a=a;},
	fu:function fu(a){this.a=a;},
	bJ:function bJ(a){this.a=a;},
	eO:function eO(a){this.a=a;},
	fi:function fi(){},
	dO:function dO(){},
	eQ:function eQ(a){this.a=a;},
	e_:function e_(a){this.a=a;},
	aK:function aK(a,b,c){this.a=a;
	this.b=b;
	this.c=c;},
	j:function j(){},
	e0:function e0(a,b,c){this.a=a;
	this.b=b;
	this.$ti=c;},
	P:function P(){},
	cY:function cY(a,b,c){this.a=a;
	this.b=b;
	this.$ti=c;},
	l:function l(){},
	c:function c(){},
	fR:function fR(){},
	ac:function ac(a){this.a=a;},
	lx:function lx(a){this.a=a;},
	ly:function ly(a){this.a=a;},
	lz:function lz(a,b){this.a=a;
	this.b=b;},
	en:function en(a,b,c,d,e,f,g){var _=this;
	_.a=a;
	_.b=b;
	_.c=c;
	_.d=d;
	_.e=e;
	_.f=f;
	_.r=g;
	_.y=_.w=$;},
	lv:function lv(a,b,c){this.a=a;
	this.b=b;
	this.c=c;},
	mB:function mB(a){this.a=a;},
	mC:function mC(){},
	mD:function mD(){},
	fP:function fP(a,b,c,d,e,f,g,h){var _=this;
	_.a=a;
	_.b=b;
	_.c=c;
	_.d=d;
	_.e=e;
	_.f=f;
	_.r=g;
	_.w=h;
	_.x=null;},
	fH:function fH(a,b,c,d,e,f,g){var _=this;
	_.a=a;
	_.b=b;
	_.c=c;
	_.d=d;
	_.e=e;
	_.f=f;
	_.r=g;
	_.y=_.w=$;},
	nR(a){if(!t.I.b(a)&&!t.j.b(a))throw A.d(A.K("object must be a Map or Iterable",null))
	return A.w5(a)},
	w5(a){var s=new A.mz(new A.e4(t.aH)).$1(a);
	s.toString;
	return s},
	mz:function mz(a){this.a=a;},
	tN(a,b){var s,r,q,p,o,n,m,l,k,j,i,h,g,f="byteOffset",e=null,d="normalized";
	A.w(a,B.cZ,b);
	s=A.W(a,"bufferView",b,!1);
	if(s===-1){r=a.v(f);
	if(r)b.l($.cO(),A.a(["bufferView"],t.M),f);
	q=0;}else q=A.a0(a,f,b,0,e,-1,0,!1);
	p=A.a0(a,"componentType",b,-1,B.cu,-1,0,!0);
	o=A.a0(a,"count",b,-1,e,-1,1,!0);
	n=A.J(a,"type",b,e,B.m.gN(),e,!0);
	m=A.pO(a,d,b);
	if(n!=null&&p!==-1){l=B.m.i(0,n);
	if(l!=null)if(p===5126){r=t.V;
	k=A.ae(a,"min",b,e,A.a([l],r),1/0,-1/0,!0);
	j=A.ae(a,"max",b,e,A.a([l],r),1/0,-1/0,!0);}else {k=A.pP(a,"min",b,p,l);
	j=A.pP(a,"max",b,p,l);}else {k=e;
	j=k;}}else {k=e;
	j=k;}i=A.T(a,"sparse",b,A.wK(),!1);
	if(m)r=p===5126||p===5125;
	else r=!1;
	if(r)b.n($.ru(),d);
	if((n==="MAT2"||n==="MAT3"||n==="MAT4")&&q!==-1&&(q&3)!==0)b.n($.rt(),f);
	switch(p){case 5120:case 5121:case 5122:case 5123:case 5125:r=t.w;
	r.a(j);
	r.a(k);
	A.J(a,"name",b,e,e,e,!1);
	r=A.t(a,B.S,b,e);
	h=A.x(a,b);
	g=new A.fC(s,q,p,o,n,m,j,k,i,A.b0(p),r,h,!1);
	if(k!=null){r=b.S();
	h=t.e;
	b.a_(g,new A.f6(A.U(k.length,0,!1,h),A.U(k.length,0,!1,h),J.h4(k,!1),r));}if(j!=null){r=b.S();
	h=t.e;
	b.a_(g,new A.f4(A.U(j.length,0,!1,h),A.U(j.length,0,!1,h),J.h4(j,!1),r));}break
	default:r=t.fy;
	r.a(j);
	r.a(k);
	A.J(a,"name",b,e,e,e,!1);
	r=A.t(a,B.S,b,e);
	h=A.x(a,b);
	g=new A.fB(s,q,p,o,n,m,j,k,i,A.b0(p),r,h,!1);
	b.a_(g,new A.eY(b.S()));
	if(k!=null){r=b.S();
	b.a_(g,new A.f5(A.U(k.length,0,!1,t.e),A.U(k.length,0,!1,t.F),J.h4(k,!1),r));}if(j!=null){r=b.S();
	b.a_(g,new A.f3(A.U(j.length,0,!1,t.e),A.U(j.length,0,!1,t.F),J.h4(j,!1),r));}break}return g},
	bu(a,b,c,d,e,f){var s,r,q="byteOffset";
	if(a===-1)return !1
	if(a%b!==0)if(f!=null)f.l($.rv(),A.a([a,b],t.M),q);
	else return !1
	s=d.x;
	if(s===-1)return !1
	r=s+a;
	if(r%b!==0)if(f!=null)f.F($.qM(),A.a([r,b],t.M));
	else return !1
	s=d.y;
	if(a>s)if(f!=null)f.l($.o3(),A.a([a,c,e,s],t.M),q);
	else return !1
	else if(a+c>s)if(f!=null)f.F($.o3(),A.a([a,c,e,s],t.M));
	else return !1
	return !0},
	np(a,b,c,d){var s=b.byteLength,r=A.b0(a);
	if(s<c+r*d)return null
	switch(a){case 5121:return A.nw(b,c,d)
	case 5123:return A.oO(b,c,d)
	case 5125:return A.oP(b,c,d)
	default:return null}},
	oq(a,b,c,d){var s=b.byteLength,r=A.b0(a);
	if(s<c+r*d)return null
	switch(a){case 5126:A.de(b,c,d);
	return new Float32Array(b,c,d)
	default:return null}},
	or(a,b,c,d){var s=b.byteLength,r=A.b0(a);
	if(s<c+r*d)return null
	switch(a){case 5120:A.de(b,c,d);
	s=new Int8Array(b,c,d);
	return s
	case 5121:return A.nw(b,c,d)
	case 5122:A.de(b,c,d);
	return new Int16Array(b,c,d)
	case 5123:return A.oO(b,c,d)
	case 5125:return A.oP(b,c,d)
	default:return null}},
	tM(a,b){var s,r,q;
	A.w(a,B.cH,b);
	s=A.a0(a,"count",b,-1,null,-1,1,!0);
	r=A.T(a,"indices",b,A.wI(),!0);
	q=A.T(a,"values",b,A.wJ(),!0);
	if(s===-1||r==null||q==null)return null
	return new A.bZ(s,r,q,A.t(a,B.dP,b,null),A.x(a,b),!1)},
	tK(a,b){A.w(a,B.cA,b);
	return new A.c_(A.W(a,"bufferView",b,!0),A.a0(a,"byteOffset",b,0,null,-1,0,!1),A.a0(a,"componentType",b,-1,B.ce,-1,0,!0),A.t(a,B.dN,b,null),A.x(a,b),!1)},
	tL(a,b){A.w(a,B.cD,b);
	return new A.c0(A.W(a,"bufferView",b,!0),A.a0(a,"byteOffset",b,0,null,-1,0,!1),A.t(a,B.dO,b,null),A.x(a,b),!1)},
	a4:function a4(){},
	fC:function fC(a,b,c,d,e,f,g,h,i,j,k,l,m){var _=this;
	_.w=a;
	_.x=b;
	_.y=c;
	_.z=d;
	_.Q=e;
	_.as=f;
	_.at=g;
	_.ax=h;
	_.ay=i;
	_.ch=j;
	_.CW=null;
	_.cx=0;
	_.fr=_.dy=null;
	_.a=k;
	_.b=l;
	_.a$=m;},
	lR:function lR(a,b,c,d,e){var _=this;
	_.a=a;
	_.b=b;
	_.c=c;
	_.d=d;
	_.e=e;},
	lS:function lS(a){this.a=a;},
	lT:function lT(){},
	lU:function lU(a,b,c,d,e){var _=this;
	_.a=a;
	_.b=b;
	_.c=c;
	_.d=d;
	_.e=e;},
	lP:function lP(a){this.a=a;},
	lQ:function lQ(a){this.a=a;},
	fB:function fB(a,b,c,d,e,f,g,h,i,j,k,l,m){var _=this;
	_.w=a;
	_.x=b;
	_.y=c;
	_.z=d;
	_.Q=e;
	_.as=f;
	_.at=g;
	_.ax=h;
	_.ay=i;
	_.ch=j;
	_.CW=null;
	_.cx=0;
	_.fr=_.dy=null;
	_.a=k;
	_.b=l;
	_.a$=m;},
	lL:function lL(a,b,c,d,e){var _=this;
	_.a=a;
	_.b=b;
	_.c=c;
	_.d=d;
	_.e=e;},
	lM:function lM(a){this.a=a;},
	lN:function lN(){},
	lO:function lO(a,b,c,d,e){var _=this;
	_.a=a;
	_.b=b;
	_.c=c;
	_.d=d;
	_.e=e;},
	bZ:function bZ(a,b,c,d,e,f){var _=this;
	_.d=a;
	_.e=b;
	_.f=c;
	_.a=d;
	_.b=e;
	_.a$=f;},
	c_:function c_(a,b,c,d,e,f){var _=this;
	_.d=a;
	_.e=b;
	_.f=c;
	_.r=null;
	_.a=d;
	_.b=e;
	_.a$=f;},
	c0:function c0(a,b,c,d,e){var _=this;
	_.d=a;
	_.e=b;
	_.f=null;
	_.a=c;
	_.b=d;
	_.a$=e;},
	eY:function eY(a){this.a=a;},
	f5:function f5(a,b,c,d){var _=this;
	_.a=a;
	_.b=b;
	_.c=c;
	_.d=d;},
	f3:function f3(a,b,c,d){var _=this;
	_.a=a;
	_.b=b;
	_.c=c;
	_.d=d;},
	f6:function f6(a,b,c,d){var _=this;
	_.a=a;
	_.b=b;
	_.c=c;
	_.d=d;},
	f4:function f4(a,b,c,d){var _=this;
	_.a=a;
	_.b=b;
	_.c=c;
	_.d=d;},
	tP(a0,a1){var s,r,q,p,o,n,m,l,k,j,i,h,g,f,e,d=null,c="channels",b="extras",a="samplers";
	A.w(a0,B.cF,a1);
	s=A.eB(a0,c,a1);
	if(s!=null){r=s.gj(s);
	q=A.U(r,d,!1,t.aA);
	p=new A.F(q,r,c,t.eq);
	r=a1.c;
	r.push(c);
	for(o=t.h,n=0;n<s.gj(s);++n){m=s.i(0,n);
	r.push(B.c.k(n));
	A.w(m,B.di,a1);
	l=A.W(m,"sampler",a1,!0);
	k=A.T(m,"target",a1,A.wM(),!0);
	j=A.t(m,B.dQ,a1,d);
	i=m.i(0,b);
	if(i!=null&&!o.b(i))a1.n($.dk(),b);
	q[n]=new A.b2(l,k,j,i,!1);
	r.pop();}r.pop();}else p=d;
	h=A.eB(a0,a,a1);
	if(h!=null){r=h.gj(h);
	q=A.U(r,d,!1,t.gW);
	g=new A.F(q,r,a,t.az);
	r=a1.c;
	r.push(a);
	for(o=t.h,n=0;n<h.gj(h);++n){f=h.i(0,n);
	r.push(B.c.k(n));
	A.w(f,B.cW,a1);
	l=A.W(f,"input",a1,!0);
	k=A.J(f,"interpolation",a1,"LINEAR",B.cq,d,!1);
	j=A.W(f,"output",a1,!0);
	e=A.t(f,B.dR,a1,d);
	i=f.i(0,b);
	if(i!=null&&!o.b(i))a1.n($.dk(),b);
	q[n]=new A.b3(l,k,j,e,i,!1);
	r.pop();}r.pop();}else g=d;
	A.J(a0,"name",a1,d,d,d,!1);
	return new A.bv(p,g,A.t(a0,B.T,a1,d),A.x(a0,a1),!1)},
	tO(a,b){var s,r;
	A.w(a,B.d3,b);
	s=A.t(a,B.aC,b,B.T);
	r=new A.bw(A.W(a,"node",b,!1),A.J(a,"path",b,null,b.fy,null,!0),s,A.x(a,b),!1);
	b.W(r,A.bc(s.gX(),!0,t._));
	return r},
	bv:function bv(a,b,c,d,e){var _=this;
	_.w=a;
	_.x=b;
	_.a=c;
	_.b=d;
	_.a$=e;},
	h5:function h5(a,b){this.a=a;
	this.b=b;},
	h6:function h6(a,b,c){this.a=a;
	this.b=b;
	this.c=c;},
	b2:function b2(a,b,c,d,e){var _=this;
	_.d=a;
	_.e=b;
	_.f=null;
	_.a=c;
	_.b=d;
	_.a$=e;},
	bw:function bw(a,b,c,d,e){var _=this;
	_.d=a;
	_.e=b;
	_.f=null;
	_.a=c;
	_.b=d;
	_.a$=e;},
	b3:function b3(a,b,c,d,e,f){var _=this;
	_.d=a;
	_.e=b;
	_.f=c;
	_.w=_.r=null;
	_.a=d;
	_.b=e;
	_.a$=f;},
	eE:function eE(a){this.a=0;
	this.b=a;},
	dK:function dK(a,b,c,d){var _=this;
	_.a=a;
	_.b=b;
	_.c=c;
	_.e=_.d=0;
	_.$ti=d;},
	tQ(a,b){var s,r,q,p,o=null,n="minVersion";
	A.w(a,B.cC,b);
	A.J(a,"copyright",b,o,o,o,!1);
	s=A.J(a,"generator",b,o,o,o,!1);
	r=$.br();
	q=A.J(a,"version",b,o,o,r,!0);
	r=A.J(a,n,b,o,o,r,!1);
	p=new A.bx(s,q,r,A.t(a,B.dS,b,o),A.x(a,b),!1);
	if(r!=null&&q!=null){if(p.gcS()<=p.gbj())s=p.gcS()===p.gbj()&&p.ged()>p.gbW();
	else s=!0;
	if(s)b.l($.rV(),A.a([r,q],t.M),n);}return p},
	bx:function bx(a,b,c,d,e,f){var _=this;
	_.e=a;
	_.f=b;
	_.r=c;
	_.a=d;
	_.b=e;
	_.a$=f;},
	tU(a,b){var s,r,q,p,o,m,l,k=null,j="uri";
	A.w(a,B.dk,b);
	p=A.a0(a,"byteLength",b,-1,k,-1,1,!0);
	s=null;
	o=a.v(j);
	if(o){r=A.J(a,j,b,k,k,k,!1);
	if(r!=null){if(b.dx)b.n($.o2(),j);
	q=null;
	try{q=A.p5(r);}catch(n){if(A.M(n) instanceof A.aK)s=A.pS(r,b);
	else throw n}if(q!=null){if(b.dx)b.n($.o1(),j);
	switch(q.gbV().toLowerCase()){case"application/gltf-buffer":case"application/octet-stream":m=q.cD();
	break
	default:b.l($.ry(),A.a([q.gbV()],t.M),j);
	m=k;
	break}}else m=k;}else m=k;
	o=!0;}else m=k;
	l=s;
	A.J(a,"name",b,k,k,k,!1);
	return new A.aT(l,p,o,m,A.t(a,B.dT,b,k),A.x(a,b),!1)},
	aT:function aT(a,b,c,d,e,f,g){var _=this;
	_.w=a;
	_.x=b;
	_.y=c;
	_.z=d;
	_.a=e;
	_.b=f;
	_.a$=g;},
	tT(a,b){var s,r,q,p,o,n=null,m="byteStride";
	A.w(a,B.cp,b);
	s=A.a0(a,"byteLength",b,-1,n,-1,1,!0);
	r=A.a0(a,m,b,-1,n,252,4,!1);
	q=A.a0(a,"target",b,-1,B.cb,-1,0,!1);
	if(r!==-1){if(s!==-1&&r>s)b.l($.rz(),A.a([r,s],t.M),m);
	if(r%4!==0)b.l($.rr(),A.a([r,4],t.M),m);
	if(q===34963)b.n($.nj(),m);}p=A.W(a,"buffer",b,!0);
	o=A.a0(a,"byteOffset",b,0,n,-1,0,!1);
	A.J(a,"name",b,n,n,n,!1);
	return new A.by(p,o,s,r,q,A.t(a,B.aD,b,n),A.x(a,b),!1)},
	by:function by(a,b,c,d,e,f,g,h){var _=this;
	_.w=a;
	_.x=b;
	_.y=c;
	_.z=d;
	_.Q=e;
	_.at=_.as=null;
	_.ax=-1;
	_.a=f;
	_.b=g;
	_.a$=h;},
	tX(a,b){var s=null,r="orthographic",q="perspective";
	A.w(a,B.dj,b);
	if(a.v(r)&&a.v(q))b.F($.oe(),B.aw);
	switch(A.J(a,"type",b,s,B.aw,s,!0)){case"orthographic":A.T(a,r,b,A.wV(),!0);
	break
	case"perspective":A.T(a,q,b,A.wW(),!0);
	break}A.J(a,"name",b,s,s,s,!1);
	return new A.bz(A.t(a,B.dW,b,s),A.x(a,b),!1)},
	tV(a,b){var s,r,q,p,o="xmag",n="ymag";
	A.w(a,B.dq,b);
	s=A.E(a,o,b,0/0,1/0,-1/0,1/0,-1/0,!0,0/0);
	r=A.E(a,n,b,0/0,1/0,-1/0,1/0,-1/0,!0,0/0);
	q=A.E(a,"zfar",b,0/0,1/0,0,1/0,-1/0,!0,0/0);
	p=A.E(a,"znear",b,0/0,1/0,-1/0,1/0,0,!0,0/0);
	if(q<=p)b.L($.oh());
	if(s===0)b.n($.og(),o);
	else if(s<0)b.n($.of(),o);
	if(r===0)b.n($.og(),n);
	else if(r<0)b.n($.of(),n);
	return new A.c3(A.t(a,B.dU,b,null),A.x(a,b),!1)},
	tW(a,b){var s,r,q;
	A.w(a,B.cB,b);
	s=A.E(a,"yfov",b,0/0,1/0,0,1/0,-1/0,!0,0/0);
	if(s>=3.141592653589793)b.L($.rA());
	r=A.E(a,"zfar",b,0/0,1/0,0,1/0,-1/0,!1,0/0);
	q=A.E(a,"znear",b,0/0,1/0,0,1/0,-1/0,!0,0/0);
	if(r<=q)b.L($.oh());
	A.E(a,"aspectRatio",b,0/0,1/0,0,1/0,-1/0,!1,0/0);
	return new A.c4(A.t(a,B.dV,b,null),A.x(a,b),!1)},
	bz:function bz(a,b,c){this.a=a;
	this.b=b;
	this.a$=c;},
	c3:function c3(a,b,c){this.a=a;
	this.b=b;
	this.a$=c;},
	c4:function c4(a,b,c){this.a=a;
	this.b=b;
	this.a$=c;},
	oC(c0,c1){var s,r,q,p,o,n,m,l,k,j,i,h,g,f,e,d,c,b,a,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,b0,b1,b2,b3,b4,b5,b6="extensionsRequired",b7="extensionsUsed",b8=null,b9=new A.iw(c1);
	b9.$0();
	A.w(c0,B.dr,c1);
	if(c0.v(b6)&&!c0.v(b7))c1.l($.cO(),A.a(["extensionsUsed"],t.M),b6);
	s=A.pQ(c0,b7,c1);
	if(s==null)s=A.a([],t.i);
	r=A.pQ(c0,b6,c1);
	if(r==null)r=A.a([],t.i);
	c1.e9(s,r);
	q=new A.ix(c0,b9,c1);
	p=new A.iy(b9,c0,c1).$1$3$req("asset",A.wO(),!0,t.gP);
	if((p==null?b8:p.f)==null)return b8
	else if(p.gbj()!==2){o=$.t8();
	n=p.gbj();
	c1.l(o,A.a([n],t.M),"version");
	return b8}else if(p.gbW()>0){o=$.t9();
	n=p.gbW();
	c1.l(o,A.a([n],t.M),"version");}m=q.$1$2("accessors",A.wL(),t.W);
	l=q.$1$2("animations",A.wN(),t.bj);
	k=q.$1$2("buffers",A.wT(),t.cT);
	j=q.$1$2("bufferViews",A.wU(),t.r);
	i=q.$1$2("cameras",A.wX(),t.h2);
	h=q.$1$2("images",A.xc(),t.ec);
	g=q.$1$2("materials",A.xF(),t.fC);
	f=q.$1$2("meshes",A.xI(),t.eM);
	o=t.L;
	e=q.$1$2("nodes",A.xJ(),o);
	d=q.$1$2("samplers",A.xK(),t.c2);
	c=q.$1$2("scenes",A.xL(),t.bn);
	b9.$0();
	b=A.W(c0,"scene",c1,!1);
	a=c.i(0,b);
	if(b!==-1&&a==null)c1.l($.Q(),A.a([b],t.M),"scene");
	a0=q.$1$2("skins",A.xM(),t.aV);
	a1=q.$1$2("textures",A.xO(),t.ai);
	b9.$0();
	a2=A.t(c0,B.U,c1,b8);
	b9.$0();
	a3=new A.du(s,r,m,l,p,k,j,i,h,g,f,e,d,a,a0,a1,a2,A.x(c0,c1),!1);
	a4=new A.iu(c1,a3);
	a4.$2(j,B.aD);
	a4.$2(m,B.S);
	a4.$2(h,B.aE);
	a4.$2(a1,B.W);
	a4.$2(g,B.f);
	a4.$2(f,B.aG);
	a4.$2(e,B.V);
	a4.$2(a0,B.aK);
	a4.$2(l,B.T);
	a4.$2(c,B.aJ);
	if(a2.a!==0){n=c1.c;
	n.push("extensions");
	a2.M(0,new A.is(c1,a3));
	n.pop();}n=c1.c;
	n.push("nodes");
	e.a4(new A.it(c1,A.aD(o)));
	n.pop();
	a5=[m,k,j,i,h,g,f,e,d,a0,a1];
	for(a6=0;a6<11;++a6){a7=a5[a6];
	if(a7.gj(a7)===0)continue
	n.push(a7.c);
	for(o=a7.b,a8=a7.a,a9=a8.length,b0=0;b0<o;++b0){b1=b0>=a9;
	b1=b1?b8:a8[b0];
	if((b1==null?b8:b1.a$)===!1)c1.Z($.h1(),b0);}n.pop();}o=c1.x;
	if(o.a!==0){for(a8=A.uH(o,o.r,A.A(o).c);a8.q();){a9=a8.d;
	if(a9.gj(a9)===0)continue
	b2=o.i(0,a9);
	B.d.P(n);
	B.d.D(n,b2);
	for(b1=a9.b,a9=a9.a,b3=a9.length,b0=0;b0<b1;++b0){b4=b0>=b3;
	b4=b4?b8:a9[b0];
	if((b4==null?b8:b4.a$)===!1)c1.Z($.h1(),b0);}}B.d.P(n);}n.push("meshes");
	for(o=f.b,a8=f.a,a9=a8.length,b0=0;b0<o;++b0){b1=b0>=a9;
	b5=b1?b8:a8[b0];
	if((b5==null?b8:b5.x)!=null&&b5.a$&&!b5.y){n.push(B.c.k(b0));
	c1.n($.ro(),"weights");
	n.pop();}}B.d.P(n);
	return a3},
	du:function du(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s){var _=this;
	_.d=a;
	_.e=b;
	_.f=c;
	_.r=d;
	_.w=e;
	_.x=f;
	_.y=g;
	_.z=h;
	_.Q=i;
	_.as=j;
	_.at=k;
	_.ax=l;
	_.ay=m;
	_.ch=n;
	_.cx=o;
	_.cy=p;
	_.a=q;
	_.b=r;
	_.a$=s;},
	iw:function iw(a){this.a=a;},
	ix:function ix(a,b,c){this.a=a;
	this.b=b;
	this.c=c;},
	iy:function iy(a,b,c){this.a=a;
	this.b=b;
	this.c=c;},
	iu:function iu(a,b){this.a=a;
	this.b=b;},
	iv:function iv(a,b){this.a=a;
	this.b=b;},
	is:function is(a,b){this.a=a;
	this.b=b;},
	it:function it(a,b){this.a=a;
	this.b=b;},
	iq:function iq(){},
	ir:function ir(){},
	iz:function iz(a,b){this.a=a;
	this.b=b;},
	iA:function iA(a,b){this.a=a;
	this.b=b;},
	m:function m(){},
	k:function k(){},
	eR:function eR(){},
	fL:function fL(){},
	ug(a,b){var s,r,q,p,o,n,m,k,j="bufferView",i=null,h="uri";
	A.w(a,B.cE,b);
	p=A.W(a,j,b,!1);
	o=A.J(a,"mimeType",b,i,b.dy,i,!1);
	s=A.J(a,h,b,i,i,i,!1);
	n=p===-1;
	m=!n;
	if(m&&o==null)b.l($.cO(),A.a(["mimeType"],t.M),j);
	if(!(m&&s!=null))n=n&&s==null;
	else n=!0;
	if(n)b.F($.oe(),A.a(["bufferView","uri"],t.M));
	r=null;
	if(s!=null){if(b.dx)b.n($.o2(),h);
	q=null;
	try{q=A.p5(s);}catch(l){if(A.M(l) instanceof A.aK)r=A.pS(s,b);
	else throw l}if(q!=null){if(b.dx)b.n($.o1(),h);
	k=q.cD();
	n=A.oD(k);
	n=n==null?i:B.ci[n.a];
	n=n!==q.gbV().toLowerCase();
	if(n){b.l($.od(),A.a([s,"The declared mediatype does not match the embedded content."],t.M),h);
	k=i;}}else k=i;}else k=i;
	n=r;
	A.J(a,"name",b,i,i,i,!1);
	return new A.aU(p,o,n,k,A.t(a,B.aE,b,i),A.x(a,b),!1)},
	aU:function aU(a,b,c,d,e,f,g){var _=this;
	_.w=a;
	_.x=b;
	_.y=c;
	_.z=d;
	_.as=_.Q=null;
	_.a=e;
	_.b=f;
	_.a$=g;},
	uL(a,b){var s,r,q,p,o,n,m,l,k,j,i=null,h="alphaCutoff";
	A.w(a,B.cs,b);
	s=A.T(a,"pbrMetallicRoughness",b,A.xH(),!1);
	r=A.T(a,"normalTexture",b,A.pV(),!1);
	q=A.T(a,"occlusionTexture",b,A.xG(),!1);
	p=A.T(a,"emissiveTexture",b,A.ao(),!1);
	o=A.ae(a,"emissiveFactor",b,B.ak,B.l,1,0,!1);
	n=A.J(a,"alphaMode",b,"OPAQUE",B.cr,i,!1);
	A.E(a,h,b,0.5,1/0,-1/0,1/0,0,!1,0/0);
	if(n!=="MASK"&&a.v(h))b.n($.rO(),h);
	m=A.pO(a,"doubleSided",b);
	l=A.t(a,B.f,b,i);
	A.J(a,"name",b,i,i,i,!1);
	k=new A.ai(s,r,q,p,o,m,A.a9(t.X,t.e),l,A.x(a,b),!1);
	j=A.a([s,r,q,p],t.M);
	B.d.D(j,l.gX());
	b.W(k,j);
	return k},
	uX(a,b){var s,r,q,p,o;
	A.w(a,B.cG,b);
	A.ae(a,"baseColorFactor",b,B.al,B.P,1,0,!1);
	s=A.T(a,"baseColorTexture",b,A.ao(),!1);
	A.E(a,"metallicFactor",b,1,1/0,-1/0,1,0,!1,0/0);
	A.E(a,"roughnessFactor",b,1,1/0,-1/0,1,0,!1,0/0);
	r=A.T(a,"metallicRoughnessTexture",b,A.ao(),!1);
	q=A.t(a,B.ej,b,null);
	p=new A.cB(s,r,q,A.x(a,b),!1);
	o=A.a([s,r],t.M);
	B.d.D(o,q.gX());
	b.W(p,o);
	return p},
	uW(a,b){var s,r,q,p;
	A.w(a,B.cU,b);
	s=A.t(a,B.aI,b,B.f);
	r=A.W(a,"index",b,!0);
	q=A.a0(a,"texCoord",b,0,null,-1,0,!1);
	A.E(a,"strength",b,1,1/0,-1/0,1,0,!1,0/0);
	p=new A.cA(r,q,s,A.x(a,b),!1);
	b.W(p,s.gX());
	return p},
	uV(a,b){var s,r,q,p;
	A.w(a,B.cT,b);
	s=A.t(a,B.aH,b,B.f);
	r=A.W(a,"index",b,!0);
	q=A.a0(a,"texCoord",b,0,null,-1,0,!1);
	A.E(a,"scale",b,1,1/0,-1/0,1/0,-1/0,!1,0/0);
	p=new A.cz(r,q,s,A.x(a,b),!1);
	b.W(p,s.gX());
	return p},
	vb(a,b){var s,r;
	A.w(a,B.cS,b);
	s=A.t(a,B.aL,b,B.f);
	r=new A.bj(A.W(a,"index",b,!0),A.a0(a,"texCoord",b,0,null,-1,0,!1),s,A.x(a,b),!1);
	b.W(r,s.gX());
	return r},
	ai:function ai(a,b,c,d,e,f,g,h,i,j){var _=this;
	_.w=a;
	_.x=b;
	_.y=c;
	_.z=d;
	_.Q=e;
	_.ax=f;
	_.ay=!1;
	_.ch=g;
	_.a=h;
	_.b=i;
	_.a$=j;},
	jR:function jR(a,b){this.a=a;
	this.b=b;},
	cB:function cB(a,b,c,d,e){var _=this;
	_.e=a;
	_.w=b;
	_.a=c;
	_.b=d;
	_.a$=e;},
	cA:function cA(a,b,c,d,e){var _=this;
	_.d=a;
	_.e=b;
	_.f=null;
	_.a=c;
	_.b=d;
	_.a$=e;},
	cz:function cz(a,b,c,d,e){var _=this;
	_.d=a;
	_.e=b;
	_.f=null;
	_.a=c;
	_.b=d;
	_.a$=e;},
	bj:function bj(a,b,c,d,e){var _=this;
	_.d=a;
	_.e=b;
	_.f=null;
	_.a=c;
	_.b=d;
	_.a$=e;},
	dl(a){return new A.y(a.Q,a.y,a.as)},
	c2:function c2(a){this.a=a;},
	c1:function c1(a){this.a=a;},
	y:function y(a,b,c){this.a=a;
	this.b=b;
	this.c=c;},
	uP(a,b){var s,r,q,p,o,n,m,l,k,j,i=null,h="primitives";
	A.w(a,B.da,b);
	s=A.ae(a,"weights",b,i,i,1/0,-1/0,!1);
	r=A.eB(a,h,b);
	if(r!=null){q=r.gj(r);
	p=A.U(q,i,!1,t.ft);
	o=new A.F(p,q,h,t.b_);
	q=b.c;
	q.push(h);
	for(n=0,m=0;m<r.gj(r);++m){q.push(B.c.k(m));
	l=A.uO(r.i(0,m),b);
	k=l.w;
	j=k==null?i:k.length;
	if(j==null)j=0;
	if(m===0)n=j;
	else if(n!==j){k=$.rU();
	b.n(k,j>0?"targets":i);}p[m]=l;
	q.pop();}q.pop();
	if(s!=null&&n!==s.length)b.l($.rP(),A.a([s.length,n],t.M),"weights");}else o=i;
	A.J(a,"name",b,i,i,i,!1);
	return new A.aV(o,s,A.t(a,B.aG,b,i),A.x(a,b),!1)},
	uN(a,b,c,d,e,f,g,h,i,j,k,l,m,n){var s,r=J.oF(l,t.e);
	for(s=0;s<l;++s)r[s]=s;
	return new A.aE(a,b,c,d,e,g,h,j,k,l,A.a9(t.X,t.W),r,m,n,!1)},
	uO(a,b){var s,r,q,p,o,n,m,l,k="attributes",j={};
	A.w(a,B.cY,b);
	j.a=j.b=j.c=!1;
	j.d=0;
	j.e=-1;
	j.f=0;
	j.r=-1;
	j.w=0;
	j.x=-1;
	j.y=0;
	j.z=-1;
	s=new A.jV();
	r=A.a0(a,"mode",b,4,null,6,0,!1);
	q=A.x5(a,k,b,new A.jS(j,b,s));
	if(q!=null){p=b.c;
	p.push(k);
	if(!j.c)b.L($.rS());
	if(!j.b&&j.a)b.n($.rT(),"TANGENT");
	o=new A.jT(b);
	j.d=o.$3(j.e,j.d,"COLOR");
	j.f=o.$3(j.r,j.f,"JOINTS");
	j.w=o.$3(j.x,j.w,"WEIGHTS");
	j.y=o.$3(j.z,j.y,"TEXCOORD");
	o=j.f;
	n=j.w;
	if(o!==n){b.F($.rR(),A.a([o,n],t.M));
	j.w=j.f=0;}p.pop();}m=A.x6(a,"targets",b,new A.jU(s,b));
	l=A.uN(q,A.W(a,"indices",b,!1),A.W(a,"material",b,!1),r,m,j.c,j.b,j.a,j.d,j.f,j.w,j.y,A.t(a,B.aF,b,null),A.x(a,b));
	b.W(l,l.a.gX());
	return l},
	aV:function aV(a,b,c,d,e){var _=this;
	_.w=a;
	_.x=b;
	_.y=!1;
	_.a=c;
	_.b=d;
	_.a$=e;},
	k1:function k1(a,b){this.a=a;
	this.b=b;},
	k0:function k0(a,b){this.a=a;
	this.b=b;},
	aE:function aE(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o){var _=this;
	_.d=a;
	_.e=b;
	_.f=c;
	_.r=d;
	_.w=e;
	_.y=f;
	_.z=g;
	_.as=h;
	_.at=i;
	_.ax=j;
	_.ay=k;
	_.CW=_.ch=-1;
	_.db=_.cy=_.cx=null;
	_.dx=l;
	_.a=m;
	_.b=n;
	_.a$=o;},
	jV:function jV(){},
	jS:function jS(a,b,c){this.a=a;
	this.b=b;
	this.c=c;},
	jT:function jT(a){this.a=a;},
	jU:function jU(a,b){this.a=a;
	this.b=b;},
	jX:function jX(a,b,c){this.a=a;
	this.b=b;
	this.c=c;},
	jY:function jY(a,b){this.a=a;
	this.b=b;},
	jZ:function jZ(){},
	k_:function k_(a,b,c,d){var _=this;
	_.a=a;
	_.b=b;
	_.c=c;
	_.d=d;},
	jW:function jW(){},
	eU:function eU(a,b,c,d,e,f){var _=this;
	_.a=a;
	_.b=b;
	_.c=c;
	_.w=d;
	_.Q=_.z=0;
	_.as=e;
	_.at=f;},
	uU(b4,b5){var s,r,q,p,o,n,m,l,k,j,i,h,g,f,e,d,c,b,a,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,b0=null,b1="matrix",b2="translation",b3="rotation";
	A.w(b4,B.cj,b5);
	if(b4.v(b1)){s=A.ae(b4,b1,b5,b0,B.c6,1/0,-1/0,!1);
	if(s!=null){r=new Float32Array(16);
	q=new A.cZ(r);
	p=s[0];
	o=s[1];
	n=s[2];
	m=s[3];
	l=s[4];
	k=s[5];
	j=s[6];
	i=s[7];
	h=s[8];
	g=s[9];
	f=s[10];
	e=s[11];
	d=s[12];
	c=s[13];
	b=s[14];
	r[15]=s[15];
	r[14]=b;
	r[13]=c;
	r[12]=d;
	r[11]=e;
	r[10]=f;
	r[9]=g;
	r[8]=h;
	r[7]=i;
	r[6]=j;
	r[5]=k;
	r[4]=l;
	r[3]=m;
	r[2]=n;
	r[1]=o;
	r[0]=p;}else q=b0;}else q=b0;
	if(b4.v(b2)){a=A.ae(b4,b2,b5,b0,B.l,1/0,-1/0,!1);
	a0=a!=null?A.pb(a):b0;}else a0=b0;
	if(b4.v(b3)){a1=A.ae(b4,b3,b5,b0,B.P,1,-1,!1);
	if(a1!=null){r=a1[0];
	p=a1[1];
	o=a1[2];
	n=a1[3];
	m=new Float32Array(4);
	a2=new A.fl(m);
	m[0]=r;
	m[1]=p;
	m[2]=o;
	m[3]=n;
	r=Math.sqrt(a2.gaW());
	if(Math.abs(1-r)>0.00769)b5.n($.t5(),b3);}else a2=b0;}else a2=b0;
	if(b4.v("scale")){a3=A.ae(b4,"scale",b5,b0,B.l,1/0,-1/0,!1);
	a4=a3!=null?A.pb(a3):b0;}else a4=b0;
	a5=A.W(b4,"camera",b5,!1);
	a6=A.mR(b4,"children",b5,!1);
	a7=A.W(b4,"mesh",b5,!1);
	a8=A.W(b4,"skin",b5,!1);
	a9=A.ae(b4,"weights",b5,b0,b0,1/0,-1/0,!1);
	if(a7===-1){if(a8!==-1)b5.l($.cO(),A.a(["mesh"],t.M),"skin");
	if(a9!=null)b5.l($.cO(),A.a(["mesh"],t.M),"weights");}if(q!=null){if(a0!=null||a2!=null||a4!=null)b5.n($.rZ(),b1);
	if(q.cP())b5.n($.rX(),b1);
	else if(!A.xi(q))b5.n($.t_(),b1);}A.J(b4,"name",b5,b0,b0,b0,!1);
	return new A.ap(a5,a6,a8,q,a7,a0,a2,a4,a9,A.aD(t.bn),A.t(b4,B.V,b5,b0),A.x(b4,b5),!1)},
	ap:function ap(a,b,c,d,e,f,g,h,i,j,k,l,m){var _=this;
	_.w=a;
	_.x=b;
	_.y=c;
	_.z=d;
	_.Q=e;
	_.as=f;
	_.at=g;
	_.ax=h;
	_.ay=i;
	_.ch=j;
	_.dx=_.db=_.cy=_.cx=_.CW=null;
	_.dy=!1;
	_.a=k;
	_.b=l;
	_.a$=m;},
	k3:function k3(){},
	k4:function k4(){},
	k5:function k5(a,b){this.a=a;
	this.b=b;},
	v6(a,b){var s=null;
	A.w(a,B.dc,b);
	A.a0(a,"magFilter",b,-1,B.cg,-1,0,!1);
	A.a0(a,"minFilter",b,-1,B.ck,-1,0,!1);
	A.a0(a,"wrapS",b,10497,B.ao,-1,0,!1);
	A.a0(a,"wrapT",b,10497,B.ao,-1,0,!1);
	A.J(a,"name",b,s,s,s,!1);
	return new A.bF(A.t(a,B.ek,b,s),A.x(a,b),!1)},
	bF:function bF(a,b,c){this.a=a;
	this.b=b;
	this.a$=c;},
	v7(a,b){var s,r=null;
	A.w(a,B.d4,b);
	s=A.mR(a,"nodes",b,!1);
	A.J(a,"name",b,r,r,r,!1);
	return new A.bG(s,A.t(a,B.aJ,b,r),A.x(a,b),!1)},
	bG:function bG(a,b,c,d){var _=this;
	_.w=a;
	_.x=null;
	_.a=b;
	_.b=c;
	_.a$=d;},
	ke:function ke(a,b){this.a=a;
	this.b=b;},
	v8(a,b){var s,r,q,p=null;
	A.w(a,B.cw,b);
	s=A.W(a,"inverseBindMatrices",b,!1);
	r=A.W(a,"skeleton",b,!1);
	q=A.mR(a,"joints",b,!0);
	A.J(a,"name",b,p,p,p,!1);
	return new A.bI(s,r,q,A.aD(t.L),A.t(a,B.aK,b,p),A.x(a,b),!1)},
	bI:function bI(a,b,c,d,e,f,g){var _=this;
	_.w=a;
	_.x=b;
	_.y=c;
	_.as=_.Q=_.z=null;
	_.at=d;
	_.a=e;
	_.b=f;
	_.a$=g;},
	lm:function lm(a){this.a=a;},
	eT:function eT(a){this.a=a;},
	vc(a,b){var s,r,q=null;
	A.w(a,B.de,b);
	s=A.W(a,"sampler",b,!1);
	r=A.W(a,"source",b,!1);
	A.J(a,"name",b,q,q,q,!1);
	return new A.bK(s,r,A.t(a,B.W,b,q),A.x(a,b),!1)},
	bK:function bK(a,b,c,d,e){var _=this;
	_.w=a;
	_.x=b;
	_.z=_.y=null;
	_.a=c;
	_.b=d;
	_.a$=e;},
	p9(a,b,c,d){var s,r=t.X,q=A.aD(r);
	r=A.aD(r);
	s=b==null?0:b;
	if(a!=null)q.D(0,a);
	if(c!=null)r.D(0,c);
	return new A.lE(s,q,r,d)},
	u4(){return new A.ab(B.au,new A.hh(),t.gw)},
	u3(a){var s,r,q,p,o=null,n=t.i,m=A.a([],n),l=t._,k=A.a([],t.d6),j=A.a9(t.al,t.f9),i=A.a([],n),h=A.a([],n),g=A.a([],t.fh),f=A.a([],t.a9);
	n=A.a(["image/jpeg","image/png"],n);
	s=t.aD;
	r=t.X;
	q=t.cn;
	p=A.nu(["POSITION",A.aP([B.k],s),"NORMAL",A.aP([B.k],s),"TANGENT",A.aP([B.n],s),"TEXCOORD",A.aP([B.a4,B.a0,B.a3],s),"COLOR",A.aP([B.k,B.H,B.I,B.n,B.y,B.z],s),"JOINTS",A.aP([B.b_,B.b0],s),"WEIGHTS",A.aP([B.n,B.y,B.z],s)],r,q);
	q=A.nu(["POSITION",A.aP([B.k],s),"NORMAL",A.aP([B.k],s),"TANGENT",A.aP([B.k],s),"TEXCOORD",A.aP([B.a4,B.a_,B.a0,B.a2,B.a3],s),"COLOR",A.aP([B.k,B.w,B.H,B.x,B.I,B.n,B.J,B.y,B.K,B.z],s)],r,q);
	r=A.bc(B.R,!0,r);
	s=a==null?A.p9(o,o,o,o):a;
	r=new A.i(s,m,A.a9(t.W,t.b7),A.a9(l,l),A.a9(t.f7,t.an),k,A.a9(t.r,t.gz),A.a9(t.b5,t.eG),j,i,h,g,A.aD(t.af),f,new A.ac(""),n,p,q,r);
	q=t.em;
	r.ay=new A.aX(h,q);
	r.at=new A.aX(i,q);
	r.Q=new A.bm(j,t.f8);
	r.CW=new A.aX(g,t.go);
	return r},
	lE:function lE(a,b,c,d){var _=this;
	_.a=a;
	_.b=b;
	_.c=c;
	_.d=d;},
	i:function i(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s){var _=this;
	_.b=a;
	_.c=b;
	_.d=c;
	_.e=d;
	_.f=e;
	_.r=f;
	_.w=g;
	_.x=h;
	_.y=!1;
	_.z=i;
	_.Q=null;
	_.as=j;
	_.at=null;
	_.ax=k;
	_.ay=null;
	_.ch=l;
	_.CW=null;
	_.cx=m;
	_.cy=n;
	_.db=o;
	_.dx=!1;
	_.dy=p;
	_.fr=q;
	_.fx=r;
	_.fy=s;},
	hh:function hh(){},
	hg:function hg(){},
	hi:function hi(){},
	hl:function hl(a){this.a=a;},
	hm:function hm(a){this.a=a;},
	hj:function hj(a){this.a=a;},
	hk:function hk(){},
	hn:function hn(a,b){this.a=a;
	this.b=b;},
	bA:function bA(){},
	uf(a){var s,r,q={};
	q.a=q.b=null;
	s=new A.C($.B,t.dD);
	r=new A.ay(s,t.eP);
	q.c=!1;
	q.a=a.bT(new A.iC(q,r),new A.iD(q),new A.iE(q,r));
	return s},
	oD(a){var s,r;
	if(a.length<14)return null
	s=A.f7(a.buffer,a.byteOffset,14);
	r=s.getUint32(0,!0);
	if((r&16777215)===16767231)return B.ag
	if(r===1196314761&&s.getUint32(4,!0)===169478669)return B.ah
	if(r===1179011410&&s.getUint32(8,!0)===1346520407&&s.getUint16(12,!0)===20566)return B.ai
	if(r===1481919403&&s.getUint32(4,!0)===3140497952&&s.getUint32(8,!0)===169478669)return B.bV
	return null},
	cU:function cU(a,b){this.a=a;
	this.b=b;},
	dV:function dV(a,b){this.a=a;
	this.b=b;},
	d5:function d5(a,b){this.a=a;
	this.b=b;},
	cc:function cc(a,b){this.a=a;
	this.b=b;},
	cd:function cd(a,b,c,d,e,f,g,h,i){var _=this;
	_.a=a;
	_.b=b;
	_.c=c;
	_.d=d;
	_.e=e;
	_.f=f;
	_.r=g;
	_.w=h;
	_.x=i;},
	iC:function iC(a,b){this.a=a;
	this.b=b;},
	iE:function iE(a,b){this.a=a;
	this.b=b;},
	iD:function iD(a){this.a=a;},
	iB:function iB(){},
	iM:function iM(a,b){var _=this;
	_.f=_.e=_.d=_.c=0;
	_.r=null;
	_.a=a;
	_.b=b;},
	iO:function iO(){},
	iN:function iN(){},
	k7:function k7(a,b,c,d,e,f){var _=this;
	_.x=_.w=_.r=_.f=_.e=_.d=_.c=0;
	_.z=_.y=!1;
	_.Q=a;
	_.as=b;
	_.at=!1;
	_.ax=c;
	_.ay=d;
	_.a=e;
	_.b=f;},
	k8:function k8(a){this.a=a;},
	lJ:function lJ(a,b,c){var _=this;
	_.c=a;
	_.d=0;
	_.a=b;
	_.b=c;},
	dS:function dS(){},
	dR:function dR(){},
	aL:function aL(a){this.a=a;},
	d9:function d9(a,b){this.a=a;
	this.b=b;},
	fn:function fn(a){var _=this;
	_.a=a;
	_.f=_.e=_.d=_.c=_.b=null;},
	kb:function kb(a,b,c,d){var _=this;
	_.a=a;
	_.b=b;
	_.c=c;
	_.d=d;},
	kc:function kc(a,b,c){this.a=a;
	this.b=b;
	this.c=c;},
	kd:function kd(a,b){this.a=a;
	this.b=b;},
	mJ(a){if(a==null)return null
	if(a.Q==null||a.y===-1||a.z===-1)return null
	if(a.CW==null&&a.ay==null)return null
	return a},
	xS(a0,a1){var s,r,q,p,o,n,m,l,k,j,i,h,g,f,e,d,c,b,a;
	a0.f.a4(new A.ne(a1));
	A.wx(a1);
	s=A.a([],t.b2);
	r=A.a([],t.bd);
	q=a1.c;
	B.d.P(q);
	q.push("meshes");
	for(p=a0.at,o=p.b,n=a0.ax,m=n.$ti.h("aa<p.E>"),l=a0.cx,p=p.a,k=p.length,j=0;j<o;++j){i={};
	h=j>=k;
	g=h?null:p[j];
	if((g==null?null:g.w)==null)continue
	h=g.w;
	if(h.be(h,new A.nf()))continue
	i.a=i.b=-1;
	for(f=new A.aa(n,n.gj(n),m);f.q();){e=f.d;
	if(e.cy==g){d=e.dx;
	d=(d==null?null:d.Q)!=null;}else d=!1;
	if(d){e=e.dx;
	c=e.Q.length;
	d=i.b;
	if(d===-1||c<d){i.b=c;
	i.a=l.bR(l,e);}}}if(i.b<1)continue
	q.push(B.c.k(j));
	q.push("primitives");
	h.a4(new A.ng(i,a1,s,r));
	q.pop();
	q.pop();}q.pop();
	if(s.length===0)return
	for(;A.wD(s);)for(q=r.length,b=0;b<r.length;r.length===q||(0, A.cN)(r),++b){a=r[b];
	if(!a.w)a.dY(a1);}},
	wD(a){var s,r;
	for(s=a.length,r=0;r<a.length;a.length===s||(0, A.cN)(a),++r)a[r].q();
	if(!!a.fixed$length)A.Z(A.ad("removeWhere"));
	B.d.dP(a,new A.mL(),!0);
	return a.length!==0},
	wx(a){var s,r,q,p,o,n,m,l,k,j,i,h;
	for(s=a.d.ge4(),s=s.gH(s),r=a.c;s.q();){q=s.gt();
	p=A.mJ(q.a);
	if(p==null)continue
	o=B.m.i(0,p.Q);
	if(o==null)o=0;
	n=q.b;
	B.d.P(r);
	for(q=p.af(),q=new A.aH(q.a(),A.A(q).h("aH<1>")),m=J.V(n),l=0,k=0,j=!1;q.q();j=!0){i=q.gt();
	for(h=0;h<m.gj(n);++h)m.i(n,h).a0(a,l,k,i);++k;
	if(k===o)k=0;++l;}if(j)for(h=0;h<m.gj(n);++h)m.i(n,h).aF(a);}},
	ne:function ne(a){this.a=a;},
	nf:function nf(){},
	ng:function ng(a,b,c,d){var _=this;
	_.a=a;
	_.b=b;
	_.c=c;
	_.d=d;},
	mL:function mL(){},
	eX:function eX(a,b,c,d,e,f){var _=this;
	_.a=a;
	_.b=b;
	_.c=c;
	_.d=d;
	_.e=e;
	_.r=_.f=0;
	_.w=!1;
	_.y=_.x=0;
	_.z=f;},
	G(a,b,c){return new A.ho(c,a,b)},
	am(a,b,c){return new A.kf(c,a,b)},
	r(a,b,c){return new A.kw(c,a,b)},
	v(a,b,c){return new A.iY(c,a,b)},
	al(a,b,c){return new A.hZ(c,a,b)},
	wy(a){return "'"+A.b(a)+"'"},
	wu(a){return typeof a=="string"?"'"+a+"'":J.as(a)},
	bH:function bH(a,b){this.a=a;
	this.b=b;},
	iH:function iH(){},
	ho:function ho(a,b,c){this.a=a;
	this.b=b;
	this.c=c;},
	hL:function hL(){},
	hM:function hM(){},
	hE:function hE(){},
	hD:function hD(){},
	ht:function ht(){},
	hs:function hs(){},
	hI:function hI(){},
	hz:function hz(){},
	hr:function hr(){},
	hF:function hF(){},
	hx:function hx(){},
	hu:function hu(){},
	hw:function hw(){},
	hv:function hv(){},
	hp:function hp(){},
	hq:function hq(){},
	hH:function hH(){},
	hG:function hG(){},
	hy:function hy(){},
	hO:function hO(){},
	hQ:function hQ(){},
	hT:function hT(){},
	hU:function hU(){},
	hR:function hR(){},
	hS:function hS(){},
	hP:function hP(){},
	hV:function hV(){},
	hN:function hN(){},
	hB:function hB(){},
	hA:function hA(){},
	hJ:function hJ(){},
	hK:function hK(){},
	hC:function hC(){},
	iF:function iF(a,b,c){this.a=a;
	this.b=b;
	this.c=c;},
	iG:function iG(){},
	kf:function kf(a,b,c){this.a=a;
	this.b=b;
	this.c=c;},
	kh:function kh(){},
	ki:function ki(){},
	kg:function kg(){},
	kk:function kk(){},
	kl:function kl(){},
	km:function km(){},
	kj:function kj(){},
	kn:function kn(){},
	ko:function ko(){},
	kp:function kp(){},
	ku:function ku(){},
	kv:function kv(){},
	kt:function kt(){},
	kq:function kq(){},
	kr:function kr(){},
	ks:function ks(){},
	kw:function kw(a,b,c){this.a=a;
	this.b=b;
	this.c=c;},
	lj:function lj(){},
	lk:function lk(){},
	l4:function l4(){},
	kL:function kL(){},
	ky:function ky(){},
	kz:function kz(){},
	kx:function kx(){},
	kA:function kA(){},
	kB:function kB(){},
	kC:function kC(){},
	kE:function kE(){},
	kD:function kD(){},
	kF:function kF(){},
	kG:function kG(){},
	kH:function kH(){},
	kI:function kI(){},
	kX:function kX(){},
	l_:function l_(){},
	l3:function l3(){},
	l1:function l1(){},
	kZ:function kZ(){},
	l2:function l2(){},
	l0:function l0(){},
	kY:function kY(){},
	l8:function l8(){},
	l6:function l6(){},
	l9:function l9(){},
	lg:function lg(){},
	ll:function ll(){},
	lf:function lf(){},
	kK:function kK(){},
	l7:function l7(){},
	lc:function lc(){},
	lb:function lb(){},
	la:function la(){},
	lh:function lh(){},
	li:function li(){},
	le:function le(){},
	l5:function l5(){},
	ld:function ld(){},
	kJ:function kJ(){},
	kM:function kM(){},
	kN:function kN(){},
	kO:function kO(){},
	kP:function kP(){},
	kQ:function kQ(){},
	kR:function kR(){},
	kS:function kS(){},
	kW:function kW(){},
	kV:function kV(){},
	kT:function kT(){},
	kU:function kU(){},
	iY:function iY(a,b,c){this.a=a;
	this.b=b;
	this.c=c;},
	j0:function j0(){},
	iZ:function iZ(){},
	j_:function j_(){},
	j1:function j1(){},
	j4:function j4(){},
	j2:function j2(){},
	j3:function j3(){},
	j8:function j8(){},
	j6:function j6(){},
	ja:function ja(){},
	j7:function j7(){},
	j9:function j9(){},
	j5:function j5(){},
	jb:function jb(){},
	je:function je(){},
	jd:function jd(){},
	jc:function jc(){},
	jf:function jf(){},
	jg:function jg(){},
	jh:function jh(){},
	jl:function jl(){},
	jm:function jm(){},
	ju:function ju(){},
	jk:function jk(){},
	jj:function jj(){},
	jq:function jq(){},
	jp:function jp(){},
	jo:function jo(){},
	jv:function jv(){},
	jt:function jt(){},
	jn:function jn(){},
	jw:function jw(){},
	js:function js(){},
	jr:function jr(){},
	jx:function jx(){},
	jy:function jy(){},
	jB:function jB(){},
	jz:function jz(){},
	jA:function jA(){},
	jC:function jC(){},
	jE:function jE(){},
	jD:function jD(){},
	jF:function jF(){},
	jG:function jG(){},
	jH:function jH(){},
	jI:function jI(){},
	jJ:function jJ(){},
	jM:function jM(){},
	jL:function jL(){},
	jK:function jK(){},
	ji:function ji(){},
	hZ:function hZ(a,b,c){this.a=a;
	this.b=b;
	this.c=c;},
	i5:function i5(){},
	i6:function i6(){},
	i8:function i8(){},
	i_:function i_(){},
	i7:function i7(){},
	i0:function i0(){},
	i3:function i3(){},
	i2:function i2(){},
	i1:function i1(){},
	ib:function ib(){},
	ia:function ia(){},
	ic:function ic(){},
	id:function id(){},
	i9:function i9(){},
	ie:function ie(){},
	i4:function i4(){},
	cW:function cW(a,b,c,d,e){var _=this;
	_.a=a;
	_.b=b;
	_.c=c;
	_.d=d;
	_.e=e;},
	we(a){a.dy.push("image/webp");},
	ua(a,b){b.toString;
	A.w(a,B.df,b);
	return new A.ca(A.W(a,"source",b,!1),A.t(a,B.dY,b,null),A.x(a,b),!1)},
	ca:function ca(a,b,c,d){var _=this;
	_.d=a;
	_.e=null;
	_.a=b;
	_.b=c;
	_.a$=d;},
	un(a,b){b.toString;
	A.w(a,B.d9,b);
	A.J(a,"pointer",b,null,null,$.qK(),!0);
	return new A.cf(A.t(a,B.dZ,b,null),A.x(a,b),!1)},
	wf(a){a.fy.push("pointer");},
	cf:function cf(a,b,c){this.a=a;
	this.b=b;
	this.a$=c;},
	uo(a,b){var s,r,q,p,o,n,m,l,k,j,i,h=null,g="lights",f="spot";
	b.toString;
	A.w(a,B.d0,b);
	s=A.eB(a,g,b);
	r=t.cp;
	if(s!=null){q=s.gj(s);
	r=A.U(q,h,!1,r);
	p=new A.F(r,q,g,t.E);
	q=b.c;
	q.push(g);
	for(o=t.h,n=0;n<s.gj(s);++n){m=s.i(0,n);
	q.push(B.c.k(n));
	A.w(m,B.co,b);
	A.ae(m,"color",b,B.C,B.l,1,0,!1);
	A.E(m,"intensity",b,1,1/0,-1/0,1/0,0,!1,0/0);
	l=A.J(m,"type",b,h,B.cJ,h,!0);
	if(l==="spot")A.T(m,f,b,A.xm(),!0);
	else {k=m.v(f);
	if(k)b.n($.oi(),f);}j=A.E(m,"range",b,0/0,1/0,0,1/0,-1/0,!1,0/0);
	if(l==="directional"&&!isNaN(j))b.n($.oi(),"range");
	A.J(m,"name",b,h,h,h,!1);
	k=A.t(m,B.e1,b,h);
	i=m.i(0,"extras");
	if(i!=null&&!o.b(i))b.n($.dk(),"extras");
	r[n]=new A.ba(k,i,!1);
	q.pop();}q.pop();}else {r=J.b8(0,r);
	p=new A.F(r,0,g,t.E);}return new A.bC(p,A.t(a,B.e_,b,h),A.x(a,b),!1)},
	up(a,b){var s,r,q="outerConeAngle";
	A.w(a,B.cV,b);
	s=A.E(a,"innerConeAngle",b,0,1.5707963267948966,-1/0,1/0,0,!1,0/0);
	r=A.E(a,q,b,0.7853981633974483,1/0,0,1.5707963267948966,-1/0,!1,0/0);
	if(r<=s)b.l($.rF(),A.a([s,r],t.M),q);
	return new A.cg(A.t(a,B.e0,b,null),A.x(a,b),!1)},
	uq(a,b){b.toString;
	A.w(a,B.d_,b);
	return new A.ch(A.W(a,"light",b,!0),A.t(a,B.e2,b,null),A.x(a,b),!1)},
	bC:function bC(a,b,c,d){var _=this;
	_.d=a;
	_.a=b;
	_.b=c;
	_.a$=d;},
	iS:function iS(a,b){this.a=a;
	this.b=b;},
	ba:function ba(a,b,c){this.a=a;
	this.b=b;
	this.a$=c;},
	cg:function cg(a,b,c){this.a=a;
	this.b=b;
	this.a$=c;},
	ch:function ch(a,b,c,d){var _=this;
	_.d=a;
	_.e=null;
	_.a=b;
	_.b=c;
	_.a$=d;},
	ur(a,b){var s,r,q,p;
	b.toString;
	A.w(a,B.cv,b);
	A.E(a,"anisotropyStrength",b,0,1/0,-1/0,1,0,!1,0/0);
	A.E(a,"anisotropyRotation",b,0,1/0,-1/0,1/0,-1/0,!1,0/0);
	s=A.T(a,"anisotropyTexture",b,A.ao(),!1);
	r=A.t(a,B.e3,b,null);
	q=new A.ci(s,r,A.x(a,b),!1);
	p=A.a([s],t.M);
	B.d.D(p,r.gX());
	b.W(q,p);
	return q},
	ci:function ci(a,b,c,d){var _=this;
	_.f=a;
	_.a=b;
	_.b=c;
	_.a$=d;},
	us(a,b){var s,r,q,p,o,n;
	b.toString;
	A.w(a,B.ca,b);
	A.E(a,"clearcoatFactor",b,0,1/0,-1/0,1,0,!1,0/0);
	s=A.T(a,"clearcoatTexture",b,A.ao(),!1);
	A.E(a,"clearcoatRoughnessFactor",b,0,1/0,-1/0,1,0,!1,0/0);
	r=A.T(a,"clearcoatRoughnessTexture",b,A.ao(),!1);
	q=A.T(a,"clearcoatNormalTexture",b,A.pV(),!1);
	p=A.t(a,B.e4,b,null);
	o=new A.cj(s,r,q,p,A.x(a,b),!1);
	n=A.a([s,r,q],t.M);
	B.d.D(n,p.gX());
	b.W(o,n);
	return o},
	cj:function cj(a,b,c,d,e,f){var _=this;
	_.e=a;
	_.r=b;
	_.w=c;
	_.a=d;
	_.b=e;
	_.a$=f;},
	ut(a,b){b.toString;
	A.w(a,B.cK,b);
	A.E(a,"dispersion",b,0,1/0,-1/0,1/0,0,!1,0/0);
	return new A.ck(A.t(a,B.e5,b,null),A.x(a,b),!1)},
	ck:function ck(a,b,c){this.a=a;
	this.b=b;
	this.a$=c;},
	uu(a,b){b.toString;
	A.w(a,B.cL,b);
	return new A.cl(A.E(a,"emissiveStrength",b,1,1/0,-1/0,1/0,0,!1,0/0),A.t(a,B.e6,b,null),A.x(a,b),!1)},
	cl:function cl(a,b,c,d){var _=this;
	_.d=a;
	_.a=b;
	_.b=c;
	_.a$=d;},
	uv(a,b){b.toString;
	A.w(a,B.cX,b);
	A.E(a,"ior",b,1.5,1/0,-1/0,1/0,1,!1,0);
	return new A.cm(A.t(a,B.e7,b,null),A.x(a,b),!1)},
	cm:function cm(a,b,c){this.a=a;
	this.b=b;
	this.a$=c;},
	uw(a,b){var s,r,q,p,o,n,m,l="iridescenceThicknessMinimum",k="iridescenceThicknessTexture";
	b.toString;
	A.w(a,B.dg,b);
	A.E(a,"iridescenceFactor",b,0,1/0,-1/0,1,0,!1,0/0);
	s=A.T(a,"iridescenceTexture",b,A.ao(),!1);
	A.E(a,"iridescenceIor",b,1.3,1/0,-1/0,1/0,1,!1,0/0);
	r=A.E(a,l,b,100,1/0,-1/0,1/0,0,!1,0/0);
	q=A.E(a,"iridescenceThicknessMaximum",b,400,1/0,-1/0,1/0,0,!1,0/0);
	p=A.T(a,k,b,A.ao(),!1);
	if(p!=null){if(r===q)b.n($.rL(),k);}else if(!isNaN(r)&&a.v(l))b.n($.rK(),l);
	o=A.t(a,B.e8,b,null);
	n=new A.cn(s,p,o,A.x(a,b),!1);
	m=A.a([s,p],t.M);
	B.d.D(m,o.gX());
	b.W(n,m);
	return n},
	cn:function cn(a,b,c,d,e){var _=this;
	_.e=a;
	_.x=b;
	_.a=c;
	_.b=d;
	_.a$=e;},
	ux(a,b){var s,r,q,p,o;
	b.toString;
	A.w(a,B.cI,b);
	A.ae(a,"diffuseFactor",b,B.al,B.P,1,0,!1);
	s=A.T(a,"diffuseTexture",b,A.ao(),!1);
	A.ae(a,"specularFactor",b,B.C,B.l,1,0,!1);
	A.E(a,"glossinessFactor",b,1,1/0,-1/0,1,0,!1,0/0);
	r=A.T(a,"specularGlossinessTexture",b,A.ao(),!1);
	q=A.t(a,B.dX,b,null);
	p=new A.co(s,r,q,A.x(a,b),!1);
	o=A.a([s,r],t.M);
	B.d.D(o,q.gX());
	b.W(p,o);
	return p},
	co:function co(a,b,c,d,e){var _=this;
	_.e=a;
	_.w=b;
	_.a=c;
	_.b=d;
	_.a$=e;},
	uy(a,b){var s,r,q,p,o;
	b.toString;
	A.w(a,B.c9,b);
	A.ae(a,"sheenColorFactor",b,B.ak,B.l,1,0,!1);
	s=A.T(a,"sheenColorTexture",b,A.ao(),!1);
	A.E(a,"sheenRoughnessFactor",b,0,1/0,-1/0,1,0,!1,0/0);
	r=A.T(a,"sheenRoughnessTexture",b,A.ao(),!1);
	q=A.t(a,B.e9,b,null);
	p=new A.cp(s,r,q,A.x(a,b),!1);
	o=A.a([s,r],t.M);
	B.d.D(o,q.gX());
	b.W(p,o);
	return p},
	cp:function cp(a,b,c,d,e){var _=this;
	_.e=a;
	_.r=b;
	_.a=c;
	_.b=d;
	_.a$=e;},
	uz(a,b){var s,r,q,p,o;
	b.toString;
	A.w(a,B.cc,b);
	A.E(a,"specularFactor",b,1,1/0,-1/0,1,0,!1,0/0);
	s=A.T(a,"specularTexture",b,A.ao(),!1);
	A.ae(a,"specularColorFactor",b,B.C,B.l,1/0,0,!1);
	r=A.T(a,"specularColorTexture",b,A.ao(),!1);
	q=A.t(a,B.ea,b,null);
	p=new A.cq(s,r,q,A.x(a,b),!1);
	o=A.a([s,r],t.M);
	B.d.D(o,q.gX());
	b.W(p,o);
	return p},
	cq:function cq(a,b,c,d,e){var _=this;
	_.e=a;
	_.r=b;
	_.a=c;
	_.b=d;
	_.a$=e;},
	uA(a,b){var s,r,q,p;
	b.toString;
	A.w(a,B.cf,b);
	A.E(a,"transmissionFactor",b,0,1/0,-1/0,1,0,!1,0/0);
	s=A.T(a,"transmissionTexture",b,A.ao(),!1);
	r=A.t(a,B.eb,b,null);
	q=new A.cr(s,r,A.x(a,b),!1);
	p=A.a([s],t.M);
	B.d.D(p,r.gX());
	b.W(q,p);
	return q},
	cr:function cr(a,b,c,d){var _=this;
	_.e=a;
	_.a=b;
	_.b=c;
	_.a$=d;},
	uB(a,b){b.toString;
	A.w(a,B.cM,b);
	return new A.cs(A.t(a,B.ec,b,null),A.x(a,b),!1)},
	cs:function cs(a,b,c){this.a=a;
	this.b=b;
	this.a$=c;},
	uC(a,b){var s,r,q,p,o,n,m,l,k,j=null,i="variants";
	b.toString;
	A.w(a,B.dl,b);
	s=A.eB(a,i,b);
	r=t.J;
	if(s!=null){q=s.gj(s);
	r=A.U(q,j,!1,r);
	p=new A.F(r,q,i,t.u);
	q=b.c;
	q.push(i);
	for(o=t.h,n=0;n<s.gj(s);++n){m=s.i(0,n);
	q.push(B.c.k(n));
	A.w(m,B.d2,b);
	A.J(m,"name",b,j,j,j,!0);
	l=A.t(m,B.ef,b,j);
	k=m.i(0,"extras");
	if(k!=null&&!o.b(k))b.n($.dk(),"extras");
	r[n]=new A.aM(l,k,!1);
	q.pop();}q.pop();}else {r=J.b8(0,r);
	p=new A.F(r,0,i,t.u);}return new A.bD(p,A.t(a,B.ed,b,j),A.x(a,b),!1)},
	uD(a,b){var s,r,q,p,o,n,m,l,k,j,i,h,g=null,f="mappings";
	b.toString;
	A.w(a,B.d1,b);
	s=A.eB(a,f,b);
	r=t.aa;
	if(s!=null){q=s.gj(s);
	r=A.U(q,g,!1,r);
	p=new A.F(r,q,f,t.B);
	q=b.c;
	q.push(f);
	for(o=t.h,n=0;n<s.gj(s);++n){m=s.i(0,n);
	q.push(B.c.k(n));
	A.w(m,B.dm,b);
	l=A.mR(m,"variants",b,!0);
	k=A.W(m,"material",b,!0);
	A.J(m,"name",b,g,g,g,!1);
	j=A.t(m,B.ee,b,g);
	i=m.i(0,"extras");
	if(i!=null&&!o.b(i))b.n($.dk(),"extras");
	r[n]=new A.bb(l,k,j,i,!1);
	q.pop();}q.pop();}else {r=J.b8(0,r);
	p=new A.F(r,0,f,t.B);}h=new A.ct(p,A.t(a,B.el,b,g),A.x(a,b),!1);
	b.W(h,A.bc(p,!0,t._));
	return h},
	bD:function bD(a,b,c,d){var _=this;
	_.d=a;
	_.a=b;
	_.b=c;
	_.a$=d;},
	iT:function iT(a,b){this.a=a;
	this.b=b;},
	aM:function aM(a,b,c){this.a=a;
	this.b=b;
	this.a$=c;},
	ct:function ct(a,b,c,d){var _=this;
	_.d=a;
	_.a=b;
	_.b=c;
	_.a$=d;},
	iW:function iW(a,b,c){this.a=a;
	this.b=b;
	this.c=c;},
	bb:function bb(a,b,c,d,e){var _=this;
	_.d=a;
	_.e=b;
	_.r=null;
	_.a=c;
	_.b=d;
	_.a$=e;},
	iU:function iU(a,b,c,d){var _=this;
	_.a=a;
	_.b=b;
	_.c=c;
	_.d=d;},
	iV:function iV(a,b){this.a=a;
	this.b=b;},
	uE(a,b){var s,r,q,p,o;
	b.toString;
	A.w(a,B.dp,b);
	A.ae(a,"attenuationColor",b,B.C,B.l,1,0,!1);
	A.E(a,"attenuationDistance",b,0/0,1/0,0,1/0,-1/0,!1,0/0);
	s=A.E(a,"thicknessFactor",b,0,1/0,-1/0,1/0,0,!1,0/0);
	r=A.T(a,"thicknessTexture",b,A.ao(),!1);
	q=A.t(a,B.eg,b,null);
	p=new A.cu(s,r,q,A.x(a,b),!1);
	o=A.a([r],t.M);
	B.d.D(o,q.gX());
	b.W(p,o);
	return p},
	cu:function cu(a,b,c,d,e){var _=this;
	_.f=a;
	_.r=b;
	_.a=c;
	_.b=d;
	_.a$=e;},
	iX:function iX(){},
	uF(a,b){b.toString;
	A.w(a,B.d8,b);
	A.ae(a,"offset",b,B.c5,B.am,1/0,-1/0,!1);
	A.E(a,"rotation",b,0,1/0,-1/0,1/0,-1/0,!1,0/0);
	A.ae(a,"scale",b,B.c7,B.am,1/0,-1/0,!1);
	return new A.cv(A.a0(a,"texCoord",b,-1,null,-1,0,!1),A.t(a,B.eh,b,null),A.x(a,b),!1)},
	cv:function cv(a,b,c,d){var _=this;
	_.r=a;
	_.a=b;
	_.b=c;
	_.a$=d;},
	L:function L(a,b,c,d){var _=this;
	_.a=a;
	_.b=b;
	_.c=c;
	_.d=d;},
	O:function O(a,b,c){this.a=a;
	this.b=b;
	this.c=c;},
	cb:function cb(a,b){this.a=a;
	this.b=b;},
	cw:function cw(a,b){this.a=a;
	this.b=b;},
	fo:function fo(a,b){this.a=a;
	this.b=b;},
	oA(a,b){var s=null,r=new Uint8Array(12),q=new A.dt(r,a,new A.ay(new A.C($.B,t.f),t.G));
	b.dx=!0;
	q.f=b;
	q.b=A.f7(r.buffer,0,s);
	q.ch=A.p1(s,s,s,t.w);
	return q},
	dt:function dt(a,b,c){var _=this;
	_.a=a;
	_.b=null;
	_.c=b;
	_.d=null;
	_.e=c;
	_.f=null;
	_.as=_.Q=_.z=_.y=_.x=_.w=_.r=0;
	_.at=!1;
	_.ch=_.ay=_.ax=null;
	_.CW=!1;
	_.cx=null;},
	ii:function ii(a){this.a=a;},
	ij:function ij(a){this.a=a;},
	ig:function ig(a){this.a=a;},
	ih:function ih(a){this.a=a;},
	ue(a,b){var s,r={},q=new A.C($.B,t.eD);
	r.a=!1;
	r.b=null;
	s=A.p1(new A.il(r),new A.im(r),new A.io(r),t.w);
	r.b=a.ea(new A.ip(r,s,new A.ay(q,t.a_),b),s.gdZ());
	return q},
	oB(a,b){var s=new A.cT(a,new A.ay(new A.C($.B,t.f),t.G));
	s.e=b;
	return s},
	ud(a,b){var s,r,p,o=null,n=null;
	try{n=B.ab.e1(a);}catch(q){p=A.M(q);
	if(p instanceof A.aK){s=p;
	b.aE($.h3(),A.a([s],t.M),!0);
	return o}else throw q}if(t.t.b(n))try{r=A.oC(n,b);
	return new A.au("model/gltf+json",r,o)}catch(q){if(A.M(q) instanceof A.bA)return o
	else throw q}else {b.aE($.a2(),A.a([n,"object"],t.M),!0);
	return o}},
	au:function au(a,b,c){this.a=a;
	this.b=b;
	this.c=c;},
	im:function im(a){this.a=a;},
	io:function io(a){this.a=a;},
	il:function il(a){this.a=a;},
	ip:function ip(a,b,c,d){var _=this;
	_.a=a;
	_.b=b;
	_.c=c;
	_.d=d;},
	cT:function cT(a,b){var _=this;
	_.a=a;
	_.b=null;
	_.c=b;
	_.e=_.d=null;
	_.f=!0;},
	ik:function ik(a){this.a=a;},
	dv:function dv(){},
	az(a,b,c,d){var s=a.i(0,b);
	if(s==null&&a.v(b))d.l($.a2(),A.a([null,c],t.M),b);
	return s},
	mM(a){return typeof a=="number"&&Math.floor(a)===a?J.no(a):a},
	W(a,b,c,d){var s=A.mM(A.az(a,b,"integer",c));
	if(A.aI(s)){if(s>=0)return s
	c.n($.h2(),b);}else if(s==null){if(d)c.F($.bs(),A.a([b],t.M));}else c.l($.a2(),A.a([s,"integer"],t.M),b);
	return -1},
	pO(a,b,c){var s=A.az(a,b,"boolean",c);
	if(s==null)return !1
	if(A.eu(s))return s
	c.l($.a2(),A.a([s,"boolean"],t.M),b);
	return !1},
	a0(a,b,c,d,e,f,g,h){var s,r=A.mM(A.az(a,b,"integer",c));
	if(A.aI(r)){if(e!=null){if(!A.nN(b,r,e,c,!1))return -1}else {if(!(r<g))s=f!==-1&&r>f;
	else s=!0;
	if(s){c.l($.ni(),A.a([r],t.M),b);
	return -1}}return r}else if(r==null){if(!h)return d
	c.F($.bs(),A.a([b],t.M));}else c.l($.a2(),A.a([r,"integer"],t.M),b);
	return -1},
	E(a,b,c,d,e,f,g,h,i,j){var s,r=A.az(a,b,"number",c);
	if(typeof r=="number"){if(r!==j)s=r<h||r<=f||r>g||r>=e;
	else s=!1;
	if(s){c.l($.ni(),A.a([r],t.M),b);
	return 0/0}return r}else if(r==null){if(!i)return d
	c.F($.bs(),A.a([b],t.M));}else c.l($.a2(),A.a([r,"number"],t.M),b);
	return 0/0},
	J(a,b,c,d,e,f,g){var s,r=A.az(a,b,"string",c);
	if(typeof r=="string"){if(e!=null)A.nN(b,r,e,c,!1);
	else {if(f==null)s=null;
	else {s=f.b;
	s=s.test(r);}if(s===!1){c.l($.rp(),A.a([r,f.a],t.M),b);
	return null}}return r}else if(r==null){if(!g)return d
	c.F($.bs(),A.a([b],t.M));}else c.l($.a2(),A.a([r,"string"],t.M),b);
	return null},
	pS(a,b){var s,r,q;
	try{s=A.p6(a);
	q=s;
	if(q.gcK()||q.gbN()||q.gcJ()||q.gbP()||q.gbO())b.l($.t3(),A.a([a],t.M),"uri");
	return s}catch(p){q=A.M(p);
	if(q instanceof A.aK){r=q;
	b.l($.od(),A.a([a,r],t.M),"uri");
	return null}else throw p}},
	nP(a,b,c,d){var s=A.az(a,b,"object",c);
	if(t.t.b(s))return s
	else if(s==null){if(d){c.F($.bs(),A.a([b],t.M));
	return null}}else {c.l($.a2(),A.a([s,"object"],t.M),b);
	if(d)return null}return A.a9(t.X,t._)},
	T(a,b,c,d,e){var s,r,q=A.az(a,b,"object",c);
	if(t.t.b(q)){s=c.c;
	s.push(b);
	r=d.$2(q,c);
	s.pop();
	return r}else if(q==null){if(e)c.F($.bs(),A.a([b],t.M));}else c.l($.a2(),A.a([q,"object"],t.M),b);
	return null},
	mR(a,b,c,d){var s,r,q,p,o,n,m=A.az(a,b,"array",c);
	if(t.m.b(m)){s=J.V(m);
	if(s.gA(m)){c.n($.bX(),b);
	return null}r=c.c;
	r.push(b);
	q=t.e;
	p=A.aD(q);
	for(o=0;o<s.gj(m);++o){n=s.i(m,o);
	if(typeof n=="number"&&Math.floor(n)===n)n=J.no(n);
	if(A.aI(n)&&n>=0){if(!p.C(0,n))c.Z($.ob(),o);
	s.m(m,o,n);}else {s.m(m,o,-1);
	c.Z($.h2(),o);}}r.pop();
	return s.aj(m,q)}else if(m==null){if(d)c.F($.bs(),A.a([b],t.M));}else c.l($.a2(),A.a([m,"array"],t.M),b);
	return null},
	x5(a,b,c,d){var s,r=A.az(a,b,"object",c);
	if(t.t.b(r)){if(r.gA(r)){c.n($.bX(),b);
	return null}s=c.c;
	s.push(b);
	r.M(0,new A.mS(d,r,c));
	s.pop();
	return r.ak(0,t.X,t.e)}else {s=t.M;
	if(r==null)c.F($.bs(),A.a([b],s));
	else c.l($.a2(),A.a([r,"object"],s),b);}return null},
	x6(a,b,c,d){var s,r,q,p,o,n,m,l=A.az(a,b,"array",c);
	if(t.m.b(l)){s=J.V(l);
	if(s.gA(l)){c.n($.bX(),b);
	return null}else {r=c.c;
	r.push(b);
	for(q=t.M,p=t.t,o=!1,n=0;n<s.gj(l);++n){m=s.i(l,n);
	if(p.b(m))if(m.gA(m)){c.Z($.bX(),n);
	o=!0;}else {r.push(B.c.k(n));
	m.M(0,new A.mT(d,m,c));
	r.pop();}else {c.F($.eC(),A.a([m,"object"],q));
	o=!0;}}r.pop();
	if(o)return null}s=J.nn(l,t.h);
	r=A.A(s).h("ab<p.E,h<e*,f*>*>");
	return A.bc(new A.ab(s,new A.mU(),r),!1,r.h("ah.E"))}else if(l!=null)c.l($.a2(),A.a([l,"array"],t.M),b);
	return null},
	ae(a,b,c,d,e,f,g,h){var s,r,q,p,o,n,m,l,k=null,j=A.az(a,b,"array",c);
	if(t.m.b(j)){s=J.V(j);
	if(s.gA(j)){c.n($.bX(),b);
	return k}if(e!=null&&!A.nN(b,s.gj(j),e,c,!0))return k
	r=A.U(s.gj(j),0,!1,t.F);
	for(q=t.M,p=c.c,o=!1,n=0;n<s.gj(j);++n){m=s.i(j,n);
	if(typeof m=="number"){l=m==1/0||m==-1/0||m<g||m>f;
	if(l){p.push(b);
	c.ao($.ni(),A.a([m],q),n);
	p.pop();
	o=!0;}if(h){l=$.ol();
	l[0]=m;
	r[n]=l[0];}else r[n]=m;}else {c.l($.eC(),A.a([m,"number"],q),b);
	o=!0;}}if(o)return k
	return r}else if(j==null){if(d==null)s=k;
	else s=J.cX(d.slice(0),A.a_(d).c);
	return s}else c.l($.a2(),A.a([j,"array"],t.M),b);
	return k},
	pP(a,b,c,d,e){var s,r,q,p,o,n,m,l,k,j=A.az(a,b,"array",c);
	if(t.m.b(j)){s=J.V(j);
	if(s.gj(j)!==e){c.l($.oc(),A.a([s.gj(j),A.a([e],t.V)],t.M),b);
	return null}r=A.xR(d);
	q=A.q1(d);
	p=A.x_(d,e);
	for(o=t.M,n=!1,m=0;m<s.gj(j);++m){l=s.i(j,m);
	if(typeof l=="number"&&Math.floor(l)===l)l=J.no(l);
	if(A.aI(l)){k=l<r||l>q;
	if(k){c.l($.rC(),A.a([l,B.ay.i(0,d)],o),b);
	n=!0;}p[m]=l;}else {c.l($.eC(),A.a([l,"integer"],o),b);
	n=!0;}}if(n)return null
	return p}else if(j!=null)c.l($.a2(),A.a([j,"array"],t.M),b);
	return null},
	pQ(a,b,c){var s,r,q,p,o,n,m,l,k=A.az(a,b,"array",c);
	if(t.m.b(k)){s=J.V(k);
	if(s.gA(k)){c.n($.bX(),b);
	return null}r=c.c;
	r.push(b);
	q=t.X;
	p=A.aD(q);
	for(o=t.M,n=!1,m=0;m<s.gj(k);++m){l=s.i(k,m);
	if(typeof l=="string"){if(!p.C(0,l))c.Z($.ob(),m);}else {c.ao($.eC(),A.a([l,"string"],o),m);
	n=!0;}}r.pop();
	if(n)return null
	return s.aj(k,q)}else if(k!=null)c.l($.a2(),A.a([k,"array"],t.M),b);
	return null},
	eB(a,b,c){var s,r,q,p,o,n,m=A.az(a,b,"array",c);
	if(t.m.b(m)){s=J.V(m);
	if(s.gA(m)){c.n($.bX(),b);
	return null}else {for(r=s.gH(m),q=t.t,p=t.M,o=!1;r.q();){n=r.gt();
	if(!q.b(n)){c.l($.eC(),A.a([n,"object"],p),b);
	o=!0;}}if(o)return null}return s.aj(m,q)}else {s=t.M;
	if(m==null)c.F($.bs(),A.a([b],s));
	else c.l($.a2(),A.a([m,"array"],s),b);}return null},
	t(a,b,c,d){var s,r,q,p,o,n,m,l,k,j,i,h,g="extensions",f=A.a9(t.X,t._),e=A.nP(a,g,c,!1);
	if(e.gA(e))return f
	s=c.c;
	s.push(g);
	for(r=e.gN(),r=r.gH(r),q=t.ax,p=t.c,o=d==null,n=c.f,m=c.r;r.q();){l=r.gt();
	k=A.nP(e,l,c,!1);
	j=c.ay;
	if(!j.G(j,l)){j=c.at;
	j=j.G(j,l);
	if(!j)c.n($.rk(),l);
	f.m(0,l,k);
	continue}i=c.Q.a.i(0,new A.cb(b,l));
	if(i==null){c.n($.rl(),l);
	continue}if(e.gj(e)>1&&i.b)c.n($.rW(),l);
	if(k!=null){s.push(l);
	h=i.a.$2(k,c);
	f.m(0,l,h);
	if(!i.c&&p.b(h)){l=o?b:d;
	l=n.c_(l,new A.mQ());
	j=A.a(s.slice(0),A.a_(s));
	j.fixed$length=Array;
	J.nm(l,new A.cw(h,j));}if(q.b(h)){l=A.a(s.slice(0),A.a_(s));
	l.fixed$length=Array;
	m.push(new A.fo(h,l));}s.pop();}}s.pop();
	return f},
	x(a,b){var s=a.i(0,"extras");
	if(s!=null&&!t.h.b(s))b.n($.dk(),"extras");
	return s},
	nN(a,b,c,d,e){var s;
	if(!J.on(c,b)){s=e?$.oc():$.rs();
	d.l(s,A.a([b,c],t.M),a);
	return !1}return !0},
	w(a,b,c){var s,r,q;
	for(s=a.gN(),s=s.gH(s);s.q();){r=s.gt();
	if(!B.d.G(b,r)){q=B.d.G(B.cP,r);
	q=!q;}else q=!1;
	if(q)c.n($.rq(),r);}},
	nT(a,b,c,d,e,f){var s,r,q,p,o,n,m=e.c;
	m.push(d);
	for(s=t.M,r=c.a,q=r.length,p=0;p<a.gj(a);++p){o=a.i(0,p);
	if(o===-1)continue
	n=o==null||o<0||o>=q?null:r[o];
	if(n!=null){n.a$=!0;
	b[p]=n;
	f.$3(n,o,p);}else e.ao($.Q(),A.a([o],s),p);}m.pop();},
	xi(b8){var s,r,q,p,o,n,m,l,k,j,i,h,g,f,e,d,c,b,a,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,b0,b1,b2,b3,b4,b5,b6,b7=b8.a;
	if(b7[3]!==0||b7[7]!==0||b7[11]!==0||b7[15]!==1)return !1
	if(b8.cG()===0)return !1
	s=$.tt();
	r=$.tq();
	q=$.tr();
	p=$.oN;
	if(p==null)p=$.oN=new A.cE(new Float32Array(3));
	p.bt(b7[0],b7[1],b7[2]);
	o=Math.sqrt(p.gaW());
	p.bt(b7[4],b7[5],b7[6]);
	n=Math.sqrt(p.gaW());
	p.bt(b7[8],b7[9],b7[10]);
	m=Math.sqrt(p.gaW());
	if(b8.cG()<0)o=-o;
	s=s.a;
	s[0]=b7[12];
	s[1]=b7[13];
	s[2]=b7[14];
	l=1/o;
	k=1/n;
	j=1/m;
	i=$.oL;
	if(i==null)i=$.oL=new A.cZ(new Float32Array(16));
	h=i.a;
	h[15]=b7[15];
	h[14]=b7[14];
	h[13]=b7[13];
	h[12]=b7[12];
	h[11]=b7[11];
	h[10]=b7[10];
	h[9]=b7[9];
	h[8]=b7[8];
	h[7]=b7[7];
	h[6]=b7[6];
	h[5]=b7[5];
	h[4]=b7[4];
	h[3]=b7[3];
	h[2]=b7[2];
	h[1]=b7[1];
	h[0]=b7[0];
	h[0]=h[0]*l;
	h[1]=h[1]*l;
	h[2]=h[2]*l;
	h[4]=h[4]*k;
	h[5]=h[5]*k;
	h[6]=h[6]*k;
	h[8]=h[8]*j;
	h[9]=h[9]*j;
	h[10]=h[10]*j;
	g=$.oM;
	if(g==null)g=$.oM=new A.f2(new Float32Array(9));
	f=g.a;
	f[0]=h[0];
	f[1]=h[1];
	f[2]=h[2];
	f[3]=h[4];
	f[4]=h[5];
	f[5]=h[6];
	f[6]=h[8];
	f[7]=h[9];
	f[8]=h[10];
	r.toString;
	b7=f[0];
	h=f[4];
	e=f[8];
	d=0+b7+h+e;
	if(d>0){c=Math.sqrt(d+1);
	b7=r.a;
	b7[3]=c*0.5;
	c=0.5/c;
	b7[0]=(f[5]-f[7])*c;
	b7[1]=(f[6]-f[2])*c;
	b7[2]=(f[1]-f[3])*c;}else {if(b7<h)b=h<e?2:1;
	else b=b7<e?2:0;
	a=(b+1)%3;
	a0=(b+2)%3;
	b7=b*3;
	h=a*3;
	e=a0*3;
	c=Math.sqrt(f[b7+b]-f[h+a]-f[e+a0]+1);
	r=r.a;
	r[b]=c*0.5;
	c=0.5/c;
	r[3]=(f[h+a0]-f[e+a])*c;
	r[a]=(f[b7+a]+f[h+b])*c;
	r[a0]=(f[b7+a0]+f[e+b])*c;
	b7=r;}q=q.a;
	q[0]=o;
	q[1]=n;
	q[2]=m;
	r=$.tp();
	a1=b7[0];
	a2=b7[1];
	a3=b7[2];
	a4=b7[3];
	a5=a1+a1;
	a6=a2+a2;
	a7=a3+a3;
	a8=a1*a5;
	a9=a1*a6;
	b0=a1*a7;
	b1=a2*a6;
	b2=a2*a7;
	b3=a3*a7;
	b4=a4*a5;
	b5=a4*a6;
	b6=a4*a7;
	b7=r.a;
	b7[0]=1-(b1+b3);
	b7[1]=a9+b6;
	b7[2]=b0-b5;
	b7[3]=0;
	b7[4]=a9-b6;
	b7[5]=1-(a8+b3);
	b7[6]=b2+b4;
	b7[7]=0;
	b7[8]=b0+b5;
	b7[9]=b2-b4;
	b7[10]=1-(a8+b1);
	b7[11]=0;
	b7[12]=s[0];
	b7[13]=s[1];
	b7[14]=s[2];
	b7[15]=1;
	o=q[0];
	n=q[1];
	m=q[2];
	b7[0]=b7[0]*o;
	b7[1]=b7[1]*o;
	b7[2]=b7[2]*o;
	b7[3]=b7[3]*o;
	b7[4]=b7[4]*n;
	b7[5]=b7[5]*n;
	b7[6]=b7[6]*n;
	b7[7]=b7[7]*n;
	b7[8]=b7[8]*m;
	b7[9]=b7[9]*m;
	b7[10]=b7[10]*m;
	b7[11]=b7[11]*m;
	b7[12]=b7[12];
	b7[13]=b7[13];
	b7[14]=b7[14];
	b7[15]=b7[15];
	return Math.abs(r.cL()-b8.cL())<0.00005},
	x_(a,b){switch(a){case 5120:return new Int8Array(b)
	case 5121:return new Uint8Array(b)
	case 5122:return new Int16Array(b)
	case 5123:return new Uint16Array(b)
	case 5124:return new Int32Array(b)
	case 5125:return new Uint32Array(b)
	default:throw A.d(A.K(null,null))}},
	mS:function mS(a,b,c){this.a=a;
	this.b=b;
	this.c=c;},
	mT:function mT(a,b,c){this.a=a;
	this.b=b;
	this.c=c;},
	mU:function mU(){},
	mQ:function mQ(){},
	F:function F(a,b,c,d){var _=this;
	_.a=a;
	_.b=b;
	_.c=c;
	_.$ti=d;},
	a1:function a1(){},
	fv:function fv(a,b){this.a=0;
	this.b=a;
	this.c=b;},
	fw:function fw(a,b){this.a=0;
	this.b=a;
	this.c=b;},
	eK:function eK(a){this.a=a;},
	lF:function lF(a,b,c,d){var _=this;
	_.a=a;
	_.b=b;
	_.c=c;
	_.d=d;},
	lI:function lI(a,b){this.a=a;
	this.b=b;},
	lH:function lH(){},
	lG:function lG(){},
	uM(){return new A.cZ(new Float32Array(16))},
	v3(){return new A.fl(new Float32Array(4))},
	pb(a){var s=new Float32Array(3);
	s[2]=a[2];
	s[1]=a[1];
	s[0]=a[0];
	return new A.cE(s)},
	pa(){return new A.cE(new Float32Array(3))},
	f2:function f2(a){this.a=a;},
	cZ:function cZ(a){this.a=a;},
	fl:function fl(a){this.a=a;},
	cE:function cE(a){this.a=a;},
	fA:function fA(a){this.a=a;},
	xD(){var s=new A.nb();
	J.tE(self.exports,A.cK(new A.n7(s)));
	J.tF(self.exports,A.cK(new A.n8(s)));
	J.tG(self.exports,A.cK(new A.n9()));
	J.tD(self.exports,A.cK(new A.na()));},
	h_(a,b){return A.xT(a,b)},
	xT(a,b){var s=0,r=A.ex(t.t),q,p=2,o,n,m,l,k,i,h,g,f;
	var $async$h_=A.ez(function(c,d){if(c===1){o=d;
	s=p;}while(true)switch(s){case 0:if(!t.a.b(a))throw A.d(A.K("data: Argument must be a Uint8Array.",null))
	l=A.pv(b);
	n=A.pz(l);
	m=null;
	k=A.w0(l==null?null:J.tw(l));
	case 3:switch(k==null?null:k.toLowerCase()){case"glb":s=5;
	break
	case"gltf":s=6;
	break
	default:s=7;
	break}break
	case 5:m=A.oA(A.fs(a,t.w),n);
	s=4;
	break
	case 6:m=A.oB(A.fs(a,t.w),n);
	s=4;
	break
	case 7:p=9;
	s=12;
	return A.dd(A.ue(A.fs(a,t.w),n),$async$h_)
	case 12:m=d;
	p=2;
	s=11;
	break
	case 9:p=8;
	i=o;
	if(A.M(i) instanceof A.dv)throw i
	else throw i
	case 8:s=2;
	break
	case 11:case 4:h=A;
	g=l;
	f=n;
	s=13;
	return A.dd(m.c0(),$async$h_)
	case 13:q=h.fY(g,f,d);
	s=1;
	break
	case 1:return A.es(q,r)
	case 2:return A.er(o,r)}});
	return A.et($async$h_,r)},
	nV(a,b){var s=0,r=A.ex(t.t),q,p,o;
	var $async$nV=A.ez(function(c,d){if(c===1)return A.er(d,r)
	while(true)switch(s){case 0:if(typeof a!="string")throw A.d(A.K("json: Argument must be a string.",null))
	p=A.pv(b);
	o=A.pz(p);
	q=A.fY(p,o,A.ud(a,o));
	s=1;
	break
	case 1:return A.es(q,r)}});
	return A.et($async$nV,r)},
	pv(a){var s;
	if(a!=null)s=typeof a=="number"||A.eu(a)||typeof a=="string"||t.l.b(a);
	else s=!1;
	if(s)throw A.d(A.K("options: Value must be an object.",null))
	return t.bv.a(a)},
	fY(a,b,c){var s=0,r=A.ex(t.t),q,p,o,n,m;
	var $async$fY=A.ez(function(d,e){if(d===1)return A.er(e,r)
	while(true)switch(s){case 0:m=a==null;
	if(!m){p=J.b1(a);
	o=A.wd(p.gbo(a));
	if(p.gbL(a)!=null&&!t.b1.b(p.gbL(a)))throw A.d(A.K("options.externalResourceFunction: Value must be a function.",null))
	else n=p.gbL(a);
	if(p.gc6(a)!=null&&!A.eu(p.gc6(a)))throw A.d(A.K("options.writeTimestamp: Value must be a boolean.",null))}else {o=null;
	n=null;}s=(c==null?null:c.b)!=null?3:4;
	break
	case 3:s=5;
	return A.dd(A.wc(b,c,n).aX(),$async$fY)
	case 5:case 4:m=m?null:J.tz(a);
	q=new A.lF(o,b,c,m==null?!0:m).bn();
	s=1;
	break
	case 1:return A.es(q,r)}});
	return A.et($async$fY,r)},
	wd(a){var s,r;
	if(a!=null)if(typeof a=="string")try{r=A.p6(a);
	return r}catch(q){r=A.M(q);
	if(r instanceof A.aK){s=r;
	throw A.d(A.K("options.uri: "+A.b(s)+".",null))}else throw q}else throw A.d(A.K("options.uri: Value must be a string.",null))
	return null},
	pz(a){var s,r,q,p,o,n,m,l,k,j,i=null,h="]: Value must be a non-empty String.";
	if(a!=null){s=J.b1(a);
	if(s.gbM(a)!=null&&typeof s.gbM(a)!="string")throw A.d(A.K("options.format: Value must be a string.",i))
	if(s.gbk(a)!=null)r=!A.aI(s.gbk(a))||s.gbk(a)<0;
	else r=!1;
	if(r)throw A.d(A.K("options.maxIssues: Value must be a non-negative integer.",i))
	if(s.gaY(a)!=null&&s.gaU(a)!=null)throw A.d(A.K("options.onlyIssues cannot be used along with options.ignoredIssues.",i))
	if(s.gaY(a)!=null){if(!t.l.b(s.gaY(a)))throw A.d(A.K("options.onlyIssues: Value must be an array.",i))
	q=A.a([],t.i);
	for(p=0;p<J.a3(s.gaY(a));++p){o=J.nl(s.gaY(a),p);
	if(typeof o=="string"&&o.length!==0)q.push(o);
	else throw A.d(A.K("options.onlyIssues["+p+h,i))}}else q=i;
	if(s.gaU(a)!=null){if(!t.l.b(s.gaU(a)))throw A.d(A.K("options.ignoredIssues: Value must be an array.",i))
	n=A.a([],t.i);
	for(p=0;p<J.a3(s.gaU(a));++p){o=J.nl(s.gaU(a),p);
	if(typeof o=="string"&&o.length!==0)n.push(o);
	else throw A.d(A.K("options.ignoredIssues["+p+h,i))}}else n=i;
	if(s.gam(a)!=null){if(typeof s.gam(a)=="number"||A.eu(s.gam(a))||typeof s.gam(a)=="string"||t.l.b(s.gam(a)))throw A.d(A.K("options.severityOverrides: Value must be an object.",i))
	r=t.X;
	m=A.a9(r,t.dz);
	for(r=J.nn(self.Object.keys(s.gam(a)),r),r=new A.aa(r,r.gj(r),A.A(r).h("aa<p.E>"));r.q();){l=r.d;
	k=s.gam(a)[l];
	if(A.aI(k)&&k>=0&&k<=3)m.m(0,l,B.cn[k]);
	else throw A.d(A.K('options.severityOverrides["'+A.b(l)+'"]: Value must be one of [0, 1, 2, 3].',i))}}else m=i;
	j=A.p9(n,s.gbk(a),q,m);}else j=i;
	return A.u3(j)},
	wc(a,b,c){var s=new A.mG(c),r=new A.e_("options.externalResourceFunction is required to load this resource.");
	return new A.kb(b.b,a,new A.mE(a,b,c,s,r),new A.mF(c,s,r))},
	bf:function bf(){},
	hX:function hX(){},
	d8:function d8(){},
	nb:function nb(){},
	n7:function n7(a){this.a=a;},
	n6:function n6(a,b,c){this.a=a;
	this.b=b;
	this.c=c;},
	n3:function n3(a){this.a=a;},
	n4:function n4(a,b){this.a=a;
	this.b=b;},
	n8:function n8(a){this.a=a;},
	n5:function n5(a,b,c){this.a=a;
	this.b=b;
	this.c=c;},
	n1:function n1(a){this.a=a;},
	n2:function n2(a,b){this.a=a;
	this.b=b;},
	n9:function n9(){},
	na:function na(){},
	mG:function mG(a){this.a=a;},
	mH:function mH(a){this.a=a;},
	mI:function mI(a){this.a=a;},
	mE:function mE(a,b,c,d,e){var _=this;
	_.a=a;
	_.b=b;
	_.c=c;
	_.d=d;
	_.e=e;},
	mF:function mF(a,b,c){this.a=a;
	this.b=b;
	this.c=c;},
	ff:function ff(a){this.a=a;},
	nU(a){return A.Z(A.uG(a))},
	w4(a){var s,r=a.$dart_jsFunction;
	if(r!=null)return r
	s=function(b,c){return function(){return b(c,Array.prototype.slice.apply(arguments))}}(A.w3,a);
	s[$.nW()]=a;
	a.$dart_jsFunction=s;
	return s},
	w3(a,b){return A.v_(a,b,null)},
	cK(a){if(typeof a=="function")return a
	else return A.w4(a)},
	wg(a){var s="POSITION",r="TEXCOORD",q=a.fr;
	q.i(0,s).D(0,B.dh);
	q.i(0,"NORMAL").D(0,B.Q);
	q.i(0,"TANGENT").D(0,B.ds);
	q.i(0,r).D(0,B.cd);
	q=a.fx;
	q.i(0,s).D(0,B.cx);
	q.i(0,"NORMAL").D(0,B.Q);
	q.i(0,"TANGENT").D(0,B.Q);
	q.i(0,r).D(0,B.dn);},
	b0(a){switch(a){case 5120:case 5121:return 1
	case 5122:case 5123:return 2
	case 5124:case 5125:case 5126:return 4
	default:return -1}},
	xR(a){switch(a){case 5121:case 5123:case 5125:return 0
	case 5120:return -128
	case 5122:return -32768
	case 5124:return -2147483648
	default:throw A.d(A.K(null,null))}},
	q1(a){switch(a){case 5120:return 127
	case 5121:return 255
	case 5122:return 32767
	case 5123:return 65535
	case 5124:return 2147483647
	case 5125:return 4294967295
	default:throw A.d(A.K(null,null))}},
	fW(a,b){var s=a+b&536870911;
	s=s+((s&524287)<<10)&536870911;
	return s^s>>>6},
	px(a){var s=a+((a&67108863)<<3)&536870911;
	s^=s>>>11;
	return s+((s&16383)<<15)&536870911}},J={
	nS(a,b,c,d){return {i:a,p:b,e:c,x:d}},
	mV(a){var s,r,q,p,o,n=a[v.dispatchPropertyName];
	if(n==null)if($.nQ==null){A.xe();
	n=a[v.dispatchPropertyName];}if(n!=null){s=n.p;
	if(!1===s)return n.i
	if(!0===s)return a
	r=Object.getPrototypeOf(a);
	if(s===r)return n.i
	if(n.e===r)throw A.d(A.p4("Return interceptor for "+A.b(s(a,n))))}q=a.constructor;
	if(q==null)p=null;
	else {o=$.mg;
	if(o==null)o=$.mg=v.getIsolateTag("_$dart_js");
	p=q[o];}if(p!=null)return p
	p=A.xC(a);
	if(p!=null)return p
	if(typeof a=="function")return B.c2
	s=Object.getPrototypeOf(a);
	if(s==null)return B.aA
	if(s===Object.prototype)return B.aA
	if(typeof q=="function"){o=$.mg;
	if(o==null)o=$.mg=v.getIsolateTag("_$dart_js");
	Object.defineProperty(q,o,{value:B.X,enumerable:false,writable:true,configurable:true});
	return B.X}return B.X},
	b8(a,b){if(a<0||a>4294967295)throw A.d(A.Y(a,0,4294967295,"length",null))
	return J.cX(new Array(a),b)},
	oF(a,b){if(a>4294967295)throw A.d(A.Y(a,0,4294967295,"length",null))
	return J.cX(new Array(a),b)},
	cX(a,b){return J.nr(A.a(a,b.h("D<0>")))},
	nr(a){a.fixed$length=Array;
	return a},
	uj(a){if(a<256)switch(a){case 9:case 10:case 11:case 12:case 13:case 32:case 133:case 160:return !0
	default:return !1}switch(a){case 5760:case 8192:case 8193:case 8194:case 8195:case 8196:case 8197:case 8198:case 8199:case 8200:case 8201:case 8202:case 8232:case 8233:case 8239:case 8287:case 12288:case 65279:return !0
	default:return !1}},
	oG(a,b){var s,r;
	for(;b>0;b=s){s=b-1;
	r=B.a.B(a,s);
	if(r!==32&&r!==13&&!J.uj(r))break}return b},
	bV(a){if(typeof a=="number"){if(Math.floor(a)==a)return J.dy.prototype
	return J.eZ.prototype}if(typeof a=="string")return J.bB.prototype
	if(a==null)return J.dz.prototype
	if(typeof a=="boolean")return J.dx.prototype
	if(a.constructor==Array)return J.D.prototype
	if(typeof a!="object"){if(typeof a=="function")return J.b9.prototype
	return a}if(a instanceof A.c)return a
	return J.mV(a)},
	V(a){if(typeof a=="string")return J.bB.prototype
	if(a==null)return a
	if(a.constructor==Array)return J.D.prototype
	if(typeof a!="object"){if(typeof a=="function")return J.b9.prototype
	return a}if(a instanceof A.c)return a
	return J.mV(a)},
	bp(a){if(a==null)return a
	if(a.constructor==Array)return J.D.prototype
	if(typeof a!="object"){if(typeof a=="function")return J.b9.prototype
	return a}if(a instanceof A.c)return a
	return J.mV(a)},
	x7(a){if(typeof a=="number")return J.ce.prototype
	if(a==null)return a
	if(!(a instanceof A.c))return J.bL.prototype
	return a},
	x8(a){if(typeof a=="number")return J.ce.prototype
	if(typeof a=="string")return J.bB.prototype
	if(a==null)return a
	if(!(a instanceof A.c))return J.bL.prototype
	return a},
	x9(a){if(typeof a=="string")return J.bB.prototype
	if(a==null)return a
	if(!(a instanceof A.c))return J.bL.prototype
	return a},
	b1(a){if(a==null)return a
	if(typeof a!="object"){if(typeof a=="function")return J.b9.prototype
	return a}if(a instanceof A.c)return a
	return J.mV(a)},
	om(a,b){if(typeof a=="number"&&typeof b=="number")return a+b
	return J.x8(a).ae(a,b)},
	af(a,b){if(a==null)return b==null
	if(typeof a!="object")return b!=null&&a===b
	return J.bV(a).O(a,b)},
	nl(a,b){if(typeof b==="number")if(a.constructor==Array||typeof a=="string"||A.pU(a,a[v.dispatchPropertyName]))if(b>>>0===b&&b<a.length)return a[b]
	return J.V(a).i(a,b)},
	tv(a,b,c){if(typeof b==="number")if((a.constructor==Array||A.pU(a,a[v.dispatchPropertyName]))&&!a.immutable$list&&b>>>0===b&&b<a.length)return a[b]=c
	return J.bp(a).m(a,b,c)},
	nm(a,b){return J.bp(a).C(a,b)},
	nn(a,b){return J.bp(a).aj(a,b)},
	on(a,b){return J.bp(a).G(a,b)},
	eD(a,b){return J.bp(a).V(a,b)},
	tw(a){return J.b1(a).gbM(a)},
	bY(a){return J.bV(a).gE(a)},
	oo(a){return J.V(a).gA(a)},
	tx(a){return J.V(a).ga8(a)},
	aA(a){return J.bp(a).gH(a)},
	a3(a){return J.V(a).gj(a)},
	ty(a){return J.b1(a).ger(a)},
	tz(a){return J.b1(a).gc6(a)},
	tA(a,b,c){return J.bp(a).b0(a,b,c)},
	bt(a,b,c){return J.bp(a).al(a,b,c)},
	tB(a,b){return J.bV(a).bm(a,b)},
	tC(a,b){return J.V(a).sj(a,b)},
	tD(a,b){return J.b1(a).sdf(a,b)},
	tE(a,b){return J.b1(a).seB(a,b)},
	tF(a,b){return J.b1(a).seD(a,b)},
	tG(a,b){return J.b1(a).seE(a,b)},
	op(a,b){return J.bp(a).a6(a,b)},
	tH(a,b,c){return J.b1(a).d1(a,b,c)},
	tI(a,b,c){return J.b1(a).es(a,b,c)},
	no(a){return J.x7(a).eu(a)},
	h4(a,b){return J.bp(a).b_(a,b)},
	as(a){return J.bV(a).k(a)},
	tJ(a){return J.x9(a).ey(a)},
	cV:function cV(){},
	dx:function dx(){},
	dz:function dz(){},
	f_:function f_(){},
	aN:function aN(){},
	fj:function fj(){},
	bL:function bL(){},
	b9:function b9(){},
	D:function D(a){this.$ti=a;},
	iL:function iL(a){this.$ti=a;},
	b4:function b4(a,b,c){var _=this;
	_.a=a;
	_.b=b;
	_.c=0;
	_.d=null;
	_.$ti=c;},
	ce:function ce(){},
	dy:function dy(){},
	eZ:function eZ(){},
	bB:function bB(){}},B={};
	var w=[A,J,B];
	var $={};
	A.ns.prototype={};
	J.cV.prototype={
	O(a,b){return a===b},
	gE(a){return A.d0(a)},
	k(a){return "Instance of '"+A.b(A.ka(a))+"'"},
	bm(a,b){throw A.d(new A.dH(a,b.gcT(),b.gcX(),b.gcU(),null))}};
	J.dx.prototype={
	k(a){return String(a)},
	gE(a){return a?519018:218159},
	$iS:1};
	J.dz.prototype={
	O(a,b){return null==b},
	k(a){return "null"},
	gE(a){return 0},
	bm(a,b){return this.d6(a,b)},
	$il:1};
	J.f_.prototype={};
	J.aN.prototype={
	gE(a){return 0},
	k(a){return String(a)},
	$ibf:1,
	$id8:1,
	ger(a){return a.then},
	d1(a,b){return a.then(b)},
	es(a,b,c){return a.then(b,c)},
	seB(a,b){return a.validateBytes=b},
	seD(a,b){return a.validateString=b},
	seE(a,b){return a.version=b},
	sdf(a,b){return a.supportedExtensions=b},
	gbo(a){return a.uri},
	gbM(a){return a.format},
	gbL(a){return a.externalResourceFunction},
	gc6(a){return a.writeTimestamp},
	gbk(a){return a.maxIssues},
	gaU(a){return a.ignoredIssues},
	gaY(a){return a.onlyIssues},
	gam(a){return a.severityOverrides}};
	J.fj.prototype={};
	J.bL.prototype={};
	J.b9.prototype={
	k(a){var s=a[$.nW()];
	if(s==null)return this.da(a)
	return "JavaScript function for "+A.b(J.as(s))},
	$iaB:1};
	J.D.prototype={
	aj(a,b){return new A.b5(a,A.a_(a).h("@<1>").I(b).h("b5<1,2>"))},
	C(a,b){if(!!a.fixed$length)A.Z(A.ad("add"));
	a.push(b);},
	dP(a,b,c){var s,r,q,p=[],o=a.length;
	for(s=0;s<o;++s){r=a[s];
	if(!b.$1(r))p.push(r);
	if(a.length!==o)throw A.d(A.ag(a))}q=p.length;
	if(q===o)return
	this.sj(a,q);
	for(s=0;s<p.length;++s)a[s]=p[s];},
	D(a,b){var s;
	if(!!a.fixed$length)A.Z(A.ad("addAll"));
	if(Array.isArray(b)){this.di(a,b);
	return}for(s=J.aA(b);s.q();)a.push(s.gt());},
	di(a,b){var s,r=b.length;
	if(r===0)return
	if(a===b)throw A.d(A.ag(a))
	for(s=0;s<r;++s)a.push(b[s]);},
	P(a){if(!!a.fixed$length)A.Z(A.ad("clear"));
	a.length=0;},
	al(a,b,c){return new A.ab(a,b,A.a_(a).h("@<1>").I(c).h("ab<1,2>"))},
	cQ(a,b){var s,r=A.U(a.length,"",!1,t.R);
	for(s=0;s<a.length;++s)r[s]=A.b(a[s]);
	return r.join(b)},
	a6(a,b){return A.dQ(a,b,null,A.a_(a).c)},
	bf(a,b,c){var s,r,q=a.length;
	for(s=0;s<q;++s){r=a[s];
	if(b.$1(r))return r
	if(a.length!==q)throw A.d(A.ag(a))}return c.$0()},
	V(a,b){return a[b]},
	a1(a,b,c){if(b<0||b>a.length)throw A.d(A.Y(b,0,a.length,"start",null))
	if(c<b||c>a.length)throw A.d(A.Y(c,b,a.length,"end",null))
	if(b===c)return A.a([],A.a_(a))
	return A.a(a.slice(b,c),A.a_(a))},
	b0(a,b,c){A.aQ(b,c,a.length);
	return A.dQ(a,b,c,A.a_(a).c)},
	gaV(a){var s=a.length;
	if(s>0)return a[s-1]
	throw A.d(A.nq())},
	G(a,b){var s;
	for(s=0;s<a.length;++s)if(J.af(a[s],b))return !0
	return !1},
	gA(a){return a.length===0},
	ga8(a){return a.length!==0},
	k(a){return A.iI(a,"[","]")},
	b_(a,b){var s=J.cX(a.slice(0),A.a_(a).c);
	return s},
	c3(a){return A.uJ(a,A.a_(a).c)},
	gH(a){return new J.b4(a,a.length,A.a_(a).h("b4<1>"))},
	gE(a){return A.d0(a)},
	gj(a){return a.length},
	sj(a,b){if(!!a.fixed$length)A.Z(A.ad("set length"));
	if(b<0)throw A.d(A.Y(b,0,null,"newLength",null))
	a.length=b;},
	i(a,b){if(!(b>=0&&b<a.length))throw A.d(A.eA(a,b))
	return a[b]},
	m(a,b,c){if(!!a.immutable$list)A.Z(A.ad("indexed set"));
	if(!(b>=0&&b<a.length))throw A.d(A.eA(a,b))
	a[b]=c;},
	$iq:1,
	$ij:1,
	$io:1};
	J.iL.prototype={};
	J.b4.prototype={
	gt(){return this.d},
	q(){var s,r=this,q=r.a,p=q.length;
	if(r.b!==p)throw A.d(A.cN(q))
	s=r.c;
	if(s>=p){r.d=null;
	return !1}r.d=q[s];
	r.c=s+1;
	return !0},
	$iP:1};
	J.ce.prototype={
	eu(a){var s;
	if(a>=-2147483648&&a<=2147483647)return a|0
	if(isFinite(a)){s=a<0?Math.ceil(a):Math.floor(a);
	return s+0}throw A.d(A.ad(""+a+".toInt()"))},
	av(a,b){var s,r,q,p;
	if(b<2||b>36)throw A.d(A.Y(b,2,36,"radix",null))
	s=a.toString(b);
	if(B.a.B(s,s.length-1)!==41)return s
	r=/^([\da-z]+)(?:\.([\da-z]+))?\(e\+(\d+)\)$/.exec(s);
	if(r==null)A.Z(A.ad("Unexpected toString result: "+s));
	s=r[1];
	q=+r[3];
	p=r[2];
	if(p!=null){s+=p;
	q-=p.length;}return s+B.a.bs("0",q)},
	k(a){if(a===0&&1/a<0)return "-0.0"
	else return ""+a},
	gE(a){var s,r,q,p,o=a|0;
	if(a===o)return o&536870911
	s=Math.abs(a);
	r=Math.log(s)/0.6931471805599453|0;
	q=Math.pow(2,r);
	p=s<1?s/q:q/s;
	return ((p*9007199254740992|0)+(p*3542243181176521|0))*599197+r*1259&536870911},
	br(a,b){var s=a%b;
	if(s===0)return 0
	if(s>0)return s
	return s+b},
	aw(a,b){if((a|0)===a)if(b>=1||b<-1)return a/b|0
	return this.cv(a,b)},
	bJ(a,b){return (a|0)===a?a/b|0:this.cv(a,b)},
	cv(a,b){var s=a/b;
	if(s>=-2147483648&&s<=2147483647)return s|0
	if(s>0){if(s!==1/0)return Math.floor(s)}else if(s>-1/0)return Math.ceil(s)
	throw A.d(A.ad("Result of truncating division is "+A.b(s)+": "+A.b(a)+" ~/ "+b))},
	aI(a,b){if(b<0)throw A.d(A.cL(b))
	return b>31?0:a<<b>>>0},
	ai(a,b){var s;
	if(a>0)s=this.cu(a,b);
	else {s=b>31?31:b;
	s=a>>s>>>0;}return s},
	dT(a,b){if(0>b)throw A.d(A.cL(b))
	return this.cu(a,b)},
	cu(a,b){return b>31?0:a>>>b},
	$iz:1,
	$iN:1};
	J.dy.prototype={$if:1};
	J.eZ.prototype={};
	J.bB.prototype={
	B(a,b){if(b<0)throw A.d(A.eA(a,b))
	if(b>=a.length)A.Z(A.eA(a,b));
	return a.charCodeAt(b)},
	J(a,b){if(b>=a.length)throw A.d(A.eA(a,b))
	return a.charCodeAt(b)},
	ae(a,b){if(typeof b!="string")throw A.d(A.h7(b,null,null))
	return a+b},
	aH(a,b,c,d){var s=A.aQ(b,c,a.length);
	return a.substring(0,b)+d+a.substring(s)},
	U(a,b,c){var s;
	if(c<0||c>a.length)throw A.d(A.Y(c,0,a.length,null,null))
	s=c+b.length;
	if(s>a.length)return !1
	return b===a.substring(c,s)},
	Y(a,b){return this.U(a,b,0)},
	u(a,b,c){return a.substring(b,A.aQ(b,c,a.length))},
	bu(a,b){return this.u(a,b,null)},
	ey(a){var s,r,q;
	if(typeof a.trimRight!="undefined"){s=a.trimRight();
	r=s.length;
	if(r===0)return s
	q=r-1;
	if(this.B(s,q)===133)r=J.oG(s,q);}else {r=J.oG(a,a.length);
	s=a;}if(r===s.length)return s
	if(r===0)return ""
	return s.substring(0,r)},
	bs(a,b){var s,r;
	if(0>=b)return ""
	if(b===1||a.length===0)return a
	if(b!==b>>>0)throw A.d(B.bh)
	for(s=a,r="";!0;){if((b&1)===1)r=s+r;
	b=b>>>1;
	if(b===0)break
	s+=s;}return r},
	aq(a,b,c){var s=b-a.length;
	if(s<=0)return a
	return this.bs(c,s)+a},
	bg(a,b,c){var s;
	if(c<0||c>a.length)throw A.d(A.Y(c,0,a.length,null,null))
	s=a.indexOf(b,c);
	return s},
	bR(a,b){return this.bg(a,b,0)},
	k(a){return a},
	gE(a){var s,r,q;
	for(s=a.length,r=0,q=0;q<s;++q){r=r+a.charCodeAt(q)&536870911;
	r=r+((r&524287)<<10)&536870911;
	r^=r>>6;}r=r+((r&67108863)<<3)&536870911;
	r^=r>>11;
	return r+((r&16383)<<15)&536870911},
	gj(a){return a.length},
	$ie:1};
	A.bM.prototype={
	gH(a){var s=A.A(this);
	return new A.dm(J.aA(this.gaa()),s.h("@<1>").I(s.z[1]).h("dm<1,2>"))},
	gj(a){return J.a3(this.gaa())},
	gA(a){return J.oo(this.gaa())},
	ga8(a){return J.tx(this.gaa())},
	a6(a,b){var s=A.A(this);
	return A.he(J.op(this.gaa(),b),s.c,s.z[1])},
	V(a,b){return A.A(this).z[1].a(J.eD(this.gaa(),b))},
	G(a,b){return J.on(this.gaa(),b)},
	k(a){return J.as(this.gaa())}};
	A.dm.prototype={
	q(){return this.a.q()},
	gt(){return this.$ti.z[1].a(this.a.gt())},
	$iP:1};
	A.c5.prototype={
	gaa(){return this.a}};
	A.dZ.prototype={$iq:1};
	A.dU.prototype={
	i(a,b){return this.$ti.z[1].a(J.nl(this.a,b))},
	m(a,b,c){J.tv(this.a,b,this.$ti.c.a(c));},
	sj(a,b){J.tC(this.a,b);},
	C(a,b){J.nm(this.a,this.$ti.c.a(b));},
	b0(a,b,c){var s=this.$ti;
	return A.he(J.tA(this.a,b,c),s.c,s.z[1])},
	$iq:1,
	$io:1};
	A.b5.prototype={
	aj(a,b){return new A.b5(this.a,this.$ti.h("@<1>").I(b).h("b5<1,2>"))},
	gaa(){return this.a}};
	A.c6.prototype={
	ak(a,b,c){var s=this.$ti;
	return new A.c6(this.a,s.h("@<1>").I(s.z[1]).I(b).I(c).h("c6<1,2,3,4>"))},
	v(a){return this.a.v(a)},
	i(a,b){return this.$ti.h("4?").a(this.a.i(0,b))},
	m(a,b,c){var s=this.$ti;
	this.a.m(0,s.c.a(b),s.z[1].a(c));},
	M(a,b){this.a.M(0,new A.hf(this,b));},
	gN(){var s=this.$ti;
	return A.he(this.a.gN(),s.c,s.z[2])},
	gj(a){var s=this.a;
	return s.gj(s)},
	gA(a){var s=this.a;
	return s.gA(s)}};
	A.hf.prototype={
	$2(a,b){var s=this.a.$ti;
	this.b.$2(s.z[2].a(a),s.z[3].a(b));},
	$S(){return this.a.$ti.h("~(1,2)")}};
	A.f1.prototype={
	k(a){return "LateInitializationError: "+this.a}};
	A.fm.prototype={
	k(a){return "ReachabilityError: "+this.a}};
	A.c8.prototype={
	gj(a){return this.a.length},
	i(a,b){return B.a.B(this.a,b)}};
	A.nd.prototype={
	$0(){var s=new A.C($.B,t.U);
	s.ah(null);
	return s},
	$S:47};
	A.dI.prototype={
	k(a){return "Null is not a valid value for '"+this.a+"' of type '"+A.pL(this.$ti.c).k(0)+"'"},
	$iaG:1};
	A.q.prototype={};
	A.ah.prototype={
	gH(a){var s=this;
	return new A.aa(s,s.gj(s),A.A(s).h("aa<ah.E>"))},
	gA(a){return this.gj(this)===0},
	G(a,b){var s,r=this,q=r.gj(r);
	for(s=0;s<q;++s){if(J.af(r.V(0,s),b))return !0
	if(q!==r.gj(r))throw A.d(A.ag(r))}return !1},
	al(a,b,c){return new A.ab(this,b,A.A(this).h("@<ah.E>").I(c).h("ab<1,2>"))},
	a6(a,b){return A.dQ(this,b,null,A.A(this).h("ah.E"))}};
	A.dP.prototype={
	gdu(){var s=J.a3(this.a),r=this.c;
	if(r==null||r>s)return s
	return r},
	gdU(){var s=J.a3(this.a),r=this.b;
	if(r>s)return s
	return r},
	gj(a){var s,r=J.a3(this.a),q=this.b;
	if(q>=r)return 0
	s=this.c;
	if(s==null||s>=r)return r-q
	return s-q},
	V(a,b){var s=this,r=s.gdU()+b;
	if(b<0||r>=s.gdu())throw A.d(A.eW(b,s.gj(s),s,null,"index"))
	return J.eD(s.a,r)},
	a6(a,b){var s,r,q=this;
	A.aW(b,"count");
	s=q.b+b;
	r=q.c;
	if(r!=null&&s>=r)return new A.b7(q.$ti.h("b7<1>"))
	return A.dQ(q.a,s,r,q.$ti.c)},
	b_(a,b){var s,r,q,p=this,o=p.b,n=p.a,m=J.V(n),l=m.gj(n),k=p.c;
	if(k!=null&&k<l)l=k;
	s=l-o;
	if(s<=0){n=J.b8(0,p.$ti.c);
	return n}r=A.U(s,m.V(n,o),!1,p.$ti.c);
	for(q=1;q<s;++q){r[q]=m.V(n,o+q);
	if(m.gj(n)<l)throw A.d(A.ag(p))}return r}};
	A.aa.prototype={
	gt(){return this.d},
	q(){var s,r=this,q=r.a,p=J.V(q),o=p.gj(q);
	if(r.b!==o)throw A.d(A.ag(q))
	s=r.c;
	if(s>=o){r.d=null;
	return !1}r.d=p.V(q,s);++r.c;
	return !0},
	$iP:1};
	A.bd.prototype={
	gH(a){var s=A.A(this);
	return new A.dD(J.aA(this.a),this.b,s.h("@<1>").I(s.z[1]).h("dD<1,2>"))},
	gj(a){return J.a3(this.a)},
	gA(a){return J.oo(this.a)},
	V(a,b){return this.b.$1(J.eD(this.a,b))}};
	A.c9.prototype={$iq:1};
	A.dD.prototype={
	q(){var s=this,r=s.b;
	if(r.q()){s.a=s.c.$1(r.gt());
	return !0}s.a=null;
	return !1},
	gt(){return this.a}};
	A.ab.prototype={
	gj(a){return J.a3(this.a)},
	V(a,b){return this.b.$1(J.eD(this.a,b))}};
	A.lK.prototype={
	gH(a){return new A.cF(J.aA(this.a),this.b,this.$ti.h("cF<1>"))},
	al(a,b,c){return new A.bd(this,b,this.$ti.h("@<1>").I(c).h("bd<1,2>"))}};
	A.cF.prototype={
	q(){var s,r;
	for(s=this.a,r=this.b;s.q();)if(r.$1(s.gt()))return !0
	return !1},
	gt(){return this.a.gt()}};
	A.bh.prototype={
	a6(a,b){A.h8(b,"count");
	A.aW(b,"count");
	return new A.bh(this.a,this.b+b,A.A(this).h("bh<1>"))},
	gH(a){return new A.dN(J.aA(this.a),this.b,A.A(this).h("dN<1>"))}};
	A.cR.prototype={
	gj(a){var s=J.a3(this.a)-this.b;
	if(s>=0)return s
	return 0},
	a6(a,b){A.h8(b,"count");
	A.aW(b,"count");
	return new A.cR(this.a,this.b+b,this.$ti)},
	$iq:1};
	A.dN.prototype={
	q(){var s,r;
	for(s=this.a,r=0;r<this.b;++r)s.q();
	this.b=0;
	return s.q()},
	gt(){return this.a.gt()}};
	A.b7.prototype={
	gH(a){return B.b9},
	gA(a){return !0},
	gj(a){return 0},
	V(a,b){throw A.d(A.Y(b,0,0,"index",null))},
	G(a,b){return !1},
	al(a,b,c){return new A.b7(c.h("b7<0>"))},
	a6(a,b){A.aW(b,"count");
	return this}};
	A.dq.prototype={
	q(){return !1},
	gt(){throw A.d(A.nq())},
	$iP:1};
	A.ds.prototype={
	sj(a,b){throw A.d(A.ad("Cannot change the length of a fixed-length list"))},
	C(a,b){throw A.d(A.ad("Cannot add to a fixed-length list"))}};
	A.fy.prototype={
	m(a,b,c){throw A.d(A.ad("Cannot modify an unmodifiable list"))},
	sj(a,b){throw A.d(A.ad("Cannot change the length of an unmodifiable list"))},
	C(a,b){throw A.d(A.ad("Cannot add to an unmodifiable list"))}};
	A.d4.prototype={};
	A.d3.prototype={
	gE(a){var s=this._hashCode;
	if(s!=null)return s
	s=664597*J.bY(this.a)&536870911;
	this._hashCode=s;
	return s},
	k(a){return 'Symbol("'+A.b(this.a)+'")'},
	O(a,b){if(b==null)return !1
	return b instanceof A.d3&&this.a==b.a},
	$icD:1};
	A.ep.prototype={};
	A.dn.prototype={};
	A.cQ.prototype={
	ak(a,b,c){var s=A.A(this);
	return A.oK(this,s.c,s.z[1],b,c)},
	gA(a){return this.gj(this)===0},
	k(a){return A.nv(this)},
	m(a,b,c){A.u2();
	A.bg(u.g);},
	$ih:1};
	A.aJ.prototype={
	gj(a){return this.a},
	v(a){if(typeof a!="string")return !1
	if("__proto__"===a)return !1
	return this.b.hasOwnProperty(a)},
	i(a,b){if(!this.v(b))return null
	return this.b[b]},
	M(a,b){var s,r,q,p,o=this.c;
	for(s=o.length,r=this.b,q=0;q<s;++q){p=o[q];
	b.$2(p,r[p]);}},
	gN(){return new A.dW(this,this.$ti.h("dW<1>"))}};
	A.dW.prototype={
	gH(a){var s=this.a.c;
	return new J.b4(s,s.length,A.a_(s).h("b4<1>"))},
	gj(a){return this.a.c.length}};
	A.X.prototype={
	aM(){var s,r,q=this,p=q.$map;
	if(p==null){s=q.$ti;
	r=A.uc(s.h("1?"));
	p=A.uI(A.wt(),r,s.c,s.z[1]);
	A.pN(q.a,p);
	q.$map=p;}return p},
	v(a){return this.aM().v(a)},
	i(a,b){return this.aM().i(0,b)},
	M(a,b){this.aM().M(0,b);},
	gN(){var s=this.aM();
	return new A.aO(s,A.A(s).h("aO<1>"))},
	gj(a){return this.aM().a}};
	A.hY.prototype={
	$1(a){return this.a.b(a)},
	$S:14};
	A.iJ.prototype={
	gcT(){var s=this.a;
	return s},
	gcX(){var s,r,q,p,o=this;
	if(o.c===1)return B.at
	s=o.d;
	r=s.length-o.e.length-o.f;
	if(r===0)return B.at
	q=[];
	for(p=0;p<r;++p)q.push(s[p]);
	q.fixed$length=Array;
	q.immutable$list=Array;
	return q},
	gcU(){var s,r,q,p,o,n,m=this;
	if(m.c!==0)return B.az
	s=m.e;
	r=s.length;
	q=m.d;
	p=q.length-r-m.f;
	if(r===0)return B.az
	o=new A.aC(t.eo);
	for(n=0;n<r;++n)o.m(0,new A.d3(s[n]),q[p+n]);
	return new A.dn(o,t.gF)}};
	A.k9.prototype={
	$2(a,b){var s=this.a;
	s.b=s.b+"$"+A.b(a);
	this.b.push(a);
	this.c.push(b);++s.a;},
	$S:69};
	A.lt.prototype={
	a9(a){var s,r,q=this,p=new RegExp(q.a).exec(a);
	if(p==null)return null
	s=Object.create(null);
	r=q.b;
	if(r!==-1)s.arguments=p[r+1];
	r=q.c;
	if(r!==-1)s.argumentsExpr=p[r+1];
	r=q.d;
	if(r!==-1)s.expr=p[r+1];
	r=q.e;
	if(r!==-1)s.method=p[r+1];
	r=q.f;
	if(r!==-1)s.receiver=p[r+1];
	return s}};
	A.dJ.prototype={
	k(a){var s=this.b;
	if(s==null)return "NoSuchMethodError: "+A.b(this.a)
	return "NoSuchMethodError: method not found: '"+s+"' on null"}};
	A.f0.prototype={
	k(a){var s,r=this,q="NoSuchMethodError: method not found: '",p=r.b;
	if(p==null)return "NoSuchMethodError: "+A.b(r.a)
	s=r.c;
	if(s==null)return q+p+"' ("+A.b(r.a)+")"
	return q+p+"' on '"+s+"' ("+A.b(r.a)+")"}};
	A.fx.prototype={
	k(a){var s=this.a;
	return s.length===0?"Error":"Error: "+s}};
	A.fh.prototype={
	k(a){return "Throw of null ('"+(this.a===null?"null":"undefined")+"' from JavaScript)"},
	$ia8:1};
	A.dr.prototype={};
	A.ed.prototype={
	k(a){var s,r=this.b;
	if(r!=null)return r
	r=this.a;
	s=r!==null&&typeof r==="object"?r.stack:null;
	return this.b=s==null?"":s},
	$ian:1};
	A.c7.prototype={
	k(a){var s=this.constructor,r=s==null?null:s.name;
	return "Closure '"+A.q2(r==null?"unknown":r)+"'"},
	$iaB:1,
	geF(){return this},
	$C:"$1",
	$R:1,
	$D:null};
	A.eL.prototype={$C:"$0",$R:0};
	A.eM.prototype={$C:"$2",$R:2};
	A.ft.prototype={};
	A.fq.prototype={
	k(a){var s=this.$static_name;
	if(s==null)return "Closure of unknown static method"
	return "Closure '"+A.q2(s)+"'"}};
	A.cP.prototype={
	O(a,b){if(b==null)return !1
	if(this===b)return !0
	if(!(b instanceof A.cP))return !1
	return this.$_target===b.$_target&&this.a===b.a},
	gE(a){return (A.fZ(this.a)^A.d0(this.$_target))>>>0},
	k(a){return "Closure '"+A.b(this.$_name)+"' of "+("Instance of '"+A.b(A.ka(this.a))+"'")}};
	A.fp.prototype={
	k(a){return "RuntimeError: "+this.a}};
	A.mm.prototype={};
	A.aC.prototype={
	gj(a){return this.a},
	gA(a){return this.a===0},
	gN(){return new A.aO(this,A.A(this).h("aO<1>"))},
	gX(){var s=A.A(this);
	return A.jQ(new A.aO(this,s.h("aO<1>")),new A.iP(this),s.c,s.z[1])},
	v(a){var s,r;
	if(typeof a=="string"){s=this.b;
	if(s==null)return !1
	return s[a]!=null}else if(typeof a=="number"&&(a&0x3fffffff)===a){r=this.c;
	if(r==null)return !1
	return r[a]!=null}else return this.cM(a)},
	cM(a){var s=this.d;
	if(s==null)return !1
	return this.bi(s[this.bh(a)],a)>=0},
	i(a,b){var s,r,q,p,o=null;
	if(typeof b=="string"){s=this.b;
	if(s==null)return o
	r=s[b];
	q=r==null?o:r.b;
	return q}else if(typeof b=="number"&&(b&0x3fffffff)===b){p=this.c;
	if(p==null)return o
	r=p[b];
	q=r==null?o:r.b;
	return q}else return this.cN(b)},
	cN(a){var s,r,q=this.d;
	if(q==null)return null
	s=q[this.bh(a)];
	r=this.bi(s,a);
	if(r<0)return null
	return s[r].b},
	m(a,b,c){var s,r,q=this;
	if(typeof b=="string"){s=q.b;
	q.ca(s==null?q.b=q.bH():s,b,c);}else if(typeof b=="number"&&(b&0x3fffffff)===b){r=q.c;
	q.ca(r==null?q.c=q.bH():r,b,c);}else q.cO(b,c);},
	cO(a,b){var s,r,q,p=this,o=p.d;
	if(o==null)o=p.d=p.bH();
	s=p.bh(a);
	r=o[s];
	if(r==null)o[s]=[p.bI(a,b)];
	else {q=p.bi(r,a);
	if(q>=0)r[q].b=b;
	else r.push(p.bI(a,b));}},
	c_(a,b){var s;
	if(this.v(a))return this.i(0,a)
	s=b.$0();
	this.m(0,a,s);
	return s},
	M(a,b){var s=this,r=s.e,q=s.r;
	for(;r!=null;){b.$2(r.a,r.b);
	if(q!==s.r)throw A.d(A.ag(s))
	r=r.c;}},
	ca(a,b,c){var s=a[b];
	if(s==null)a[b]=this.bI(b,c);
	else s.b=c;},
	bI(a,b){var s=this,r=new A.jN(a,b);
	if(s.e==null)s.e=s.f=r;
	else s.f=s.f.c=r;++s.a;
	s.r=s.r+1&1073741823;
	return r},
	bh(a){return J.bY(a)&0x3fffffff},
	bi(a,b){var s,r;
	if(a==null)return -1
	s=a.length;
	for(r=0;r<s;++r)if(J.af(a[r].a,b))return r
	return -1},
	k(a){return A.nv(this)},
	bH(){var s=Object.create(null);
	s["<non-identifier-key>"]=s;
	delete s["<non-identifier-key>"];
	return s}};
	A.iP.prototype={
	$1(a){return this.a.i(0,a)},
	$S(){return A.A(this.a).h("2(1)")}};
	A.jN.prototype={};
	A.aO.prototype={
	gj(a){return this.a.a},
	gA(a){return this.a.a===0},
	gH(a){var s=this.a,r=new A.cx(s,s.r,this.$ti.h("cx<1>"));
	r.c=s.e;
	return r},
	G(a,b){return this.a.v(b)}};
	A.cx.prototype={
	gt(){return this.d},
	q(){var s,r=this,q=r.a;
	if(r.b!==q.r)throw A.d(A.ag(q))
	s=r.c;
	if(s==null){r.d=null;
	return !1}else {r.d=s.a;
	r.c=s.c;
	return !0}},
	$iP:1};
	A.mX.prototype={
	$1(a){return this.a(a)},
	$S:30};
	A.mY.prototype={
	$2(a,b){return this.a(a,b)},
	$S:33};
	A.mZ.prototype={
	$1(a){return this.a(a)},
	$S:50};
	A.iK.prototype={
	k(a){return "RegExp/"+this.a+"/"+this.b.flags},
	aT(a){var s;
	if(typeof a!="string")A.Z(A.cL(a));
	s=this.b.exec(a);
	if(s==null)return null
	return new A.mk(s)}};
	A.mk.prototype={};
	A.dF.prototype={
	dE(a,b,c,d){var s=A.Y(b,0,c,d,null);
	throw A.d(s)},
	ci(a,b,c,d){if(b>>>0!==b||b>c)this.dE(a,b,c,d);}};
	A.d_.prototype={
	gj(a){return a.length},
	dS(a,b,c,d,e){var s,r,q=a.length;
	this.ci(a,b,q,"start");
	this.ci(a,c,q,"end");
	if(b>c)throw A.d(A.Y(b,0,c,null,null))
	s=c-b;
	if(e<0)throw A.d(A.K(e,null))
	r=d.length;
	if(r-e<s)throw A.d(A.d2("Not enough elements"))
	if(e!==0||r!==s)d=d.subarray(e,e+s);
	a.set(d,b);},
	$iav:1};
	A.dE.prototype={
	i(a,b){A.bo(b,a,a.length);
	return a[b]},
	m(a,b,c){A.bo(b,a,a.length);
	a[b]=c;},
	$iq:1,
	$ij:1,
	$io:1};
	A.aw.prototype={
	m(a,b,c){A.bo(b,a,a.length);
	a[b]=c;},
	a5(a,b,c,d,e){if(t.eB.b(d)){this.dS(a,b,c,d,e);
	return}this.dc(a,b,c,d,e);},
	d5(a,b,c,d){return this.a5(a,b,c,d,0)},
	$iq:1,
	$ij:1,
	$io:1};
	A.f8.prototype={
	a1(a,b,c){return new Float32Array(a.subarray(b,A.bR(b,c,a.length)))}};
	A.f9.prototype={
	a1(a,b,c){return new Float64Array(a.subarray(b,A.bR(b,c,a.length)))}};
	A.fa.prototype={
	i(a,b){A.bo(b,a,a.length);
	return a[b]},
	a1(a,b,c){return new Int16Array(a.subarray(b,A.bR(b,c,a.length)))}};
	A.fb.prototype={
	i(a,b){A.bo(b,a,a.length);
	return a[b]},
	a1(a,b,c){return new Int32Array(a.subarray(b,A.bR(b,c,a.length)))}};
	A.fc.prototype={
	i(a,b){A.bo(b,a,a.length);
	return a[b]},
	a1(a,b,c){return new Int8Array(a.subarray(b,A.bR(b,c,a.length)))}};
	A.fd.prototype={
	i(a,b){A.bo(b,a,a.length);
	return a[b]},
	a1(a,b,c){return new Uint16Array(a.subarray(b,A.bR(b,c,a.length)))}};
	A.fe.prototype={
	i(a,b){A.bo(b,a,a.length);
	return a[b]},
	a1(a,b,c){return new Uint32Array(a.subarray(b,A.bR(b,c,a.length)))}};
	A.dG.prototype={
	gj(a){return a.length},
	i(a,b){A.bo(b,a,a.length);
	return a[b]},
	a1(a,b,c){return new Uint8ClampedArray(a.subarray(b,A.bR(b,c,a.length)))}};
	A.cy.prototype={
	gj(a){return a.length},
	i(a,b){A.bo(b,a,a.length);
	return a[b]},
	a1(a,b,c){return new Uint8Array(a.subarray(b,A.bR(b,c,a.length)))},
	$icy:1,
	$ia6:1};
	A.e7.prototype={};
	A.e8.prototype={};
	A.e9.prototype={};
	A.ea.prototype={};
	A.aF.prototype={
	h(a){return A.mt(v.typeUniverse,this,a)},
	I(a){return A.vG(v.typeUniverse,this,a)}};
	A.fK.prototype={};
	A.eh.prototype={
	k(a){return A.ar(this.a,null)},
	$ibk:1};
	A.fJ.prototype={
	k(a){return this.a}};
	A.ei.prototype={$iaG:1};
	A.lW.prototype={
	$1(a){var s=this.a,r=s.a;
	s.a=null;
	r.$0();},
	$S:15};
	A.lV.prototype={
	$1(a){var s,r;
	this.a.a=a;
	s=this.b;
	r=this.c;
	s.firstChild?s.removeChild(r):s.appendChild(r);},
	$S:122};
	A.lX.prototype={
	$0(){this.a.$0();},
	$S:2};
	A.lY.prototype={
	$0(){this.a.$0();},
	$S:2};
	A.mr.prototype={
	dg(a,b){if(self.setTimeout!=null)self.setTimeout(A.mO(new A.ms(this,b),0),a);
	else throw A.d(A.ad("`setTimeout()` not found."))}};
	A.ms.prototype={
	$0(){this.b.$0();},
	$S:1};
	A.fD.prototype={
	a3(a){var s,r=this;
	if(!r.b)r.a.ah(a);
	else {s=r.a;
	if(r.$ti.h("a5<1>").b(a))s.cf(a);
	else s.bA(a);}},
	bK(a,b){var s;
	if(b==null)b=A.eI(a);
	s=this.a;
	if(this.b)s.aA(a,b);
	else s.b5(a,b);}};
	A.mx.prototype={
	$1(a){return this.a.$2(0,a)},
	$S:34};
	A.my.prototype={
	$2(a,b){this.a.$2(1,new A.dr(a,b));},
	$S:42};
	A.mN.prototype={
	$2(a,b){this.a(a,b);},
	$S:48};
	A.d7.prototype={
	k(a){return "IterationMarker("+this.b+", "+A.b(this.a)+")"}};
	A.aH.prototype={
	gt(){var s=this.c;
	if(s==null)return this.b
	return s.gt()},
	q(){var s,r,q,p,o,n=this;
	for(;!0;){s=n.c;
	if(s!=null)if(s.q())return !0
	else n.c=null;
	r=function(a,b,c){var m,l=b;
	while(true)try{return a(l,m)}catch(k){m=k;
	l=c;}}(n.a,0,1);
	if(r instanceof A.d7){q=r.b;
	if(q===2){p=n.d;
	if(p==null||p.length===0){n.b=null;
	return !1}n.a=p.pop();
	continue}else {s=r.a;
	if(q===3)throw s
	else {o=J.aA(s);
	if(o instanceof A.aH){s=n.d;
	if(s==null)s=n.d=[];
	s.push(n.a);
	n.a=o.a;
	continue}else {n.c=o;
	continue}}}}else {n.b=r;
	return !0}}return !1},
	$iP:1};
	A.eg.prototype={
	gH(a){return new A.aH(this.a(),this.$ti.h("aH<1>"))}};
	A.eH.prototype={
	k(a){return A.b(this.a)},
	$iH:1,
	gb2(){return this.b}};
	A.fG.prototype={
	bK(a,b){var s;
	A.bU(a,"error",t.K);
	s=this.a;
	if((s.a&30)!==0)throw A.d(A.d2("Future already completed"))
	if(b==null)b=A.eI(a);
	s.b5(a,b);},
	R(a){return this.bK(a,null)}};
	A.ay.prototype={
	a3(a){var s=this.a;
	if((s.a&30)!==0)throw A.d(A.d2("Future already completed"))
	s.ah(a);},
	bd(){return this.a3(null)}};
	A.bN.prototype={
	ec(a){if((this.c&15)!==6)return !0
	return this.b.b.c2(this.d,a.a)},
	e7(a){var r=this.e,q=null,p=this.b.b;
	if(t.C.b(r))q=p.el(r,a.a,a.b);
	else q=p.c2(r,a.a);
	try{p=q;
	return p}catch(s){if(t.eK.b(A.M(s))){if((this.c&1)!==0)throw A.d(A.K("The error handler of Future.then must return a value of the returned future's type","onError"))
	throw A.d(A.K("The error handler of Future.catchError must return a value of the future's type","onError"))}else throw s}}};
	A.C.prototype={
	au(a,b,c,d){var s,r,q=$.B;
	if(q===B.i){if(c!=null&&!t.C.b(c)&&!t.v.b(c))throw A.d(A.h7(c,"onError",u.c))}else if(c!=null)c=A.wA(c,q);
	s=new A.C(q,d.h("C<0>"));
	r=c==null?1:3;
	this.b4(new A.bN(s,r,b,c,this.$ti.h("@<1>").I(d).h("bN<1,2>")));
	return s},
	d1(a,b,c){return this.au(a,b,null,c)},
	cz(a,b,c){var s=new A.C($.B,c.h("C<0>"));
	this.b4(new A.bN(s,3,a,b,this.$ti.h("@<1>").I(c).h("bN<1,2>")));
	return s},
	bp(a){var s=this.$ti,r=new A.C($.B,s);
	this.b4(new A.bN(r,8,a,null,s.h("@<1>").I(s.c).h("bN<1,2>")));
	return r},
	dQ(a){this.a=this.a&1|16;
	this.c=a;},
	by(a){this.a=a.a&30|this.a&1;
	this.c=a.c;},
	b4(a){var s=this,r=s.a;
	if(r<=3){a.a=s.c;
	s.c=a;}else {if((r&4)!==0){r=s.c;
	if((r.a&24)===0){r.b4(a);
	return}s.by(r);}A.cI(null,null,s.b,new A.m3(s,a));}},
	cs(a){var s,r,q,p,o,n=this,m={};
	m.a=a;
	if(a==null)return
	s=n.a;
	if(s<=3){r=n.c;
	n.c=a;
	if(r!=null){q=a.a;
	for(p=a;q!=null;p=q,q=o)o=q.a;
	p.a=r;}}else {if((s&4)!==0){s=n.c;
	if((s.a&24)===0){s.cs(a);
	return}n.by(s);}m.a=n.bc(a);
	A.cI(null,null,n.b,new A.ma(m,n));}},
	bb(){var s=this.c;
	this.c=null;
	return this.bc(s)},
	bc(a){var s,r,q;
	for(s=a,r=null;s!=null;r=s,s=q){q=s.a;
	s.a=r;}return r},
	ce(a){var s,r,p=this;
	p.a^=2;
	try{a.au(0,new A.m6(p),new A.m7(p),t.P);}catch(q){s=A.M(q);
	r=A.aS(q);
	A.q_(new A.m8(p,s,r));}},
	bA(a){var s=this,r=s.bb();
	s.a=8;
	s.c=a;
	A.d6(s,r);},
	aA(a,b){var s=this.bb();
	this.dQ(A.h9(a,b));
	A.d6(this,s);},
	ah(a){if(this.$ti.h("a5<1>").b(a)){this.cf(a);
	return}this.dk(a);},
	dk(a){this.a^=2;
	A.cI(null,null,this.b,new A.m5(this,a));},
	cf(a){var s=this;
	if(s.$ti.b(a)){if((a.a&16)!==0){s.a^=2;
	A.cI(null,null,s.b,new A.m9(s,a));}else A.nz(a,s);
	return}s.ce(a);},
	b5(a,b){this.a^=2;
	A.cI(null,null,this.b,new A.m4(this,a,b));},
	$ia5:1};
	A.m3.prototype={
	$0(){A.d6(this.a,this.b);},
	$S:1};
	A.ma.prototype={
	$0(){A.d6(this.b,this.a.a);},
	$S:1};
	A.m6.prototype={
	$1(a){var s,r,p=this.a;
	p.a^=2;
	try{p.bA(p.$ti.c.a(a));}catch(q){s=A.M(q);
	r=A.aS(q);
	p.aA(s,r);}},
	$S:15};
	A.m7.prototype={
	$2(a,b){this.a.aA(a,b);},
	$S:52};
	A.m8.prototype={
	$0(){this.a.aA(this.b,this.c);},
	$S:1};
	A.m5.prototype={
	$0(){this.a.bA(this.b);},
	$S:1};
	A.m9.prototype={
	$0(){A.nz(this.b,this.a);},
	$S:1};
	A.m4.prototype={
	$0(){this.a.aA(this.b,this.c);},
	$S:1};
	A.md.prototype={
	$0(){var s,r,q,o,n,m=this,l=null;
	try{q=m.a.a;
	l=q.b.b.cZ(q.d);}catch(p){s=A.M(p);
	r=A.aS(p);
	if(m.c){q=m.b.a.c.a;
	o=s;
	o=q==null?o==null:q===o;
	q=o;}else q=!1;
	o=m.a;
	if(q)o.c=m.b.a.c;
	else o.c=A.h9(s,r);
	o.b=!0;
	return}if(l instanceof A.C&&(l.a&24)!==0){if((l.a&16)!==0){q=m.a;
	q.c=l.c;
	q.b=!0;}return}if(t.d.b(l)){n=m.b.a;
	q=m.a;
	q.c=J.tH(l,new A.me(n),t.z);
	q.b=!1;}},
	$S:1};
	A.me.prototype={
	$1(a){return this.a},
	$S:53};
	A.mc.prototype={
	$0(){var s,r,q,p;
	try{q=this.a;
	p=q.a;
	q.c=p.b.b.c2(p.d,this.b);}catch(o){s=A.M(o);
	r=A.aS(o);
	q=this.a;
	q.c=A.h9(s,r);
	q.b=!0;}},
	$S:1};
	A.mb.prototype={
	$0(){var s,r,q,p,n,m,l,k=this;
	try{s=k.a.a.c;
	p=k.b;
	if(p.a.ec(s)&&p.a.e!=null){p.c=p.a.e7(s);
	p.b=!1;}}catch(o){r=A.M(o);
	q=A.aS(o);
	p=k.a.a.c;
	n=p.a;
	m=r;
	l=k.b;
	if(n==null?m==null:n===m)l.c=p;
	else l.c=A.h9(r,q);
	l.b=!0;}},
	$S:1};
	A.fE.prototype={};
	A.bi.prototype={
	gj(a){var s={},r=new A.C($.B,t.fJ);
	s.a=0;
	this.bU(new A.lp(s,this),!0,new A.lq(s,r),r.gdq());
	return r}};
	A.ln.prototype={
	$1(a){var s=this.a;
	s.aJ(a);
	s.aK();},
	$S(){return this.b.h("l(0)")}};
	A.lo.prototype={
	$2(a,b){var s=this.a;
	s.b3(a,b);
	s.aK();},
	$S:55};
	A.lp.prototype={
	$1(a){++this.a.a;},
	$S(){return this.b.$ti.h("~(1)")}};
	A.lq.prototype={
	$0(){var s=this.b,r=this.a.a,q=s.bb();
	s.a=8;
	s.c=r;
	A.d6(s,q);},
	$S:1};
	A.fr.prototype={};
	A.da.prototype={
	gdL(){if((this.b&8)===0)return this.a
	return this.a.gc5()},
	b6(){var s,r=this;
	if((r.b&8)===0){s=r.a;
	return s==null?r.a=new A.eb():s}s=r.a.gc5();
	return s},
	gaD(){var s=this.a;
	return (this.b&8)!==0?s.gc5():s},
	bv(){if((this.b&4)!==0)return new A.bJ("Cannot add event after closing")
	return new A.bJ("Cannot add event while adding a stream")},
	ck(){var s=this.c;
	if(s==null)s=this.c=(this.b&2)!==0?$.h0():new A.C($.B,t.D);
	return s},
	C(a,b){if(this.b>=4)throw A.d(this.bv())
	this.aJ(b);},
	a7(){var s=this,r=s.b;
	if((r&4)!==0)return s.ck()
	if(r>=4)throw A.d(s.bv())
	s.aK();
	return s.ck()},
	aK(){var s=this.b|=4;
	if((s&1)!==0)this.aO();
	else if((s&3)===0)this.b6().C(0,B.M);},
	aJ(a){var s=this.b;
	if((s&1)!==0)this.aC(a);
	else if((s&3)===0)this.b6().C(0,new A.cG(a));},
	b3(a,b){var s=this.b;
	if((s&1)!==0)this.aP(a,b);
	else if((s&3)===0)this.b6().C(0,new A.dY(a,b));},
	dV(a,b,c,d){var s,r,q,p,o,n,m=this;
	if((m.b&3)!==0)throw A.d(A.d2("Stream has already been listened to."))
	s=$.B;
	r=d?1:0;
	q=A.vn(s,b);
	p=new A.dX(m,a,q,c,s,r);
	o=m.gdL();
	s=m.b|=1;
	if((s&8)!==0){n=m.a;
	n.sc5(p);
	n.ar();}else m.a=p;
	p.dR(o);
	p.bF(new A.mq(m));
	return p},
	dN(a){var s,r,q,p,n,m,l=this,k=null;
	if((l.b&8)!==0)k=l.a.K();
	l.a=null;
	l.b=l.b&4294967286|2;
	s=l.r;
	if(s!=null)if(k==null)try{r=s.$0();
	if(t.bq.b(r))k=r;}catch(o){q=A.M(o);
	p=A.aS(o);
	n=new A.C($.B,t.D);
	n.b5(q,p);
	k=n;}else k=k.bp(s);
	m=new A.mp(l);
	if(k!=null)k=k.bp(m);
	else m.$0();
	return k}};
	A.mq.prototype={
	$0(){A.nM(this.a.d);},
	$S:1};
	A.mp.prototype={
	$0(){var s=this.a.c;
	if(s!=null&&(s.a&30)===0)s.ah(null);},
	$S:1};
	A.fS.prototype={
	aC(a){this.gaD().aJ(a);},
	aP(a,b){this.gaD().b3(a,b);},
	aO(){this.gaD().dn();}};
	A.fF.prototype={
	aC(a){this.gaD().az(new A.cG(a));},
	aP(a,b){this.gaD().az(new A.dY(a,b));},
	aO(){this.gaD().az(B.M);}};
	A.aZ.prototype={};
	A.db.prototype={};
	A.aj.prototype={
	gE(a){return (A.d0(this.a)^892482866)>>>0},
	O(a,b){if(b==null)return !1
	if(this===b)return !0
	return b instanceof A.aj&&b.a===this.a}};
	A.dX.prototype={
	cp(){return this.w.dN(this)},
	b9(){var s=this.w;
	if((s.b&8)!==0)s.a.aZ();
	A.nM(s.e);},
	ba(){var s=this.w;
	if((s.b&8)!==0)s.a.ar();
	A.nM(s.f);}};
	A.dT.prototype={
	dR(a){var s=this;
	if(a==null)return
	s.r=a;
	if(a.c!=null){s.e=(s.e|64)>>>0;
	a.b1(s);}},
	cW(a){var s,r,q=this,p=q.e;
	if((p&8)!==0)return
	s=(p+128|4)>>>0;
	q.e=s;
	if(p<128){r=q.r;
	if(r!=null)if(r.a===1)r.a=3;}if((p&4)===0&&(s&32)===0)q.bF(q.gcq());},
	aZ(){return this.cW(null)},
	ar(){var s=this,r=s.e;
	if((r&8)!==0)return
	if(r>=128){r=s.e=r-128;
	if(r<128)if((r&64)!==0&&s.r.c!=null)s.r.b1(s);
	else {r=(r&4294967291)>>>0;
	s.e=r;
	if((r&32)===0)s.bF(s.gcr());}}},
	K(){var s=this,r=(s.e&4294967279)>>>0;
	s.e=r;
	if((r&8)===0)s.bw();
	r=s.f;
	return r==null?$.h0():r},
	bw(){var s,r=this,q=r.e=(r.e|8)>>>0;
	if((q&64)!==0){s=r.r;
	if(s.a===1)s.a=3;}if((q&32)===0)r.r=null;
	r.f=r.cp();},
	aJ(a){var s=this.e;
	if((s&8)!==0)return
	if(s<32)this.aC(a);
	else this.az(new A.cG(a));},
	b3(a,b){var s=this.e;
	if((s&8)!==0)return
	if(s<32)this.aP(a,b);
	else this.az(new A.dY(a,b));},
	dn(){var s=this,r=s.e;
	if((r&8)!==0)return
	r=(r|2)>>>0;
	s.e=r;
	if(r<32)s.aO();
	else s.az(B.M);},
	b9(){},
	ba(){},
	cp(){return null},
	az(a){var s,r=this,q=r.r;
	if(q==null)q=r.r=new A.eb();
	q.C(0,a);
	s=r.e;
	if((s&64)===0){s=(s|64)>>>0;
	r.e=s;
	if(s<128)q.b1(r);}},
	aC(a){var s=this,r=s.e;
	s.e=(r|32)>>>0;
	s.d.d0(s.a,a);
	s.e=(s.e&4294967263)>>>0;
	s.bx((r&4)!==0);},
	aP(a,b){var s,r=this,q=r.e,p=new A.m0(r,a,b);
	if((q&1)!==0){r.e=(q|16)>>>0;
	r.bw();
	s=r.f;
	if(s!=null&&s!==$.h0())s.bp(p);
	else p.$0();}else {p.$0();
	r.bx((q&4)!==0);}},
	aO(){var s,r=this,q=new A.m_(r);
	r.bw();
	r.e=(r.e|16)>>>0;
	s=r.f;
	if(s!=null&&s!==$.h0())s.bp(q);
	else q.$0();},
	bF(a){var s=this,r=s.e;
	s.e=(r|32)>>>0;
	a.$0();
	s.e=(s.e&4294967263)>>>0;
	s.bx((r&4)!==0);},
	bx(a){var s,r,q=this,p=q.e;
	if((p&64)!==0&&q.r.c==null){p=q.e=(p&4294967231)>>>0;
	if((p&4)!==0)if(p<128){s=q.r;
	s=s==null?null:s.c==null;
	s=s!==!1;}else s=!1;
	else s=!1;
	if(s){p=(p&4294967291)>>>0;
	q.e=p;}}for(;!0;a=r){if((p&8)!==0){q.r=null;
	return}r=(p&4)!==0;
	if(a===r)break
	q.e=(p^32)>>>0;
	if(r)q.b9();
	else q.ba();
	p=(q.e&4294967263)>>>0;
	q.e=p;}if((p&64)!==0&&p<128)q.r.b1(q);}};
	A.m0.prototype={
	$0(){var s,r,q=this.a,p=q.e;
	if((p&8)!==0&&(p&16)===0)return
	q.e=(p|32)>>>0;
	s=q.b;
	p=this.b;
	r=q.d;
	if(t.k.b(s))r.eo(s,p,this.c);
	else r.d0(s,p);
	q.e=(q.e&4294967263)>>>0;},
	$S:1};
	A.m_.prototype={
	$0(){var s=this.a,r=s.e;
	if((r&16)===0)return
	s.e=(r|42)>>>0;
	s.d.d_(s.c);
	s.e=(s.e&4294967263)>>>0;},
	$S:1};
	A.ee.prototype={
	bU(a,b,c,d){return this.a.dV(a,d,c,b===!0)},
	bT(a,b,c){return this.bU(a,null,b,c)},
	ea(a,b){return this.bU(a,null,b,null)}};
	A.fI.prototype={
	gaG(){return this.a},
	saG(a){return this.a=a}};
	A.cG.prototype={
	bY(a){a.aC(this.b);}};
	A.dY.prototype={
	bY(a){a.aP(this.b,this.c);}};
	A.m1.prototype={
	bY(a){a.aO();},
	gaG(){return null},
	saG(a){throw A.d(A.d2("No events after a done."))}};
	A.eb.prototype={
	b1(a){var s=this,r=s.a;
	if(r===1)return
	if(r>=1){s.a=1;
	return}A.q_(new A.ml(s,a));
	s.a=1;},
	C(a,b){var s=this,r=s.c;
	if(r==null)s.b=s.c=b;
	else {r.saG(b);
	s.c=b;}}};
	A.ml.prototype={
	$0(){var s,r,q=this.a,p=q.a;
	q.a=0;
	if(p===3)return
	s=q.b;
	r=s.gaG();
	q.b=r;
	if(r==null)q.c=null;
	s.bY(this.b);},
	$S:1};
	A.fQ.prototype={};
	A.mw.prototype={};
	A.mK.prototype={
	$0(){A.u8(this.a,this.b);
	A.bg(u.g);},
	$S:1};
	A.mn.prototype={
	d_(a){var s,r;
	try{if(B.i===$.B){a.$0();
	return}A.pC(null,null,this,a);}catch(q){s=A.M(q);
	r=A.aS(q);
	A.dh(s,r);}},
	eq(a,b){var s,r;
	try{if(B.i===$.B){a.$1(b);
	return}A.pE(null,null,this,a,b);}catch(q){s=A.M(q);
	r=A.aS(q);
	A.dh(s,r);}},
	d0(a,b){return this.eq(a,b,t.z)},
	en(a,b,c){var s,r;
	try{if(B.i===$.B){a.$2(b,c);
	return}A.pD(null,null,this,a,b,c);}catch(q){s=A.M(q);
	r=A.aS(q);
	A.dh(s,r);}},
	eo(a,b,c){return this.en(a,b,c,t.z,t.z)},
	cB(a){return new A.mo(this,a)},
	ek(a){if($.B===B.i)return a.$0()
	return A.pC(null,null,this,a)},
	cZ(a){return this.ek(a,t.z)},
	ep(a,b){if($.B===B.i)return a.$1(b)
	return A.pE(null,null,this,a,b)},
	c2(a,b){return this.ep(a,b,t.z,t.z)},
	em(a,b,c){if($.B===B.i)return a.$2(b,c)
	return A.pD(null,null,this,a,b,c)},
	el(a,b,c){return this.em(a,b,c,t.z,t.z,t.z)},
	eh(a){return a},
	c1(a){return this.eh(a,t.z,t.z,t.z)}};
	A.mo.prototype={
	$0(){return this.a.d_(this.b)},
	$S:1};
	A.e1.prototype={
	gj(a){return this.a},
	gA(a){return this.a===0},
	gN(){return new A.e2(this,this.$ti.h("e2<1>"))},
	v(a){var s,r;
	if(typeof a=="string"&&a!=="__proto__"){s=this.b;
	return s==null?!1:s[a]!=null}else if(typeof a=="number"&&(a&1073741823)===a){r=this.c;
	return r==null?!1:r[a]!=null}else return this.dt(a)},
	dt(a){var s=this.d;
	if(s==null)return !1
	return this.an(this.cl(s,a),a)>=0},
	i(a,b){var s,r,q;
	if(typeof b=="string"&&b!=="__proto__"){s=this.b;
	r=s==null?null:A.pe(s,b);
	return r}else if(typeof b=="number"&&(b&1073741823)===b){q=this.c;
	r=q==null?null:A.pe(q,b);
	return r}else return this.dw(b)},
	dw(a){var s,r,q=this.d;
	if(q==null)return null
	s=this.cl(q,a);
	r=this.an(s,a);
	return r<0?null:s[r+1]},
	m(a,b,c){var s,r,q,p,o,n=this;
	if(typeof b=="string"&&b!=="__proto__"){s=n.b;
	n.dj(s==null?n.b=A.pf():s,b,c);}else {r=n.d;
	if(r==null)r=n.d=A.pf();
	q=A.fZ(b)&1073741823;
	p=r[q];
	if(p==null){A.nA(r,q,[b,c]);++n.a;
	n.e=null;}else {o=n.an(p,b);
	if(o>=0)p[o+1]=c;
	else {p.push(b,c);++n.a;
	n.e=null;}}}},
	M(a,b){var s,r,q,p=this,o=p.cj();
	for(s=o.length,r=0;r<s;++r){q=o[r];
	b.$2(q,p.i(0,q));
	if(o!==p.e)throw A.d(A.ag(p))}},
	cj(){var s,r,q,p,o,n,m,l,k,j,i=this,h=i.e;
	if(h!=null)return h
	h=A.U(i.a,null,!1,t.z);
	s=i.b;
	if(s!=null){r=Object.getOwnPropertyNames(s);
	q=r.length;
	for(p=0,o=0;o<q;++o){h[p]=r[o];++p;}}else p=0;
	n=i.c;
	if(n!=null){r=Object.getOwnPropertyNames(n);
	q=r.length;
	for(o=0;o<q;++o){h[p]=+r[o];++p;}}m=i.d;
	if(m!=null){r=Object.getOwnPropertyNames(m);
	q=r.length;
	for(o=0;o<q;++o){l=m[r[o]];
	k=l.length;
	for(j=0;j<k;j+=2){h[p]=l[j];++p;}}}return i.e=h},
	dj(a,b,c){if(a[b]==null){++this.a;
	this.e=null;}A.nA(a,b,c);},
	cl(a,b){return a[A.fZ(b)&1073741823]}};
	A.e4.prototype={
	an(a,b){var s,r,q;
	if(a==null)return -1
	s=a.length;
	for(r=0;r<s;r+=2){q=a[r];
	if(q==null?b==null:q===b)return r}return -1}};
	A.e2.prototype={
	gj(a){return this.a.a},
	gA(a){return this.a.a===0},
	gH(a){var s=this.a;
	return new A.e3(s,s.cj(),this.$ti.h("e3<1>"))},
	G(a,b){return this.a.v(b)}};
	A.e3.prototype={
	gt(){return this.d},
	q(){var s=this,r=s.b,q=s.c,p=s.a;
	if(r!==p.e)throw A.d(A.ag(p))
	else if(q>=r.length){s.d=null;
	return !1}else {s.d=r[q];
	s.c=q+1;
	return !0}},
	$iP:1};
	A.e5.prototype={
	i(a,b){if(!this.y.$1(b))return null
	return this.d8(b)},
	m(a,b,c){this.d9(b,c);},
	v(a){if(!this.y.$1(a))return !1
	return this.d7(a)},
	bh(a){return this.x.$1(a)&1073741823},
	bi(a,b){var s,r,q;
	if(a==null)return -1
	s=a.length;
	for(r=this.w,q=0;q<s;++q)if(r.$2(a[q].a,b))return q
	return -1}};
	A.mi.prototype={
	$1(a){return this.a.b(a)},
	$S:63};
	A.b_.prototype={
	gH(a){var s=this,r=new A.cH(s,s.r,A.A(s).h("cH<1>"));
	r.c=s.e;
	return r},
	gj(a){return this.a},
	gA(a){return this.a===0},
	ga8(a){return this.a!==0},
	G(a,b){var s,r;
	if(typeof b=="string"&&b!=="__proto__"){s=this.b;
	if(s==null)return !1
	return s[b]!=null}else if(typeof b=="number"&&(b&1073741823)===b){r=this.c;
	if(r==null)return !1
	return r[b]!=null}else return this.ds(b)},
	ds(a){var s=this.d;
	if(s==null)return !1
	return this.an(s[this.bB(a)],a)>=0},
	C(a,b){var s,r,q=this;
	if(typeof b=="string"&&b!=="__proto__"){s=q.b;
	return q.cc(s==null?q.b=A.nC():s,b)}else if(typeof b=="number"&&(b&1073741823)===b){r=q.c;
	return q.cc(r==null?q.c=A.nC():r,b)}else return q.dh(b)},
	dh(a){var s,r,q=this,p=q.d;
	if(p==null)p=q.d=A.nC();
	s=q.bB(a);
	r=p[s];
	if(r==null)p[s]=[q.bz(a)];
	else {if(q.an(r,a)>=0)return !1
	r.push(q.bz(a));}return !0},
	ei(a,b){var s=this;
	if(typeof b=="string"&&b!=="__proto__")return s.ct(s.b,b)
	else if(typeof b=="number"&&(b&1073741823)===b)return s.ct(s.c,b)
	else return s.dO(b)},
	dO(a){var s,r,q,p,o=this,n=o.d;
	if(n==null)return !1
	s=o.bB(a);
	r=n[s];
	q=o.an(r,a);
	if(q<0)return !1
	p=r.splice(q,1)[0];
	if(0===r.length)delete n[s];
	o.cA(p);
	return !0},
	dv(a,b){var s,r,q,p,o=this,n=o.e;
	for(;n!=null;n=r){s=n.a;
	r=n.b;
	q=o.r;
	p=a.$1(s);
	if(q!==o.r)throw A.d(A.ag(o))
	if(!1===p)o.ei(0,s);}},
	P(a){var s=this;
	if(s.a>0){s.b=s.c=s.d=s.e=s.f=null;
	s.a=0;
	s.bG();}},
	cc(a,b){if(a[b]!=null)return !1
	a[b]=this.bz(b);
	return !0},
	ct(a,b){var s;
	if(a==null)return !1
	s=a[b];
	if(s==null)return !1
	this.cA(s);
	delete a[b];
	return !0},
	bG(){this.r=this.r+1&1073741823;},
	bz(a){var s,r=this,q=new A.mj(a);
	if(r.e==null)r.e=r.f=q;
	else {s=r.f;
	s.toString;
	q.c=s;
	r.f=s.b=q;}++r.a;
	r.bG();
	return q},
	cA(a){var s=this,r=a.c,q=a.b;
	if(r==null)s.e=q;
	else r.b=q;
	if(q==null)s.f=r;
	else q.c=r;--s.a;
	s.bG();},
	bB(a){return J.bY(a)&1073741823},
	an(a,b){var s,r;
	if(a==null)return -1
	s=a.length;
	for(r=0;r<s;++r)if(J.af(a[r].a,b))return r
	return -1}};
	A.mj.prototype={};
	A.cH.prototype={
	gt(){return this.d},
	q(){var s=this,r=s.c,q=s.a;
	if(s.b!==q.r)throw A.d(A.ag(q))
	else if(r==null){s.d=null;
	return !1}else {s.d=r.a;
	s.c=r.b;
	return !0}},
	$iP:1};
	A.aX.prototype={
	aj(a,b){return new A.aX(J.nn(this.a,b),b.h("aX<0>"))},
	gj(a){return J.a3(this.a)},
	i(a,b){return J.eD(this.a,b)}};
	A.dw.prototype={};
	A.dA.prototype={$iq:1,$ij:1,$io:1};
	A.p.prototype={
	gH(a){return new A.aa(a,this.gj(a),A.ak(a).h("aa<p.E>"))},
	V(a,b){return this.i(a,b)},
	gA(a){return this.gj(a)===0},
	ga8(a){return !this.gA(a)},
	gcH(a){if(this.gj(a)===0)throw A.d(A.nq())
	return this.i(a,0)},
	G(a,b){var s,r=this.gj(a);
	for(s=0;s<r;++s){if(J.af(this.i(a,s),b))return !0
	if(r!==this.gj(a))throw A.d(A.ag(a))}return !1},
	be(a,b){var s,r=this.gj(a);
	for(s=0;s<r;++s){if(!b.$1(this.i(a,s)))return !1
	if(r!==this.gj(a))throw A.d(A.ag(a))}return !0},
	aR(a,b){var s,r=this.gj(a);
	for(s=0;s<r;++s){if(b.$1(this.i(a,s)))return !0
	if(r!==this.gj(a))throw A.d(A.ag(a))}return !1},
	al(a,b,c){return new A.ab(a,b,A.ak(a).h("@<p.E>").I(c).h("ab<1,2>"))},
	a6(a,b){return A.dQ(a,b,null,A.ak(a).h("p.E"))},
	b_(a,b){var s,r,q,p,o=this;
	if(o.gA(a)){s=J.b8(0,A.ak(a).h("p.E"));
	return s}r=o.i(a,0);
	q=A.U(o.gj(a),r,!1,A.ak(a).h("p.E"));
	for(p=1;p<o.gj(a);++p)q[p]=o.i(a,p);
	return q},
	c3(a){var s,r=A.oH(A.ak(a).h("p.E"));
	for(s=0;s<this.gj(a);++s)r.C(0,this.i(a,s));
	return r},
	C(a,b){var s=this.gj(a);
	this.sj(a,s+1);
	this.m(a,s,b);},
	aj(a,b){return new A.b5(a,A.ak(a).h("@<p.E>").I(b).h("b5<1,2>"))},
	a1(a,b,c){var s=this.gj(a);
	A.aQ(b,c,s);
	return A.uK(this.b0(a,b,c),A.ak(a).h("p.E"))},
	b0(a,b,c){A.aQ(b,c,this.gj(a));
	return A.dQ(a,b,c,A.ak(a).h("p.E"))},
	e5(a,b,c,d){var s;
	A.aQ(b,c,this.gj(a));
	for(s=b;s<c;++s)this.m(a,s,d);},
	a5(a,b,c,d,e){var s,r,q,p,o;
	A.aQ(b,c,this.gj(a));
	s=c-b;
	if(s===0)return
	A.aW(e,"skipCount");
	if(A.ak(a).h("o<p.E>").b(d)){r=e;
	q=d;}else {q=J.op(d,e).b_(0,!1);
	r=0;}p=J.V(q);
	if(r+s>p.gj(q))throw A.d(A.ui())
	if(r<b)for(o=s-1;o>=0;--o)this.m(a,b+o,p.i(q,r+o));
	else for(o=0;o<s;++o)this.m(a,b+o,p.i(q,r+o));},
	bR(a,b){var s;
	for(s=0;s<this.gj(a);++s)if(J.af(this.i(a,s),b))return s
	return -1},
	k(a){return A.iI(a,"[","]")}};
	A.dB.prototype={};
	A.jO.prototype={
	$2(a,b){var s,r=this.a;
	if(!r.a)this.b.a+=", ";
	r.a=!1;
	r=this.b;
	s=r.a+=A.b(a);
	r.a=s+": ";
	r.a+=A.b(b);},
	$S:64};
	A.I.prototype={
	ak(a,b,c){var s=A.A(this);
	return A.oK(this,s.h("I.K"),s.h("I.V"),b,c)},
	M(a,b){var s,r;
	for(s=this.gN(),s=s.gH(s);s.q();){r=s.gt();
	b.$2(r,this.i(0,r));}},
	ge4(){return this.gN().al(0,new A.jP(this),A.A(this).h("cY<I.K,I.V>"))},
	v(a){return this.gN().G(0,a)},
	gj(a){var s=this.gN();
	return s.gj(s)},
	gA(a){var s=this.gN();
	return s.gA(s)},
	k(a){return A.nv(this)},
	$ih:1};
	A.jP.prototype={
	$1(a){var s=this.a,r=A.A(s);
	return new A.cY(a,s.i(0,a),r.h("@<I.K>").I(r.h("I.V")).h("cY<1,2>"))},
	$S(){return A.A(this.a).h("cY<I.K,I.V>(I.K)")}};
	A.fU.prototype={
	m(a,b,c){throw A.d(A.ad("Cannot modify unmodifiable map"))}};
	A.dC.prototype={
	ak(a,b,c){return this.a.ak(0,b,c)},
	i(a,b){return this.a.i(0,b)},
	m(a,b,c){this.a.m(0,b,c);},
	v(a){return this.a.v(a)},
	M(a,b){this.a.M(0,b);},
	gA(a){var s=this.a;
	return s.gA(s)},
	gj(a){var s=this.a;
	return s.gj(s)},
	gN(){return this.a.gN()},
	k(a){return this.a.k(0)},
	$ih:1};
	A.bm.prototype={
	ak(a,b,c){return new A.bm(this.a.ak(0,b,c),b.h("@<0>").I(c).h("bm<1,2>"))}};
	A.dM.prototype={
	gA(a){return this.a===0},
	ga8(a){return this.a!==0},
	D(a,b){var s;
	for(s=J.aA(b);s.q();)this.C(0,s.gt());},
	al(a,b,c){return new A.c9(this,b,A.A(this).h("@<1>").I(c).h("c9<1,2>"))},
	k(a){return A.iI(this,"{","}")},
	be(a,b){var s;
	for(s=A.nB(this,this.r,A.A(this).c);s.q();)if(!b.$1(s.d))return !1
	return !0},
	a6(a,b){return A.p0(this,b,A.A(this).c)},
	bf(a,b,c){var s,r;
	for(s=A.nB(this,this.r,A.A(this).c);s.q();){r=s.d;
	if(b.$1(r))return r}return c.$0()},
	V(a,b){var s,r,q,p=this,o="index";
	A.bU(b,o,t.S);
	A.aW(b,o);
	for(s=A.nB(p,p.r,A.A(p).c),r=0;s.q();){q=s.d;
	if(b===r)return q;++r;}throw A.d(A.eW(b,r,p,null,o))}};
	A.ec.prototype={$iq:1,$ij:1,$id1:1};
	A.e6.prototype={};
	A.em.prototype={};
	A.eq.prototype={};
	A.fM.prototype={
	i(a,b){var s,r=this.b;
	if(r==null)return this.c.i(0,b)
	else if(typeof b!="string")return null
	else {s=r[b];
	return typeof s=="undefined"?this.dM(b):s}},
	gj(a){return this.b==null?this.c.a:this.aL().length},
	gA(a){return this.gj(this)===0},
	gN(){if(this.b==null){var s=this.c;
	return new A.aO(s,A.A(s).h("aO<1>"))}return new A.fN(this)},
	m(a,b,c){var s,r,q=this;
	if(q.b==null)q.c.m(0,b,c);
	else if(q.v(b)){s=q.b;
	s[b]=c;
	r=q.a;
	if(r==null?s!=null:r!==s)r[b]=null;}else q.dW().m(0,b,c);},
	v(a){if(this.b==null)return this.c.v(a)
	if(typeof a!="string")return !1
	return Object.prototype.hasOwnProperty.call(this.a,a)},
	M(a,b){var s,r,q,p,o=this;
	if(o.b==null)return o.c.M(0,b)
	s=o.aL();
	for(r=0;r<s.length;++r){q=s[r];
	p=o.b[q];
	if(typeof p=="undefined"){p=A.mA(o.a[q]);
	o.b[q]=p;}b.$2(q,p);
	if(s!==o.c)throw A.d(A.ag(o))}},
	aL(){var s=this.c;
	if(s==null)s=this.c=A.a(Object.keys(this.a),t.s);
	return s},
	dW(){var s,r,q,p,o,n=this;
	if(n.b==null)return n.c
	s=A.a9(t.R,t.z);
	r=n.aL();
	for(q=0;p=r.length,q<p;++q){o=r[q];
	s.m(0,o,n.i(0,o));}if(p===0)r.push("");
	else B.d.P(r);
	n.a=n.b=null;
	return n.c=s},
	dM(a){var s;
	if(!Object.prototype.hasOwnProperty.call(this.a,a))return null
	s=A.mA(this.a[a]);
	return this.b[a]=s}};
	A.fN.prototype={
	gj(a){var s=this.a;
	return s.gj(s)},
	V(a,b){var s=this.a;
	return s.b==null?s.gN().V(0,b):s.aL()[b]},
	gH(a){var s=this.a;
	if(s.b==null){s=s.gN();
	s=s.gH(s);}else {s=s.aL();
	s=new J.b4(s,s.length,A.a_(s).h("b4<1>"));}return s},
	G(a,b){return this.a.v(b)}};
	A.mh.prototype={
	a7(){var s,r,q,p=this;
	p.de();
	s=p.a;
	r=s.a;
	s.a="";
	s=p.c;
	q=s.b;
	q.push(A.pB(r.charCodeAt(0)==0?r:r,p.b));
	s.a.$1(q);}};
	A.lD.prototype={
	$0(){var s;
	try{s=new TextDecoder("utf-8",{fatal:true});
	return s}catch(r){}return null},
	$S:7};
	A.lC.prototype={
	$0(){var s;
	try{s=new TextDecoder("utf-8",{fatal:false});
	return s}catch(r){}return null},
	$S:7};
	A.ha.prototype={
	ee(a,b,a0){var s,r,q,p,o,n,m,l,k,j,i,h,g,f,e,d,c="Invalid base64 encoding length ";
	a0=A.aQ(b,a0,a.length);
	s=$.ok();
	for(r=b,q=r,p=null,o=-1,n=-1,m=0;r<a0;r=l){l=r+1;
	k=B.a.J(a,r);
	if(k===37){j=l+2;
	if(j<=a0){i=A.pW(a,l);
	if(i===37)i=-1;
	l=j;}else i=-1;}else i=k;
	if(0<=i&&i<=127){h=s[i];
	if(h>=0){i=B.a.B("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",h);
	if(i===k)continue
	k=i;}else {if(h===-1){if(o<0){g=p==null?null:p.a.length;
	if(g==null)g=0;
	o=g+(r-q);
	n=r;}++m;
	if(k===61)continue}k=i;}if(h!==-2){if(p==null){p=new A.ac("");
	g=p;}else g=p;
	f=g.a+=B.a.u(a,q,r);
	g.a=f+A.be(k);
	q=l;
	continue}}throw A.d(A.R("Invalid base64 data",a,r))}if(p!=null){g=p.a+=B.a.u(a,q,a0);
	f=g.length;
	if(o>=0)A.os(a,n,a0,o,m,f);
	else {e=B.c.br(f-1,4)+1;
	if(e===1)throw A.d(A.R(c,a,a0))
	for(;e<4;){g+="=";
	p.a=g;++e;}}g=p.a;
	return B.a.aH(a,b,a0,g.charCodeAt(0)==0?g:g)}d=a0-b;
	if(o>=0)A.os(a,n,a0,o,m,d);
	else {e=B.c.br(d,4);
	if(e===1)throw A.d(A.R(c,a,a0))
	if(e>1)a=B.a.aH(a,a0,a0,e===2?"==":"=");}return a}};
	A.hc.prototype={};
	A.hb.prototype={
	e0(a,b){var s,r,q,p=A.aQ(b,null,a.length);
	if(b===p)return new Uint8Array(0)
	s=new A.lZ();
	r=s.e2(a,b,p);
	r.toString;
	q=s.a;
	if(q<-1)A.Z(A.R("Missing padding character",a,p));
	if(q>0)A.Z(A.R("Invalid length, must be multiple of four",a,p));
	s.a=-1;
	return r}};
	A.lZ.prototype={
	e2(a,b,c){var s,r=this,q=r.a;
	if(q<0){r.a=A.pc(a,b,c,q);
	return null}if(b===c)return new Uint8Array(0)
	s=A.vk(a,b,c,q);
	r.a=A.vm(a,b,c,s,0,r.a);
	return s}};
	A.hd.prototype={};
	A.eJ.prototype={};
	A.fO.prototype={};
	A.eN.prototype={};
	A.eP.prototype={};
	A.hW.prototype={};
	A.iQ.prototype={
	e1(a){var s=A.pB(a,this.gcF().a);
	return s},
	gcF(){return B.c4}};
	A.iR.prototype={};
	A.lr.prototype={};
	A.ls.prototype={};
	A.ef.prototype={
	a7(){}};
	A.mu.prototype={
	a7(){this.a.e6(this.c);
	this.b.a7();},
	dX(a,b,c,d){this.c.a+=this.a.cE(a,b,c,!1);}};
	A.lA.prototype={};
	A.lB.prototype={
	e_(a){var s=this.a,r=A.ve(s,a,0,null);
	if(r!=null)return r
	return new A.fV(s).cE(a,0,null,!0)}};
	A.fV.prototype={
	cE(a,b,c,d){var s,r,q,p,o,n=this,m=A.aQ(b,c,J.a3(a));
	if(b===m)return ""
	if(t.gc.b(a)){s=a;
	r=0;}else {s=A.vZ(a,b,m);
	m-=b;
	r=b;
	b=0;}q=n.bC(s,b,m,d);
	p=n.b;
	if((p&1)!==0){o=A.ps(p);
	n.b=0;
	throw A.d(A.R(o,a,r+n.c))}return q},
	bC(a,b,c,d){var s,r,q=this;
	if(c-b>1000){s=B.c.bJ(b+c,2);
	r=q.bC(a,b,s,!1);
	if((q.b&1)!==0)return r
	return r+q.bC(a,s,c,d)}return q.e3(a,b,c,d)},
	e6(a){var s=this.b;
	this.b=0;
	if(s<=32)return
	if(this.a)a.a+=A.be(65533);
	else throw A.d(A.R(A.ps(77),null,null))},
	e3(a,b,c,d){var s,r,q,p,o,n,m,l=this,k=65533,j=l.b,i=l.c,h=new A.ac(""),g=b+1,f=a[b];
	$label0$0:for(s=l.a;!0;){for(;!0;g=p){r=B.a.J("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFFFFFFFFFFFFFFFFGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHHHHHHHHIHHHJEEBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBKCCCCCCCCCCCCDCLONNNMEEEEEEEEEEE",f)&31;
	i=j<=32?f&61694>>>r:(f&63|i<<6)>>>0;
	j=B.a.J(" \x000:XECCCCCN:lDb \x000:XECCCCCNvlDb \x000:XECCCCCN:lDb AAAAA\x00\x00\x00\x00\x00AAAAA00000AAAAA:::::AAAAAGG000AAAAA00KKKAAAAAG::::AAAAA:IIIIAAAAA000\x800AAAAA\x00\x00\x00\x00 AAAAA",j+r);
	if(j===0){h.a+=A.be(i);
	if(g===c)break $label0$0
	break}else if((j&1)!==0){if(s)switch(j){case 69:case 67:h.a+=A.be(k);
	break
	case 65:h.a+=A.be(k);--g;
	break
	default:q=h.a+=A.be(k);
	h.a=q+A.be(k);
	break}else {l.b=j;
	l.c=g-1;
	return ""}j=0;}if(g===c)break $label0$0
	p=g+1;
	f=a[g];}p=g+1;
	f=a[g];
	if(f<128){while(!0){if(!(p<c)){o=c;
	break}n=p+1;
	f=a[p];
	if(f>=128){o=n-1;
	p=n;
	break}p=n;}if(o-g<20)for(m=g;m<o;++m)h.a+=A.be(a[m]);
	else h.a+=A.p2(a,g,o);
	if(o===c)break $label0$0
	g=p;}else g=p;}if(d&&j>32)if(s)h.a+=A.be(k);
	else {l.b=77;
	l.c=c;
	return ""}l.b=j;
	l.c=i;
	s=h.a;
	return s.charCodeAt(0)==0?s:s}};
	A.k2.prototype={
	$2(a,b){var s=this.b,r=this.a,q=s.a+=r.a;
	q+=A.b(a.a);
	s.a=q;
	s.a=q+": ";
	s.a+=A.cS(b);
	r.a=", ";},
	$S:75};
	A.dp.prototype={
	O(a,b){if(b==null)return !1
	return b instanceof A.dp&&this.a===b.a&&this.b===b.b},
	gE(a){var s=this.a;
	return (s^B.c.ai(s,30))&1073741823},
	ew(){var s,r;
	if(this.b)return this
	s=this.a;
	if(Math.abs(s)<=864e13)r=!1;
	else r=!0;
	if(r)A.Z(A.K("DateTime is outside valid range: "+s,null));
	A.bU(!0,"isUtc",t.y);
	return new A.dp(s,!0)},
	k(a){var s=this,r=A.oy(A.fk(s)),q=A.b6(A.oW(s)),p=A.b6(A.oS(s)),o=A.b6(A.oT(s)),n=A.b6(A.oV(s)),m=A.b6(A.oX(s)),l=A.oz(A.oU(s)),k=r+"-"+q;
	if(s.b)return k+"-"+p+" "+o+":"+n+":"+m+"."+l+"Z"
	else return k+"-"+p+" "+o+":"+n+":"+m+"."+l},
	ev(){var s=this,r=A.fk(s)>=-9999&&A.fk(s)<=9999?A.oy(A.fk(s)):A.u5(A.fk(s)),q=A.b6(A.oW(s)),p=A.b6(A.oS(s)),o=A.b6(A.oT(s)),n=A.b6(A.oV(s)),m=A.b6(A.oX(s)),l=A.oz(A.oU(s)),k=r+"-"+q;
	if(s.b)return k+"-"+p+"T"+o+":"+n+":"+m+"."+l+"Z"
	else return k+"-"+p+"T"+o+":"+n+":"+m+"."+l}};
	A.m2.prototype={
	k(a){return this.aB()}};
	A.H.prototype={
	gb2(){return A.aS(this.$thrownJsError)}};
	A.eF.prototype={
	k(a){var s=this.a;
	if(s!=null)return "Assertion failed: "+A.cS(s)
	return "Assertion failed"}};
	A.aG.prototype={};
	A.fg.prototype={
	k(a){return "Throw of null."},
	$iaG:1};
	A.at.prototype={
	gbE(){return "Invalid argument"+(!this.a?"(s)":"")},
	gbD(){return ""},
	k(a){var s=this,r=s.c,q=r==null?"":" ("+r+")",p=s.d,o=p==null?"":": "+A.b(p),n=s.gbE()+q+o;
	if(!s.a)return n
	return n+s.gbD()+": "+A.cS(s.gbS())},
	gbS(){return this.b}};
	A.dL.prototype={
	gbS(){return this.b},
	gbE(){return "RangeError"},
	gbD(){var s,r=this.e,q=this.f;
	if(r==null)s=q!=null?": Not less than or equal to "+A.b(q):"";
	else if(q==null)s=": Not greater than or equal to "+A.b(r);
	else if(q>r)s=": Not in inclusive range "+A.b(r)+".."+A.b(q);
	else s=q<r?": Valid value range is empty":": Only valid value is "+A.b(r);
	return s}};
	A.eV.prototype={
	gbS(){return this.b},
	gbE(){return "RangeError"},
	gbD(){if(this.b<0)return ": index must not be negative"
	var s=this.f;
	if(s===0)return ": no indices are valid"
	return ": index should be less than "+s},
	gj(a){return this.f}};
	A.dH.prototype={
	k(a){var s,r,q,p,o,n,m,l,k=this,j={},i=new A.ac("");
	j.a="";
	s=k.c;
	for(r=s.length,q=0,p="",o="";q<r;++q,o=", "){n=s[q];
	i.a=p+o;
	p=i.a+=A.cS(n);
	j.a=", ";}k.d.M(0,new A.k2(j,i));
	m=A.cS(k.a);
	l=i.k(0);
	return "NoSuchMethodError: method not found: '"+A.b(k.b.a)+"'\nReceiver: "+m+"\nArguments: ["+l+"]"}};
	A.fz.prototype={
	k(a){return "Unsupported operation: "+this.a}};
	A.fu.prototype={
	k(a){var s=this.a;
	return s!=null?"UnimplementedError: "+s:"UnimplementedError"}};
	A.bJ.prototype={
	k(a){return "Bad state: "+this.a}};
	A.eO.prototype={
	k(a){var s=this.a;
	if(s==null)return "Concurrent modification during iteration."
	return "Concurrent modification during iteration: "+A.cS(s)+"."}};
	A.fi.prototype={
	k(a){return "Out of Memory"},
	gb2(){return null},
	$iH:1};
	A.dO.prototype={
	k(a){return "Stack Overflow"},
	gb2(){return null},
	$iH:1};
	A.eQ.prototype={
	k(a){var s=this.a;
	return s==null?"Reading static variable during its initialization":"Reading static variable '"+s+"' during its initialization"}};
	A.e_.prototype={
	k(a){return "Exception: "+this.a},
	$ia8:1};
	A.aK.prototype={
	k(a){var s,r,q,p,o,n,m,l,k,j,i,h=this.a,g=h!=null&&""!==h?"FormatException: "+A.b(h):"FormatException",f=this.c,e=this.b;
	if(typeof e=="string"){if(f!=null)s=f<0||f>e.length;
	else s=!1;
	if(s)f=null;
	if(f==null){if(e.length>78)e=B.a.u(e,0,75)+"...";
	return g+"\n"+e}for(r=1,q=0,p=!1,o=0;o<f;++o){n=B.a.J(e,o);
	if(n===10){if(q!==o||!p)++r;
	q=o+1;
	p=!1;}else if(n===13){++r;
	q=o+1;
	p=!0;}}g=r>1?g+(" (at line "+r+", character "+(f-q+1)+")\n"):g+(" (at character "+(f+1)+")\n");
	m=e.length;
	for(o=f;o<m;++o){n=B.a.B(e,o);
	if(n===10||n===13){m=o;
	break}}if(m-q>78)if(f-q<75){l=q+75;
	k=q;
	j="";
	i="...";}else {if(m-f<75){k=m-75;
	l=m;
	i="";}else {k=f-36;
	l=f+36;
	i="...";}j="...";}else {l=m;
	k=q;
	j="";
	i="";}return g+j+B.a.u(e,k,l)+i+"\n"+B.a.bs(" ",f-k+j.length)+"^\n"}else return f!=null?g+(" (at offset "+A.b(f)+")"):g},
	$ia8:1};
	A.j.prototype={
	aj(a,b){return A.he(this,A.A(this).h("j.E"),b)},
	al(a,b,c){return A.jQ(this,b,A.A(this).h("j.E"),c)},
	G(a,b){var s;
	for(s=this.gH(this);s.q();)if(J.af(s.gt(),b))return !0
	return !1},
	aR(a,b){var s;
	for(s=this.gH(this);s.q();)if(b.$1(s.gt()))return !0
	return !1},
	b_(a,b){return A.bc(this,!1,A.A(this).h("j.E"))},
	gj(a){var s,r=this.gH(this);
	for(s=0;r.q();)++s;
	return s},
	gA(a){return !this.gH(this).q()},
	ga8(a){return !this.gA(this)},
	a6(a,b){return A.p0(this,b,A.A(this).h("j.E"))},
	V(a,b){var s,r,q;
	A.aW(b,"index");
	for(s=this.gH(this),r=0;s.q();){q=s.gt();
	if(b===r)return q;++r;}throw A.d(A.eW(b,r,this,null,"index"))},
	k(a){return A.uh(this,"(",")")}};
	A.e0.prototype={
	V(a,b){var s=this.a;
	if(0>b||b>=s)A.Z(A.eW(b,s,this,null,"index"));
	return this.b.$1(b)},
	gj(a){return this.a}};
	A.P.prototype={};
	A.cY.prototype={
	k(a){return "MapEntry("+A.b(this.a)+": "+A.b(this.b)+")"}};
	A.l.prototype={
	gE(a){return A.c.prototype.gE.call(this,this)},
	k(a){return "null"}};
	A.c.prototype={$ic:1,
	O(a,b){return this===b},
	gE(a){return A.d0(this)},
	k(a){return "Instance of '"+A.b(A.ka(this))+"'"},
	bm(a,b){throw A.d(A.uT(this,b.gcT(),b.gcX(),b.gcU(),null))},
	toString(){return this.k(this)}};
	A.fR.prototype={
	k(a){return ""},
	$ian:1};
	A.ac.prototype={
	gj(a){return this.a.length},
	k(a){var s=this.a;
	return s.charCodeAt(0)==0?s:s}};
	A.lx.prototype={
	$2(a,b){throw A.d(A.R("Illegal IPv4 address, "+a,this.a,b))},
	$S:87};
	A.ly.prototype={
	$2(a,b){throw A.d(A.R("Illegal IPv6 address, "+a,this.a,b))},
	$S:88};
	A.lz.prototype={
	$2(a,b){var s;
	if(b-a>4)this.a.$2("an IPv6 part can only contain a maximum of 4 hex digits",a);
	s=A.cM(B.a.u(this.b,a,b),16);
	if(s<0||s>65535)this.a.$2("each part must be in the range of `0x0..0xFFFF`",a);
	return s},
	$S:89};
	A.en.prototype={
	gcw(){var s,r,q,p,o=this,n=o.w;
	if(n===$){s=o.a;
	r=s.length!==0?s+":":"";
	q=o.c;
	p=q==null;
	if(!p||s==="file"){s=r+"//";
	r=o.b;
	if(r.length!==0)s=s+r+"@";
	if(!p)s+=q;
	r=o.d;
	if(r!=null)s=s+":"+A.b(r);}else s=r;
	s+=o.e;
	r=o.f;
	if(r!=null)s=s+"?"+r;
	r=o.r;
	if(r!=null)s=s+"#"+r;
	n!==$&&A.nU("_text");
	n=o.w=s.charCodeAt(0)==0?s:s;}return n},
	gE(a){var s,r=this,q=r.y;
	if(q===$){s=B.a.gE(r.gcw());
	r.y!==$&&A.nU("hashCode");
	r.y=s;
	q=s;}return q},
	gd2(){return this.b},
	gbQ(){var s=this.c;
	if(s==null)return ""
	if(B.a.Y(s,"["))return B.a.u(s,1,s.length-1)
	return s},
	gbZ(){var s=this.d;
	return s==null?A.pm(this.a):s},
	gcY(){var s=this.f;
	return s==null?"":s},
	gcI(){var s=this.r;
	return s==null?"":s},
	gcK(){return this.a.length!==0},
	gbN(){return this.c!=null},
	gbP(){return this.f!=null},
	gbO(){return this.r!=null},
	gcJ(){return B.a.Y(this.e,"/")},
	k(a){return this.gcw()},
	O(a,b){var s,r,q=this;
	if(b==null)return !1
	if(q===b)return !0
	if(t.n.b(b))if(q.a===b.gc8())if(q.c!=null===b.gbN())if(q.b===b.gd2())if(q.gbQ()===b.gbQ())if(q.gbZ()===b.gbZ())if(q.e===b.gcV()){s=q.f;
	r=s==null;
	if(!r===b.gbP()){if(r)s="";
	if(s===b.gcY()){s=q.r;
	r=s==null;
	if(!r===b.gbO()){if(r)s="";
	s=s===b.gcI();}else s=!1;}else s=!1;}else s=!1;}else s=!1;
	else s=!1;
	else s=!1;
	else s=!1;
	else s=!1;
	else s=!1;
	else s=!1;
	return s},
	$iaY:1,
	gc8(){return this.a},
	gcV(){return this.e}};
	A.lv.prototype={
	gbo(a){var s,r,q,p,o=this,n=null,m=o.c;
	if(m==null){m=o.a;
	s=o.b[0]+1;
	r=B.a.bg(m,"?",s);
	q=m.length;
	if(r>=0){p=A.eo(m,r+1,q,B.D,!1,!1);
	q=r;}else p=n;
	m=o.c=new A.fH("data","",n,n,A.eo(m,s,q,B.ax,!1,!1),p,n);}return m},
	gbV(){var s=this.b,r=s[0]+1,q=s[1];
	if(r===q)return "text/plain"
	return A.vY(this.a,r,q,B.ac,!1)},
	cD(){var s,r,q,p,o,n,m,l,k=this.a,j=this.b,i=B.d.gaV(j)+1;
	if((j.length&1)===1)return B.b8.e0(k,i)
	j=k.length;
	s=j-i;
	for(r=i;r<j;++r)if(B.a.B(k,r)===37){r+=2;
	s-=2;}q=new Uint8Array(s);
	if(s===j){B.j.a5(q,0,s,new A.c8(k),i);
	return q}for(r=i,p=0;r<j;++r){o=B.a.B(k,r);
	if(o!==37){n=p+1;
	q[p]=o;}else {m=r+2;
	if(m<j){l=A.pW(k,r+1);
	if(l>=0){n=p+1;
	q[p]=l;
	r=m;
	p=n;
	continue}}throw A.d(A.R("Invalid percent escape",k,r))}p=n;}return q},
	k(a){var s=this.a;
	return this.b[0]===-1?"data:"+s:s}};
	A.mB.prototype={
	$2(a,b){var s=this.a[a];
	B.j.e5(s,0,96,b);
	return s},
	$S:96};
	A.mC.prototype={
	$3(a,b,c){var s,r;
	for(s=b.length,r=0;r<s;++r)a[B.a.J(b,r)^96]=c;},
	$S:17};
	A.mD.prototype={
	$3(a,b,c){var s,r;
	for(s=B.a.J(b,0),r=B.a.J(b,1);s<=r;++s)a[(s^96)>>>0]=c;},
	$S:17};
	A.fP.prototype={
	gcK(){return this.b>0},
	gbN(){return this.c>0},
	gbP(){return this.f<this.r},
	gbO(){return this.r<this.a.length},
	gcJ(){return B.a.U(this.a,"/",this.e)},
	gc8(){var s=this.w;
	return s==null?this.w=this.dr():s},
	dr(){var s,r=this,q=r.b;
	if(q<=0)return ""
	s=q===4;
	if(s&&B.a.Y(r.a,"http"))return "http"
	if(q===5&&B.a.Y(r.a,"https"))return "https"
	if(s&&B.a.Y(r.a,"file"))return "file"
	if(q===7&&B.a.Y(r.a,"package"))return "package"
	return B.a.u(r.a,0,q)},
	gd2(){var s=this.c,r=this.b+3;
	return s>r?B.a.u(this.a,r,s-1):""},
	gbQ(){var s=this.c;
	return s>0?B.a.u(this.a,s,this.d):""},
	gbZ(){var s,r=this;
	if(r.c>0&&r.d+1<r.e)return A.cM(B.a.u(r.a,r.d+1,r.e),null)
	s=r.b;
	if(s===4&&B.a.Y(r.a,"http"))return 80
	if(s===5&&B.a.Y(r.a,"https"))return 443
	return 0},
	gcV(){return B.a.u(this.a,this.e,this.f)},
	gcY(){var s=this.f,r=this.r;
	return s<r?B.a.u(this.a,s+1,r):""},
	gcI(){var s=this.r,r=this.a;
	return s<r.length?B.a.bu(r,s+1):""},
	gE(a){var s=this.x;
	return s==null?this.x=B.a.gE(this.a):s},
	O(a,b){if(b==null)return !1
	if(this===b)return !0
	return t.n.b(b)&&this.a===b.k(0)},
	k(a){return this.a},
	$iaY:1};
	A.fH.prototype={};
	A.mz.prototype={
	$1(a){var s,r,q,p=this.a;
	if(p.v(a))return p.i(0,a)
	if(t.I.b(a)){s={};
	p.m(0,a,s);
	for(p=a.gN(),p=p.gH(p);p.q();){r=p.gt();
	s[r]=this.$1(a.i(0,r));}return s}else if(t.j.b(a)){q=[];
	p.m(0,a,q);
	B.d.D(q,J.bt(a,this,t.z));
	return q}else return a},
	$S:123};
	A.a4.prototype={
	gco(){var s,r=this.y;
	if(r===5121||r===5120){s=this.Q;
	s=s==="MAT2"||s==="MAT3";}else s=!1;
	if(!s)r=(r===5123||r===5122)&&this.Q==="MAT3";
	else r=!0;
	return r},
	gac(){var s=B.m.i(0,this.Q);
	return s==null?0:s},
	gad(){var s=this,r=s.y;
	if(r===5121||r===5120){r=s.Q;
	if(r==="MAT2")return 6
	else if(r==="MAT3")return 11
	return s.gac()}else if(r===5123||r===5122){if(s.Q==="MAT3")return 22
	return 2*s.gac()}return 4*s.gac()},
	gap(){var s=this,r=s.cx;
	if(r!==0)return r
	r=s.y;
	if(r===5121||r===5120){r=s.Q;
	if(r==="MAT2")return 8
	else if(r==="MAT3")return 12
	return s.gac()}else if(r===5123||r===5122){if(s.Q==="MAT3")return 24
	return 2*s.gac()}return 4*s.gac()},
	gaS(){return this.gap()*(this.z-1)+this.gad()},
	p(a,b){var s,r,q,p=this,o="bufferView",n=a.y,m=p.w,l=p.CW=n.i(0,m),k=l==null;
	if(!k&&l.z!==-1)p.cx=l.z;
	if(p.y===-1||p.z===-1||p.Q==null)return
	if(m!==-1)if(k)b.l($.Q(),A.a([m],t.M),o);
	else {l.a$=!0;
	l=l.z;
	if(l!==-1&&l<p.gad())b.F($.qL(),A.a([p.CW.z,p.gad()],t.M));
	A.bu(p.x,p.ch,p.gaS(),p.CW,m,b);}m=p.ay;
	if(m!=null){l=m.d;
	if(l!==-1)k=!1;
	else k=!0;
	if(k)return
	k=b.c;
	k.push("sparse");
	s=p.z;
	if(l>s)b.l($.rw(),A.a([l,s],t.M),"count");
	s=m.f;
	r=s.d;
	s.f=n.i(0,r);
	k.push("indices");
	q=m.e;
	m=q.d;
	if(m!==-1){n=q.r=n.i(0,m);
	if(n==null)b.l($.Q(),A.a([m],t.M),o);
	else {n.T(B.o,o,b);
	if(q.r.z!==-1)b.n($.nj(),o);
	n=q.f;
	if(n!==-1)A.bu(q.e,A.b0(n),A.b0(n)*l,q.r,m,b);}}k.pop();
	k.push("values");
	if(r!==-1){n=s.f;
	if(n==null)b.l($.Q(),A.a([r],t.M),o);
	else {n.T(B.o,o,b);
	if(s.f.z!==-1)b.n($.nj(),o);
	n=p.ch;
	m=B.m.i(0,p.Q);
	if(m==null)m=0;
	A.bu(s.e,n,n*m*l,s.f,r,b);}}k.pop();
	k.pop();}},
	T(a,b,c){var s;
	this.a$=!0;
	s=this.fr;
	if(s==null)this.fr=a;
	else if(s!==a)c.l($.qN(),A.a([s,a],t.M),b);},
	eA(a){var s=this.dy;
	if(s==null)this.dy=a;
	else if(s!==a)return !1
	return !0},
	ef(a){var s,r,q=this;
	if(!q.as||5126===q.y){a.toString;
	return a}s=q.ch*8;
	r=q.y;
	if(r===5120||r===5122||r===5124)return Math.max(a/(B.c.aI(1,s-1)-1),-1)
	else return a/(B.c.aI(1,s)-1)}};
	A.fC.prototype={
	af(){var s=this;
	return A.bS(function(){var r=0,q=2,p,o,n,m,l,k,j,i,h,g,f,e,d,c,b,a,a0;
	return function $async$af(a1,a2){if(a1===1){p=a2;
	r=q;}while(true)switch(r){case 0:a0=s.y;
	if(a0===-1||s.z===-1||s.Q==null){r=1;
	break}o=s.gac();
	n=s.z;
	m=s.CW;
	if(m!=null){m=m.as;
	if((m==null?null:m.z)==null){r=1;
	break}if(s.gap()<s.gad()){r=1;
	break}m=s.x;
	l=s.ch;
	if(!A.bu(m,l,s.gaS(),s.CW,null,null)){r=1;
	break}k=s.CW;
	j=A.or(a0,k.as.z.buffer,k.x+m,B.c.aw(s.gaS(),l));
	if(j==null){r=1;
	break}i=j.length;
	if(s.gco()){m=B.c.aw(s.gap(),l);
	l=s.Q==="MAT2";
	k=l?8:12;
	h=l?2:3;
	g=new A.lR(i,j,h,h,m-k).$0();}else g=new A.lS(j).$3(i,o,B.c.aw(s.gap(),l)-o);}else g=A.oE(n*o,new A.lT(),t.e);
	m=s.ay;
	if(m!=null){l=m.f;
	k=l.e;
	if(k!==-1){f=l.f;
	if(f!=null)if(f.y!==-1)if(f.x!==-1){f=f.as;
	if((f==null?null:f.z)!=null){f=m.e;
	if(f.f!==-1)if(f.e!==-1){f=f.r;
	if(f!=null)if(f.y!==-1)if(f.x!==-1){f=f.as;
	f=(f==null?null:f.z)==null;}else f=!0;
	else f=!0;
	else f=!0;}else f=!0;
	else f=!0;}else f=!0;}else f=!0;
	else f=!0;
	else f=!0;}else f=!0;
	if(f){r=1;
	break}f=m.d;
	if(f>n){r=1;
	break}n=m.e;
	m=n.e;
	e=n.f;
	if(A.bu(m,A.b0(e),A.b0(e)*f,n.r,null,null)){d=s.ch;
	c=B.m.i(0,s.Q);
	if(c==null)c=0;
	c=!A.bu(k,d,d*c*f,l.f,null,null);
	d=c;}else d=!0;
	if(d){r=1;
	break}n=n.r;
	b=A.np(e,n.as.z.buffer,n.x+m,f);
	l=l.f;
	a=A.or(a0,l.as.z.buffer,l.x+k,f*o);
	if(b==null||a==null){r=1;
	break}g=new A.lU(s,b,g,o,a).$0();}r=3;
	return A.mf(g)
	case 3:case 1:return A.bO()
	case 2:return A.bP(p)}}},t.e)},
	bq(){var s=this;
	return A.bS(function(){var r=0,q=1,p,o,n,m,l;
	return function $async$bq(a,b){if(a===1){p=b;
	r=q;}while(true)switch(r){case 0:m=s.ch*8;
	l=s.y;
	l=l===5120||l===5122||l===5124;
	o=t.F;
	r=l?2:4;
	break
	case 2:l=B.c.aI(1,m-1);
	n=s.af();
	n.toString;
	r=5;
	return A.mf(A.jQ(n,new A.lP(1/(l-1)),n.$ti.h("j.E"),o))
	case 5:r=3;
	break
	case 4:l=B.c.aI(1,m);
	n=s.af();
	n.toString;
	r=6;
	return A.mf(A.jQ(n,new A.lQ(1/(l-1)),n.$ti.h("j.E"),o))
	case 6:case 3:return A.bO()
	case 1:return A.bP(p)}}},t.F)}};
	A.lR.prototype={
	$0(){var s=this;
	return A.bS(function(){var r=0,q=1,p,o,n,m,l,k,j,i,h;
	return function $async$$0(a,b){if(a===1){p=b;
	r=q;}while(true)switch(r){case 0:o=s.a,n=s.c,m=s.b,l=s.d,k=s.e,j=0,i=0,h=0;
	case 2:if(!(j<o)){r=3;
	break}r=4;
	return m[j]
	case 4:++j;++i;
	if(i===n){j+=4-i;++h;
	if(h===l){j+=k;
	h=0;}i=0;}r=2;
	break
	case 3:return A.bO()
	case 1:return A.bP(p)}}},t.e)},
	$S:18};
	A.lS.prototype={
	$3(a,b,c){return this.d4(a,b,c)},
	d4(a,b,c){var s=this;
	return A.bS(function(){var r=a,q=b,p=c;
	var o=0,n=1,m,l,k,j;
	return function $async$$3(d,e){if(d===1){m=e;
	o=n;}while(true)switch(o){case 0:l=s.a,k=0,j=0;
	case 2:if(!(k<r)){o=3;
	break}o=4;
	return l[k]
	case 4:++k;++j;
	if(j===q){k+=p;
	j=0;}o=2;
	break
	case 3:return A.bO()
	case 1:return A.bP(m)}}},t.e)},
	$S:31};
	A.lT.prototype={
	$1(a){return 0},
	$S:32};
	A.lU.prototype={
	$0(){var s=this;
	return A.bS(function(){var r=0,q=1,p,o,n,m,l,k,j,i,h,g,f;
	return function $async$$0(a,b){if(a===1){p=b;
	r=q;}while(true)switch(r){case 0:g=s.b;
	f=g[0];
	o=J.aA(s.c),n=s.d,m=s.a.ay,l=s.e,k=0,j=0,i=0;
	case 2:if(!o.q()){r=3;
	break}h=o.gt();
	if(j===n){if(k===f&&i!==m.d-1){++i;
	f=g[i];}++k;
	j=0;}r=k===f?4:6;
	break
	case 4:r=7;
	return l[i*n+j]
	case 7:r=5;
	break
	case 6:r=8;
	return h
	case 8:case 5:++j;
	r=2;
	break
	case 3:return A.bO()
	case 1:return A.bP(p)}}},t.e)},
	$S:18};
	A.lP.prototype={
	$1(a){return Math.max(a*this.a,-1)},
	$S:8};
	A.lQ.prototype={
	$1(a){return a*this.a},
	$S:8};
	A.fB.prototype={
	af(){var s=this;
	return A.bS(function(){var r=0,q=2,p,o,n,m,l,k,j,i,h,g,f,e,d,c,b,a,a0;
	return function $async$af(a1,a2){if(a1===1){p=a2;
	r=q;}while(true)switch(r){case 0:a0=s.y;
	if(a0===-1||s.z===-1||s.Q==null){r=1;
	break}o=s.gac();
	n=s.z;
	m=s.CW;
	if(m!=null){m=m.as;
	if((m==null?null:m.z)==null){r=1;
	break}if(s.gap()<s.gad()){r=1;
	break}m=s.x;
	l=s.ch;
	if(!A.bu(m,l,s.gaS(),s.CW,null,null)){r=1;
	break}k=s.CW;
	j=A.oq(a0,k.as.z.buffer,k.x+m,B.c.aw(s.gaS(),l));
	if(j==null){r=1;
	break}i=j.length;
	if(s.gco()){m=B.c.aw(s.gap(),l);
	l=s.Q==="MAT2";
	k=l?8:12;
	h=l?2:3;
	g=new A.lL(i,j,h,h,m-k).$0();}else g=new A.lM(j).$3(i,o,B.c.aw(s.gap(),l)-o);}else g=A.oE(n*o,new A.lN(),t.F);
	m=s.ay;
	if(m!=null){l=m.f;
	k=l.e;
	if(k!==-1){f=l.f;
	if(f!=null)if(f.y!==-1)if(f.x!==-1){f=f.as;
	if((f==null?null:f.z)!=null){f=m.e;
	if(f.f!==-1)if(f.e!==-1){f=f.r;
	if(f!=null)if(f.y!==-1)if(f.x!==-1){f=f.as;
	f=(f==null?null:f.z)==null;}else f=!0;
	else f=!0;
	else f=!0;}else f=!0;
	else f=!0;}else f=!0;}else f=!0;
	else f=!0;
	else f=!0;}else f=!0;
	if(f){r=1;
	break}f=m.d;
	if(f>n){r=1;
	break}n=m.e;
	m=n.e;
	e=n.f;
	if(A.bu(m,A.b0(e),A.b0(e)*f,n.r,null,null)){d=s.ch;
	c=B.m.i(0,s.Q);
	if(c==null)c=0;
	c=!A.bu(k,d,d*c*f,l.f,null,null);
	d=c;}else d=!0;
	if(d){r=1;
	break}n=n.r;
	b=A.np(e,n.as.z.buffer,n.x+m,f);
	l=l.f;
	a=A.oq(a0,l.as.z.buffer,l.x+k,f*o);
	if(b==null||a==null){r=1;
	break}g=new A.lO(s,b,g,o,a).$0();}r=3;
	return A.mf(g)
	case 3:case 1:return A.bO()
	case 2:return A.bP(p)}}},t.F)},
	bq(){return this.af()}};
	A.lL.prototype={
	$0(){var s=this;
	return A.bS(function(){var r=0,q=1,p,o,n,m,l,k,j,i,h;
	return function $async$$0(a,b){if(a===1){p=b;
	r=q;}while(true)switch(r){case 0:o=s.a,n=s.c,m=s.b,l=s.d,k=s.e,j=0,i=0,h=0;
	case 2:if(!(j<o)){r=3;
	break}r=4;
	return m[j]
	case 4:++j;++i;
	if(i===n){j+=4-i;++h;
	if(h===l){j+=k;
	h=0;}i=0;}r=2;
	break
	case 3:return A.bO()
	case 1:return A.bP(p)}}},t.F)},
	$S:19};
	A.lM.prototype={
	$3(a,b,c){return this.d3(a,b,c)},
	d3(a,b,c){var s=this;
	return A.bS(function(){var r=a,q=b,p=c;
	var o=0,n=1,m,l,k,j;
	return function $async$$3(d,e){if(d===1){m=e;
	o=n;}while(true)switch(o){case 0:l=s.a,k=0,j=0;
	case 2:if(!(k<r)){o=3;
	break}o=4;
	return l[k]
	case 4:++k;++j;
	if(j===q){k+=p;
	j=0;}o=2;
	break
	case 3:return A.bO()
	case 1:return A.bP(m)}}},t.F)},
	$S:35};
	A.lN.prototype={
	$1(a){return 0},
	$S:8};
	A.lO.prototype={
	$0(){var s=this;
	return A.bS(function(){var r=0,q=1,p,o,n,m,l,k,j,i,h,g,f;
	return function $async$$0(a,b){if(a===1){p=b;
	r=q;}while(true)switch(r){case 0:g=s.b;
	f=g[0];
	o=J.aA(s.c),n=s.d,m=s.a.ay,l=s.e,k=0,j=0,i=0;
	case 2:if(!o.q()){r=3;
	break}h=o.gt();
	if(j===n){if(k===f&&i!==m.d-1){++i;
	f=g[i];}++k;
	j=0;}r=k===f?4:6;
	break
	case 4:r=7;
	return l[i*n+j]
	case 7:r=5;
	break
	case 6:r=8;
	return h
	case 8:case 5:++j;
	r=2;
	break
	case 3:return A.bO()
	case 1:return A.bP(p)}}},t.F)},
	$S:19};
	A.bZ.prototype={
	ge8(){var s=this.e,r=s.r,q=r==null?null:r.as;
	if((q==null?null:q.z)==null)return null
	return A.np(s.f,r.as.z.buffer,r.x+s.e,this.d)}};
	A.c_.prototype={
	p(a,b){this.r=a.y.i(0,this.d);}};
	A.c0.prototype={
	p(a,b){this.f=a.y.i(0,this.d);}};
	A.eY.prototype={
	a0(a,b,c,d){d.toString;
	if(d==1/0||d==-1/0||isNaN(d)){a.l($.qa(),A.a([b,d],t.M),this.a);
	return !1}return !0}};
	A.f5.prototype={
	a0(a,b,c,d){var s,r=this;
	if(b===c||r.b[c]>d)r.b[c]=d;
	if(d<r.c[c]){s=r.a;
	s[c]=s[c]+1;}return !0},
	aF(a){var s,r,q,p,o,n,m,l,k,j=this;
	for(s=j.b,r=s.length,q=j.c,p=j.a,o=j.d+"/min/",n=t.M,m=0;m<r;++m)if(!J.af(q[m],s[m])){l=o+m;
	a.l($.o_(),A.a([q[m],s[m]],n),l);
	k=p[m];
	if(k>0)a.l($.nY(),A.a([k,q[m]],n),l);}return !0}};
	A.f3.prototype={
	a0(a,b,c,d){var s,r=this;
	if(b===c||r.b[c]<d)r.b[c]=d;
	if(d>r.c[c]){s=r.a;
	s[c]=s[c]+1;}return !0},
	aF(a){var s,r,q,p,o,n,m,l,k,j=this;
	for(s=j.b,r=s.length,q=j.c,p=j.a,o=j.d+"/max/",n=t.M,m=0;m<r;++m)if(!J.af(q[m],s[m])){l=o+m;
	a.l($.nZ(),A.a([q[m],s[m]],n),l);
	k=p[m];
	if(k>0)a.l($.nX(),A.a([k,q[m]],n),l);}return !0}};
	A.f6.prototype={
	a0(a,b,c,d){var s,r=this;
	if(b===c||r.b[c]>d)r.b[c]=d;
	if(d<r.c[c]){s=r.a;
	s[c]=s[c]+1;}return !0},
	aF(a){var s,r,q,p,o,n,m,l,k,j=this;
	for(s=j.b,r=s.length,q=j.c,p=j.a,o=j.d+"/min/",n=t.M,m=0;m<r;++m)if(!J.af(q[m],s[m])){l=o+m;
	a.l($.o_(),A.a([q[m],s[m]],n),l);
	k=p[m];
	if(k>0)a.l($.nY(),A.a([k,q[m]],n),l);}return !0}};
	A.f4.prototype={
	a0(a,b,c,d){var s,r=this;
	if(b===c||r.b[c]<d)r.b[c]=d;
	if(d>r.c[c]){s=r.a;
	s[c]=s[c]+1;}return !0},
	aF(a){var s,r,q,p,o,n,m,l,k,j=this;
	for(s=j.b,r=s.length,q=j.c,p=j.a,o=j.d+"/max/",n=t.M,m=0;m<r;++m)if(!J.af(q[m],s[m])){l=o+m;
	a.l($.nZ(),A.a([q[m],s[m]],n),l);
	k=p[m];
	if(k>0)a.l($.nX(),A.a([k,q[m]],n),l);}return !0}};
	A.bv.prototype={
	p(a,b){var s,r,q,p,o,n=this,m="samplers",l=n.x;
	if(l==null||n.w==null)return
	s=b.c;
	s.push(m);
	l.a4(new A.h5(b,a));
	s.pop();
	s.push("channels");
	n.w.a4(new A.h6(n,b,a));
	s.pop();
	s.push(m);
	for(r=l.b,l=l.a,q=l.length,p=0;p<r;++p){o=p>=q;
	if(!(o?null:l[p]).a$)b.Z($.h1(),p);}s.pop();}};
	A.h5.prototype={
	$2(a,b){var s,r,q,p,o,n,m="input",l="output",k=this.a,j=k.c;
	j.push(B.c.k(a));
	s=this.b.f;
	r=b.d;
	b.r=s.i(0,r);
	q=b.f;
	b.w=s.i(0,q);
	if(r!==-1){s=b.r;
	if(s==null)k.l($.Q(),A.a([r],t.M),m);
	else {s.T(B.b1,m,k);
	p=b.r.CW;
	if(p!=null){p.T(B.o,m,k);
	s=p.z;
	if(s!==-1)k.n($.o4(),m);}j.push(m);
	o=A.dl(b.r);
	if(!o.O(0,B.G))k.F($.qR(),A.a([o,A.a([B.G],t.p)],t.M));
	else k.a_(b.r,new A.eE(k.S()));
	s=b.r;
	if(s.ax==null||s.at==null)k.L($.qT());
	if(b.e==="CUBICSPLINE"&&b.r.z<2)k.F($.qS(),A.a(["CUBICSPLINE",2,b.r.z],t.M));
	j.pop();}}if(q!==-1){s=b.w;
	if(s==null)k.l($.Q(),A.a([q],t.M),l);
	else {s.T(B.b2,l,k);
	n=b.w.CW;
	if(n!=null){n.T(B.o,l,k);
	s=n.z;
	if(s!==-1)k.n($.o4(),l);}s=b.w.CW;
	if(s!=null)s.T(B.o,l,k);
	b.w.eA("CUBICSPLINE"===b.e);}}j.pop();},
	$S:36};
	A.h6.prototype={
	$2(a,a0){var s,r,q,p,o,n,m,l,k,j,i,h,g,f,e=null,d="sampler",c=this.b,b=c.c;
	b.push(B.c.k(a));
	s=this.a;
	r=a0.d;
	a0.f=s.x.i(0,r);
	q=a0.e;
	p=q!=null;
	if(p){o=q.d;
	q.f=this.c.ax.i(0,o);
	if(o!==-1){b.push("target");
	n=q.f;
	if(n==null)c.l($.Q(),A.a([o],t.M),"node");
	else {n.a$=!0;
	switch(q.e){case"translation":case"rotation":case"scale":if(n.z!=null)c.L($.qO());
	if(q.f.dx!=null)c.n($.rx(),"path");
	break
	case"weights":o=n.cy;
	o=o==null?e:o.w;
	o=o==null?e:o.gcH(o);
	if((o==null?e:o.cx)==null)c.L($.qP());
	break}}b.pop();}}if(r!==-1){o=a0.f;
	if(o==null)c.l($.Q(),A.a([r],t.M),d);
	else {o.a$=!0;
	if(p&&o.w!=null){r=q.e;
	if(r==="rotation"){m=o.w;
	if(m.gac()===4){b.push(d);
	o=c.S();
	n=5126===m.y?e:m.gbX();
	c.a_(m,new A.dK("CUBICSPLINE"===a0.f.e,n,o,t.ed));
	b.pop();}o=a0.f;
	o.w.toString;}l=A.dl(o.w);
	k=B.dt.i(0,r);
	if((k==null?e:B.d.G(k,l))===!1)c.l($.qV(),A.a([l,k,r],t.M),d);
	o=a0.f;
	n=o.r;
	if(n!=null&&n.z!==-1&&o.w.z!==-1&&o.e!=null){j=n.z;
	if(o.e==="CUBICSPLINE")j*=3;
	if(r==="weights"){r=q.f;
	r=r==null?e:r.cy;
	r=r==null?e:r.w;
	r=r==null?e:r.gcH(r);
	r=r==null?e:r.cx;
	i=r==null?e:r.length;
	j*=i==null?0:i;}else if(!B.d.G(B.R,r))j=0;
	if(j!==0&&j!==a0.f.w.z)c.l($.qU(),A.a([j,a0.f.w.z],t.M),d);}}}for(h=a+1,s=s.w,r=s.b,o=t.M,s=s.a,n=s.length;h<r;++h){if(p){g=h>=n;
	f=(g?e:s[h]).e;
	if(f!=null){g=q.d;
	g=g!==-1&&g===f.d&&q.e==f.e;}else g=!1;}else g=!1;
	if(g)c.l($.qQ(),A.a([h],o),"target");}b.pop();}},
	$S:37};
	A.b2.prototype={};
	A.bw.prototype={};
	A.b3.prototype={};
	A.eE.prototype={
	a0(a,b,c,d){var s=this;
	if(d<0)a.l($.q4(),A.a([b,d],t.M),s.b);
	else {if(b!==0&&d<=s.a)a.l($.q5(),A.a([b,d,s.a],t.M),s.b);
	s.a=d;}return !0}};
	A.dK.prototype={
	a0(a,b,c,d){var s,r,q=this;
	if(!q.a||4===(q.d&4)){s=q.b;
	r=s!=null?s.$1(d):d;
	s=q.e+r*r;
	q.e=s;
	if(3===c){if(Math.abs(Math.sqrt(s)-1)>0.00769)a.l($.q6(),A.a([b-3,b,Math.sqrt(q.e)],t.M),q.c);
	q.e=0;}}if(++q.d===12)q.d=0;
	return !0}};
	A.bx.prototype={
	gbj(){var s,r=this.f;
	if(r!=null){s=$.br().b;
	s=!s.test(r);}else s=!0;
	if(s)return 0
	return A.cM($.br().aT(r).b[1],null)},
	gbW(){var s,r=this.f;
	if(r!=null){s=$.br().b;
	s=!s.test(r);}else s=!0;
	if(s)return 0
	return A.cM($.br().aT(r).b[2],null)},
	gcS(){var s,r=this.r;
	if(r!=null){s=$.br().b;
	s=!s.test(r);}else s=!0;
	if(s)return 2
	return A.cM($.br().aT(r).b[1],null)},
	ged(){var s,r=this.r;
	if(r!=null){s=$.br().b;
	s=!s.test(r);}else s=!0;
	if(s)return 0
	return A.cM($.br().aT(r).b[2],null)}};
	A.aT.prototype={};
	A.by.prototype={
	T(a,b,c){var s;
	this.a$=!0;
	s=this.at;
	if(s==null){this.at=a;
	if(a===B.L||a===B.A)c.n($.qX(),b);}else if(s!==a)c.l($.qY(),A.a([s,a],t.M),b);},
	p(a,b){var s,r=this,q=r.w,p=r.as=a.x.i(0,q);
	r.ax=r.z;
	s=r.Q;
	if(s===34962)r.at=B.A;
	else if(s===34963)r.at=B.L;
	if(q!==-1)if(p==null)b.l($.Q(),A.a([q],t.M),"buffer");
	else {p.a$=!0;
	p=p.x;
	if(p!==-1){s=r.x;
	if(s>=p)b.l($.o5(),A.a([q,p],t.M),"byteOffset");
	else if(s+r.y>p)b.l($.o5(),A.a([q,p],t.M),"byteLength");}}}};
	A.bz.prototype={};
	A.c3.prototype={};
	A.c4.prototype={};
	A.du.prototype={
	eC(a){var s,r,q,p,o;
	new A.iz(this,a).$1(this.cy);
	s=a.r;
	for(r=s.length,q=a.c,p=0;p<s.length;s.length===r||(0, A.cN)(s),++p){o=s[p];
	B.d.P(q);
	B.d.D(q,o.b);
	o.a.c4(this,a);}B.d.P(q);}};
	A.iw.prototype={
	$0(){return B.d.P(this.a.c)},
	$S:1};
	A.ix.prototype={
	$1$2(a,b,c){var s,r,q,p,o,n,m,l,k,j=this,i=j.a;
	if(!i.v(a)){i=J.b8(0,c.h("0*"));
	return new A.F(i,0,a,c.h("F<0*>"))}j.b.$0();
	s=i.i(0,a);
	if(t.m.b(s)){i=J.V(s);
	r=j.c;
	q=c.h("0*");
	if(i.ga8(s)){p=i.gj(s);
	q=A.U(p,null,!1,q);
	o=r.c;
	o.push(a);
	for(n=t.M,m=t.t,l=0;l<i.gj(s);++l){k=i.i(s,l);
	if(m.b(k)){o.push(B.c.k(l));
	q[l]=b.$2(k,r);
	o.pop();}else r.ao($.a2(),A.a([k,"object"],n),l);}return new A.F(q,p,a,c.h("F<0*>"))}else {r.n($.bX(),a);
	i=J.b8(0,q);
	return new A.F(i,0,a,c.h("F<0*>"))}}else {j.c.l($.a2(),A.a([s,"array"],t.M),a);
	i=J.b8(0,c.h("0*"));
	return new A.F(i,0,a,c.h("F<0*>"))}},
	$2(a,b){return this.$1$2(a,b,t.z)},
	$S:38};
	A.iy.prototype={
	$1$3$req(a,b,c,d){var s,r;
	this.a.$0();
	s=this.c;
	r=A.nP(this.b,a,s,!0);
	if(r==null)return null
	s.c.push(a);
	return b.$2(r,s)},
	$2(a,b){return this.$1$3$req(a,b,!1,t.z)},
	$1$2(a,b,c){return this.$1$3$req(a,b,!1,c)},
	$S:39};
	A.iu.prototype={
	$2(a,b){var s,r,q,p,o,n=this.a,m=n.c;
	m.push(a.c);
	s=this.b;
	a.a4(new A.iv(n,s));
	r=n.f.i(0,b);
	if(r!=null){q=J.cX(m.slice(0),A.a_(m).c);
	for(p=J.aA(r);p.q();){o=p.gt();
	B.d.P(m);
	B.d.D(m,o.b);
	o.a.p(s,n);}B.d.P(m);
	B.d.D(m,q);}m.pop();},
	$S:40};
	A.iv.prototype={
	$2(a,b){var s=this.a,r=s.c;
	r.push(B.c.k(a));
	b.p(this.b,s);
	r.pop();},
	$S:41};
	A.is.prototype={
	$2(a,b){var s,r;
	if(t.c.b(b)){s=this.a;
	r=s.c;
	r.push(a);
	b.p(this.b,s);
	r.pop();}},
	$S:3};
	A.it.prototype={
	$2(a,b){var s,r,q,p=this;
	if(!b.dy&&b.cx==null&&b.cy==null&&b.CW==null&&b.a.a===0&&b.b==null)p.a.Z($.rY(),a);
	if(b.db!=null){s=p.b;
	s.P(0);
	for(r=b;r.db!=null;)if(s.C(0,r))r=r.db;
	else {if(r===b)p.a.Z($.rc(),a);
	break}}if(b.dx!=null){if(b.db!=null)p.a.Z($.t2(),a);
	s=b.z;
	if(s==null||s.cP()){s=b.as;
	if(s!=null){s=s.a;
	s=s[0]===0&&s[1]===0&&s[2]===0;}else s=!0;
	if(s){s=b.at;
	if(s!=null){s=s.a;
	s=s[0]===0&&s[1]===0&&s[2]===0&&s[3]===1;}else s=!0;
	if(s){s=b.ax;
	if(s!=null){s=s.a;
	s=s[0]===1&&s[1]===1&&s[2]===1;}else s=!0;}else s=!1;}else s=!1;}else s=!1;
	if(!s)p.a.Z($.t1(),a);
	q=b.dx.at.bf(0,new A.iq(),new A.ir());
	if(q!=null){s=q.ch;
	s=!b.ch.be(0,s.gcC(s));}else s=!1;
	if(s)p.a.Z($.t0(),a);}},
	$S:43};
	A.iq.prototype={
	$1(a){return a.db==null},
	$S:44};
	A.ir.prototype={
	$0(){return null},
	$S:2};
	A.iz.prototype={
	$1(a){var s=this.b,r=s.c;
	B.d.P(r);
	r.push(a.c);
	a.a4(new A.iA(this.a,s));
	r.pop();},
	$S:45};
	A.iA.prototype={
	$2(a,b){var s=this.b,r=s.c;
	r.push(B.c.k(a));
	b.c4(this.a,s);
	r.pop();},
	$S:46};
	A.m.prototype={};
	A.k.prototype={
	p(a,b){},
	$in:1};
	A.eR.prototype={};
	A.fL.prototype={};
	A.aU.prototype={
	p(a,b){var s,r="bufferView",q=this.w;
	if(q!==-1){s=this.Q=a.y.i(0,q);
	if(s==null)b.l($.Q(),A.a([q],t.M),r);
	else {s.T(B.b6,r,b);
	if(this.Q.z!==-1)b.n($.qZ(),r);}}},
	ez(){var r=this.Q,q=r==null?null:r.as;
	if((q==null?null:q.z)!=null)try{this.z=A.nw(r.as.z.buffer,r.x,r.y);}catch(s){if(!(A.M(s) instanceof A.at))throw s}}};
	A.ai.prototype={
	p(a,b){var s=this,r=new A.jR(b,a);
	r.$2(s.w,"pbrMetallicRoughness");
	r.$2(s.x,"normalTexture");
	r.$2(s.y,"occlusionTexture");
	r.$2(s.z,"emissiveTexture");}};
	A.jR.prototype={
	$2(a,b){var s,r;
	if(a!=null){s=this.a;
	r=s.c;
	r.push(b);
	a.p(this.b,s);
	r.pop();}},
	$S:28};
	A.cB.prototype={
	p(a,b){var s,r=this.e;
	if(r!=null){s=b.c;
	s.push("baseColorTexture");
	r.p(a,b);
	s.pop();}r=this.w;
	if(r!=null){s=b.c;
	s.push("metallicRoughnessTexture");
	r.p(a,b);
	s.pop();}}};
	A.cA.prototype={};
	A.cz.prototype={
	p(a,b){var s,r;
	this.dd(a,b);
	for(s=b.e,r=this;r!=null;){r=s.i(0,r);
	if(r instanceof A.ai){r.ay=!0;
	break}}}};
	A.bj.prototype={
	p(a,b){var s,r=this,q=r.d,p=r.f=a.cy.i(0,q);
	if(q!==-1)if(p==null)b.l($.Q(),A.a([q],t.M),"index");
	else p.a$=!0;
	for(q=b.e,s=r;s!=null;){s=q.i(0,s);
	if(s instanceof A.ai){s.ch.m(0,b.S(),r.e);
	break}}}};
	A.c2.prototype={
	k(a){return this.a}};
	A.c1.prototype={
	k(a){return this.a}};
	A.y.prototype={
	k(a){var s=B.ay.i(0,this.b),r=this.c?" normalized":"";
	return "{"+A.b(this.a)+", "+A.b(s)+r+"}"},
	O(a,b){if(b==null)return !1
	return b instanceof A.y&&b.a==this.a&&b.b===this.b&&b.c===this.c},
	gE(a){return A.px(A.fW(A.fW(A.fW(0,J.bY(this.a)),B.c.gE(this.b)),B.c0.gE(this.c)))}};
	A.aV.prototype={
	p(a,b){var s,r=b.c;
	r.push("primitives");
	s=this.w;
	if(s!=null)s.a4(new A.k1(b,a));
	r.pop();}};
	A.k1.prototype={
	$2(a,b){var s,r=this.a,q=r.c;
	q.push(B.c.k(a));
	q.push("extensions");
	s=this.b;
	b.a.M(0,new A.k0(r,s));
	q.pop();
	b.p(s,r);
	q.pop();},
	$S:20};
	A.k0.prototype={
	$2(a,b){var s,r;
	if(t.c.b(b)){s=this.a;
	r=s.c;
	r.push(a);
	b.p(this.b,s);
	r.pop();}},
	$S:3};
	A.aE.prototype={
	gex(){switch(this.r){case 4:return B.c.bJ(this.ch,3)
	case 5:case 6:var s=this.ch;
	return s>2?s-2:0
	default:return 0}},
	p(a,a0){var s,r,q,p,o,n,m,l,k,j,i,h,g,f=this,e="attributes",d="indices",c="material",b=f.d;
	if(b!=null){s=a0.c;
	s.push(e);
	b.M(0,new A.jX(f,a,a0));
	s.pop();}b=f.e;
	if(b!==-1){s=f.cy=a.f.i(0,b);
	if(s==null)a0.l($.Q(),A.a([b],t.M),d);
	else {f.ch=s.z;
	s.T(B.b4,d,a0);
	b=f.cy.CW;
	if(b!=null)b.T(B.L,d,a0);
	b=a0.c;
	b.push(d);
	s=f.cy.CW;
	if(s!=null&&s.z!==-1)a0.L($.r7());
	r=A.dl(f.cy);
	if(!B.d.G(B.aq,r))a0.F($.r6(),A.a([r,B.aq],t.M));
	else {s=f.CW;
	q=s!==-1?s-1:-1;
	s=f.r;
	p=s!==-1?B.c.aI(1,s):-1;
	if(p!==0&&q>=-1){s=f.cy;
	o=a0.S();
	n=B.c.bJ(f.ch,3);
	m=f.cy.y;
	l=new Uint32Array(3);
	a0.a_(s,new A.eU(q,n,A.q1(m),16===(p&16),l,o));}}b.pop();}}b=f.ch;
	if(b!==-1){s=f.r;
	if(!(s===1&&b%2!==0))if(!((s===2||s===3)&&b<2))if(!(s===4&&b%3!==0))b=(s===5||s===6)&&b<3;
	else b=!0;
	else b=!0;
	else b=!0;}else b=!1;
	if(b)a0.F($.r5(),A.a([f.ch,B.cz[f.r]],t.M));
	b=f.f;
	s=f.db=a.as.i(0,b);
	if(b!==-1)if(s==null)a0.l($.Q(),A.a([b],t.M),c);
	else {s.a$=!0;
	if(!(f.y&&f.z)&&s.ay)a0.n(s.x!=null?$.r4():$.ra(),c);
	f.db.ch.M(0,new A.jY(f,a0));}if(f.z){b=f.db;
	b=b==null||!b.ay;}else b=!1;
	if(b){b=a0.c;
	b.push(e);
	a0.n($.rn(),"TANGENT");
	b.pop();}for(b=f.dx,s=B.d.gH(b),b=new A.cF(s,new A.jZ(),A.a_(b).h("cF<1>")),o=a0.c;b.q();){n=s.gt();
	o.push(e);
	a0.n($.h1(),"TEXCOORD_"+A.b(n));
	o.pop();}b=f.w;
	if(b!=null){s=a0.c;
	s.push("targets");
	k=b.length;
	j=J.oF(k,t.gj);
	for(o=t.X,n=t.W,i=0;i<k;++i)j[i]=A.a9(o,n);
	f.cx=j;
	for(h=0;h<b.length;++h){g=b[h];
	s.push(B.c.k(h));
	g.M(0,new A.k_(f,a,a0,h));
	s.pop();}s.pop();}},
	cg(a,b,c){var s,r=a.CW;
	if(r.z===-1){s=c.w.c_(r,new A.jW());
	if(s.C(0,a)&&s.gj(s)>1)c.n($.r2(),b);}}};
	A.jV.prototype={
	$1(a){var s,r,q,p,o;
	if(a.gj(a)!==0){s=a.a;
	s=s.length>1&&B.a.J(s,0)===48;}else s=!0;
	if(s)return -1
	for(s=a.a,r=s.length,q=0,p=0;p<r;++p){o=B.a.J(s,p)-48;
	if(o>9||o<0)return -1
	q=10*q+o;}return q},
	$S:49};
	A.jS.prototype={
	$1(a){var s,r,q,p,o,n,m,l,k=this;
	if(a.length!==0&&B.a.J(a,0)===95)return
	switch(a){case"POSITION":k.a.c=!0;
	break
	case"NORMAL":k.a.b=!0;
	break
	case"TANGENT":k.a.a=!0;
	break
	default:s=a.split("_");
	r=s[0];
	if(!B.d.G(B.cl,r)||s.length!==2){k.b.n($.nk(),a);
	break}q=s[1];
	q.toString;
	p=k.c.$1(new A.c8(q));
	if(p!==-1)switch(r){case"COLOR":q=k.a;++q.d;
	o=q.e;
	q.e=p>o?p:o;
	break
	case"JOINTS":q=k.a;++q.f;
	n=q.r;
	q.r=p>n?p:n;
	break
	case"TEXCOORD":q=k.a;++q.y;
	m=q.z;
	q.z=p>m?p:m;
	break
	case"WEIGHTS":q=k.a;++q.w;
	l=q.x;
	q.x=p>l?p:l;
	break}else k.b.n($.nk(),a);}},
	$S:21};
	A.jT.prototype={
	$3(a,b,c){var s=a+1;
	if(s!==b){this.a.F($.rQ(),A.a([c,s,b],t.M));
	return 0}return b},
	$S:51};
	A.jU.prototype={
	$1(a){var s,r;
	if(a.length!==0&&B.a.J(a,0)===95)return
	if(B.d.G(B.ct,a))return
	s=a.split("_");
	if(B.d.G(B.cm,s[0]))if(s.length===2){r=s[1];
	r.toString;
	r=J.af(this.a.$1(new A.c8(r)),-1);}else r=!0;
	else r=!0;
	if(r)this.b.n($.nk(),a);},
	$S:21};
	A.jX.prototype={
	$2(a,b){var s,r,q,p,o,n,m,l=this;
	if(b===-1)return
	s=l.b.f.i(0,b);
	if(s==null){l.c.l($.Q(),A.a([b],t.M),a);
	return}r=l.a;
	r.ay.m(0,a,s);
	q=l.c;
	s.T(B.a7,a,q);
	p=s.CW;
	if(p!=null)p.T(B.A,a,q);
	if(a==="POSITION")p=s.ax==null||s.at==null;
	else p=!1;
	if(p)q.n($.o8(),"POSITION");
	o=A.dl(s);
	n=q.fr.i(0,A.a(a.split("_"),t.s)[0]);
	if(n!=null){if(!n.G(0,o))q.l($.o7(),A.a([o,n],t.M),a);
	else if(a==="NORMAL"){p=q.c;
	p.push("NORMAL");
	m=q.S();
	q.a_(s,new A.fv(m,5126===s.y?null:s.gbX()));
	p.pop();}else if(a==="TANGENT"){p=q.c;
	p.push("TANGENT");
	m=q.S();
	q.a_(s,new A.fw(m,5126===s.y?null:s.gbX()));
	p.pop();}else if(a==="COLOR_0"&&5126===s.y){p=q.c;
	p.push(a);
	q.a_(s,new A.eK(q.S()));
	p.pop();}}else if(s.y===5125)q.n($.r3(),a);
	p=s.x;
	if(!(p!==-1&&p%4!==0))if(s.gad()%4!==0){p=s.CW;
	p=p!=null&&p.z===-1;}else p=!1;
	else p=!0;
	if(p)q.n($.o6(),a);
	p=r.CW;
	if(p===-1)r.ch=r.CW=s.z;
	else if(p!==s.z)q.n($.rb(),a);
	p=s.CW;
	if(p!=null&&p.z===-1){if(p.ax===-1)p.ax=s.gad();
	r.cg(s,a,q);}},
	$S:4};
	A.jY.prototype={
	$2(a,b){var s;
	if(b!==-1){s=this.a;
	if(b+1>s.ax)this.b.l($.o9(),A.a([a,b],t.M),"material");
	else s.dx[b]=-1;}},
	$S:4};
	A.jZ.prototype={
	$1(a){return a!==-1},
	$S:9};
	A.k_.prototype={
	$2(a,b){var s,r,q,p,o,n,m=this;
	if(b===-1)return
	s=m.b.f.i(0,b);
	if(s==null)m.c.l($.Q(),A.a([b],t.M),a);
	else {r=m.c;
	s.T(B.a7,a,r);
	q=s.CW;
	if(q!=null)q.T(B.A,a,r);
	p=m.a.ay.i(0,a);
	if(p==null)r.n($.r9(),a);
	else if(p.z!==s.z)r.n($.r8(),a);
	if(a==="POSITION")q=s.ax==null||s.at==null;
	else q=!1;
	if(q)r.n($.o8(),"POSITION");
	o=A.dl(s);
	n=r.fx.i(0,A.a(a.split("_"),t.s)[0]);
	if(n!=null&&!n.G(0,o))r.l($.o7(),A.a([o,n],t.M),a);
	q=s.x;
	if(!(q!==-1&&q%4!==0))if(s.gad()%4!==0){q=s.CW;
	q=q!=null&&q.z===-1;}else q=!1;
	else q=!0;
	if(q)r.n($.o6(),a);
	q=s.CW;
	if(q!=null&&q.z===-1){if(q.ax===-1)q.ax=s.gad();
	m.a.cg(s,a,r);}}m.a.cx[m.d].m(0,a,s);},
	$S:4};
	A.jW.prototype={
	$0(){return A.aD(t.W)},
	$S:54};
	A.eU.prototype={
	a0(a,b,c,d){var s,r,q=this,p=q.a;
	if(d>p)a.l($.q7(),A.a([b,d,p],t.M),q.at);
	if(d===q.c)a.l($.q8(),A.a([d,b],t.M),q.at);
	if(q.w){p=q.as;
	s=q.z;
	p[s]=d;++s;
	q.z=s;
	if(s===3){q.z=0;
	s=p[0];
	r=p[1];
	if(s!==r){p=p[2];
	p=r===p||p===s;}else p=!0;
	if(p)++q.Q;}}return !0},
	aF(a){var s=this.Q;
	if(s>0)a.l($.q9(),A.a([s,this.b],t.M),this.at);
	return !0}};
	A.ap.prototype={
	p(a,b){var s,r,q,p=this,o=p.w;
	p.CW=a.z.i(0,o);
	s=p.y;
	p.dx=a.cx.i(0,s);
	r=p.Q;
	p.cy=a.at.i(0,r);
	if(o!==-1){q=p.CW;
	if(q==null)b.l($.Q(),A.a([o],t.M),"camera");
	else q.a$=!0;}if(s!==-1){o=p.dx;
	if(o==null)b.l($.Q(),A.a([s],t.M),"skin");
	else o.a$=!0;}if(r!==-1){o=p.cy;
	if(o==null)b.l($.Q(),A.a([r],t.M),"mesh");
	else {o.a$=!0;
	o=o.w;
	if(o!=null){s=p.ay;
	r=s==null;
	if(!r){o=o.i(0,0).cx;
	o=o==null?null:o.length;
	o=o!==s.length;}else o=!1;
	if(o){o=$.rg();
	s=s.length;
	q=p.cy.w.i(0,0).cx;
	b.l(o,A.a([s,q==null?null:q.length],t.M),"weights");}if(r&&p.cy.x!=null)p.cy.y=!0;
	if(p.dx!=null){o=p.cy.w;
	if(o.be(o,new A.k3()))b.L($.re());}else {o=p.cy.w;
	if(o.aR(o,new A.k4()))b.L($.rf());}}}}o=p.x;
	if(o!=null){s=A.U(o.gj(o),null,!1,t.L);
	p.cx=s;
	A.nT(o,s,a.ax,"children",b,new A.k5(p,b));}},
	cd(a,b){var s,r,q,p,o=this;
	o.ch.C(0,a);
	if(o.cx==null||!b.C(0,o))return
	for(s=o.cx,r=s.length,q=0;q<r;++q){p=s[q];
	if(p!=null)p.cd(a,b);}}};
	A.k3.prototype={
	$1(a){return a.as===0},
	$S:5};
	A.k4.prototype={
	$1(a){return a.as!==0},
	$S:5};
	A.k5.prototype={
	$3(a,b,c){if(a.db!=null)this.b.ao($.rd(),A.a([b],t.M),c);
	a.db=this.a;},
	$S:10};
	A.bF.prototype={};
	A.bG.prototype={
	p(a,b){var s,r=this.w;
	if(r==null)return
	s=A.U(r.gj(r),null,!1,t.L);
	this.x=s;
	A.nT(r,s,a.ax,"nodes",b,new A.ke(this,b));}};
	A.ke.prototype={
	$3(a,b,c){if(a.db!=null)this.b.ao($.rh(),A.a([b],t.M),c);
	a.cd(this.a,A.aD(t.L));},
	$S:10};
	A.bI.prototype={
	p(a,b){var s,r,q,p,o,n=this,m="inverseBindMatrices",l="skeleton",k=n.w;
	n.z=a.f.i(0,k);
	s=a.ax;
	r=n.x;
	n.as=s.i(0,r);
	q=n.y;
	if(q!=null){p=A.U(q.gj(q),null,!1,t.L);
	n.Q=p;
	A.nT(q,p,s,"joints",b,new A.lm(n));
	if(n.at.a===0)b.n($.t6(),"joints");}if(k!==-1){s=n.z;
	if(s==null)b.l($.Q(),A.a([k],t.M),m);
	else {s.T(B.b3,m,b);
	k=n.z.CW;
	if(k!=null)k.T(B.b5,m,b);
	k=b.c;
	k.push(m);
	s=n.z.CW;
	if(s!=null&&s.z!==-1)b.L($.ri());
	o=A.dl(n.z);
	if(!o.O(0,B.Y))b.F($.rj(),A.a([o,A.a([B.Y],t.p)],t.M));
	else b.a_(n.z,new A.eT(b.S()));
	s=n.Q;
	if(s!=null&&n.z.z<s.length)b.F($.r0(),A.a([s.length,n.z.z],t.M));
	k.pop();}}if(r!==-1){k=n.as;
	if(k==null)b.l($.Q(),A.a([r],t.M),l);
	else if(!n.at.G(0,k))b.n($.t7(),l);}}};
	A.lm.prototype={
	$3(a,b,c){var s,r,q;
	a.dy=!0;
	s=A.aD(t.L);
	r=a;
	while(!0){if(!(r!=null&&s.C(0,r)))break
	r=r.db;}q=this.a.at;
	if(q.a===0)q.D(0,s);
	else q.dv(s.gcC(s),!1);},
	$S:10};
	A.eT.prototype={
	a0(a,b,c,d){var s;
	if(!(3===c&&0!==d))if(!(7===c&&0!==d))if(!(11===c&&0!==d))s=15===c&&1!==d;
	else s=!0;
	else s=!0;
	else s=!0;
	if(s)a.l($.qb(),A.a([b,c,d],t.M),this.a);
	return !0}};
	A.bK.prototype={
	p(a,b){var s,r,q=this,p=q.x;
	q.z=a.Q.i(0,p);
	s=q.w;
	q.y=a.ay.i(0,s);
	if(p!==-1){r=q.z;
	if(r==null)b.l($.Q(),A.a([p],t.M),"source");
	else r.a$=!0;}if(s!==-1){p=q.y;
	if(p==null)b.l($.Q(),A.a([s],t.M),"sampler");
	else p.a$=!0;}},
	c4(a,b){var s=this.z,r=s==null,q=r?null:s.x;
	if(q==null){s=r?null:s.as;
	q=s==null?null:s.a;}if(q!=null&&!B.d.G(B.ap,q))b.l($.oa(),A.a([q,B.ap],t.M),"source");},
	$icC:1};
	A.lE.prototype={};
	A.i.prototype={
	a_(a,b){J.nm(this.d.c_(a,new A.hg()),b);},
	W(a,b){var s,r,q;
	for(s=J.aA(b),r=this.e;s.q();){q=s.gt();
	if(q!=null)r.m(0,q,a);}},
	c7(a){var s,r,q,p=this.c;
	if(p.length===0&&a!=null&&B.a.Y(a,"/"))return a
	s=a!=null;
	if(s)p.push(a);
	r=this.db;
	q=r.a+="/";
	r.a=A.ny(q,new A.ab(p,new A.hi(),A.a_(p).h("ab<1,e*>")),"/");
	if(s)p.pop();
	p=r.a;
	r.a="";
	return p.charCodeAt(0)==0?p:p},
	S(){return this.c7(null)},
	e9(a,b){var s,r,q,p,o,n,m,l,k,j,i=this,h="/extensionsUsed/";
	B.d.D(i.as,a);
	for(s=J.V(a),r=i.ax,q=i.cx,p=J.V(b),o=t.M,n=0;n<s.gj(a);++n){m=s.i(a,n);
	l=$.q3().aT(m);
	if((l==null?null:l.b[1])==null)i.n($.rB(),h+n);
	k=q.bf(0,new A.hl(m),new A.hm(m));
	if(k==null){i.l($.rm(),A.a([m],o),h+n);
	continue}k.b.M(0,new A.hn(i,k));
	l=k.c;
	if(l!=null)l.$1(i);
	if(k.d&&!p.G(b,m))i.l($.t4(),A.a([m],o),h+n);
	r.push(m);}for(n=0;n<p.gj(b);++n){j=p.i(b,n);
	if(!s.G(a,j))i.l($.ta(),A.a([j],o),"/extensionsRequired/"+n);}},
	ab(a,b,c,d,e,f){var s,r,q,p=this,o=p.b,n=a.b;
	if(o.b.G(0,n))return
	s=o.c;
	if(s.a!==0&&!s.G(0,n))return
	s=o.a;
	if(s>0&&p.cy.length===s){p.y=!0;
	throw A.d(B.ba)}o=o.d;
	r=o!=null?o.i(0,n):null;
	if(f!=null)p.cy.push(new A.cW(a,r,null,f,b));
	else {q=c!=null?B.c.k(c):d;
	o=e?"":p.c7(q);
	p.cy.push(new A.cW(a,r,o,null,b));}},
	n(a,b){return this.ab(a,null,null,b,!1,null)},
	F(a,b){return this.ab(a,b,null,null,!1,null)},
	l(a,b,c){return this.ab(a,b,null,c,!1,null)},
	ao(a,b,c){return this.ab(a,b,c,null,!1,null)},
	Z(a,b){return this.ab(a,null,b,null,!1,null)},
	L(a){return this.ab(a,null,null,null,!1,null)},
	aE(a,b,c){return this.ab(a,b,null,null,c,null)},
	aQ(a,b){return this.ab(a,null,null,null,!1,b)},
	a2(a,b,c){return this.ab(a,b,null,null,!1,c)}};
	A.hh.prototype={
	$1(a){return a.a},
	$S:57};
	A.hg.prototype={
	$0(){return A.a([],t.gd)},
	$S:58};
	A.hi.prototype={
	$1(a){var s;
	a.toString;
	s=A.q0(a,"~","~0");
	return A.q0(s,"/","~1")},
	$S:59};
	A.hl.prototype={
	$1(a){return a.a===this.a},
	$S:22};
	A.hm.prototype={
	$0(){return B.d.bf(B.au,new A.hj(this.a),new A.hk())},
	$S:61};
	A.hj.prototype={
	$1(a){return a.a===this.a},
	$S:22};
	A.hk.prototype={
	$0(){return null},
	$S:2};
	A.hn.prototype={
	$2(a,b){this.a.z.m(0,new A.cb(a,this.b.a),b);},
	$S:62};
	A.bA.prototype={$ia8:1};
	A.cU.prototype={
	aB(){return "ImageCodec."+this.b}};
	A.dV.prototype={
	aB(){return "_ColorPrimaries."+this.b}};
	A.d5.prototype={
	aB(){return "_ColorTransfer."+this.b}};
	A.cc.prototype={
	aB(){return "Format."+this.b}};
	A.cd.prototype={};
	A.iC.prototype={
	$1(a){var s,r,q,p=this.a;
	if(!p.c){s=A.oD(t.a.a(a));
	r=p.a;
	q=this.b;
	switch(s){case B.ag:p.b=new A.iM(q,r);
	break
	case B.ah:s=new Uint8Array(13);
	p.b=new A.k7(B.u,B.r,s,new Uint8Array(32),q,r);
	break
	case B.ai:p.b=new A.lJ(new Uint8Array(30),q,r);
	break
	default:r.K();
	q.R(B.bj);
	return}p.c=!0;}p.b.C(0,a);},
	$S:11};
	A.iE.prototype={
	$1(a){this.a.a.K();
	this.b.R(a);},
	$S:23};
	A.iD.prototype={
	$0(){var s=this.a.b;
	s.b.K();
	s=s.a;
	if((s.a.a&30)===0)s.R(B.bi);},
	$S:2};
	A.iB.prototype={
	cb(a){var s;
	this.b.K();
	s=this.a;
	if((s.a.a&30)===0)s.R(a);}};
	A.iM.prototype={
	C(a,b){var s,q;
	try{this.dD(b);}catch(r){q=A.M(r);
	if(q instanceof A.aL){s=q;
	this.b.K();
	this.a.R(s);}else throw r}},
	dD(a){var s,r,q,p,o,n,m,l,k,j,i=this,h=new A.iO(),g=new A.iN();
	for(s=J.V(a),r=0;r!==s.gj(a);){q=s.i(a,r);
	switch(i.c){case 0:if(255===q)i.c=255;
	else throw A.d(B.c_)
	break
	case 255:if(g.$1(q)){i.c=1;
	i.d=q;
	i.e=i.f=0;}break
	case 1:i.e=q<<8>>>0;
	i.c=2;
	break
	case 2:p=i.e+q;
	i.e=p;
	if(p<2)throw A.d(B.bY)
	if(h.$1(i.d)){p=i.e;
	i.r=new Uint8Array(p-2);}i.c=3;
	break
	case 3:o=Math.min(s.gj(a)-r,i.e-i.f-2);
	p=h.$1(i.d);
	n=i.f;
	m=n+o;
	if(p){p=i.r;
	i.f=m;(p&&B.j).a5(p,n,m,a,r);
	if(i.f===i.e-2){i.b.K();
	a=i.r;
	l=a[0];
	s=a[1];
	p=a[2];
	n=a[3];
	m=a[4];
	k=a[5];
	if(k===3)j=B.p;
	else if(k===1)j=B.ae;
	else {A.Z(B.bZ);
	j=B.O;}k=i.a.a;
	if((k.a&30)!==0)A.Z(A.d2("Future already completed"));
	k.ah(new A.cd("image/jpeg",l,j,(n<<8|m)>>>0,(s<<8|p)>>>0,B.r,B.u,!1,!1));
	return}}else {i.f=m;
	if(m===i.e-2)i.c=255;}r+=o;
	continue}++r;}}};
	A.iO.prototype={
	$1(a){return (a&240)===192&&a!==196&&a!==200&&a!==204||a===222},
	$S:9};
	A.iN.prototype={
	$1(a){return !(a===1||(a&248)===208||a===216||a===217||a===255)},
	$S:9};
	A.k7.prototype={
	C(a,b){var s,r,q,p,o,n,m,l,k,j,i,h,g,f,e=this,d=new A.k8(e);
	for(s=J.V(b),r=e.ay,q=e.ax,p=0;p!==s.gj(b);){o=s.i(b,p);
	switch(e.x){case 0:p+=8;
	e.x=1;
	continue
	case 1:e.c=(e.c<<8|o)>>>0;
	if(++e.d===4)e.x=2;
	break
	case 2:n=(e.e<<8|o)>>>0;
	e.e=n;
	if(++e.f===4){switch(n){case 1229472850:if(e.c!==13){e.b.K();
	s=e.a;
	if((s.a.a&30)===0)s.R(B.q);
	return}e.y=!0;
	break
	case 1951551059:e.z=!0;
	break
	case 1665684045:if(e.c!==32){e.b.K();
	s=e.a;
	if((s.a.a&30)===0)s.R(B.q);
	return}break
	case 1934772034:if(e.c!==1){e.b.K();
	s=e.a;
	if((s.a.a&30)===0)s.R(B.q);
	return}break
	case 1883789683:if(e.c!==9){e.b.K();
	s=e.a;
	if((s.a.a&30)===0)s.R(B.q);
	return}break
	case 1732332865:if(e.c!==4){e.b.K();
	s=e.a;
	if((s.a.a&30)===0)s.R(B.q);
	return}break
	case 1766015824:e.Q=B.F;
	e.as=B.E;
	break
	case 1229209940:e.b.K();
	if(!e.y)e.a.R(B.bX);
	s=q.buffer;
	b=new DataView(s,0);
	m=b.getUint32(0,!1);
	l=b.getUint32(4,!1);
	k=b.getUint8(8);
	switch(b.getUint8(9)){case 0:j=e.z?B.af:B.ae;
	break
	case 2:case 3:j=e.z?B.B:B.p;
	break
	case 4:j=B.af;
	break
	case 6:j=B.B;
	break
	default:j=B.O;}s=e.as;
	if(s===B.r)s=e.as=B.t;
	r=e.Q;
	if(r===B.u)r=e.Q=B.v;
	q=e.at;
	n=e.a.a;
	if((n.a&30)!==0)A.Z(A.d2("Future already completed"));
	n.ah(new A.cd("image/png",k,j,m,l,s,r,q,!1));
	return}if(e.c===0)e.x=4;
	else e.x=3;}break
	case 3:n=s.gj(b);
	i=e.c;
	h=e.w;
	g=Math.min(n-p,i-h);
	switch(e.e){case 1229472850:n=h+g;
	e.w=n;
	B.j.a5(q,h,n,b,p);
	break
	case 1665684045:case 1732332865:case 1883789683:n=h+g;
	e.w=n;
	B.j.a5(r,h,n,b,p);
	break
	case 1934772034:e.Q=B.v;
	e.as=B.t;
	e.w=h+1;
	break
	default:e.w=h+g;}if(e.w===e.c){switch(e.e){case 1665684045:if(e.as===B.r)e.dl();
	break
	case 1732332865:if(e.Q===B.u)e.dm();
	break
	case 1883789683:n=r.buffer;
	f=new DataView(n,0);
	if(f.getUint32(0,!1)!==f.getUint32(4,!1))e.at=!0;
	break}e.x=4;}p+=g;
	continue
	case 4:if(++e.r===4){d.$0();
	e.x=1;}break}++p;}},
	dm(){var s=this;
	if(s.Q===B.v)return
	switch(A.f7(s.ay.buffer,0,null).getUint32(0,!1)){case 45455:s.Q=B.v;
	break
	case 1e5:s.Q=B.en;
	break
	default:s.Q=B.F;}},
	dl(){var s,r=this;
	if(r.as===B.t)return
	s=A.f7(r.ay.buffer,0,null);
	if(s.getUint32(0,!1)===31270&&s.getUint32(4,!1)===32900&&s.getUint32(8,!1)===64e3&&s.getUint32(12,!1)===33e3&&s.getUint32(16,!1)===3e4&&s.getUint32(20,!1)===6e4&&s.getUint32(24,!1)===15e3&&s.getUint32(28,!1)===6000)r.as=B.t;
	else r.as=B.E;}};
	A.k8.prototype={
	$0(){var s=this.a;
	s.r=s.w=s.f=s.e=s.d=s.c=0;},
	$S:1};
	A.lJ.prototype={
	C(a,b){var s,r,q,p,o,n,m,l=this,k=J.a3(b),j=l.d,i=l.c;
	k=j+Math.min(k,30-j);
	l.d=k;
	B.j.d5(i,j,k,b);
	k=l.d;
	if(k>=25)k=k<30&&i[15]!==76;
	else k=!0;
	if(k)return
	l.b.K();
	s=A.f7(i.buffer,0,null);
	if(s.getUint32(0,!1)!==1380533830||s.getUint32(8,!1)!==1464156752){l.cb(B.aj);
	return}switch(s.getUint32(12,!1)){case 1448097824:r=s.getUint16(26,!0)&16383;
	q=s.getUint16(28,!0)&16383;
	p=B.p;
	o=!1;
	n=!1;
	break
	case 1448097868:k=i[21];
	j=i[22];
	r=1+((k|(j&63)<<8)>>>0);
	k=i[23];
	i=i[24];
	q=1+((j>>>6|k<<2|(i&15)<<10)>>>0);
	p=(i&16)===16?B.B:B.p;
	o=!1;
	n=!1;
	break
	case 1448097880:m=i[20];
	n=(m&2)===2;
	o=(m&32)===32;
	p=(m&16)===16?B.B:B.p;
	r=((i[24]|i[25]<<8|i[26]<<16)>>>0)+1;
	q=((i[27]|i[28]<<8|i[29]<<16)>>>0)+1;
	break
	default:l.cb(B.aj);
	return}k=o?B.F:B.v;
	j=o?B.E:B.t;
	l.a.a3(new A.cd("image/webp",8,p,r,q,j,k,!1,n));}};
	A.dS.prototype={$ia8:1};
	A.dR.prototype={$ia8:1};
	A.aL.prototype={
	k(a){return this.a},
	$ia8:1};
	A.d9.prototype={
	aB(){return "_Storage."+this.b}};
	A.fn.prototype={
	bn(){var s,r=this,q=t.X,p=t._,o=A.a9(q,p);
	o.m(0,"pointer",r.a);
	s=r.b;
	if(s!=null)o.m(0,"mimeType",s);
	s=r.c;
	if(s!=null)o.m(0,"storage",B.cy[s.a]);
	s=r.e;
	if(s!=null)o.m(0,"uri",s);
	s=r.d;
	if(s!=null)o.m(0,"byteLength",s);
	s=r.f;
	if(s!=null){q=A.a9(q,p);
	q.m(0,"width",s.d);
	q.m(0,"height",s.e);
	p=s.c;
	if(p!==B.O)q.m(0,"format",B.dd[p.a]);
	p=s.f;
	if(p!==B.r)q.m(0,"primaries",B.d6[p.a]);
	p=s.r;
	if(p!==B.u)q.m(0,"transfer",B.d5[p.a]);
	p=s.b;
	if(p>0)q.m(0,"bits",p);
	o.m(0,"image",q);}return o}};
	A.kb.prototype={
	aX(){	return this.eb()},
	eb(){var s=0,r=A.ex(t.H),q,p=2,o,n=this,l,k;
	var $async$aX=A.ez(function(a,b){if(a===1){o=b;
	s=p;}while(true)switch(s){case 0:l=!0;
	p=4;
	s=7;
	return A.dd(n.b7(),$async$aX)
	case 7:s=8;
	return A.dd(n.b8(),$async$aX)
	case 8:if(l)A.xS(n.a,n.b);
	n.a.eC(n.b);
	p=2;
	s=6;
	break
	case 4:p=3;
	k=o;
	if(A.M(k) instanceof A.bA){s=1;
	break}else throw k
	case 3:s=2;
	break
	case 6:case 1:return A.es(q,r)
	case 2:return A.er(o,r)}});
	return A.et($async$aX,r)},
	b7(){var s=0,r=A.ex(t.H),q=1,p,o=this,n,m,l,k,j,i,h,g,f,e,d,c,b,a0,a1,a2,a3;
	var $async$b7=A.ez(function(a4,a5){if(a4===1){p=a5;
	s=q;}while(true)switch(s){case 0:a1=o.b;
	a2=a1.c;
	B.d.P(a2);
	a2.push("buffers");
	j=o.a.x,i=j.b,h=a1.ch,g=t.M,f=t.x,j=j.a,e=j.length,d=0;
	case 2:if(!(d<i)){s=4;
	break}c=d>=e;
	n=c?null:j[d];
	if(n==null){s=3;
	break}a2.push(B.c.k(d));
	b=new A.fn(a1.S());
	b.b="application/gltf-buffer";
	m=new A.kc(o,b,d);
	l=null;
	q=6;
	s=9;
	return A.dd(m.$1(n),$async$b7)
	case 9:l=a5;
	q=1;
	s=8;
	break
	case 6:q=5;
	a3=p;
	c=A.M(a3);
	if(f.b(c)){k=c;
	a1.l($.nh(),A.a([k],g),"uri");}else throw a3
	s=8;
	break
	case 5:s=1;
	break
	case 8:if(l!=null){b.d=J.a3(l);
	if(J.a3(l)<n.x)a1.F($.ql(),A.a([J.a3(l),n.x],g));
	else {if(a1.dx&&d===0&&!n.y){c=n.x;
	a0=c+(-c&3);
	if(J.a3(l)>a0)a1.F($.qm(),A.a([J.a3(l)-a0],g));}c=n;
	if(c.z==null)c.z=l;}}h.push(b.bn());
	a2.pop();
	case 3:++d;
	s=2;
	break
	case 4:return A.es(null,r)
	case 1:return A.er(p,r)}});
	return A.et($async$b7,r)},
	b8(){var s=0,r=A.ex(t.H),q=1,p,o=this,n,m,l,k,j,i,h,g,f,e,d,c,b,a,a0,a1,a2,a4,a5,a6,a7;
	var $async$b8=A.ez(function(a9,b0){if(a9===1){p=b0;
	s=q;}while(true)switch(s){case 0:a5=o.b;
	a6=a5.c;
	B.d.P(a6);
	a6.push("images");
	g=o.a.Q,f=g.b,e=a5.ch,d=t.M,c=t.x,b=a5.dy,g=g.a,a=g.length,a0=0;
	case 2:if(!(a0<f)){s=4;
	break}a1=a0>=a;
	n=a1?null:g[a0];
	if(n==null){s=3;
	break}a6.push(B.c.k(a0));
	a2=new A.fn(a5.S());
	m=new A.kd(o,a2);
	l=null;
	try{l=m.$1(n);}catch(a8){a1=A.M(a8);
	if(c.b(a1)){k=a1;
	a5.l($.nh(),A.a([k],d),"uri");}else throw a8}j=null;
	s=l!=null?5:6;
	break
	case 5:q=8;
	s=11;
	return A.dd(A.uf(l),$async$b8)
	case 11:j=b0;
	a1=B.d.G(b,j.a);
	if(!a1)a5.F($.qq(),A.a([j.a],d));
	q=1;
	s=10;
	break
	case 8:q=7;
	a7=p;
	a1=A.M(a7);
	if(a1 instanceof A.dS)a5.L($.qt());
	else if(a1 instanceof A.dR)a5.L($.qs());
	else if(a1 instanceof A.aL){i=a1;
	a5.F($.qn(),A.a([i],d));}else if(c.b(a1)){h=a1;
	a5.l($.nh(),A.a([h],d),"uri");}else throw a7
	s=10;
	break
	case 7:s=1;
	break
	case 10:if(j!=null){a2.b=j.a;
	if(n.x!=null&&n.x!==j.a){a1=$.qp();
	a4=A.a([j.a,n.x],d);
	a5.l(a1,a4,a2.c===B.aN?"bufferView":"uri");}a1=j.d;
	if(a1!==0&&(a1&a1-1)>>>0===0){a1=j.e;
	a1=!(a1!==0&&(a1&a1-1)>>>0===0);}else a1=!0;
	if(a1)a5.F($.qr(),A.a([j.d,j.e],d));
	a1=j;
	if(a1.f===B.E||a1.r===B.F||j.x||j.w)a5.L($.qo());
	n.as=j;
	a2.f=j;}case 6:e.push(a2.bn());
	a6.pop();
	case 3:++a0;
	s=2;
	break
	case 4:return A.es(null,r)
	case 1:return A.er(p,r)}});
	return A.et($async$b8,r)}};
	A.kc.prototype={
	$1(a){var s,r,q,p=this;
	if(a.x===-1)return null
	s=a.w;
	if(s!=null){r=p.b;
	r.c=B.aO;
	r.e=s.k(0);
	return p.a.c.$1(s)}else {s=a.z;
	if(s!=null){p.b.c=B.aM;
	return s}else {s=p.a;
	r=s.b;
	if(r.dx&&p.c===0&&!a.y){p.b.c=B.ep;
	q=s.c.$0();
	if(q==null)r.L($.qW());
	return q}}}return null},
	$S:65};
	A.kd.prototype={
	$1(a){var s,r,q=this;
	if(a.a.a===0){s=a.y;
	if(s!=null){r=q.b;
	r.c=B.aO;
	r.e=s.k(0);
	return q.a.d.$1(s)}else {s=a.z;
	if(s!=null){q.b.c=B.aM;
	return A.fs(s,t.w)}else if(a.Q!=null){q.b.c=B.aN;
	a.ez();
	s=a.z;
	if(s!=null)return A.fs(s,t.w)}}}return null},
	$S:66};
	A.ne.prototype={
	$2(a,b){var s,r,q,p,o,n,m,l,k=A.mJ(b);
	if((k==null?null:k.ay)!=null){k=this.a;
	s=k.c;
	B.d.P(s);
	s.push("accessors");
	s.push(B.c.k(a));
	r=b.ay.ge8();
	if(r!=null)for(s=r.length,q=b.z,p=t.M,o=0,n=-1,m=0;m<s;++m,n=l){l=r[m];
	if(n!==-1&&l<=n)k.l($.qi(),A.a([o,l,n],p),"sparse");
	if(l>=q)k.l($.qh(),A.a([o,l,q],p),"sparse");++o;}}},
	$S:67};
	A.nf.prototype={
	$1(a){return a.as===0},
	$S:5};
	A.ng.prototype={
	$2(a,b){var s,r,q,p,o=this,n=null,m=b.CW,l=b.as,k=A.U(l,n,!1,t.bF),j=A.U(l,n,!1,t.ga),i=t.hc,h=b.ay,g=0;
	while(!0){if(!(g<l)){s=!1;
	break}r=""+g;
	q=A.mJ(h.i(0,"JOINTS_"+r));
	p=A.mJ(h.i(0,"WEIGHTS_"+r));
	if((q==null?n:q.z)===m)r=(p==null?n:p.z)!==m;
	else r=!0;
	if(r){s=!0;
	break}r=i.a(q).af();
	k[g]=new A.aH(r.a(),A.A(r).h("aH<1>"));
	r=p.bq();
	j[g]=new A.aH(r.a(),A.A(r).h("aH<1>"));++g;}if(s)return
	l=o.b;
	i=l.c;
	i.push(B.c.k(a));
	i.push("attributes");
	h=o.c;
	B.d.D(h,k);
	B.d.D(h,j);
	l=l.S();
	h=o.a;
	o.d.push(new A.eX(k,j,h.b-1,h.a,l,A.aD(t.e)));
	i.pop();
	i.pop();},
	$S:20};
	A.mL.prototype={
	$1(a){return a.gt()==null},
	$S:68};
	A.eX.prototype={
	dY(a){var s,r,q,p,o,n,m,l,k,j,i,h,g,f,e,d=this;
	for(s=d.a,r=s.length,q=d.b,p=d.c,o=d.e,n=o+"/JOINTS_",m=t.M,l=d.z,o+="/WEIGHTS_",k=d.d,j=0;j<r;++j){i=s[j].gt();
	if(i==null){d.w=!0;
	return}if(i>p){a.l($.qe(),A.a([d.f,d.r,i,p,k],m),n+j);
	continue}h=q[j].gt();
	if(h==null){d.w=!0;
	return}if(h!==0){if(!l.C(0,i)){a.l($.qd(),A.a([d.f,d.r,i],m),n+j);
	g=!1;}else g=!0;
	if(h<0)a.l($.qj(),A.a([d.f,d.r,h],m),o+j);
	else if(g){f=d.x;
	e=$.ol();
	e[0]=f+h;
	d.x=e[0];
	d.y+=2e-7;}}else if(i!==0)a.l($.qf(),A.a([d.f,d.r,i],m),n+j);}if(4===++d.r){if(Math.abs(d.x-1)>d.y)for(j=0;j<r;++j){s=$.qk();
	q=d.f;
	a.l(s,A.a([q-3,q,d.x],m),o+j);}l.P(0);
	d.x=d.y=d.r=0;}++d.f;}};
	A.bH.prototype={
	aB(){return "Severity."+this.b}};
	A.iH.prototype={};
	A.ho.prototype={};
	A.hL.prototype={
	$1(a){return "Actual data byte length ("+A.b(a[0])+") is less than the declared buffer byte length ("+A.b(a[1])+")."},
	$S:0};
	A.hM.prototype={
	$1(a){return "GLB-stored BIN chunk contains "+A.b(a[0])+" extra padding byte(s)."},
	$S:0};
	A.hE.prototype={
	$1(a){return "Declared minimum value for this component ("+A.b(a[0])+") does not match actual minimum ("+A.b(a[1])+")."},
	$S:0};
	A.hD.prototype={
	$1(a){return "Declared maximum value for this component ("+A.b(a[0])+") does not match actual maximum ("+A.b(a[1])+")."},
	$S:0};
	A.ht.prototype={
	$1(a){return "Accessor contains "+A.b(a[0])+" element(s) less than declared minimum value "+A.b(a[1])+"."},
	$S:0};
	A.hs.prototype={
	$1(a){return "Accessor contains "+A.b(a[0])+" element(s) greater than declared maximum value "+A.b(a[1])+"."},
	$S:0};
	A.hI.prototype={
	$1(a){return "Vector3 at accessor indices "+A.b(a[0])+".."+A.b(a[1])+" is not of unit length: "+A.b(a[2])+"."},
	$S:0};
	A.hz.prototype={
	$1(a){return "Vector3 with sign at accessor indices "+A.b(a[0])+".."+A.b(a[1])+" has invalid w component: "+A.b(a[2])+". Must be 1.0 or -1.0."},
	$S:0};
	A.hr.prototype={
	$1(a){return "Animation sampler output accessor element at indices "+A.b(a[0])+".."+A.b(a[1])+" is not of unit length: "+A.b(a[2])+"."},
	$S:0};
	A.hF.prototype={
	$1(a){return "Accessor element at index "+A.b(a[0])+" is not clamped to 0..1 range: "+A.b(a[1])+"."},
	$S:0};
	A.hx.prototype={
	$1(a){return "Accessor element at index "+A.b(a[0])+" is "+A.b(a[1])+"."},
	$S:0};
	A.hu.prototype={
	$1(a){return "Indices accessor element at index "+A.b(a[0])+" has value "+A.b(a[1])+" that is greater than the maximum vertex index available ("+A.b(a[2])+")."},
	$S:0};
	A.hw.prototype={
	$1(a){return "Indices accessor contains "+A.b(a[0])+" degenerate triangles (out of "+A.b(a[1])+")."},
	$S:0};
	A.hv.prototype={
	$1(a){return "Indices accessor contains primitive restart value ("+A.b(a[0])+") at index "+A.b(a[1])+"."},
	$S:0};
	A.hp.prototype={
	$1(a){return u.m+A.b(a[0])+" is negative: "+A.b(a[1])+"."},
	$S:0};
	A.hq.prototype={
	$1(a){return u.m+A.b(a[0])+" is less than or equal to previous: "+A.b(a[1])+" <= "+A.b(a[2])+"."},
	$S:0};
	A.hH.prototype={
	$1(a){return u.d+A.b(a[0])+" is less than or equal to previous: "+A.b(a[1])+" <= "+A.b(a[2])+"."},
	$S:0};
	A.hG.prototype={
	$1(a){return u.d+A.b(a[0])+" is greater than or equal to the number of accessor elements: "+A.b(a[1])+" >= "+A.b(a[2])+"."},
	$S:0};
	A.hy.prototype={
	$1(a){return "Matrix element at index "+A.b(a[0])+" (component index "+A.b(a[1])+") contains invalid value: "+A.b(a[2])+"."},
	$S:0};
	A.hO.prototype={
	$1(a){return "Image data is invalid. "+A.b(a[0])},
	$S:0};
	A.hQ.prototype={
	$1(a){return "Recognized image format "+("'"+A.b(a[0])+"'")+" does not match declared image format "+("'"+A.b(a[1])+"'")+"."},
	$S:0};
	A.hT.prototype={
	$1(a){return "Unexpected end of image stream."},
	$S:0};
	A.hU.prototype={
	$1(a){return "Image format not recognized."},
	$S:0};
	A.hR.prototype={
	$1(a){return "'"+A.b(a[0])+"' MIME type requires an extension."},
	$S:0};
	A.hS.prototype={
	$1(a){return "Image has non-power-of-two dimensions: "+A.b(a[0])+"x"+A.b(a[1])+"."},
	$S:0};
	A.hP.prototype={
	$1(a){return "Image contains unsupported features like non-default colorspace information, non-square pixels, or animation."},
	$S:0};
	A.hV.prototype={
	$1(a){return "URI is used in GLB container."},
	$S:0};
	A.hN.prototype={
	$1(a){return "Data URI is used in GLB container."},
	$S:0};
	A.hB.prototype={
	$1(a){return "Joints accessor element at index "+A.b(a[0])+" (component index "+A.b(a[1])+") has value "+A.b(a[2])+" that is greater than the maximum joint index ("+A.b(a[3])+") set by skin "+A.b(a[4])+"."},
	$S:0};
	A.hA.prototype={
	$1(a){return "Joints accessor element at index "+A.b(a[0])+" (component index "+A.b(a[1])+") has value "+A.b(a[2])+" that is already in use for the vertex."},
	$S:0};
	A.hJ.prototype={
	$1(a){return "Weights accessor element at index "+A.b(a[0])+" (component index "+A.b(a[1])+") has negative value "+A.b(a[2])+"."},
	$S:0};
	A.hK.prototype={
	$1(a){return "Weights accessor elements (at indices "+A.b(a[0])+".."+A.b(a[1])+") have non-normalized sum: "+A.b(a[2])+"."},
	$S:0};
	A.hC.prototype={
	$1(a){return "Joints accessor element at index "+A.b(a[0])+" (component index "+A.b(a[1])+") is used with zero weight but has non-zero value ("+A.b(a[2])+")."},
	$S:0};
	A.iF.prototype={};
	A.iG.prototype={
	$1(a){return J.as(a[0])},
	$S:0};
	A.kf.prototype={};
	A.kh.prototype={
	$1(a){return "Invalid array length "+A.b(a[0])+". Valid lengths are: "+J.bt(t.Y.a(a[1]),A.pM(),t.X).k(0)+"."},
	$S:0};
	A.ki.prototype={
	$1(a){var s=a[0];
	s=typeof s=="string"?"'"+s+"'":J.as(s);
	return "Type mismatch. Array element "+A.b(s)+" is not a "+("'"+A.b(a[1])+"'")+"."},
	$S:0};
	A.kg.prototype={
	$1(a){return "Duplicate element."},
	$S:0};
	A.kk.prototype={
	$1(a){return "Index must be a non-negative integer."},
	$S:0};
	A.kl.prototype={
	$1(a){return "Invalid JSON data. Parser output: "+A.b(a[0])},
	$S:0};
	A.km.prototype={
	$1(a){return "Invalid URI "+("'"+A.b(a[0])+"'")+". Parser output:\n"+A.b(a[1])},
	$S:0};
	A.kj.prototype={
	$1(a){return "Entity cannot be empty."},
	$S:0};
	A.kn.prototype={
	$1(a){a.toString;
	return "Exactly one of "+new A.ab(a,A.dj(),A.a_(a).h("ab<1,e*>")).k(0)+" properties must be defined."},
	$S:0};
	A.ko.prototype={
	$1(a){return "Value "+("'"+A.b(a[0])+"'")+" does not match regexp pattern "+("'"+A.b(a[1])+"'")+"."},
	$S:0};
	A.kp.prototype={
	$1(a){var s=a[0];
	s=typeof s=="string"?"'"+s+"'":J.as(s);
	return "Type mismatch. Property value "+A.b(s)+" is not a "+("'"+A.b(a[1])+"'")+"."},
	$S:0};
	A.ku.prototype={
	$1(a){var s=a[0];
	s=typeof s=="string"?"'"+s+"'":J.as(s);
	return "Invalid value "+A.b(s)+". Valid values are "+J.bt(t.Y.a(a[1]),A.pM(),t.X).k(0)+"."},
	$S:0};
	A.kv.prototype={
	$1(a){return "Value "+A.b(a[0])+" is out of range."},
	$S:0};
	A.kt.prototype={
	$1(a){return "Value "+A.b(a[0])+" is not a multiple of "+A.b(a[1])+"."},
	$S:0};
	A.kq.prototype={
	$1(a){return "Property "+("'"+A.b(a[0])+"'")+" must be defined."},
	$S:0};
	A.kr.prototype={
	$1(a){return "Unexpected property."},
	$S:0};
	A.ks.prototype={
	$1(a){return "Dependency failed. "+("'"+A.b(a[0])+"'")+" must be defined."},
	$S:0};
	A.kw.prototype={};
	A.lj.prototype={
	$1(a){return "Unknown glTF major asset version: "+A.b(a[0])+"."},
	$S:0};
	A.lk.prototype={
	$1(a){return "Unknown glTF minor asset version: "+A.b(a[0])+"."},
	$S:0};
	A.l4.prototype={
	$1(a){return "Asset minVersion "+("'"+A.b(a[0])+"'")+" is greater than version "+("'"+A.b(a[1])+"'")+"."},
	$S:0};
	A.kL.prototype={
	$1(a){return "Invalid value "+A.b(a[0])+" for GL type "+("'"+A.b(a[1])+"'")+"."},
	$S:0};
	A.ky.prototype={
	$1(a){return "Only (u)byte and (u)short accessors can be normalized."},
	$S:0};
	A.kz.prototype={
	$1(a){return "Offset "+A.b(a[0])+" is not a multiple of componentType length "+A.b(a[1])+"."},
	$S:0};
	A.kx.prototype={
	$1(a){return "Matrix accessors must be aligned to 4-byte boundaries."},
	$S:0};
	A.kA.prototype={
	$1(a){return "Sparse accessor overrides more elements ("+A.b(a[0])+") than the base accessor contains ("+A.b(a[1])+")."},
	$S:0};
	A.kB.prototype={
	$1(a){return "Animated TRS properties will not affect a skinned mesh."},
	$S:0};
	A.kC.prototype={
	$1(a){return "Data URI media type must be 'application/octet-stream' or 'application/gltf-buffer'. Found "+("'"+A.b(a[0])+"'")+" instead."},
	$S:0};
	A.kE.prototype={
	$1(a){return "Buffer view's byteStride ("+A.b(a[0])+") is greater than byteLength ("+A.b(a[1])+")."},
	$S:0};
	A.kD.prototype={
	$1(a){return "Only buffer views with raw vertex data can have byteStride."},
	$S:0};
	A.kF.prototype={
	$1(a){return "xmag and ymag should not be negative."},
	$S:0};
	A.kG.prototype={
	$1(a){return "xmag and ymag must not be zero."},
	$S:0};
	A.kH.prototype={
	$1(a){return "yfov should be less than Pi."},
	$S:0};
	A.kI.prototype={
	$1(a){return "zfar must be greater than znear."},
	$S:0};
	A.kX.prototype={
	$1(a){return "Alpha cutoff is supported only for 'MASK' alpha mode."},
	$S:0};
	A.l_.prototype={
	$1(a){return "Invalid attribute name."},
	$S:0};
	A.l3.prototype={
	$1(a){return "All primitives must have the same number of morph targets."},
	$S:0};
	A.l1.prototype={
	$1(a){return "No POSITION attribute found."},
	$S:0};
	A.kZ.prototype={
	$1(a){return "Indices for indexed attribute semantic "+("'"+A.b(a[0])+"'")+" must start with 0 and be continuous. Total expected indices: "+A.b(a[1])+", total provided indices: "+A.b(a[2])+"."},
	$S:0};
	A.l2.prototype={
	$1(a){return "TANGENT attribute without NORMAL found."},
	$S:0};
	A.l0.prototype={
	$1(a){return "Number of JOINTS attribute semantics ("+A.b(a[0])+") does not match the number of WEIGHTS ("+A.b(a[1])+")."},
	$S:0};
	A.kY.prototype={
	$1(a){return "The length of weights array ("+A.b(a[0])+u.p+A.b(a[1])+")."},
	$S:0};
	A.l8.prototype={
	$1(a){return "A node can have either a matrix or any combination of translation/rotation/scale (TRS) properties."},
	$S:0};
	A.l6.prototype={
	$1(a){return "Do not specify default transform matrix."},
	$S:0};
	A.l9.prototype={
	$1(a){return "Matrix must be decomposable to TRS."},
	$S:0};
	A.lg.prototype={
	$1(a){return "Rotation quaternion must be normalized."},
	$S:0};
	A.ll.prototype={
	$1(a){return "Unused extension "+("'"+A.b(a[0])+"'")+" cannot be required."},
	$S:0};
	A.lf.prototype={
	$1(a){return "Extension "+("'"+A.b(a[0])+"'")+" cannot be optional."},
	$S:0};
	A.kK.prototype={
	$1(a){return "Extension name has invalid format."},
	$S:0};
	A.l7.prototype={
	$1(a){return "Empty node encountered."},
	$S:0};
	A.lc.prototype={
	$1(a){return "Node with a skinned mesh is not root. Parent transforms will not affect a skinned mesh."},
	$S:0};
	A.lb.prototype={
	$1(a){return "Local transforms will not affect a skinned mesh."},
	$S:0};
	A.la.prototype={
	$1(a){return "A node with a skinned mesh is used in a scene that does not contain joint nodes."},
	$S:0};
	A.lh.prototype={
	$1(a){return "Joints do not have a common root."},
	$S:0};
	A.li.prototype={
	$1(a){return "Skeleton node is not a common root."},
	$S:0};
	A.le.prototype={
	$1(a){return "Non-relative URI found: "+("'"+A.b(a[0])+"'")+"."},
	$S:0};
	A.l5.prototype={
	$1(a){return "This extension may be incompatible with other extensions for the object."},
	$S:0};
	A.ld.prototype={
	$1(a){return "Prefer JSON Objects for extras."},
	$S:0};
	A.kJ.prototype={
	$1(a){return "This property should not be defined as it will not be used."},
	$S:0};
	A.kM.prototype={
	$1(a){return "This extension requires the animation channel target node to be undefined."},
	$S:0};
	A.kN.prototype={
	$1(a){return "This extension requires the animation channel target path to be 'pointer'. Found "+("'"+A.b(a[0])+"'")+" instead."},
	$S:0};
	A.kO.prototype={
	$1(a){return "outerConeAngle ("+A.b(a[1])+") is less than or equal to innerConeAngle ("+A.b(a[0])+")."},
	$S:0};
	A.kP.prototype={
	$1(a){return "Normal and anisotropy textures should use the same texture coords."},
	$S:0};
	A.kQ.prototype={
	$1(a){return "Normal and clearcoat normal textures should use the same texture coords."},
	$S:0};
	A.kR.prototype={
	$1(a){return "The dispersion extension needs to be combined with the volume extension."},
	$S:0};
	A.kS.prototype={
	$1(a){return "Emissive strength has no effect when the emissive factor is zero or undefined."},
	$S:0};
	A.kW.prototype={
	$1(a){return "The volume extension needs to be combined with an extension that allows light to transmit through the surface."},
	$S:0};
	A.kV.prototype={
	$1(a){return "The volume extension should not be used with double-sided materials."},
	$S:0};
	A.kT.prototype={
	$1(a){return "Thickness minimum has no effect when a thickness texture is not defined."},
	$S:0};
	A.kU.prototype={
	$1(a){return "Thickness texture has no effect when the thickness minimum is equal to the thickness maximum."},
	$S:0};
	A.iY.prototype={};
	A.j0.prototype={
	$1(a){return "Accessor's total byteOffset "+A.b(a[0])+" isn't a multiple of componentType length "+A.b(a[1])+"."},
	$S:0};
	A.iZ.prototype={
	$1(a){return "Referenced bufferView's byteStride value "+A.b(a[0])+" is less than accessor element's length "+A.b(a[1])+"."},
	$S:0};
	A.j_.prototype={
	$1(a){return "Accessor (offset: "+A.b(a[0])+", length: "+A.b(a[1])+") does not fit referenced bufferView ["+A.b(a[2])+"] length "+A.b(a[3])+"."},
	$S:0};
	A.j1.prototype={
	$1(a){return "Override of previously set accessor usage. Initial: "+("'"+A.b(a[0])+"'")+", new: "+("'"+A.b(a[1])+"'")+"."},
	$S:0};
	A.j4.prototype={
	$1(a){return "Animation channel has the same target as channel "+A.b(a[0])+"."},
	$S:0};
	A.j2.prototype={
	$1(a){return "Animation channel cannot target TRS properties of a node with defined matrix."},
	$S:0};
	A.j3.prototype={
	$1(a){return "Animation channel cannot target WEIGHTS when mesh does not have morph targets."},
	$S:0};
	A.j8.prototype={
	$1(a){return "accessor.min and accessor.max must be defined for animation input accessor."},
	$S:0};
	A.j6.prototype={
	$1(a){return "Invalid Animation sampler input accessor format "+("'"+A.b(a[0])+"'")+". Must be one of "+J.bt(t.Y.a(a[1]),A.dj(),t.X).k(0)+"."},
	$S:0};
	A.ja.prototype={
	$1(a){return "Invalid animation sampler output accessor format "+("'"+A.b(a[0])+"'")+" for path "+("'"+A.b(a[2])+"'")+". Must be one of "+J.bt(t.Y.a(a[1]),A.dj(),t.X).k(0)+"."},
	$S:0};
	A.j7.prototype={
	$1(a){return "Animation sampler output accessor with "+("'"+A.b(a[0])+"'")+" interpolation must have at least "+A.b(a[1])+" elements. Got "+A.b(a[2])+"."},
	$S:0};
	A.j9.prototype={
	$1(a){return "Animation sampler output accessor of count "+A.b(a[0])+" expected. Found "+A.b(a[1])+"."},
	$S:0};
	A.j5.prototype={
	$1(a){return "bufferView.byteStride must not be defined for buffer views used by animation sampler accessors."},
	$S:0};
	A.jb.prototype={
	$1(a){return "Buffer refers to an unresolved GLB binary chunk."},
	$S:0};
	A.je.prototype={
	$1(a){return "BufferView does not fit buffer ("+A.b(a[0])+") byteLength ("+A.b(a[1])+")."},
	$S:0};
	A.jd.prototype={
	$1(a){return "Override of previously set bufferView target or usage. Initial: "+("'"+A.b(a[0])+"'")+", new: "+("'"+A.b(a[1])+"'")+"."},
	$S:0};
	A.jc.prototype={
	$1(a){return "bufferView.target should be set for vertex or index data."},
	$S:0};
	A.jf.prototype={
	$1(a){return "bufferView.byteStride must not be defined for buffer views containing image data."},
	$S:0};
	A.jg.prototype={
	$1(a){return "Validation support for this extension is incomplete; the asset may have undetected issues."},
	$S:0};
	A.jh.prototype={
	$1(a){return "IBM accessor must have at least "+A.b(a[0])+" elements. Found "+A.b(a[1])+"."},
	$S:0};
	A.jl.prototype={
	$1(a){return "Invalid accessor format "+("'"+A.b(a[0])+"'")+" for this attribute semantic. Must be one of "+J.bt(t.Y.a(a[1]),A.dj(),t.X).k(0)+"."},
	$S:0};
	A.jm.prototype={
	$1(a){return "Mesh attributes cannot use UNSIGNED_INT component type."},
	$S:0};
	A.ju.prototype={
	$1(a){return "accessor.min and accessor.max must be defined for POSITION attribute accessor."},
	$S:0};
	A.jk.prototype={
	$1(a){return "bufferView.byteStride must be defined when two or more accessors use the same buffer view."},
	$S:0};
	A.jj.prototype={
	$1(a){return "Vertex attribute data must be aligned to 4-byte boundaries."},
	$S:0};
	A.jq.prototype={
	$1(a){return "bufferView.byteStride must not be defined for indices accessor."},
	$S:0};
	A.jp.prototype={
	$1(a){return "Invalid indices accessor format "+("'"+A.b(a[0])+"'")+". Must be one of "+J.bt(t.Y.a(a[1]),A.dj(),t.X).k(0)+". "},
	$S:0};
	A.jo.prototype={
	$1(a){return "Number of vertices or indices ("+A.b(a[0])+") is not compatible with used drawing mode ("+("'"+A.b(a[1])+"'")+")."},
	$S:0};
	A.jv.prototype={
	$1(a){return "Material is incompatible with mesh primitive: Texture binding "+("'"+A.b(a[0])+"'")+" needs 'TEXCOORD_"+A.b(a[1])+"' attribute."},
	$S:0};
	A.jt.prototype={
	$1(a){return "Material requires a tangent space but the mesh primitive does not provide it and the material does not contain a normal map to generate it."},
	$S:0};
	A.jn.prototype={
	$1(a){return "Material requires a tangent space but the mesh primitive does not provide it. Runtime-generated tangent space may be non-portable across implementations."},
	$S:0};
	A.jw.prototype={
	$1(a){return "All accessors of the same primitive must have the same count."},
	$S:0};
	A.js.prototype={
	$1(a){return "The mesh primitive does not define this attribute semantic."},
	$S:0};
	A.jr.prototype={
	$1(a){return "Base accessor has different count."},
	$S:0};
	A.jx.prototype={
	$1(a){return "Node is a part of a node loop."},
	$S:0};
	A.jy.prototype={
	$1(a){return "Value overrides parent of node "+A.b(a[0])+"."},
	$S:0};
	A.jB.prototype={
	$1(a){var s=A.b(a[0]),r=a[1];
	return "The length of weights array ("+s+u.p+A.b(r==null?0:r)+")."},
	$S:0};
	A.jz.prototype={
	$1(a){return "Node has skin defined, but mesh has no joints data."},
	$S:0};
	A.jA.prototype={
	$1(a){return "Node uses skinned mesh, but has no skin defined."},
	$S:0};
	A.jC.prototype={
	$1(a){return "Node "+A.b(a[0])+" is not a root node."},
	$S:0};
	A.jE.prototype={
	$1(a){return "Invalid IBM accessor format "+("'"+A.b(a[0])+"'")+". Must be one of "+J.bt(t.Y.a(a[1]),A.dj(),t.X).k(0)+". "},
	$S:0};
	A.jD.prototype={
	$1(a){return "bufferView.byteStride must not be defined for buffer views used by inverse bind matrices accessors."},
	$S:0};
	A.jF.prototype={
	$1(a){return "Invalid MIME type "+("'"+A.b(a[0])+"'")+" for the texture source. Valid MIME types are "+J.bt(t.Y.a(a[1]),A.dj(),t.X).k(0)+"."},
	$S:0};
	A.jG.prototype={
	$1(a){return "Extension is not declared in extensionsUsed."},
	$S:0};
	A.jH.prototype={
	$1(a){return "Unexpected location for this extension."},
	$S:0};
	A.jI.prototype={
	$1(a){return "Unresolved reference: "+A.b(a[0])+"."},
	$S:0};
	A.jJ.prototype={
	$1(a){return "Cannot validate an extension as it is not supported by the validator: "+("'"+A.b(a[0])+"'")+"."},
	$S:0};
	A.jM.prototype={
	$1(a){return "This object may be unused."},
	$S:0};
	A.jL.prototype={
	$1(a){return "The static morph target weights are always overridden."},
	$S:0};
	A.jK.prototype={
	$1(a){return "Tangents are not used because the material has no normal texture."},
	$S:0};
	A.ji.prototype={
	$1(a){return "This variant is used more than once for this mesh primitive."},
	$S:0};
	A.hZ.prototype={};
	A.i5.prototype={
	$1(a){return "Invalid GLB magic value ("+A.b(a[0])+")."},
	$S:0};
	A.i6.prototype={
	$1(a){return "Invalid GLB version value "+A.b(a[0])+"."},
	$S:0};
	A.i8.prototype={
	$1(a){return "Declared GLB length ("+A.b(a[0])+") is too small."},
	$S:0};
	A.i_.prototype={
	$1(a){return "Length of "+A.b(a[0])+" chunk is not aligned to 4-byte boundaries."},
	$S:0};
	A.i7.prototype={
	$1(a){return "Declared length ("+A.b(a[0])+") does not match GLB length ("+A.b(a[1])+")."},
	$S:0};
	A.i0.prototype={
	$1(a){return "Chunk ("+A.b(a[0])+") length ("+A.b(a[1])+") does not fit total GLB length."},
	$S:0};
	A.i3.prototype={
	$1(a){return "Chunk ("+A.b(a[0])+") cannot have zero length."},
	$S:0};
	A.i2.prototype={
	$1(a){return "Empty BIN chunk should be omitted."},
	$S:0};
	A.i1.prototype={
	$1(a){return "Chunk of type "+A.b(a[0])+" has already been used."},
	$S:0};
	A.ib.prototype={
	$1(a){return "Unexpected end of chunk header."},
	$S:0};
	A.ia.prototype={
	$1(a){return "Unexpected end of chunk data."},
	$S:0};
	A.ic.prototype={
	$1(a){return "Unexpected end of header."},
	$S:0};
	A.id.prototype={
	$1(a){return "First chunk must be of JSON type. Found "+A.b(a[0])+" instead."},
	$S:0};
	A.i9.prototype={
	$1(a){return "BIN chunk must be the second chunk."},
	$S:0};
	A.ie.prototype={
	$1(a){return "Unknown GLB chunk type: "+A.b(a[0])+"."},
	$S:0};
	A.i4.prototype={
	$1(a){return "Extra data after the end of GLB stream."},
	$S:0};
	A.cW.prototype={
	gbl(){var s=J.tJ(this.a.c.$1(this.e));
	return s},
	gc9(){var s=this.b;
	return s==null?this.a.a:s},
	gE(a){return B.a.gE(this.k(0))},
	O(a,b){if(b==null)return !1
	return b instanceof A.cW&&b.k(0)===this.k(0)},
	k(a){var s=this,r=s.c;
	if(r!=null&&r.length!==0)return A.b(r)+": "+s.gbl()
	r=s.d;
	if(r!=null)return "@"+A.b(r)+": "+s.gbl()
	return s.gbl()}};
	A.ca.prototype={
	p(a,b){var s=this.d,r=this.e=a.Q.i(0,s);
	if(s!==-1)if(r==null)b.l($.Q(),A.a([s],t.M),"source");
	else r.a$=!0;},
	c4(a,b){var s=this.e,r=s==null,q=r?null:s.x;
	if(q==null){s=r?null:s.as;
	q=s==null?null:s.a;}if(q!=null&&q!=="image/webp")b.l($.oa(),A.a([q,B.d7],t.M),"source");},
	$icC:1};
	A.cf.prototype={
	p(a,b){var s,r;
	b.L($.r_());
	for(s=b.e,r=this;r!=null;){r=s.i(0,r);
	if(r instanceof A.bw){if(r.f!=null)b.L($.rD());
	s=r.e;
	if(s!=="pointer")b.F($.rE(),A.a([s],t.M));
	break}}}};
	A.bC.prototype={
	p(a,b){var s,r,q=b.c;
	q.push("lights");
	s=this.d;
	r=J.cX(q.slice(0),A.a_(q).c);
	b.x.m(0,s,r);
	s.a4(new A.iS(b,a));
	q.pop();}};
	A.iS.prototype={
	$2(a,b){var s=this.a.c;
	s.push(B.c.k(a));
	s.pop();},
	$S:70};
	A.ba.prototype={};
	A.cg.prototype={};
	A.ch.prototype={
	p(a,b){var s,r,q=a.a.i(0,"KHR_lights_punctual");
	if(q instanceof A.bC){s=this.d;
	r=this.e=q.d.i(0,s);
	if(s!==-1)if(r==null)b.l($.Q(),A.a([s],t.M),"light");
	else r.a$=!0;}else b.F($.cO(),A.a(["/extensions/KHR_lights_punctual"],t.M));}};
	A.ci.prototype={
	p(a,b){var s,r,q,p,o=this.f;
	if(o!=null){s=b.c;
	s.push("anisotropyTexture");
	o.p(a,b);
	for(r=b.e,q=this;q!=null;){q=r.i(0,q);
	if(q instanceof A.ai){q.ay=!0;
	p=q.x;
	if(p!=null&&p.e!==o.e)b.L($.rG());
	break}}s.pop();}}};
	A.cj.prototype={
	p(a,b){var s,r,q,p,o=this,n=o.e;
	if(n!=null){s=b.c;
	s.push("clearcoatTexture");
	n.p(a,b);
	s.pop();}n=o.r;
	if(n!=null){s=b.c;
	s.push("clearcoatRoughnessTexture");
	n.p(a,b);
	s.pop();}n=o.w;
	if(n!=null){s=b.c;
	s.push("clearcoatNormalTexture");
	n.p(a,b);
	for(r=b.e,q=o;q!=null;){q=r.i(0,q);
	if(q instanceof A.ai){p=q.x;
	if(p!=null&&p.e!==n.e)b.L($.rH());
	break}}s.pop();}}};
	A.ck.prototype={
	p(a,b){var s,r;
	for(s=b.e,r=this;r!=null;){r=s.i(0,r);
	if(r instanceof A.ai){if(!r.a.v("KHR_materials_volume"))b.L($.rI());
	break}}}};
	A.cl.prototype={
	p(a,b){var s,r,q=this.d;
	q=isNaN(q)||q===1;
	if(q)return
	for(q=b.e,s=this;s!=null;){s=q.i(0,s);
	if(s instanceof A.ai){r=s.Q;
	if(r!=null&&J.af(r[0],0)&&J.af(r[1],0)&&J.af(r[2],0))b.L($.rJ());
	break}}}};
	A.cm.prototype={};
	A.cn.prototype={
	p(a,b){var s,r=this.e;
	if(r!=null){s=b.c;
	s.push("iridescenceTexture");
	r.p(a,b);
	s.pop();}r=this.x;
	if(r!=null){s=b.c;
	s.push("iridescenceThicknessTexture");
	r.p(a,b);
	s.pop();}}};
	A.co.prototype={
	p(a,b){var s,r=this.e;
	if(r!=null){s=b.c;
	s.push("diffuseTexture");
	r.p(a,b);
	s.pop();}r=this.w;
	if(r!=null){s=b.c;
	s.push("specularGlossinessTexture");
	r.p(a,b);
	s.pop();}}};
	A.cp.prototype={
	p(a,b){var s,r=this.e;
	if(r!=null){s=b.c;
	s.push("sheenColorTexture");
	r.p(a,b);
	s.pop();}r=this.r;
	if(r!=null){s=b.c;
	s.push("sheenRoughnessTexture");
	r.p(a,b);
	s.pop();}}};
	A.cq.prototype={
	p(a,b){var s,r=this.e;
	if(r!=null){s=b.c;
	s.push("specularTexture");
	r.p(a,b);
	s.pop();}r=this.r;
	if(r!=null){s=b.c;
	s.push("specularColorTexture");
	r.p(a,b);
	s.pop();}}};
	A.cr.prototype={
	p(a,b){var s,r=this.e;
	if(r!=null){s=b.c;
	s.push("transmissionTexture");
	r.p(a,b);
	s.pop();}}};
	A.cs.prototype={};
	A.bD.prototype={
	p(a,b){var s,r,q=b.c;
	q.push("variants");
	s=this.d;
	r=J.cX(q.slice(0),A.a_(q).c);
	b.x.m(0,s,r);
	s.a4(new A.iT(b,a));
	q.pop();}};
	A.iT.prototype={
	$2(a,b){var s=this.a.c;
	s.push(B.c.k(a));
	s.pop();},
	$S:71};
	A.aM.prototype={};
	A.ct.prototype={
	p(a,b){var s=b.c;
	s.push("mappings");
	this.d.a4(new A.iW(b,a,A.aD(t.e)));
	s.pop();}};
	A.iW.prototype={
	$2(a,b){var s=this.a,r=s.c;
	r.push(B.c.k(a));
	b.cR(this.b,s,this.c);
	r.pop();},
	$S:72};
	A.bb.prototype={
	cR(a,b,c){var s,r,q,p=this,o=a.a.i(0,"KHR_materials_variants");
	if(o instanceof A.bD){s=p.d;
	if(s!=null){r=b.c;
	r.push("variants");
	A.oJ(s.gj(s),new A.iU(p,o,b,c),!1,t.J);
	r.pop();}s=p.e;
	r=p.r=a.as.i(0,s);
	if(s!==-1)if(r==null)b.l($.Q(),A.a([s],t.M),"material");
	else {r.a$=!0;
	for(s=b.e,q=p;q!=null;){q=s.i(0,q);
	if(q instanceof A.aE){p.r.ch.M(0,new A.iV(q,b));
	break}}}}else b.F($.cO(),A.a(["/extensions/KHR_materials_variants"],t.M));},
	p(a,b){return this.cR(a,b,null)}};
	A.iU.prototype={
	$1(a){var s=this,r=s.a.d.i(0,a),q=s.b.d.i(0,r);
	if(r!==-1){if(!s.d.C(0,r))s.c.Z($.r1(),a);
	if(q==null)s.c.ao($.Q(),A.a([r],t.M),a);
	else q.a$=!0;}return q},
	$S:73};
	A.iV.prototype={
	$2(a,b){var s;
	if(b!==-1){s=this.a;
	if(b+1>s.ax)this.b.l($.o9(),A.a([a,b],t.M),"material");
	else s.dx[b]=-1;}},
	$S:4};
	A.cu.prototype={
	p(a,b){var s,r,q=this.r;
	if(q!=null){s=b.c;
	s.push("thicknessTexture");
	q.p(a,b);
	s.pop();}for(q=b.e,r=this;r!=null;){r=q.i(0,r);
	if(r instanceof A.ai){q=r.a;
	if(!q.v("KHR_materials_transmission")&&!q.gX().aR(0,new A.iX()))b.L($.rN());
	if(r.ax&&this.f>0)b.L($.rM());
	break}}}};
	A.iX.prototype={
	$1(a){return t.h.b(a)},
	$S:74};
	A.cv.prototype={
	p(a,b){var s,r;
	for(s=b.e,r=this;r!=null;){r=s.i(0,r);
	if(r instanceof A.ai){r.ch.m(0,b.S(),this.r);
	break}}}};
	A.L.prototype={};
	A.O.prototype={};
	A.cb.prototype={
	gE(a){var s=J.bY(this.a),r=J.bY(this.b);
	return A.px(A.fW(A.fW(0,B.c.gE(s)),B.c.gE(r)))},
	O(a,b){if(b==null)return !1
	return b instanceof A.cb&&this.b==b.b&&this.a==b.a}};
	A.cw.prototype={};
	A.fo.prototype={};
	A.dt.prototype={
	c0(){var s=this,r=s.d=s.c.bT(new A.ii(s),s.gdB(),s.gcn()),q=s.ch;
	q.e=r.geg();
	q.f=r.gej();
	q.r=new A.ij(s);
	return s.e.a},
	aN(){this.d.K();
	var s=this.e;
	if((s.a.a&30)===0)s.a3(new A.au("model/gltf-binary",null,this.cx));},
	dA(a0){var s,r,q,p,o,n,m,l,k,j,i,h,g,f,e,d,c=this,b="model/gltf-binary",a="0";
	c.d.aZ();
	for(s=J.V(a0),r=t.f,q=t.G,p=t.M,o=c.a,n=0;n!==s.gj(a0);)switch(c.r){case 0:m=s.gj(a0);
	l=c.w;
	k=Math.min(m-n,12-l);
	m=l+k;
	c.w=m;
	B.j.a5(o,l,m,a0,n);
	n+=k;
	c.x=k;
	if(c.w!==12)break
	j=c.b.getUint32(0,!0);
	if(j!==1179937895){c.f.a2($.qA(),A.a([j],p),0);
	c.d.K();
	s=c.e.a;
	if((s.a&30)===0){r=c.cx;
	s.ah(new A.au(b,null,r));}return}i=c.b.getUint32(4,!0);
	if(i!==2){c.f.a2($.qB(),A.a([i],p),4);
	c.d.K();
	s=c.e.a;
	if((s.a&30)===0){r=c.cx;
	s.ah(new A.au(b,null,r));}return}m=c.y=c.b.getUint32(8,!0);
	if(m<=c.x)c.f.a2($.qD(),A.a([m],p),8);
	c.r=1;
	c.w=0;
	break
	case 1:m=c.x;
	if(m===c.y){c.f.aQ($.qz(),m);
	c.d.K();
	c.cm();
	return}m=s.gj(a0);
	l=c.w;
	k=Math.min(m-n,8-l);
	m=l+k;
	c.w=m;
	B.j.a5(o,l,m,a0,n);
	n+=k;
	c.x+=k;
	if(c.w!==8)break
	c.Q=c.b.getUint32(0,!0);
	m=c.b.getUint32(4,!0);
	c.as=m;
	if((c.Q&3)!==0){l=c.f;
	h=$.qu();
	g=c.x;
	l.a2(h,A.a(["0x"+B.a.aq(B.c.av(m,16),8,a)],p),g-8);}if(c.x+c.Q>c.y)c.f.a2($.qv(),A.a(["0x"+B.a.aq(B.c.av(c.as,16),8,a),c.Q],p),c.x-8);
	if(c.z===0&&c.as!==1313821514)c.f.a2($.qI(),A.a(["0x"+B.a.aq(B.c.av(c.as,16),8,a)],p),c.x-8);
	m=c.as;
	if(m===5130562&&c.z>1&&!c.CW)c.f.a2($.qE(),A.a(["0x"+B.a.aq(B.c.av(m,16),8,a)],p),c.x-8);
	f=new A.ig(c);
	m=c.as;
	switch(m){case 1313821514:if(c.Q===0){l=c.f;
	h=$.qy();
	g=c.x;
	l.a2(h,A.a(["0x"+B.a.aq(B.c.av(m,16),8,a)],p),g-8);}f.$1$seen(c.at);
	c.at=!0;
	break
	case 5130562:if(c.Q===0)c.f.aQ($.qx(),c.x-8);
	f.$1$seen(c.CW);
	c.CW=!0;
	break
	default:c.f.a2($.qJ(),A.a(["0x"+B.a.aq(B.c.av(m,16),8,a)],p),c.x-8);
	c.r=4294967295;}++c.z;
	c.w=0;
	break
	case 1313821514:k=Math.min(s.gj(a0)-n,c.Q-c.w);
	if(c.ax==null){m=c.ch;
	l=c.f;
	m=new A.cT(new A.aj(m,A.A(m).h("aj<1>")),new A.ay(new A.C($.B,r),q));
	m.e=l;
	c.ax=m;
	c.ay=m.c0();}m=c.ch;
	e=n+k;
	l=s.a1(a0,n,e);
	h=m.b;
	if(h>=4)A.Z(m.bv());
	if((h&1)!==0)m.aC(l);
	else if((h&3)===0){m=m.b6();
	l=new A.cG(l);
	d=m.c;
	if(d==null)m.b=m.c=l;
	else {d.saG(l);
	m.c=l;}}m=c.w+=k;
	c.x+=k;
	if(m===c.Q){c.ch.a7();
	c.r=1;
	c.w=0;}n=e;
	break
	case 5130562:m=s.gj(a0);
	l=c.Q;
	h=c.w;
	k=Math.min(m-n,l-h);
	m=c.cx;
	if(m==null)m=c.cx=new Uint8Array(l);
	l=h+k;
	c.w=l;
	B.j.a5(m,h,l,a0,n);
	n+=k;
	c.x+=k;
	if(c.w===c.Q){c.r=1;
	c.w=0;}break
	case 4294967295:m=s.gj(a0);
	l=c.Q;
	h=c.w;
	k=Math.min(m-n,l-h);
	h+=k;
	c.w=h;
	n+=k;
	c.x+=k;
	if(h===l){c.r=1;
	c.w=0;}break}c.d.ar();},
	cm(){var s,r,q=this;
	switch(q.r){case 0:q.f.aQ($.qH(),q.x);
	q.aN();
	break
	case 1:if(q.w!==0){q.f.aQ($.qG(),q.x);
	q.aN();}else {s=q.y;
	r=q.x;
	if(s!==r)q.f.a2($.qC(),A.a([s,r],t.M),q.x);
	s=q.ay;
	if(s!=null)s.au(0,new A.ih(q),q.gcn(),t.P);
	else q.e.a3(new A.au("model/gltf-binary",null,q.cx));}break
	default:if(q.Q>0)q.f.aQ($.qF(),q.x);
	q.aN();}},
	dC(a){var s;
	this.d.K();
	s=this.e;
	if((s.a.a&30)===0)s.R(a);},
	$ieS:1};
	A.ii.prototype={
	$1(a){	try{this.a.dA(a);}catch(s){if(A.M(s) instanceof A.bA)this.a.aN();
	else throw s}},
	$S:11};
	A.ij.prototype={
	$0(){var s=this.a;
	if((s.ch.b&4)!==0)s.d.ar();
	else s.aN();},
	$S:2};
	A.ig.prototype={
	$1$seen(a){var s=this.a;
	if(a){s.f.a2($.qw(),A.a(["0x"+B.a.aq(B.c.av(s.as,16),8,"0")],t.M),s.x-8);
	s.r=4294967295;}else s.r=s.as;},
	$0(){return this.$1$seen(null)},
	$S:76};
	A.ih.prototype={
	$1(a){var s=this.a,r=a==null?null:a.b;
	s.e.a3(new A.au("model/gltf-binary",r,s.cx));},
	$S:77};
	A.au.prototype={};
	A.im.prototype={
	$0(){return this.a.b.aZ()},
	$S:1};
	A.io.prototype={
	$0(){return this.a.b.ar()},
	$S:1};
	A.il.prototype={
	$0(){return this.a.b.K()},
	$S:78};
	A.ip.prototype={
	$1(a){var s,r,q,p,o=this,n=o.a;
	if(!n.a){s=J.V(a);
	if(s.gA(a)){n.b.K();
	o.b.a7();
	o.c.R(B.a8);
	return}r=s.i(a,0);
	if(103===r){s=o.b;
	o.c.a3(A.oA(new A.aj(s,A.A(s).h("aj<1>")),o.d));
	n.a=!0;}else {s=123===r||9===r||32===r||10===r||13===r||239===r;
	q=o.c;
	p=o.b;
	if(s){q.a3(A.oB(new A.aj(p,A.A(p).h("aj<1>")),o.d));
	n.a=!0;}else {n.b.K();
	p.a7();
	q.R(B.a8);
	return}}}o.b.C(0,a);},
	$S:11};
	A.cT.prototype={
	c0(){var s=this,r=A.a([],t.M),q=new A.ac("");
	s.d=new A.mu(new A.fV(!1),new A.mh(B.ab.gcF().a,new A.fO(new A.ik(s),r,t.cy),q),q);
	s.b=s.a.bT(s.gdF(),s.gdH(),s.gdJ());
	return s.c.a},
	dG(a){var s,r,p=this;
	p.b.aZ();
	if(p.f){r=J.V(a);
	if(r.ga8(a)&&239===r.i(a,0))p.e.aE($.h3(),A.a(["BOM found at the beginning of UTF-8 stream."],t.M),!0);
	p.f=!1;}try{p.d.dX(a,0,J.a3(a),!1);
	p.b.ar();}catch(q){r=A.M(q);
	if(r instanceof A.aK){s=r;
	p.e.aE($.h3(),A.a([s],t.M),!0);
	p.b.K();
	p.c.bd();}else throw q}},
	dK(a){var s;
	this.b.K();
	s=this.c;
	if((s.a.a&30)===0)s.R(a);},
	dI(){var s,q,p=this;
	try{p.d.a7();}catch(r){q=A.M(r);
	if(q instanceof A.aK){s=q;
	p.e.aE($.h3(),A.a([s],t.M),!0);
	p.b.K();
	p.c.bd();}else throw r}},
	$ieS:1};
	A.ik.prototype={
	$1(a){var s,r,p=a[0];
	if(t.t.b(p))try{r=this.a;
	s=A.oC(p,r.e);
	r.c.a3(new A.au("model/gltf+json",s,null));}catch(q){if(A.M(q) instanceof A.bA){r=this.a;
	r.b.K();
	r.c.bd();}else throw q}else {r=this.a;
	r.e.aE($.a2(),A.a([p,"object"],t.M),!0);
	r.b.K();
	r.c.bd();}},
	$S:80};
	A.dv.prototype={
	k(a){return "Invalid data: could not detect glTF format."},
	$ia8:1};
	A.mS.prototype={
	$2(a,b){var s,r;
	this.a.$1(a);
	b=A.mM(b);
	s=A.aI(b)&&b>=0;
	r=this.b;
	if(s)r.m(0,a,b);
	else {r.m(0,a,-1);
	this.c.n($.h2(),a);}},
	$S:3};
	A.mT.prototype={
	$2(a,b){var s,r;
	this.a.$1(a);
	b=A.mM(b);
	s=A.aI(b)&&b>=0;
	r=this.b;
	if(s)r.m(0,a,b);
	else {r.m(0,a,-1);
	this.c.n($.h2(),a);}},
	$S:3};
	A.mU.prototype={
	$1(a){return a.ak(0,t.X,t.e)},
	$S:81};
	A.mQ.prototype={
	$0(){return A.a([],t.bH)},
	$S:82};
	A.F.prototype={
	i(a,b){return b==null||b<0||b>=this.a.length?null:this.a[b]},
	m(a,b,c){this.a[b]=c;},
	gj(a){return this.b},
	sj(a,b){throw A.d(A.ad("Changing length is not supported"))},
	k(a){return A.iI(this.a,"[","]")},
	a4(a){var s,r,q,p;
	for(s=this.b,r=this.a,q=0;q<s;++q){p=r[q];
	if(p==null)continue
	a.$2(q,p);}}};
	A.a1.prototype={
	aF(a){return !0}};
	A.fv.prototype={
	a0(a,b,c,d){var s=this,r=s.c,q=r!=null?r.$1(d):d;
	r=s.a+q*q;
	s.a=r;
	if(2===c){if(Math.abs(Math.sqrt(r)-1)>0.00674)a.l($.o0(),A.a([b-2,b,Math.sqrt(s.a)],t.M),s.b);
	s.a=0;}return !0}};
	A.fw.prototype={
	a0(a,b,c,d){var s=this,r=s.c,q=r!=null?r.$1(d):d;
	if(3===c){if(1!==q&&-1!==q)a.l($.qc(),A.a([b-3,b,q],t.M),s.b);}else {r=s.a+q*q;
	s.a=r;
	if(2===c){if(Math.abs(Math.sqrt(r)-1)>0.00674)a.l($.o0(),A.a([b-2,b,Math.sqrt(s.a)],t.M),s.b);
	s.a=0;}}return !0}};
	A.eK.prototype={
	a0(a,b,c,d){if(1<d||0>d)a.l($.qg(),A.a([b,d],t.M),this.a);
	return !0}};
	A.lF.prototype={
	bn(){var s,r,q,p,o,n=this,m=t.X,l=t._,k=A.a9(m,l),j=n.a;
	if(j!=null)k.m(0,"uri",j.k(0));
	j=n.c;
	s=j==null;
	if((s?null:j.a)!=null)k.m(0,"mimeType",s?null:j.a);
	k.m(0,"validatorVersion","2.0.0-dev.3.10");
	if(n.d)k.m(0,"validatedAt",new A.dp(Date.now(),!1).ew().ev());
	j=n.b;
	r=j.cy;
	q=A.a9(m,l);
	p=A.a([0,0,0,0],t.V);
	o=A.oJ(r.length,new A.lI(r,p),!1,t.t);
	q.m(0,"numErrors",p[0]);
	q.m(0,"numWarnings",p[1]);
	q.m(0,"numInfos",p[2]);
	q.m(0,"numHints",p[3]);
	q.m(0,"messages",o);
	q.m(0,"truncated",j.y);
	k.m(0,"issues",q);
	j=n.dz();
	if(j!=null)k.m(0,"info",j);
	return k},
	dz(){var s,r,q,p,o,n,m,l,k,j,i=null,h=this.c,g=h==null?i:h.b;
	h=g==null?i:g.w;
	if((h==null?i:h.f)==null)return i
	s=A.a9(t.X,t._);
	h=g.w;
	s.m(0,"version",h.f);
	r=h.r;
	if(r!=null)s.m(0,"minVersion",r);
	h=h.e;
	if(h!=null)s.m(0,"generator",h);
	h=g.d;
	r=J.V(h);
	if(r.ga8(h)){h=r.c3(h);
	s.m(0,"extensionsUsed",A.bc(h,!1,A.A(h).c));}h=g.e;
	r=J.V(h);
	if(r.ga8(h)){h=r.c3(h);
	s.m(0,"extensionsRequired",A.bc(h,!1,A.A(h).c));}h=this.b;
	r=h.CW;
	if(!r.gA(r))s.m(0,"resources",h.CW);
	s.m(0,"animationCount",g.r.b);
	s.m(0,"materialCount",g.as.b);
	h=g.at;
	s.m(0,"hasMorphTargets",h.aR(h,new A.lH()));
	r=g.cx;
	s.m(0,"hasSkins",!r.gA(r));
	r=g.cy;
	s.m(0,"hasTextures",!r.gA(r));
	s.m(0,"hasDefaultScene",g.ch!=null);
	for(h=new A.aa(h,h.gj(h),h.$ti.h("aa<p.E>")),q=0,p=0,o=0,n=0,m=0,l=0;h.q();){r=h.d.w;
	if(r!=null){q+=r.b;
	for(r=new A.aa(r,r.gj(r),r.$ti.h("aa<p.E>"));r.q();){k=r.d;
	j=k.CW;
	if(j!==-1)m+=j;
	l+=k.gex();
	p=Math.max(p,k.ay.a);
	o=Math.max(o,k.ax);
	n=Math.max(n,k.as*4);}}}s.m(0,"drawCallCount",q);
	s.m(0,"totalVertexCount",m);
	s.m(0,"totalTriangleCount",l);
	s.m(0,"maxUVs",o);
	s.m(0,"maxInfluences",n);
	s.m(0,"maxAttributes",p);
	return s}};
	A.lI.prototype={
	$1(a){var s,r=this.a[a],q=r.gc9().a,p=this.b;
	p[q]=p[q]+1;
	s=A.nu(["code",r.a.b,"message",r.gbl(),"severity",r.gc9().a],t.X,t._);
	q=r.c;
	if(q!=null)s.m(0,"pointer",q);
	else {q=r.d;
	if(q!=null)s.m(0,"offset",q);}return s},
	$S:83};
	A.lH.prototype={
	$1(a){var s=a.w;
	return s!=null&&s.aR(s,new A.lG())},
	$S:84};
	A.lG.prototype={
	$1(a){return a.cx!=null},
	$S:5};
	A.f2.prototype={
	k(a){return "[0] "+this.ag(0).k(0)+"\n[1] "+this.ag(1).k(0)+"\n[2] "+this.ag(2).k(0)+"\n"},
	O(a,b){var s,r,q;
	if(b==null)return !1
	if(b instanceof A.f2){s=this.a;
	r=s[0];
	q=b.a;
	s=r===q[0]&&s[1]===q[1]&&s[2]===q[2]&&s[3]===q[3]&&s[4]===q[4]&&s[5]===q[5]&&s[6]===q[6]&&s[7]===q[7]&&s[8]===q[8];}else s=!1;
	return s},
	gE(a){return A.k6(this.a)},
	ag(a){var s=new Float32Array(3),r=this.a;
	s[0]=r[a];
	s[1]=r[3+a];
	s[2]=r[6+a];
	return new A.cE(s)}};
	A.cZ.prototype={
	k(a){var s=this;
	return "[0] "+s.ag(0).k(0)+"\n[1] "+s.ag(1).k(0)+"\n[2] "+s.ag(2).k(0)+"\n[3] "+s.ag(3).k(0)+"\n"},
	O(a,b){var s,r,q;
	if(b==null)return !1
	if(b instanceof A.cZ){s=this.a;
	r=s[0];
	q=b.a;
	s=r===q[0]&&s[1]===q[1]&&s[2]===q[2]&&s[3]===q[3]&&s[4]===q[4]&&s[5]===q[5]&&s[6]===q[6]&&s[7]===q[7]&&s[8]===q[8]&&s[9]===q[9]&&s[10]===q[10]&&s[11]===q[11]&&s[12]===q[12]&&s[13]===q[13]&&s[14]===q[14]&&s[15]===q[15];}else s=!1;
	return s},
	gE(a){return A.k6(this.a)},
	ag(a){var s=new Float32Array(4),r=this.a;
	s[0]=r[a];
	s[1]=r[4+a];
	s[2]=r[8+a];
	s[3]=r[12+a];
	return new A.fA(s)},
	cG(){var s=this.a,r=s[0],q=s[5],p=s[1],o=s[4],n=r*q-p*o,m=s[6],l=s[2],k=r*m-l*o,j=s[7],i=s[3],h=r*j-i*o,g=p*m-l*q,f=p*j-i*q,e=l*j-i*m;
	m=s[8];
	i=s[9];
	j=s[10];
	l=s[11];
	return -(i*e-j*f+l*g)*s[12]+(m*e-j*h+l*k)*s[13]-(m*f-i*h+l*n)*s[14]+(m*g-i*k+j*n)*s[15]},
	cL(){var s=this.a,r=0+Math.abs(s[0])+Math.abs(s[1])+Math.abs(s[2])+Math.abs(s[3]),q=r>0?r:0;
	r=0+Math.abs(s[4])+Math.abs(s[5])+Math.abs(s[6])+Math.abs(s[7]);
	if(r>q)q=r;
	r=0+Math.abs(s[8])+Math.abs(s[9])+Math.abs(s[10])+Math.abs(s[11]);
	if(r>q)q=r;
	r=0+Math.abs(s[12])+Math.abs(s[13])+Math.abs(s[14])+Math.abs(s[15]);
	return r>q?r:q},
	cP(){var s=this.a;
	return s[0]===1&&s[1]===0&&s[2]===0&&s[3]===0&&s[4]===0&&s[5]===1&&s[6]===0&&s[7]===0&&s[8]===0&&s[9]===0&&s[10]===1&&s[11]===0&&s[12]===0&&s[13]===0&&s[14]===0&&s[15]===1}};
	A.fl.prototype={
	gaW(){var s=this.a,r=s[0],q=s[1],p=s[2],o=s[3];
	return r*r+q*q+p*p+o*o},
	gj(a){var s=this.a,r=s[0],q=s[1],p=s[2],o=s[3];
	return Math.sqrt(r*r+q*q+p*p+o*o)},
	k(a){var s=this.a;
	return A.b(s[0])+", "+A.b(s[1])+", "+A.b(s[2])+" @ "+A.b(s[3])}};
	A.cE.prototype={
	bt(a,b,c){var s=this.a;
	s[0]=a;
	s[1]=b;
	s[2]=c;},
	k(a){var s=this.a;
	return "["+A.b(s[0])+","+A.b(s[1])+","+A.b(s[2])+"]"},
	O(a,b){var s,r,q;
	if(b==null)return !1
	if(b instanceof A.cE){s=this.a;
	r=s[0];
	q=b.a;
	s=r===q[0]&&s[1]===q[1]&&s[2]===q[2];}else s=!1;
	return s},
	gE(a){return A.k6(this.a)},
	gj(a){var s=this.a,r=s[0],q=s[1];
	s=s[2];
	return Math.sqrt(r*r+q*q+s*s)},
	gaW(){var s=this.a,r=s[0],q=s[1];
	s=s[2];
	return r*r+q*q+s*s}};
	A.fA.prototype={
	k(a){var s=this.a;
	return A.b(s[0])+","+A.b(s[1])+","+A.b(s[2])+","+A.b(s[3])},
	O(a,b){var s,r,q;
	if(b==null)return !1
	if(b instanceof A.fA){s=this.a;
	r=s[0];
	q=b.a;
	s=r===q[0]&&s[1]===q[1]&&s[2]===q[2]&&s[3]===q[3];}else s=!1;
	return s},
	gE(a){return A.k6(this.a)},
	gj(a){var s=this.a,r=s[0],q=s[1],p=s[2];
	s=s[3];
	return Math.sqrt(r*r+q*q+p*p+s*s)}};
	A.bf.prototype={};
	A.hX.prototype={};
	A.d8.prototype={};
	A.nb.prototype={
	$3(a,b,c){var s=c.$1(J.as(a));
	return s},
	$S:85};
	A.n7.prototype={
	$2(a,b){return new self.Promise(A.cK(new A.n6(a,b,this.a)),t._)},
	$S:86};
	A.n6.prototype={
	$2(a,b){A.h_(this.a,this.b).au(0,new A.n3(a),new A.n4(this.c,b),t.P);},
	$S:24};
	A.n3.prototype={
	$1(a){this.a.$1(A.nR(a));},
	$S:25};
	A.n4.prototype={
	$2(a,b){return this.a.$3(a,b,this.b)},
	$S:26};
	A.n8.prototype={
	$2(a,b){return new self.Promise(A.cK(new A.n5(a,b,this.a)),t._)},
	$S:90};
	A.n5.prototype={
	$2(a,b){A.nV(this.a,this.b).au(0,new A.n1(a),new A.n2(this.c,b),t.P);},
	$S:24};
	A.n1.prototype={
	$1(a){this.a.$1(A.nR(a));},
	$S:25};
	A.n2.prototype={
	$2(a,b){return this.a.$3(a,b,this.b)},
	$S:26};
	A.n9.prototype={
	$0(){return "2.0.0-dev.3.10"},
	$S:91};
	A.na.prototype={
	$0(){return A.nR(A.u4())},
	$S:7};
	A.mG.prototype={
	$1(a){var s=new A.C($.B,t.q),r=new A.ay(s,t.as),q=this.a.$1(J.as(a));
	if((q==null?null:J.ty(q))==null)r.R(new A.at(!1,null,null,"options.externalResourceFunction: Function must return a Promise."));
	else J.tI(q,A.cK(new A.mH(r)),A.cK(new A.mI(r)));
	return s},
	$S:92};
	A.mH.prototype={
	$1(a){var s=this.a;
	if(t.a.b(a))s.a3(a);
	else s.R(new A.at(!1,null,null,"options.externalResourceFunction: Promise must be fulfilled with Uint8Array or rejected."));},
	$S:23};
	A.mI.prototype={
	$1(a){return this.a.R(new A.ff(J.as(a)))},
	$S:12};
	A.mE.prototype={
	$1(a){var s,r,q,p=this;
	if(p.a.dx&&a==null)return p.b.c
	if(p.c!=null)s=p.d.$1(a);
	else {r=p.e;
	A.bU(r,"error",t.K);
	$.B!==B.i;
	q=A.eI(r);
	s=new A.C($.B,t.q);
	s.b5(r,q);}return s},
	$0(){return this.$1(null)},
	$C:"$1",
	$R:0,
	$D(){return [null]},
	$S:93};
	A.mF.prototype={
	$1(a){var s,r,q,p,o=null;
	if(this.a!=null){s=this.b.$1(a);
	s=A.v9(s,A.ak(s).c);}else {s=this.c;
	A.bU(s,"error",t.K);
	r=t.f1;
	q=new A.aZ(o,o,o,o,r);
	p=A.eI(s);
	q.b3(s,p);
	q.aK();
	s=new A.aj(q,r.h("aj<1>"));}return s},
	$S:94};
	A.ff.prototype={
	k(a){return "Node Exception: "+A.b(this.a)},
	$ia8:1};(function aliases(){var s=J.cV.prototype;
	s.d6=s.bm;
	s=J.aN.prototype;
	s.da=s.k;
	s=A.aC.prototype;
	s.d7=s.cM;
	s.d8=s.cN;
	s.d9=s.cO;
	s=A.p.prototype;
	s.dc=s.a5;
	s=A.ef.prototype;
	s.de=s.a7;
	s=A.bj.prototype;
	s.dd=s.p;})();(function installTearOffs(){var s=hunkHelpers._static_1,r=hunkHelpers._static_0,q=hunkHelpers._static_2,p=hunkHelpers._instance_2u,o=hunkHelpers._instance_0u,n=hunkHelpers.installInstanceTearOff,m=hunkHelpers._instance_1i,l=hunkHelpers._instance_1u;
	s(A,"wt","ub",143);
	s(A,"wP","vh",13);
	s(A,"wQ","vi",13);
	s(A,"wR","vj",13);
	r(A,"pK","wC",1);
	q(A,"wS","ww",16);
	p(A.C.prototype,"gdq","aA",16);
	o(A.da.prototype,"gdZ","a7",56);
	var k;
	o(k=A.dX.prototype,"gcq","b9",1);
	o(k,"gcr","ba",1);
	n(k=A.dT.prototype,"geg",0,0,null,["$1","$0"],["cW","aZ"],60,0,0);
	o(k,"gej","ar",1);
	o(k,"gcq","b9",1);
	o(k,"gcr","ba",1);
	q(A,"wZ","w7",97);
	m(A.b_.prototype,"gcC","G",14);
	q(A,"wL","tN",98);
	q(A,"wK","tM",99);
	q(A,"wI","tK",100);
	q(A,"wJ","tL",101);
	l(A.a4.prototype,"gbX","ef",29);
	q(A,"wN","tP",102);
	q(A,"wM","tO",103);
	q(A,"wO","tQ",104);
	q(A,"wT","tU",105);
	q(A,"wU","tT",106);
	q(A,"wX","tX",107);
	q(A,"wV","tV",108);
	q(A,"wW","tW",109);
	q(A,"xc","ug",110);
	q(A,"xF","uL",111);
	q(A,"xH","uX",112);
	q(A,"xG","uW",113);
	q(A,"pV","uV",114);
	q(A,"ao","vb",115);
	q(A,"xI","uP",116);
	q(A,"xJ","uU",117);
	q(A,"xK","v6",118);
	q(A,"xL","v7",119);
	q(A,"xM","v8",120);
	q(A,"xO","vc",121);
	s(A,"dj","wy",27);
	s(A,"pM","wu",27);
	s(A,"x3","we",6);
	q(A,"x2","ua",124);
	q(A,"xj","un",125);
	s(A,"xk","wf",6);
	q(A,"xl","uo",126);
	q(A,"xm","up",127);
	q(A,"xn","uq",128);
	q(A,"xo","ur",129);
	q(A,"xp","us",130);
	q(A,"xq","ut",131);
	q(A,"xr","uu",132);
	q(A,"xs","uv",133);
	q(A,"xt","uw",134);
	q(A,"xu","ux",135);
	q(A,"xv","uy",136);
	q(A,"xw","uz",137);
	q(A,"xx","uA",138);
	q(A,"xy","uB",139);
	q(A,"ul","uC",140);
	q(A,"um","uD",141);
	q(A,"xz","uE",142);
	q(A,"xB","uF",95);
	o(k=A.dt.prototype,"gdB","cm",1);
	l(k,"gcn","dC",12);
	l(k=A.cT.prototype,"gdF","dG",79);
	l(k,"gdJ","dK",12);
	o(k,"gdH","dI",1);
	s(A,"xA","wg",6);})();(function inheritance(){var s=hunkHelpers.mixin,r=hunkHelpers.inherit,q=hunkHelpers.inheritMany;
	r(A.c,null);
	q(A.c,[A.ns,J.cV,J.b4,A.j,A.dm,A.I,A.c7,A.H,A.e6,A.aa,A.P,A.dq,A.ds,A.fy,A.d3,A.dC,A.cQ,A.iJ,A.lt,A.fh,A.dr,A.ed,A.mm,A.jN,A.cx,A.iK,A.mk,A.aF,A.fK,A.eh,A.mr,A.fD,A.d7,A.aH,A.eH,A.fG,A.bN,A.C,A.fE,A.bi,A.fr,A.da,A.fS,A.fF,A.dT,A.fI,A.m1,A.eb,A.fQ,A.mw,A.e3,A.eq,A.mj,A.cH,A.p,A.fU,A.dM,A.ls,A.eN,A.lZ,A.eJ,A.fV,A.dp,A.m2,A.fi,A.dO,A.e_,A.aK,A.cY,A.l,A.fR,A.ac,A.en,A.lv,A.fP,A.fL,A.a1,A.m,A.c2,A.c1,A.y,A.lE,A.i,A.bA,A.cd,A.iB,A.dS,A.dR,A.aL,A.fn,A.kb,A.eX,A.iH,A.cW,A.L,A.O,A.cb,A.cw,A.fo,A.dt,A.au,A.cT,A.dv,A.lF,A.f2,A.cZ,A.fl,A.cE,A.fA,A.ff]);
	q(J.cV,[J.dx,J.dz,J.f_,J.D,J.ce,J.bB,A.dF]);
	r(J.aN,J.f_);
	q(J.aN,[J.fj,J.bL,J.b9,A.bf,A.hX,A.d8]);
	r(J.iL,J.D);
	q(J.ce,[J.dy,J.eZ]);
	q(A.j,[A.bM,A.q,A.bd,A.lK,A.bh,A.dW,A.dw]);
	q(A.bM,[A.c5,A.ep]);
	r(A.dZ,A.c5);
	r(A.dU,A.ep);
	r(A.b5,A.dU);
	r(A.dB,A.I);
	q(A.dB,[A.c6,A.aC,A.e1,A.fM]);
	q(A.c7,[A.eM,A.eL,A.hY,A.ft,A.iP,A.mX,A.mZ,A.lW,A.lV,A.mx,A.m6,A.me,A.ln,A.lp,A.mi,A.jP,A.mC,A.mD,A.mz,A.lS,A.lT,A.lP,A.lQ,A.lM,A.lN,A.ix,A.iy,A.iq,A.iz,A.jV,A.jS,A.jT,A.jU,A.jZ,A.k3,A.k4,A.k5,A.ke,A.lm,A.hh,A.hi,A.hl,A.hj,A.iC,A.iE,A.iO,A.iN,A.kc,A.kd,A.nf,A.mL,A.hL,A.hM,A.hE,A.hD,A.ht,A.hs,A.hI,A.hz,A.hr,A.hF,A.hx,A.hu,A.hw,A.hv,A.hp,A.hq,A.hH,A.hG,A.hy,A.hO,A.hQ,A.hT,A.hU,A.hR,A.hS,A.hP,A.hV,A.hN,A.hB,A.hA,A.hJ,A.hK,A.hC,A.iG,A.kh,A.ki,A.kg,A.kk,A.kl,A.km,A.kj,A.kn,A.ko,A.kp,A.ku,A.kv,A.kt,A.kq,A.kr,A.ks,A.lj,A.lk,A.l4,A.kL,A.ky,A.kz,A.kx,A.kA,A.kB,A.kC,A.kE,A.kD,A.kF,A.kG,A.kH,A.kI,A.kX,A.l_,A.l3,A.l1,A.kZ,A.l2,A.l0,A.kY,A.l8,A.l6,A.l9,A.lg,A.ll,A.lf,A.kK,A.l7,A.lc,A.lb,A.la,A.lh,A.li,A.le,A.l5,A.ld,A.kJ,A.kM,A.kN,A.kO,A.kP,A.kQ,A.kR,A.kS,A.kW,A.kV,A.kT,A.kU,A.j0,A.iZ,A.j_,A.j1,A.j4,A.j2,A.j3,A.j8,A.j6,A.ja,A.j7,A.j9,A.j5,A.jb,A.je,A.jd,A.jc,A.jf,A.jg,A.jh,A.jl,A.jm,A.ju,A.jk,A.jj,A.jq,A.jp,A.jo,A.jv,A.jt,A.jn,A.jw,A.js,A.jr,A.jx,A.jy,A.jB,A.jz,A.jA,A.jC,A.jE,A.jD,A.jF,A.jG,A.jH,A.jI,A.jJ,A.jM,A.jL,A.jK,A.ji,A.i5,A.i6,A.i8,A.i_,A.i7,A.i0,A.i3,A.i2,A.i1,A.ib,A.ia,A.ic,A.id,A.i9,A.ie,A.i4,A.iU,A.iX,A.ii,A.ig,A.ih,A.ip,A.ik,A.mU,A.lI,A.lH,A.lG,A.nb,A.n3,A.n1,A.mG,A.mH,A.mI,A.mE,A.mF]);
	q(A.eM,[A.hf,A.k9,A.mY,A.my,A.mN,A.m7,A.lo,A.jO,A.k2,A.lx,A.ly,A.lz,A.mB,A.h5,A.h6,A.iu,A.iv,A.is,A.it,A.iA,A.jR,A.k1,A.k0,A.jX,A.jY,A.k_,A.hn,A.ne,A.ng,A.iS,A.iT,A.iW,A.iV,A.mS,A.mT,A.n7,A.n6,A.n4,A.n8,A.n5,A.n2]);
	q(A.H,[A.f1,A.fm,A.dI,A.aG,A.f0,A.fx,A.fp,A.fJ,A.eF,A.fg,A.at,A.dH,A.fz,A.fu,A.bJ,A.eO,A.eQ]);
	r(A.dA,A.e6);
	q(A.dA,[A.d4,A.F]);
	q(A.d4,[A.c8,A.aX]);
	q(A.eL,[A.nd,A.lX,A.lY,A.ms,A.m3,A.ma,A.m8,A.m5,A.m9,A.m4,A.md,A.mc,A.mb,A.lq,A.mq,A.mp,A.m0,A.m_,A.ml,A.mK,A.mo,A.lD,A.lC,A.lR,A.lU,A.lL,A.lO,A.iw,A.ir,A.jW,A.hg,A.hm,A.hk,A.iD,A.k8,A.ij,A.im,A.io,A.il,A.mQ,A.n9,A.na]);
	q(A.q,[A.ah,A.b7,A.aO,A.e2]);
	q(A.ah,[A.dP,A.ab,A.fN,A.e0]);
	r(A.c9,A.bd);
	q(A.P,[A.dD,A.cF,A.dN]);
	r(A.cR,A.bh);
	r(A.em,A.dC);
	r(A.bm,A.em);
	r(A.dn,A.bm);
	q(A.cQ,[A.aJ,A.X]);
	r(A.dJ,A.aG);
	q(A.ft,[A.fq,A.cP]);
	r(A.d_,A.dF);
	q(A.d_,[A.e7,A.e9]);
	r(A.e8,A.e7);
	r(A.dE,A.e8);
	r(A.ea,A.e9);
	r(A.aw,A.ea);
	q(A.dE,[A.f8,A.f9]);
	q(A.aw,[A.fa,A.fb,A.fc,A.fd,A.fe,A.dG,A.cy]);
	r(A.ei,A.fJ);
	r(A.eg,A.dw);
	r(A.ay,A.fG);
	q(A.da,[A.aZ,A.db]);
	r(A.ee,A.bi);
	r(A.aj,A.ee);
	r(A.dX,A.dT);
	q(A.fI,[A.cG,A.dY]);
	r(A.mn,A.mw);
	r(A.e4,A.e1);
	r(A.e5,A.aC);
	r(A.ec,A.eq);
	r(A.b_,A.ec);
	r(A.lr,A.ls);
	r(A.ef,A.lr);
	r(A.mh,A.ef);
	q(A.eN,[A.ha,A.hW,A.iQ]);
	r(A.eP,A.fr);
	q(A.eP,[A.hc,A.hb,A.iR,A.lB]);
	q(A.eJ,[A.hd,A.fO]);
	r(A.mu,A.hd);
	r(A.lA,A.hW);
	q(A.at,[A.dL,A.eV]);
	r(A.fH,A.en);
	r(A.k,A.fL);
	q(A.k,[A.eR,A.bZ,A.c_,A.c0,A.b2,A.bw,A.b3,A.bx,A.c3,A.c4,A.du,A.cB,A.bj,A.aE,A.ca,A.cf,A.bC,A.cg,A.ch,A.ci,A.cj,A.ck,A.cl,A.cm,A.cn,A.co,A.cp,A.cq,A.cr,A.cs,A.bD,A.ct,A.bb,A.cu,A.cv]);
	q(A.eR,[A.a4,A.bv,A.aT,A.by,A.bz,A.aU,A.ai,A.aV,A.ap,A.bF,A.bG,A.bI,A.bK,A.ba,A.aM]);
	q(A.a4,[A.fC,A.fB]);
	q(A.a1,[A.eY,A.f5,A.f3,A.f6,A.f4,A.eE,A.dK,A.eU,A.eT,A.fv,A.fw,A.eK]);
	q(A.bj,[A.cA,A.cz]);
	q(A.m2,[A.cU,A.dV,A.d5,A.cc,A.d9,A.bH]);
	q(A.iB,[A.iM,A.k7,A.lJ]);
	q(A.iH,[A.ho,A.iF,A.kf,A.kw,A.iY,A.hZ]);
	s(A.d4,A.fy);
	s(A.ep,A.p);
	s(A.e7,A.p);
	s(A.e8,A.ds);
	s(A.e9,A.p);
	s(A.ea,A.ds);
	s(A.aZ,A.fF);
	s(A.db,A.fS);
	s(A.e6,A.p);
	s(A.em,A.fU);
	s(A.eq,A.dM);
	s(A.fL,A.m);})();
	var v={typeUniverse:{eC:new Map(),tR:{},eT:{},tPV:{},sEA:[]},mangledGlobalNames:{f:"int",z:"double",N:"num",e:"String",S:"bool",l:"Null",o:"List"},mangledNames:{},types:["e*(o<@>*)","~()","l()","l(e*,c*)","l(e*,f*)","S*(aE*)","~(i*)","@()","z*(f*)","S*(f*)","l(ap*,f*,f*)","l(o<f*>*)","~(c*)","~(~())","S(c?)","l(@)","~(c,an)","~(a6,e,f)","j<f*>*()","j<z*>*()","l(f*,aE*)","~(e*)","S*(L*)","l(c*)","l(~(c*)*,aB*)","l(h<e*,c*>*)","~(c*,an*)","e*(c*)","~(k*,e*)","z*(N*)","@(@)","j<f*>*(f*,f*,f*)","f*(f*)","@(@,e)","~(@)","j<z*>*(f*,f*,f*)","l(f*,b3*)","l(f*,b2*)","F<0^*>*(e*,0^*(h<e*,c*>*,i*)*)<c*>","0^*(e*,0^*(h<e*,c*>*,i*)*{req:S*})<c*>","~(F<k*>*,bk*)","l(f*,k*)","l(@,an)","l(f*,ap*)","S*(ap*)","~(F<cC*>*)","l(f*,cC*)","a5<l>()","~(f,@)","f*(o<f*>*)","@(e)","f*(f*,f*,e*)","l(c,an)","C<@>(@)","d1<a4<N*>*>*()","l(@,@)","a5<@>()","e*(L*)","o<a1<N*>*>*()","e*(e*)","~([a5<~>?])","L*()","l(bk*,O*)","S(@)","~(c?,c?)","a6*/*(aT*)","bi<o<f*>*>*(aU*)","l(f*,a4<N*>*)","S*(P<N*>*)","~(e,@)","l(f*,ba*)","l(f*,aM*)","l(f*,bb*)","aM*(f*)","S*(c*)","~(cD,@)","~({seen:S*})","l(au*)","a5<~>*()","~(o<f*>*)","l(o<c*>*)","h<e*,f*>*(h<@,@>*)","o<cw*>*()","h<e*,c*>*(f*)","S*(aV*)","~(c*,an*,aB*)","bf<1&>*(a6*,c*)","~(e,f)","~(e,f?)","f(f,f)","bf<1&>*(e*,c*)","e*()","a5<a6*>*(aY*)","a6*/*([aY*])","bi<o<f*>*>*(aY*)","cv*(h<e*,c*>*,i*)","a6(@,@)","S(c?,c?)","a4<N*>*(h<e*,c*>*,i*)","bZ*(h<e*,c*>*,i*)","c_*(h<e*,c*>*,i*)","c0*(h<e*,c*>*,i*)","bv*(h<e*,c*>*,i*)","bw*(h<e*,c*>*,i*)","bx*(h<e*,c*>*,i*)","aT*(h<e*,c*>*,i*)","by*(h<e*,c*>*,i*)","bz*(h<e*,c*>*,i*)","c3*(h<e*,c*>*,i*)","c4*(h<e*,c*>*,i*)","aU*(h<e*,c*>*,i*)","ai*(h<e*,c*>*,i*)","cB*(h<e*,c*>*,i*)","cA*(h<e*,c*>*,i*)","cz*(h<e*,c*>*,i*)","bj*(h<e*,c*>*,i*)","aV*(h<e*,c*>*,i*)","ap*(h<e*,c*>*,i*)","bF*(h<e*,c*>*,i*)","bG*(h<e*,c*>*,i*)","bI*(h<e*,c*>*,i*)","bK*(h<e*,c*>*,i*)","l(~())","c?(c?)","ca*(h<e*,c*>*,i*)","cf*(h<e*,c*>*,i*)","bC*(h<e*,c*>*,i*)","cg*(h<e*,c*>*,i*)","ch*(h<e*,c*>*,i*)","ci*(h<e*,c*>*,i*)","cj*(h<e*,c*>*,i*)","ck*(h<e*,c*>*,i*)","cl*(h<e*,c*>*,i*)","cm*(h<e*,c*>*,i*)","cn*(h<e*,c*>*,i*)","co*(h<e*,c*>*,i*)","cp*(h<e*,c*>*,i*)","cq*(h<e*,c*>*,i*)","cr*(h<e*,c*>*,i*)","cs*(h<e*,c*>*,i*)","bD*(h<e*,c*>*,i*)","ct*(h<e*,c*>*,i*)","cu*(h<e*,c*>*,i*)","f(c?)"],interceptorsByTag:null,leafTags:null,arrayRti:Symbol("$ti")};
	A.vF(v.typeUniverse,JSON.parse('{"fj":"aN","bL":"aN","b9":"aN","bf":"aN","hX":"aN","d8":"aN","dx":{"S":[]},"dz":{"l":[]},"aN":{"bf":["1&"],"d8":[]},"D":{"o":["1"],"q":["1"],"j":["1"]},"iL":{"D":["1"],"o":["1"],"q":["1"],"j":["1"]},"b4":{"P":["1"]},"ce":{"z":[],"N":[]},"dy":{"z":[],"f":[],"N":[]},"eZ":{"z":[],"N":[]},"bB":{"e":[]},"bM":{"j":["2"]},"dm":{"P":["2"]},"c5":{"bM":["1","2"],"j":["2"],"j.E":"2"},"dZ":{"c5":["1","2"],"bM":["1","2"],"q":["2"],"j":["2"],"j.E":"2"},"dU":{"p":["2"],"o":["2"],"bM":["1","2"],"q":["2"],"j":["2"]},"b5":{"dU":["1","2"],"p":["2"],"o":["2"],"bM":["1","2"],"q":["2"],"j":["2"],"p.E":"2","j.E":"2"},"c6":{"I":["3","4"],"h":["3","4"],"I.K":"3","I.V":"4"},"f1":{"H":[]},"fm":{"H":[]},"c8":{"p":["f"],"o":["f"],"q":["f"],"j":["f"],"p.E":"f"},"dI":{"aG":[],"H":[]},"q":{"j":["1"]},"ah":{"q":["1"],"j":["1"]},"dP":{"ah":["1"],"q":["1"],"j":["1"],"j.E":"1","ah.E":"1"},"aa":{"P":["1"]},"bd":{"j":["2"],"j.E":"2"},"c9":{"bd":["1","2"],"q":["2"],"j":["2"],"j.E":"2"},"dD":{"P":["2"]},"ab":{"ah":["2"],"q":["2"],"j":["2"],"j.E":"2","ah.E":"2"},"lK":{"j":["1"],"j.E":"1"},"cF":{"P":["1"]},"bh":{"j":["1"],"j.E":"1"},"cR":{"bh":["1"],"q":["1"],"j":["1"],"j.E":"1"},"dN":{"P":["1"]},"b7":{"q":["1"],"j":["1"],"j.E":"1"},"dq":{"P":["1"]},"d4":{"p":["1"],"o":["1"],"q":["1"],"j":["1"]},"d3":{"cD":[]},"dn":{"bm":["1","2"],"h":["1","2"]},"cQ":{"h":["1","2"]},"aJ":{"cQ":["1","2"],"h":["1","2"]},"dW":{"j":["1"],"j.E":"1"},"X":{"cQ":["1","2"],"h":["1","2"]},"dJ":{"aG":[],"H":[]},"f0":{"H":[]},"fx":{"H":[]},"fh":{"a8":[]},"ed":{"an":[]},"c7":{"aB":[]},"eL":{"aB":[]},"eM":{"aB":[]},"ft":{"aB":[]},"fq":{"aB":[]},"cP":{"aB":[]},"fp":{"H":[]},"aC":{"I":["1","2"],"h":["1","2"],"I.K":"1","I.V":"2"},"aO":{"q":["1"],"j":["1"],"j.E":"1"},"cx":{"P":["1"]},"d_":{"av":["1"]},"dE":{"p":["z"],"av":["z"],"o":["z"],"q":["z"],"j":["z"]},"aw":{"p":["f"],"av":["f"],"o":["f"],"q":["f"],"j":["f"]},"f8":{"p":["z"],"av":["z"],"o":["z"],"q":["z"],"j":["z"],"p.E":"z"},"f9":{"p":["z"],"av":["z"],"o":["z"],"q":["z"],"j":["z"],"p.E":"z"},"fa":{"aw":[],"p":["f"],"av":["f"],"o":["f"],"q":["f"],"j":["f"],"p.E":"f"},"fb":{"aw":[],"p":["f"],"av":["f"],"o":["f"],"q":["f"],"j":["f"],"p.E":"f"},"fc":{"aw":[],"p":["f"],"av":["f"],"o":["f"],"q":["f"],"j":["f"],"p.E":"f"},"fd":{"aw":[],"p":["f"],"av":["f"],"o":["f"],"q":["f"],"j":["f"],"p.E":"f"},"fe":{"aw":[],"p":["f"],"av":["f"],"o":["f"],"q":["f"],"j":["f"],"p.E":"f"},"dG":{"aw":[],"p":["f"],"av":["f"],"o":["f"],"q":["f"],"j":["f"],"p.E":"f"},"cy":{"aw":[],"p":["f"],"a6":[],"av":["f"],"o":["f"],"q":["f"],"j":["f"],"p.E":"f"},"eh":{"bk":[]},"fJ":{"H":[]},"ei":{"aG":[],"H":[]},"C":{"a5":["1"]},"aH":{"P":["1"]},"eg":{"j":["1"],"j.E":"1"},"eH":{"H":[]},"ay":{"fG":["1"]},"aZ":{"da":["1"]},"db":{"da":["1"]},"aj":{"bi":["1"]},"ee":{"bi":["1"]},"e1":{"I":["1","2"],"h":["1","2"]},"e4":{"e1":["1","2"],"I":["1","2"],"h":["1","2"],"I.K":"1","I.V":"2"},"e2":{"q":["1"],"j":["1"],"j.E":"1"},"e3":{"P":["1"]},"e5":{"aC":["1","2"],"I":["1","2"],"h":["1","2"],"I.K":"1","I.V":"2"},"b_":{"ec":["1"],"dM":["1"],"d1":["1"],"q":["1"],"j":["1"]},"cH":{"P":["1"]},"aX":{"p":["1"],"o":["1"],"q":["1"],"j":["1"],"p.E":"1"},"dw":{"j":["1"]},"dA":{"p":["1"],"o":["1"],"q":["1"],"j":["1"]},"dB":{"I":["1","2"],"h":["1","2"]},"I":{"h":["1","2"]},"dC":{"h":["1","2"]},"bm":{"h":["1","2"]},"ec":{"dM":["1"],"d1":["1"],"q":["1"],"j":["1"]},"fM":{"I":["e","@"],"h":["e","@"],"I.K":"e","I.V":"@"},"fN":{"ah":["e"],"q":["e"],"j":["e"],"j.E":"e","ah.E":"e"},"z":{"N":[]},"f":{"N":[]},"o":{"q":["1"],"j":["1"]},"d1":{"q":["1"],"j":["1"]},"eF":{"H":[]},"aG":{"H":[]},"fg":{"aG":[],"H":[]},"at":{"H":[]},"dL":{"H":[]},"eV":{"H":[]},"dH":{"H":[]},"fz":{"H":[]},"fu":{"H":[]},"bJ":{"H":[]},"eO":{"H":[]},"fi":{"H":[]},"dO":{"H":[]},"eQ":{"H":[]},"e_":{"a8":[]},"aK":{"a8":[]},"e0":{"ah":["1"],"q":["1"],"j":["1"],"j.E":"1","ah.E":"1"},"fR":{"an":[]},"en":{"aY":[]},"fP":{"aY":[]},"fH":{"aY":[]},"a4":{"k":[],"m":[],"n":[]},"bZ":{"k":[],"m":[],"n":[]},"c_":{"k":[],"m":[],"n":[]},"c0":{"k":[],"m":[],"n":[]},"fC":{"a4":["f*"],"k":[],"m":[],"n":[]},"fB":{"a4":["z*"],"k":[],"m":[],"n":[]},"eY":{"a1":["z*"]},"f5":{"a1":["z*"]},"f3":{"a1":["z*"]},"f6":{"a1":["f*"]},"f4":{"a1":["f*"]},"bv":{"k":[],"m":[],"n":[]},"b2":{"k":[],"m":[],"n":[]},"bw":{"k":[],"m":[],"n":[]},"b3":{"k":[],"m":[],"n":[]},"eE":{"a1":["z*"]},"dK":{"a1":["1*"]},"bx":{"k":[],"m":[],"n":[]},"aT":{"k":[],"m":[],"n":[]},"by":{"k":[],"m":[],"n":[]},"bz":{"k":[],"m":[],"n":[]},"c3":{"k":[],"m":[],"n":[]},"c4":{"k":[],"m":[],"n":[]},"du":{"k":[],"m":[],"n":[]},"k":{"m":[],"n":[]},"eR":{"k":[],"m":[],"n":[]},"aU":{"k":[],"m":[],"n":[]},"ai":{"k":[],"m":[],"n":[]},"cB":{"k":[],"m":[],"n":[]},"cA":{"k":[],"m":[],"n":[]},"cz":{"k":[],"m":[],"n":[]},"bj":{"k":[],"m":[],"n":[]},"aV":{"k":[],"m":[],"n":[]},"aE":{"k":[],"m":[],"n":[]},"eU":{"a1":["f*"]},"ap":{"k":[],"m":[],"n":[]},"bF":{"k":[],"m":[],"n":[]},"bG":{"k":[],"m":[],"n":[]},"bI":{"k":[],"m":[],"n":[]},"eT":{"a1":["z*"]},"bK":{"k":[],"m":[],"n":[],"cC":[]},"bA":{"a8":[]},"dS":{"a8":[]},"dR":{"a8":[]},"aL":{"a8":[]},"ca":{"k":[],"m":[],"n":[],"cC":[]},"cf":{"k":[],"m":[],"n":[]},"bC":{"k":[],"m":[],"n":[]},"ba":{"k":[],"m":[],"n":[]},"cg":{"k":[],"m":[],"n":[]},"ch":{"k":[],"m":[],"n":[]},"ci":{"k":[],"m":[],"n":[]},"cj":{"k":[],"m":[],"n":[]},"ck":{"k":[],"m":[],"n":[]},"cl":{"k":[],"m":[],"n":[]},"cm":{"k":[],"m":[],"n":[]},"cn":{"k":[],"m":[],"n":[]},"co":{"k":[],"m":[],"n":[]},"cp":{"k":[],"m":[],"n":[]},"cq":{"k":[],"m":[],"n":[]},"cr":{"k":[],"m":[],"n":[]},"cs":{"k":[],"m":[],"n":[]},"bD":{"k":[],"m":[],"n":[]},"aM":{"k":[],"m":[],"n":[]},"ct":{"k":[],"m":[],"n":[]},"bb":{"k":[],"m":[],"n":[]},"cu":{"k":[],"m":[],"n":[]},"cv":{"k":[],"m":[],"n":[]},"dt":{"eS":[]},"cT":{"eS":[]},"dv":{"a8":[]},"F":{"p":["1*"],"o":["1*"],"q":["1*"],"j":["1*"],"p.E":"1*"},"fv":{"a1":["N*"]},"fw":{"a1":["N*"]},"eK":{"a1":["z*"]},"ff":{"a8":[]},"a6":{"o":["f"],"q":["f"],"j":["f"]}}'));
	A.vE(v.typeUniverse,JSON.parse('{"ds":1,"fy":1,"d4":1,"ep":2,"d_":1,"fr":2,"fS":1,"fF":1,"dX":1,"dT":1,"ee":1,"fI":1,"cG":1,"eb":1,"fQ":1,"dw":1,"dA":1,"dB":2,"fU":2,"dC":2,"e6":1,"em":2,"eq":1,"eJ":1,"eN":2,"eP":2,"ef":1}'));
	var u={p:") does not match the number of morph targets (",d:"Accessor sparse indices element at index ",m:"Animation input accessor element at index ",c:"Error handler must accept one Object or one Object and a StackTrace as arguments, and return a value of the returned future's type",g:"`null` encountered as the result from expression with type `Never`."};
	var t=(function rtii(){var s=A.aR;
	return {gF:s("dn<cD,@>"),O:s("q<@>"),Q:s("H"),b8:s("aB"),d:s("a5<@>"),bq:s("a5<~>"),N:s("X<bk*,O*>"),j:s("j<@>"),s:s("D<e>"),gN:s("D<a6>"),b:s("D<@>"),Z:s("D<f>"),p:s("D<y*>"),gd:s("D<a1<N*>*>"),bd:s("D<eX*>"),a9:s("D<cW*>"),b2:s("D<P<N*>*>"),bH:s("D<cw*>"),fh:s("D<h<e*,c*>*>"),M:s("D<c*>"),d6:s("D<fo*>"),i:s("D<e*>"),o:s("D<z*>"),V:s("D<f*>"),T:s("dz"),g:s("b9"),aU:s("av<@>"),eo:s("aC<cD,@>"),I:s("h<@,@>"),gw:s("ab<L*,e*>"),eB:s("aw"),bm:s("cy"),P:s("l"),K:s("c"),ed:s("dK<N*>"),gT:s("zA"),eq:s("F<b2*>"),az:s("F<b3*>"),E:s("F<ba*>"),B:s("F<bb*>"),u:s("F<aM*>"),b_:s("F<aE*>"),gm:s("an"),R:s("e"),fo:s("cD"),dd:s("bk"),eK:s("aG"),gc:s("a6"),ak:s("bL"),go:s("aX<h<e*,c*>*>"),em:s("aX<e*>"),f8:s("bm<cb*,O*>"),n:s("aY"),a_:s("ay<eS*>"),G:s("ay<au*>"),eP:s("ay<cd*>"),as:s("ay<a6*>"),f1:s("aZ<o<f*>*>"),U:s("C<l>"),eI:s("C<@>"),fJ:s("C<f>"),eD:s("C<eS*>"),f:s("C<au*>"),dD:s("C<cd*>"),q:s("C<a6*>"),D:s("C<~>"),aH:s("e4<@,@>"),cy:s("fO<c*>"),y:s("S"),gR:s("z"),z:s("@"),v:s("@(c)"),C:s("@(c,an)"),S:s("f"),aD:s("y*"),hc:s("a4<f*>*"),W:s("a4<N*>*"),bj:s("bv*"),aA:s("b2*"),gW:s("b3*"),gP:s("bx*"),cT:s("aT*"),r:s("by*"),h2:s("bz*"),x:s("a8*"),af:s("L*"),f9:s("O*"),al:s("cb*"),b1:s("aB*"),ec:s("aU*"),Y:s("j<@>*"),ga:s("P<z*>*"),bF:s("P<f*>*"),cp:s("ba*"),aa:s("bb*"),J:s("aM*"),c:s("n*"),l:s("o<@>*"),b7:s("o<a1<N*>*>*"),an:s("o<cw*>*"),m:s("o<c*>*"),eG:s("o<e*>*"),fy:s("o<z*>*"),w:s("o<f*>*"),h:s("h<@,@>*"),gj:s("h<e*,a4<N*>*>*"),t:s("h<e*,c*>*"),fC:s("ai*"),eM:s("aV*"),ft:s("aE*"),A:s("0&*"),L:s("ap*"),_:s("c*"),ax:s("cC*"),b5:s("F<m*>*"),c2:s("bF*"),bn:s("bG*"),cn:s("d1<y*>*"),gz:s("d1<a4<N*>*>*"),dz:s("bH*"),aV:s("bI*"),X:s("e*"),ai:s("bK*"),f7:s("bk*"),a:s("a6*"),bv:s("d8*"),F:s("z*"),e:s("f*"),eH:s("a5<l>?"),cK:s("c?"),di:s("N"),H:s("~"),d5:s("~(c)"),k:s("~(c,an)")}})();(function constants(){var s=hunkHelpers.makeConstList;
	B.bW=J.cV.prototype;
	B.d=J.D.prototype;
	B.c0=J.dx.prototype;
	B.c=J.dy.prototype;
	B.c1=J.ce.prototype;
	B.a=J.bB.prototype;
	B.c2=J.b9.prototype;
	B.c3=J.f_.prototype;
	B.j=A.cy.prototype;
	B.aA=J.fj.prototype;
	B.X=J.bL.prototype;
	B.Y=new A.y("MAT4",5126,!1);
	B.G=new A.y("SCALAR",5126,!1);
	B.a_=new A.y("VEC2",5120,!0);
	B.a0=new A.y("VEC2",5121,!0);
	B.a2=new A.y("VEC2",5122,!0);
	B.a3=new A.y("VEC2",5123,!0);
	B.a4=new A.y("VEC2",5126,!1);
	B.w=new A.y("VEC3",5120,!0);
	B.H=new A.y("VEC3",5121,!0);
	B.x=new A.y("VEC3",5122,!0);
	B.I=new A.y("VEC3",5123,!0);
	B.k=new A.y("VEC3",5126,!1);
	B.J=new A.y("VEC4",5120,!0);
	B.b_=new A.y("VEC4",5121,!1);
	B.y=new A.y("VEC4",5121,!0);
	B.K=new A.y("VEC4",5122,!0);
	B.b0=new A.y("VEC4",5123,!1);
	B.z=new A.y("VEC4",5123,!0);
	B.n=new A.y("VEC4",5126,!1);
	B.b1=new A.c1("AnimationInput");
	B.b2=new A.c1("AnimationOutput");
	B.b3=new A.c1("IBM");
	B.b4=new A.c1("PrimitiveIndices");
	B.a7=new A.c1("VertexAttribute");
	B.b5=new A.c2("IBM");
	B.b6=new A.c2("Image");
	B.L=new A.c2("IndexBuffer");
	B.o=new A.c2("Other");
	B.A=new A.c2("VertexBuffer");
	B.eq=new A.hc();
	B.b7=new A.ha();
	B.b8=new A.hb();
	B.b9=new A.dq(A.aR("dq<0&*>"));
	B.a8=new A.dv();
	B.ba=new A.bA();
	B.a9=function getTagFallback(o) {
	  var s = Object.prototype.toString.call(o);
	  return s.substring(8, s.length - 1);
	};
	B.bb=function() {
	  var toStringFunction = Object.prototype.toString;
	  function getTag(o) {
	    var s = toStringFunction.call(o);
	    return s.substring(8, s.length - 1);
	  }
	  function getUnknownTag(object, tag) {
	    if (/^HTML[A-Z].*Element$/.test(tag)) {
	      var name = toStringFunction.call(object);
	      if (name == "[object Object]") return null;
	      return "HTMLElement";
	    }
	  }
	  function getUnknownTagGenericBrowser(object, tag) {
	    if (self.HTMLElement && object instanceof HTMLElement) return "HTMLElement";
	    return getUnknownTag(object, tag);
	  }
	  function prototypeForTag(tag) {
	    if (typeof window == "undefined") return null;
	    if (typeof window[tag] == "undefined") return null;
	    var constructor = window[tag];
	    if (typeof constructor != "function") return null;
	    return constructor.prototype;
	  }
	  function discriminator(tag) { return null; }
	  var isBrowser = typeof navigator == "object";
	  return {
	    getTag: getTag,
	    getUnknownTag: isBrowser ? getUnknownTagGenericBrowser : getUnknownTag,
	    prototypeForTag: prototypeForTag,
	    discriminator: discriminator };
	};
	B.bg=function(getTagFallback) {
	  return function(hooks) {
	    if (typeof navigator != "object") return hooks;
	    var ua = navigator.userAgent;
	    if (ua.indexOf("DumpRenderTree") >= 0) return hooks;
	    if (ua.indexOf("Chrome") >= 0) {
	      function confirm(p) {
	        return typeof window == "object" && window[p] && window[p].name == p;
	      }
	      if (confirm("Window") && confirm("HTMLElement")) return hooks;
	    }
	    hooks.getTag = getTagFallback;
	  };
	};
	B.bc=function(hooks) {
	  if (typeof dartExperimentalFixupGetTag != "function") return hooks;
	  hooks.getTag = dartExperimentalFixupGetTag(hooks.getTag);
	};
	B.bd=function(hooks) {
	  var getTag = hooks.getTag;
	  var prototypeForTag = hooks.prototypeForTag;
	  function getTagFixed(o) {
	    var tag = getTag(o);
	    if (tag == "Document") {
	      if (!!o.xmlVersion) return "!Document";
	      return "!HTMLDocument";
	    }
	    return tag;
	  }
	  function prototypeForTagFixed(tag) {
	    if (tag == "Document") return null;
	    return prototypeForTag(tag);
	  }
	  hooks.getTag = getTagFixed;
	  hooks.prototypeForTag = prototypeForTagFixed;
	};
	B.bf=function(hooks) {
	  var userAgent = typeof navigator == "object" ? navigator.userAgent : "";
	  if (userAgent.indexOf("Firefox") == -1) return hooks;
	  var getTag = hooks.getTag;
	  var quickMap = {
	    "BeforeUnloadEvent": "Event",
	    "DataTransfer": "Clipboard",
	    "GeoGeolocation": "Geolocation",
	    "Location": "!Location",
	    "WorkerMessageEvent": "MessageEvent",
	    "XMLDocument": "!Document"};
	  function getTagFirefox(o) {
	    var tag = getTag(o);
	    return quickMap[tag] || tag;
	  }
	  hooks.getTag = getTagFirefox;
	};
	B.be=function(hooks) {
	  var userAgent = typeof navigator == "object" ? navigator.userAgent : "";
	  if (userAgent.indexOf("Trident/") == -1) return hooks;
	  var getTag = hooks.getTag;
	  var quickMap = {
	    "BeforeUnloadEvent": "Event",
	    "DataTransfer": "Clipboard",
	    "HTMLDDElement": "HTMLElement",
	    "HTMLDTElement": "HTMLElement",
	    "HTMLPhraseElement": "HTMLElement",
	    "Position": "Geoposition"
	  };
	  function getTagIE(o) {
	    var tag = getTag(o);
	    var newTag = quickMap[tag];
	    if (newTag) return newTag;
	    if (tag == "Object") {
	      if (window.DataView && (o instanceof window.DataView)) return "DataView";
	    }
	    return tag;
	  }
	  function prototypeForTagIE(tag) {
	    var constructor = window[tag];
	    if (constructor == null) return null;
	    return constructor.prototype;
	  }
	  hooks.getTag = getTagIE;
	  hooks.prototypeForTag = prototypeForTagIE;
	};
	B.aa=function(hooks) { return hooks; };

	B.ab=new A.iQ();
	B.bh=new A.fi();
	B.bi=new A.dR();
	B.bj=new A.dS();
	B.ac=new A.lA();
	B.M=new A.m1();
	B.ad=new A.mm();
	B.i=new A.mn();
	B.bk=new A.fR();
	B.O=new A.cc(0,"Unknown");
	B.p=new A.cc(1,"RGB");
	B.B=new A.cc(2,"RGBA");
	B.ae=new A.cc(3,"Luminance");
	B.af=new A.cc(4,"LuminanceAlpha");
	B.ag=new A.cU(0,"JPEG");
	B.ah=new A.cU(1,"PNG");
	B.ai=new A.cU(2,"WebP");
	B.bV=new A.cU(3,"KTX2");
	B.aj=new A.aL("Wrong WebP header.");
	B.bX=new A.aL("PNG header not found.");
	B.bY=new A.aL("Invalid JPEG marker segment length.");
	B.q=new A.aL("Wrong chunk length.");
	B.bZ=new A.aL("Invalid number of JPEG color channels.");
	B.c_=new A.aL("Invalid start of file.");
	B.c4=new A.iR(null);
	B.c5=A.a(s([0,0]),t.o);
	B.ak=A.a(s([0,0,0]),t.o);
	B.c6=A.a(s([16]),t.V);
	B.c7=A.a(s([1,1]),t.o);
	B.C=A.a(s([1,1,1]),t.o);
	B.al=A.a(s([1,1,1,1]),t.o);
	B.am=A.a(s([2]),t.V);
	B.c9=A.a(s(["sheenColorFactor","sheenColorTexture","sheenRoughnessFactor","sheenRoughnessTexture"]),t.i);
	B.an=A.a(s([0,0,32776,33792,1,10240,0,0]),t.V);
	B.ca=A.a(s(["clearcoatFactor","clearcoatTexture","clearcoatRoughnessFactor","clearcoatRoughnessTexture","clearcoatNormalTexture"]),t.i);
	B.l=A.a(s([3]),t.V);
	B.ao=A.a(s([33071,33648,10497]),t.V);
	B.cb=A.a(s([34962,34963]),t.V);
	B.cc=A.a(s(["specularFactor","specularTexture","specularColorFactor","specularColorTexture"]),t.i);
	B.P=A.a(s([4]),t.V);
	B.Z=new A.y("VEC2",5120,!1);
	B.aW=new A.y("VEC2",5121,!1);
	B.a1=new A.y("VEC2",5122,!1);
	B.aX=new A.y("VEC2",5123,!1);
	B.cd=A.a(s([B.Z,B.a_,B.aW,B.a1,B.a2,B.aX]),t.p);
	B.ce=A.a(s([5121,5123,5125]),t.V);
	B.ap=A.a(s(["image/jpeg","image/png"]),t.i);
	B.cf=A.a(s(["transmissionFactor","transmissionTexture"]),t.i);
	B.cg=A.a(s([9728,9729]),t.V);
	B.aQ=new A.y("SCALAR",5121,!1);
	B.aT=new A.y("SCALAR",5123,!1);
	B.aV=new A.y("SCALAR",5125,!1);
	B.aq=A.a(s([B.aQ,B.aT,B.aV]),t.p);
	B.ci=A.a(s(["image/jpeg","image/png","image/webp","image/ktx2"]),t.i);
	B.cj=A.a(s(["camera","children","skin","matrix","mesh","rotation","scale","translation","weights","name"]),t.i);
	B.ck=A.a(s([9728,9729,9984,9985,9986,9987]),t.V);
	B.cl=A.a(s(["COLOR","JOINTS","TEXCOORD","WEIGHTS"]),t.i);
	B.cm=A.a(s(["COLOR","TEXCOORD"]),t.i);
	B.D=A.a(s([0,0,65490,45055,65535,34815,65534,18431]),t.V);
	B.b=new A.bH(0,"Error");
	B.e=new A.bH(1,"Warning");
	B.h=new A.bH(2,"Information");
	B.aB=new A.bH(3,"Hint");
	B.cn=A.a(s([B.b,B.e,B.h,B.aB]),A.aR("D<bH*>"));
	B.co=A.a(s(["color","intensity","spot","type","range","name"]),t.i);
	B.cp=A.a(s(["buffer","byteOffset","byteLength","byteStride","target","name"]),t.i);
	B.as=A.a(s([0,0,26624,1023,65534,2047,65534,2047]),t.V);
	B.cq=A.a(s(["LINEAR","STEP","CUBICSPLINE"]),t.i);
	B.cr=A.a(s(["OPAQUE","MASK","BLEND"]),t.i);
	B.cs=A.a(s(["pbrMetallicRoughness","normalTexture","occlusionTexture","emissiveTexture","emissiveFactor","alphaMode","alphaCutoff","doubleSided","name"]),t.i);
	B.ct=A.a(s(["POSITION","NORMAL","TANGENT"]),t.i);
	B.cu=A.a(s([5120,5121,5122,5123,5125,5126]),t.V);
	B.cv=A.a(s(["anisotropyStrength","anisotropyRotation","anisotropyTexture"]),t.i);
	B.cw=A.a(s(["inverseBindMatrices","skeleton","joints","name"]),t.i);
	B.a5=new A.y("VEC3",5120,!1);
	B.a6=new A.y("VEC3",5122,!1);
	B.cx=A.a(s([B.a5,B.w,B.a6,B.x]),t.p);
	B.cy=A.a(s(["data-uri","buffer-view","glb","external"]),t.i);
	B.cz=A.a(s(["POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN"]),t.i);
	B.cA=A.a(s(["bufferView","byteOffset","componentType"]),t.i);
	B.Q=A.a(s([B.w,B.x]),t.p);
	B.cB=A.a(s(["aspectRatio","yfov","zfar","znear"]),t.i);
	B.cC=A.a(s(["copyright","generator","version","minVersion"]),t.i);
	B.cD=A.a(s(["bufferView","byteOffset"]),t.i);
	B.cE=A.a(s(["bufferView","mimeType","uri","name"]),t.i);
	B.cF=A.a(s(["channels","samplers","name"]),t.i);
	B.cG=A.a(s(["baseColorFactor","baseColorTexture","metallicFactor","roughnessFactor","metallicRoughnessTexture"]),t.i);
	B.cH=A.a(s(["count","indices","values"]),t.i);
	B.cI=A.a(s(["diffuseFactor","diffuseTexture","specularFactor","glossinessFactor","specularGlossinessTexture"]),t.i);
	B.cJ=A.a(s(["directional","point","spot"]),t.i);
	B.cK=A.a(s(["dispersion"]),t.i);
	B.cL=A.a(s(["emissiveStrength"]),t.i);
	B.at=A.a(s([]),t.b);
	B.cM=A.a(s([]),t.i);
	B.cP=A.a(s(["extensions","extras"]),t.i);
	B.cQ=A.a(s([0,0,32722,12287,65534,34815,65534,18431]),t.V);
	B.W=A.u("bK");
	B.bl=new A.O(A.x2(),!1,!1);
	B.dK=new A.X([B.W,B.bl],t.N);
	B.bG=new A.L("EXT_texture_webp",B.dK,A.x3(),!1);
	B.aC=A.u("bw");
	B.bm=new A.O(A.xj(),!1,!1);
	B.dG=new A.X([B.aC,B.bm],t.N);
	B.bP=new A.L("KHR_animation_pointer",B.dG,A.xk(),!1);
	B.U=A.u("du");
	B.V=A.u("ap");
	B.bn=new A.O(A.xl(),!1,!1);
	B.bs=new A.O(A.xn(),!1,!1);
	B.dI=new A.X([B.U,B.bn,B.V,B.bs],t.N);
	B.bQ=new A.L("KHR_lights_punctual",B.dI,null,!1);
	B.f=A.u("ai");
	B.bt=new A.O(A.xo(),!1,!1);
	B.du=new A.X([B.f,B.bt],t.N);
	B.bD=new A.L("KHR_materials_anisotropy",B.du,null,!1);
	B.bu=new A.O(A.xp(),!1,!1);
	B.dv=new A.X([B.f,B.bu],t.N);
	B.bM=new A.L("KHR_materials_clearcoat",B.dv,null,!1);
	B.bv=new A.O(A.xq(),!1,!1);
	B.dw=new A.X([B.f,B.bv],t.N);
	B.bL=new A.L("KHR_materials_dispersion",B.dw,null,!1);
	B.bw=new A.O(A.xr(),!1,!1);
	B.dy=new A.X([B.f,B.bw],t.N);
	B.bT=new A.L("KHR_materials_emissive_strength",B.dy,null,!1);
	B.bx=new A.O(A.xs(),!1,!1);
	B.dz=new A.X([B.f,B.bx],t.N);
	B.bR=new A.L("KHR_materials_ior",B.dz,null,!1);
	B.by=new A.O(A.xt(),!1,!1);
	B.dA=new A.X([B.f,B.by],t.N);
	B.bK=new A.L("KHR_materials_iridescence",B.dA,null,!1);
	B.bB=new A.O(A.xu(),!0,!1);
	B.dB=new A.X([B.f,B.bB],t.N);
	B.bI=new A.L("KHR_materials_pbrSpecularGlossiness",B.dB,null,!1);
	B.bz=new A.O(A.xv(),!1,!1);
	B.dC=new A.X([B.f,B.bz],t.N);
	B.bF=new A.L("KHR_materials_sheen",B.dC,null,!1);
	B.bo=new A.O(A.xw(),!1,!1);
	B.dD=new A.X([B.f,B.bo],t.N);
	B.bO=new A.L("KHR_materials_specular",B.dD,null,!1);
	B.bp=new A.O(A.xx(),!1,!1);
	B.dE=new A.X([B.f,B.bp],t.N);
	B.bN=new A.L("KHR_materials_transmission",B.dE,null,!1);
	B.bC=new A.O(A.xy(),!0,!1);
	B.dF=new A.X([B.f,B.bC],t.N);
	B.bE=new A.L("KHR_materials_unlit",B.dF,null,!1);
	B.aF=A.u("aE");
	B.bq=new A.O(A.ul(),!1,!1);
	B.bA=new A.O(A.um(),!1,!0);
	B.dH=new A.X([B.U,B.bq,B.aF,B.bA],t.N);
	B.bJ=new A.L("KHR_materials_variants",B.dH,null,!1);
	B.br=new A.O(A.xz(),!1,!1);
	B.dx=new A.X([B.f,B.br],t.N);
	B.bS=new A.L("KHR_materials_volume",B.dx,null,!1);
	B.cN=A.a(s([]),A.aR("D<bk*>"));
	B.dL=new A.aJ(0,{},B.cN,A.aR("aJ<bk*,O*>"));
	B.bU=new A.L("KHR_mesh_quantization",B.dL,A.xA(),!0);
	B.aL=A.u("bj");
	B.aH=A.u("cz");
	B.aI=A.u("cA");
	B.N=new A.O(A.xB(),!1,!1);
	B.dJ=new A.X([B.aL,B.N,B.aH,B.N,B.aI,B.N],t.N);
	B.bH=new A.L("KHR_texture_transform",B.dJ,null,!1);
	B.au=A.a(s([B.bG,B.bP,B.bQ,B.bD,B.bM,B.bL,B.bT,B.bR,B.bK,B.bI,B.bF,B.bO,B.bN,B.bE,B.bJ,B.bS,B.bU,B.bH]),A.aR("D<L*>"));
	B.cS=A.a(s(["index","texCoord"]),t.i);
	B.cT=A.a(s(["index","texCoord","scale"]),t.i);
	B.cU=A.a(s(["index","texCoord","strength"]),t.i);
	B.cV=A.a(s(["innerConeAngle","outerConeAngle"]),t.i);
	B.cW=A.a(s(["input","interpolation","output"]),t.i);
	B.cX=A.a(s(["ior"]),t.i);
	B.cY=A.a(s(["attributes","indices","material","mode","targets"]),t.i);
	B.cZ=A.a(s(["bufferView","byteOffset","componentType","count","type","normalized","max","min","sparse","name"]),t.i);
	B.d_=A.a(s(["light"]),t.i);
	B.d0=A.a(s(["lights"]),t.i);
	B.d1=A.a(s(["mappings"]),t.i);
	B.d2=A.a(s(["name"]),t.i);
	B.d3=A.a(s(["node","path"]),t.i);
	B.d4=A.a(s(["nodes","name"]),t.i);
	B.d5=A.a(s([null,"linear","srgb","custom"]),t.i);
	B.d6=A.a(s([null,"srgb","custom"]),t.i);
	B.av=A.a(s([0,0,24576,1023,65534,34815,65534,18431]),t.V);
	B.d7=A.a(s(["image/webp"]),t.i);
	B.d8=A.a(s(["offset","rotation","scale","texCoord"]),t.i);
	B.aw=A.a(s(["orthographic","perspective"]),t.i);
	B.d9=A.a(s(["pointer"]),t.i);
	B.da=A.a(s(["primitives","weights","name"]),t.i);
	B.db=A.a(s([0,0,32754,11263,65534,34815,65534,18431]),t.V);
	B.dc=A.a(s(["magFilter","minFilter","wrapS","wrapT","name"]),t.i);
	B.dd=A.a(s([null,"rgb","rgba","luminance","luminance-alpha"]),t.i);
	B.ax=A.a(s([0,0,65490,12287,65535,34815,65534,18431]),t.V);
	B.de=A.a(s(["sampler","source","name"]),t.i);
	B.df=A.a(s(["source"]),t.i);
	B.dg=A.a(s(["iridescenceFactor","iridescenceTexture","iridescenceIor","iridescenceThicknessMinimum","iridescenceThicknessMaximum","iridescenceThicknessTexture"]),t.i);
	B.aY=new A.y("VEC3",5121,!1);
	B.aZ=new A.y("VEC3",5123,!1);
	B.dh=A.a(s([B.a5,B.w,B.aY,B.H,B.a6,B.x,B.aZ,B.I]),t.p);
	B.di=A.a(s(["target","sampler"]),t.i);
	B.R=A.a(s(["translation","rotation","scale","weights"]),t.i);
	B.dj=A.a(s(["type","orthographic","perspective","name"]),t.i);
	B.dk=A.a(s(["uri","byteLength","name"]),t.i);
	B.dl=A.a(s(["variants"]),t.i);
	B.dm=A.a(s(["variants","material","name"]),t.i);
	B.dn=A.a(s([B.Z,B.a1]),t.p);
	B.dp=A.a(s(["attenuationColor","attenuationDistance","thicknessFactor","thicknessTexture"]),t.i);
	B.dq=A.a(s(["xmag","ymag","zfar","znear"]),t.i);
	B.dr=A.a(s(["extensionsUsed","extensionsRequired","accessors","animations","asset","buffers","bufferViews","cameras","images","materials","meshes","nodes","samplers","scene","scenes","skins","textures"]),t.i);
	B.ds=A.a(s([B.J,B.K]),t.p);
	B.ar=A.a(s([B.k]),t.p);
	B.c8=A.a(s([B.n,B.y,B.J,B.z,B.K]),t.p);
	B.aR=new A.y("SCALAR",5121,!0);
	B.aP=new A.y("SCALAR",5120,!0);
	B.aU=new A.y("SCALAR",5123,!0);
	B.aS=new A.y("SCALAR",5122,!0);
	B.cR=A.a(s([B.G,B.aR,B.aP,B.aU,B.aS]),t.p);
	B.dt=new A.aJ(4,{translation:B.ar,rotation:B.c8,scale:B.ar,weights:B.cR},B.R,A.aR("aJ<e*,o<y*>*>"));
	B.ch=A.a(s(["SCALAR","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4"]),t.i);
	B.m=new A.aJ(7,{SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},B.ch,A.aR("aJ<e*,f*>"));
	B.ay=new A.X([5120,"BYTE",5121,"UNSIGNED_BYTE",5122,"SHORT",5123,"UNSIGNED_SHORT",5124,"INT",5125,"UNSIGNED_INT",5126,"FLOAT",35664,"FLOAT_VEC2",35665,"FLOAT_VEC3",35666,"FLOAT_VEC4",35667,"INT_VEC2",35668,"INT_VEC3",35669,"INT_VEC4",35670,"BOOL",35671,"BOOL_VEC2",35672,"BOOL_VEC3",35673,"BOOL_VEC4",35674,"FLOAT_MAT2",35675,"FLOAT_MAT3",35676,"FLOAT_MAT4",35678,"SAMPLER_2D"],A.aR("X<f*,e*>"));
	B.cO=A.a(s([]),A.aR("D<cD*>"));
	B.az=new A.aJ(0,{},B.cO,A.aR("aJ<cD*,@>"));
	B.dM=new A.d3("call");
	B.dN=A.u("c_");
	B.dO=A.u("c0");
	B.dP=A.u("bZ");
	B.S=A.u("a4<N>");
	B.dQ=A.u("b2");
	B.dR=A.u("b3");
	B.T=A.u("bv");
	B.dS=A.u("bx");
	B.aD=A.u("by");
	B.dT=A.u("aT");
	B.dU=A.u("c3");
	B.dV=A.u("c4");
	B.dW=A.u("bz");
	B.dX=A.u("co");
	B.dY=A.u("ca");
	B.aE=A.u("aU");
	B.dZ=A.u("cf");
	B.e_=A.u("bC");
	B.e0=A.u("cg");
	B.e1=A.u("ba");
	B.e2=A.u("ch");
	B.e3=A.u("ci");
	B.e4=A.u("cj");
	B.e5=A.u("ck");
	B.e6=A.u("cl");
	B.e7=A.u("cm");
	B.e8=A.u("cn");
	B.e9=A.u("cp");
	B.ea=A.u("cq");
	B.eb=A.u("cr");
	B.ec=A.u("cs");
	B.ed=A.u("bD");
	B.ee=A.u("bb");
	B.ef=A.u("aM");
	B.eg=A.u("cu");
	B.eh=A.u("cv");
	B.aG=A.u("aV");
	B.ei=A.u("c");
	B.ej=A.u("cB");
	B.ek=A.u("bF");
	B.aJ=A.u("bG");
	B.aK=A.u("bI");
	B.el=A.u("ct");
	B.em=new A.lB(!1);
	B.r=new A.dV(0,"Unknown");
	B.t=new A.dV(1,"sRGB");
	B.E=new A.dV(2,"Custom");
	B.u=new A.d5(0,"Unknown");
	B.en=new A.d5(1,"Linear");
	B.v=new A.d5(2,"sRGB");
	B.F=new A.d5(3,"Custom");
	B.eo=new A.d7(null,2);
	B.aM=new A.d9(0,"DataUri");
	B.aN=new A.d9(1,"BufferView");
	B.ep=new A.d9(2,"GLB");
	B.aO=new A.d9(3,"External");})();(function staticFields(){$.mg=null;
	$.oR=null;
	$.ov=null;
	$.ou=null;
	$.pR=null;
	$.pJ=null;
	$.pY=null;
	$.mP=null;
	$.n_=null;
	$.nQ=null;
	$.dg=null;
	$.ev=null;
	$.ew=null;
	$.nK=!1;
	$.B=B.i;
	$.cJ=A.a([],A.aR("D<c>"));
	$.oN=null;
	$.oL=null;
	$.oM=null;})();(function lazyInitializers(){var s=hunkHelpers.lazyFinal,r=hunkHelpers.lazy,q=hunkHelpers.lazyOld;
	s($,"xW","nW",()=>A.xa("_$dart_dartClosure"));
	s($,"Bi","tu",()=>B.i.cZ(new A.nd()));
	s($,"AH","tb",()=>A.bl(A.lu({
	toString:function(){return "$receiver$"}})));
	s($,"AI","tc",()=>A.bl(A.lu({$method$:null,
	toString:function(){return "$receiver$"}})));
	s($,"AJ","td",()=>A.bl(A.lu(null)));
	s($,"AK","te",()=>A.bl(function(){var $argumentsExpr$="$arguments$";
	try{null.$method$($argumentsExpr$);}catch(p){return p.message}}()));
	s($,"AN","th",()=>A.bl(A.lu(void 0)));
	s($,"AO","ti",()=>A.bl(function(){var $argumentsExpr$="$arguments$";
	try{(void 0).$method$($argumentsExpr$);}catch(p){return p.message}}()));
	s($,"AM","tg",()=>A.bl(A.p3(null)));
	s($,"AL","tf",()=>A.bl(function(){try{null.$method$;}catch(p){return p.message}}()));
	s($,"AQ","tk",()=>A.bl(A.p3(void 0)));
	s($,"AP","tj",()=>A.bl(function(){try{(void 0).$method$;}catch(p){return p.message}}()));
	s($,"AT","oj",()=>A.vg());
	s($,"yt","h0",()=>t.U.a($.tu()));
	s($,"AR","tl",()=>new A.lD().$0());
	s($,"AS","tm",()=>new A.lC().$0());
	s($,"AV","ok",()=>A.uR(A.w8(A.a([-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-1,-2,-2,-2,-2,-2,62,-2,62,-2,63,52,53,54,55,56,57,58,59,60,61,-2,-2,-2,-1,-2,-2,-2,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,-2,-2,-2,-2,63,-2,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,-2,-2,-2,-2,-2],t.Z))));
	r($,"AU","tn",()=>A.uS(0));
	s($,"Bb","to",()=>A.fZ(B.ei));
	s($,"Bf","ts",()=>A.w6());
	q($,"xU","br",()=>A.nx("^([0-9]+)\\.([0-9]+)$"));
	q($,"xV","q3",()=>A.nx("^([A-Z0-9]+)_[A-Za-z0-9_]+$"));
	q($,"yi","ql",()=>A.G("BUFFER_BYTE_LENGTH_MISMATCH",new A.hL(),B.b));
	q($,"yj","qm",()=>A.G("BUFFER_GLB_CHUNK_TOO_BIG",new A.hM(),B.e));
	q($,"yb","o_",()=>A.G("ACCESSOR_MIN_MISMATCH",new A.hE(),B.b));
	q($,"ya","nZ",()=>A.G("ACCESSOR_MAX_MISMATCH",new A.hD(),B.b));
	q($,"y0","nY",()=>A.G("ACCESSOR_ELEMENT_OUT_OF_MIN_BOUND",new A.ht(),B.b));
	q($,"y_","nX",()=>A.G("ACCESSOR_ELEMENT_OUT_OF_MAX_BOUND",new A.hs(),B.b));
	q($,"yf","o0",()=>A.G("ACCESSOR_VECTOR3_NON_UNIT",new A.hI(),B.b));
	q($,"y6","qc",()=>A.G("ACCESSOR_INVALID_SIGN",new A.hz(),B.b));
	q($,"xZ","q6",()=>A.G("ACCESSOR_ANIMATION_SAMPLER_OUTPUT_NON_NORMALIZED_QUATERNION",new A.hr(),B.b));
	q($,"yc","qg",()=>A.G("ACCESSOR_NON_CLAMPED",new A.hF(),B.b));
	q($,"y4","qa",()=>A.G("ACCESSOR_INVALID_FLOAT",new A.hx(),B.b));
	q($,"y1","q7",()=>A.G("ACCESSOR_INDEX_OOB",new A.hu(),B.b));
	q($,"y3","q9",()=>A.G("ACCESSOR_INDEX_TRIANGLE_DEGENERATE",new A.hw(),B.h));
	q($,"y2","q8",()=>A.G("ACCESSOR_INDEX_PRIMITIVE_RESTART",new A.hv(),B.b));
	q($,"xX","q4",()=>A.G("ACCESSOR_ANIMATION_INPUT_NEGATIVE",new A.hp(),B.b));
	q($,"xY","q5",()=>A.G("ACCESSOR_ANIMATION_INPUT_NON_INCREASING",new A.hq(),B.b));
	q($,"ye","qi",()=>A.G("ACCESSOR_SPARSE_INDICES_NON_INCREASING",new A.hH(),B.b));
	q($,"yd","qh",()=>A.G("ACCESSOR_SPARSE_INDEX_OOB",new A.hG(),B.b));
	q($,"y5","qb",()=>A.G("ACCESSOR_INVALID_IBM",new A.hy(),B.b));
	q($,"yl","qn",()=>A.G("IMAGE_DATA_INVALID",new A.hO(),B.b));
	q($,"yn","qp",()=>A.G("IMAGE_MIME_TYPE_INVALID",new A.hQ(),B.b));
	q($,"yq","qs",()=>A.G("IMAGE_UNEXPECTED_EOS",new A.hT(),B.b));
	q($,"yr","qt",()=>A.G("IMAGE_UNRECOGNIZED_FORMAT",new A.hU(),B.e));
	q($,"yo","qq",()=>A.G("IMAGE_NON_ENABLED_MIME_TYPE",new A.hR(),B.b));
	q($,"yp","qr",()=>A.G("IMAGE_NPOT_DIMENSIONS",new A.hS(),B.h));
	q($,"ym","qo",()=>A.G("IMAGE_FEATURES_UNSUPPORTED",new A.hP(),B.e));
	q($,"ys","o2",()=>A.G("URI_GLB",new A.hV(),B.h));
	q($,"yk","o1",()=>A.G("DATA_URI_GLB",new A.hN(),B.e));
	q($,"y8","qe",()=>A.G("ACCESSOR_JOINTS_INDEX_OOB",new A.hB(),B.b));
	q($,"y7","qd",()=>A.G("ACCESSOR_JOINTS_INDEX_DUPLICATE",new A.hA(),B.b));
	q($,"yg","qj",()=>A.G("ACCESSOR_WEIGHTS_NEGATIVE",new A.hJ(),B.b));
	q($,"yh","qk",()=>A.G("ACCESSOR_WEIGHTS_NON_NORMALIZED",new A.hK(),B.b));
	q($,"y9","qf",()=>A.G("ACCESSOR_JOINTS_USED_ZERO_WEIGHT",new A.hC(),B.e));
	q($,"yK","nh",()=>new A.iF(B.b,"IO_ERROR",new A.iG()));
	q($,"zC","oc",()=>A.am("ARRAY_LENGTH_NOT_IN_LIST",new A.kh(),B.b));
	q($,"zD","eC",()=>A.am("ARRAY_TYPE_MISMATCH",new A.ki(),B.b));
	q($,"zB","ob",()=>A.am("DUPLICATE_ELEMENTS",new A.kg(),B.b));
	q($,"zF","h2",()=>A.am("INVALID_INDEX",new A.kk(),B.b));
	q($,"zG","h3",()=>A.am("INVALID_JSON",new A.kl(),B.b));
	q($,"zH","od",()=>A.am("INVALID_URI",new A.km(),B.b));
	q($,"zE","bX",()=>A.am("EMPTY_ENTITY",new A.kj(),B.b));
	q($,"zI","oe",()=>A.am("ONE_OF_MISMATCH",new A.kn(),B.b));
	q($,"zJ","rp",()=>A.am("PATTERN_MISMATCH",new A.ko(),B.b));
	q($,"zK","a2",()=>A.am("TYPE_MISMATCH",new A.kp(),B.b));
	q($,"zP","rs",()=>A.am("VALUE_NOT_IN_LIST",new A.ku(),B.e));
	q($,"zQ","ni",()=>A.am("VALUE_NOT_IN_RANGE",new A.kv(),B.b));
	q($,"zO","rr",()=>A.am("VALUE_MULTIPLE_OF",new A.kt(),B.b));
	q($,"zL","bs",()=>A.am("UNDEFINED_PROPERTY",new A.kq(),B.b));
	q($,"zM","rq",()=>A.am("UNEXPECTED_PROPERTY",new A.kr(),B.e));
	q($,"zN","cO",()=>A.am("UNSATISFIED_DEPENDENCY",new A.ks(),B.b));
	q($,"AD","t8",()=>A.r("UNKNOWN_ASSET_MAJOR_VERSION",new A.lj(),B.b));
	q($,"AE","t9",()=>A.r("UNKNOWN_ASSET_MINOR_VERSION",new A.lk(),B.e));
	q($,"Ao","rV",()=>A.r("ASSET_MIN_VERSION_GREATER_THAN_VERSION",new A.l4(),B.b));
	q($,"A4","rC",()=>A.r("INVALID_GL_VALUE",new A.kL(),B.b));
	q($,"zS","ru",()=>A.r("ACCESSOR_NORMALIZED_INVALID",new A.ky(),B.b));
	q($,"zT","rv",()=>A.r("ACCESSOR_OFFSET_ALIGNMENT",new A.kz(),B.b));
	q($,"zR","rt",()=>A.r("ACCESSOR_MATRIX_ALIGNMENT",new A.kx(),B.b));
	q($,"zU","rw",()=>A.r("ACCESSOR_SPARSE_COUNT_OUT_OF_RANGE",new A.kA(),B.b));
	q($,"zV","rx",()=>A.r("ANIMATION_CHANNEL_TARGET_NODE_SKIN",new A.kB(),B.e));
	q($,"zW","ry",()=>A.r("BUFFER_DATA_URI_MIME_TYPE_INVALID",new A.kC(),B.b));
	q($,"zY","rz",()=>A.r("BUFFER_VIEW_TOO_BIG_BYTE_STRIDE",new A.kE(),B.b));
	q($,"zX","nj",()=>A.r("BUFFER_VIEW_INVALID_BYTE_STRIDE",new A.kD(),B.b));
	q($,"zZ","of",()=>A.r("CAMERA_XMAG_YMAG_NEGATIVE",new A.kF(),B.e));
	q($,"A_","og",()=>A.r("CAMERA_XMAG_YMAG_ZERO",new A.kG(),B.b));
	q($,"A0","rA",()=>A.r("CAMERA_YFOV_GEQUAL_PI",new A.kH(),B.e));
	q($,"A1","oh",()=>A.r("CAMERA_ZFAR_LEQUAL_ZNEAR",new A.kI(),B.b));
	q($,"Ag","rO",()=>A.r("MATERIAL_ALPHA_CUTOFF_INVALID_MODE",new A.kX(),B.e));
	q($,"Aj","nk",()=>A.r("MESH_PRIMITIVE_INVALID_ATTRIBUTE",new A.l_(),B.b));
	q($,"An","rU",()=>A.r("MESH_PRIMITIVES_UNEQUAL_TARGETS_COUNT",new A.l3(),B.b));
	q($,"Al","rS",()=>A.r("MESH_PRIMITIVE_NO_POSITION",new A.l1(),B.e));
	q($,"Ai","rQ",()=>A.r("MESH_PRIMITIVE_INDEXED_SEMANTIC_CONTINUITY",new A.kZ(),B.b));
	q($,"Am","rT",()=>A.r("MESH_PRIMITIVE_TANGENT_WITHOUT_NORMAL",new A.l2(),B.e));
	q($,"Ak","rR",()=>A.r("MESH_PRIMITIVE_JOINTS_WEIGHTS_MISMATCH",new A.l0(),B.b));
	q($,"Ah","rP",()=>A.r("MESH_INVALID_WEIGHTS_COUNT",new A.kY(),B.b));
	q($,"As","rZ",()=>A.r("NODE_MATRIX_TRS",new A.l8(),B.b));
	q($,"Aq","rX",()=>A.r("NODE_MATRIX_DEFAULT",new A.l6(),B.h));
	q($,"At","t_",()=>A.r("NODE_MATRIX_NON_TRS",new A.l9(),B.b));
	q($,"AA","t5",()=>A.r("ROTATION_NON_UNIT",new A.lg(),B.b));
	q($,"AF","ta",()=>A.r("UNUSED_EXTENSION_REQUIRED",new A.ll(),B.b));
	q($,"Az","t4",()=>A.r("NON_REQUIRED_EXTENSION",new A.lf(),B.b));
	q($,"A3","rB",()=>A.r("INVALID_EXTENSION_NAME_FORMAT",new A.kK(),B.e));
	q($,"Ar","rY",()=>A.r("NODE_EMPTY",new A.l7(),B.h));
	q($,"Aw","t2",()=>A.r("NODE_SKINNED_MESH_NON_ROOT",new A.lc(),B.e));
	q($,"Av","t1",()=>A.r("NODE_SKINNED_MESH_LOCAL_TRANSFORMS",new A.lb(),B.e));
	q($,"Au","t0",()=>A.r("NODE_SKIN_NO_SCENE",new A.la(),B.b));
	q($,"AB","t6",()=>A.r("SKIN_NO_COMMON_ROOT",new A.lh(),B.b));
	q($,"AC","t7",()=>A.r("SKIN_SKELETON_INVALID",new A.li(),B.b));
	q($,"Ay","t3",()=>A.r("NON_RELATIVE_URI",new A.le(),B.e));
	q($,"Ap","rW",()=>A.r("MULTIPLE_EXTENSIONS",new A.l5(),B.e));
	q($,"Ax","dk",()=>A.r("NON_OBJECT_EXTRAS",new A.ld(),B.h));
	q($,"A2","oi",()=>A.r("EXTRA_PROPERTY",new A.kJ(),B.h));
	q($,"A5","rD",()=>A.r("KHR_ANIMATION_POINTER_ANIMATION_CHANNEL_TARGET_NODE",new A.kM(),B.b));
	q($,"A6","rE",()=>A.r("KHR_ANIMATION_POINTER_ANIMATION_CHANNEL_TARGET_PATH",new A.kN(),B.b));
	q($,"A7","rF",()=>A.r("KHR_LIGHTS_PUNCTUAL_LIGHT_SPOT_ANGLES",new A.kO(),B.b));
	q($,"A8","rG",()=>A.r("KHR_MATERIALS_ANISOTROPY_ANISOTROPY_TEXTURE_TEXCOORD",new A.kP(),B.e));
	q($,"A9","rH",()=>A.r("KHR_MATERIALS_CLEARCOAT_CLEARCOAT_NORMAL_TEXTURE_TEXCOORD",new A.kQ(),B.e));
	q($,"Aa","rI",()=>A.r("KHR_MATERIALS_DISPERSION_NO_VOLUME",new A.kR(),B.e));
	q($,"Ab","rJ",()=>A.r("KHR_MATERIALS_EMISSIVE_STRENGTH_ZERO_FACTOR",new A.kS(),B.e));
	q($,"Af","rN",()=>A.r("KHR_MATERIALS_VOLUME_NO_TRANSMISSION",new A.kW(),B.e));
	q($,"Ae","rM",()=>A.r("KHR_MATERIALS_VOLUME_DOUBLE_SIDED",new A.kV(),B.e));
	q($,"Ac","rK",()=>A.r("KHR_MATERIALS_IRIDESCENCE_THICKNESS_RANGE_WITHOUT_TEXTURE",new A.kT(),B.h));
	q($,"Ad","rL",()=>A.r("KHR_MATERIALS_IRIDESCENCE_THICKNESS_TEXTURE_UNUSED",new A.kU(),B.h));
	q($,"yO","qM",()=>A.v("ACCESSOR_TOTAL_OFFSET_ALIGNMENT",new A.j0(),B.b));
	q($,"yM","qL",()=>A.v("ACCESSOR_SMALL_BYTESTRIDE",new A.iZ(),B.b));
	q($,"yN","o3",()=>A.v("ACCESSOR_TOO_LONG",new A.j_(),B.b));
	q($,"yP","qN",()=>A.v("ACCESSOR_USAGE_OVERRIDE",new A.j1(),B.b));
	q($,"yS","qQ",()=>A.v("ANIMATION_DUPLICATE_TARGETS",new A.j4(),B.b));
	q($,"yQ","qO",()=>A.v("ANIMATION_CHANNEL_TARGET_NODE_MATRIX",new A.j2(),B.b));
	q($,"yR","qP",()=>A.v("ANIMATION_CHANNEL_TARGET_NODE_WEIGHTS_NO_MORPHS",new A.j3(),B.b));
	q($,"yW","qT",()=>A.v("ANIMATION_SAMPLER_INPUT_ACCESSOR_WITHOUT_BOUNDS",new A.j8(),B.b));
	q($,"yU","qR",()=>A.v("ANIMATION_SAMPLER_INPUT_ACCESSOR_INVALID_FORMAT",new A.j6(),B.b));
	q($,"yY","qV",()=>A.v("ANIMATION_SAMPLER_OUTPUT_ACCESSOR_INVALID_FORMAT",new A.ja(),B.b));
	q($,"yV","qS",()=>A.v("ANIMATION_SAMPLER_INPUT_ACCESSOR_TOO_FEW_ELEMENTS",new A.j7(),B.b));
	q($,"yX","qU",()=>A.v("ANIMATION_SAMPLER_OUTPUT_ACCESSOR_INVALID_COUNT",new A.j9(),B.b));
	q($,"yT","o4",()=>A.v("ANIMATION_SAMPLER_ACCESSOR_WITH_BYTESTRIDE",new A.j5(),B.b));
	q($,"yZ","qW",()=>A.v("BUFFER_MISSING_GLB_DATA",new A.jb(),B.b));
	q($,"z1","o5",()=>A.v("BUFFER_VIEW_TOO_LONG",new A.je(),B.b));
	q($,"z0","qY",()=>A.v("BUFFER_VIEW_TARGET_OVERRIDE",new A.jd(),B.b));
	q($,"z_","qX",()=>A.v("BUFFER_VIEW_TARGET_MISSING",new A.jc(),B.aB));
	q($,"z2","qZ",()=>A.v("IMAGE_BUFFER_VIEW_WITH_BYTESTRIDE",new A.jf(),B.b));
	q($,"z3","r_",()=>A.v("INCOMPLETE_EXTENSION_SUPPORT",new A.jg(),B.h));
	q($,"z4","r0",()=>A.v("INVALID_IBM_ACCESSOR_COUNT",new A.jh(),B.b));
	q($,"z8","o7",()=>A.v("MESH_PRIMITIVE_ATTRIBUTES_ACCESSOR_INVALID_FORMAT",new A.jl(),B.b));
	q($,"z9","r3",()=>A.v("MESH_PRIMITIVE_ATTRIBUTES_ACCESSOR_UNSIGNED_INT",new A.jm(),B.b));
	q($,"zh","o8",()=>A.v("MESH_PRIMITIVE_POSITION_ACCESSOR_WITHOUT_BOUNDS",new A.ju(),B.b));
	q($,"z7","r2",()=>A.v("MESH_PRIMITIVE_ACCESSOR_WITHOUT_BYTESTRIDE",new A.jk(),B.b));
	q($,"z6","o6",()=>A.v("MESH_PRIMITIVE_ACCESSOR_UNALIGNED",new A.jj(),B.b));
	q($,"zd","r7",()=>A.v("MESH_PRIMITIVE_INDICES_ACCESSOR_WITH_BYTESTRIDE",new A.jq(),B.b));
	q($,"zc","r6",()=>A.v("MESH_PRIMITIVE_INDICES_ACCESSOR_INVALID_FORMAT",new A.jp(),B.b));
	q($,"zb","r5",()=>A.v("MESH_PRIMITIVE_INCOMPATIBLE_MODE",new A.jo(),B.e));
	q($,"zi","o9",()=>A.v("MESH_PRIMITIVE_TOO_FEW_TEXCOORDS",new A.jv(),B.b));
	q($,"zg","ra",()=>A.v("MESH_PRIMITIVE_NO_TANGENT_SPACE",new A.jt(),B.b));
	q($,"za","r4",()=>A.v("MESH_PRIMITIVE_GENERATED_TANGENT_SPACE",new A.jn(),B.e));
	q($,"zj","rb",()=>A.v("MESH_PRIMITIVE_UNEQUAL_ACCESSOR_COUNT",new A.jw(),B.b));
	q($,"zf","r9",()=>A.v("MESH_PRIMITIVE_MORPH_TARGET_NO_BASE_ACCESSOR",new A.js(),B.b));
	q($,"ze","r8",()=>A.v("MESH_PRIMITIVE_MORPH_TARGET_INVALID_ATTRIBUTE_COUNT",new A.jr(),B.b));
	q($,"zk","rc",()=>A.v("NODE_LOOP",new A.jx(),B.b));
	q($,"zl","rd",()=>A.v("NODE_PARENT_OVERRIDE",new A.jy(),B.b));
	q($,"zo","rg",()=>A.v("NODE_WEIGHTS_INVALID",new A.jB(),B.b));
	q($,"zm","re",()=>A.v("NODE_SKIN_WITH_NON_SKINNED_MESH",new A.jz(),B.b));
	q($,"zn","rf",()=>A.v("NODE_SKINNED_MESH_WITHOUT_SKIN",new A.jA(),B.e));
	q($,"zp","rh",()=>A.v("SCENE_NON_ROOT_NODE",new A.jC(),B.b));
	q($,"zr","rj",()=>A.v("SKIN_IBM_INVALID_FORMAT",new A.jE(),B.b));
	q($,"zq","ri",()=>A.v("SKIN_IBM_ACCESSOR_WITH_BYTESTRIDE",new A.jD(),B.b));
	q($,"zs","oa",()=>A.v("TEXTURE_INVALID_IMAGE_MIME_TYPE",new A.jF(),B.b));
	q($,"zt","rk",()=>A.v("UNDECLARED_EXTENSION",new A.jG(),B.b));
	q($,"zu","rl",()=>A.v("UNEXPECTED_EXTENSION_OBJECT",new A.jH(),B.b));
	q($,"zv","Q",()=>A.v("UNRESOLVED_REFERENCE",new A.jI(),B.b));
	q($,"zw","rm",()=>A.v("UNSUPPORTED_EXTENSION",new A.jJ(),B.h));
	q($,"zz","h1",()=>A.v("UNUSED_OBJECT",new A.jM(),B.h));
	q($,"zy","ro",()=>A.v("UNUSED_MESH_WEIGHTS",new A.jL(),B.h));
	q($,"zx","rn",()=>A.v("UNUSED_MESH_TANGENT",new A.jK(),B.h));
	q($,"z5","r1",()=>A.v("KHR_MATERIALS_VARIANTS_NON_UNIQUE_VARIANT",new A.ji(),B.b));
	q($,"yA","qA",()=>A.al("GLB_INVALID_MAGIC",new A.i5(),B.b));
	q($,"yB","qB",()=>A.al("GLB_INVALID_VERSION",new A.i6(),B.b));
	q($,"yD","qD",()=>A.al("GLB_LENGTH_TOO_SMALL",new A.i8(),B.b));
	q($,"yu","qu",()=>A.al("GLB_CHUNK_LENGTH_UNALIGNED",new A.i_(),B.b));
	q($,"yC","qC",()=>A.al("GLB_LENGTH_MISMATCH",new A.i7(),B.b));
	q($,"yv","qv",()=>A.al("GLB_CHUNK_TOO_BIG",new A.i0(),B.b));
	q($,"yy","qy",()=>A.al("GLB_EMPTY_CHUNK",new A.i3(),B.b));
	q($,"yx","qx",()=>A.al("GLB_EMPTY_BIN_CHUNK",new A.i2(),B.h));
	q($,"yw","qw",()=>A.al("GLB_DUPLICATE_CHUNK",new A.i1(),B.b));
	q($,"yG","qG",()=>A.al("GLB_UNEXPECTED_END_OF_CHUNK_HEADER",new A.ib(),B.b));
	q($,"yF","qF",()=>A.al("GLB_UNEXPECTED_END_OF_CHUNK_DATA",new A.ia(),B.b));
	q($,"yH","qH",()=>A.al("GLB_UNEXPECTED_END_OF_HEADER",new A.ic(),B.b));
	q($,"yI","qI",()=>A.al("GLB_UNEXPECTED_FIRST_CHUNK",new A.id(),B.b));
	q($,"yE","qE",()=>A.al("GLB_UNEXPECTED_BIN_CHUNK",new A.i9(),B.b));
	q($,"yJ","qJ",()=>A.al("GLB_UNKNOWN_CHUNK_TYPE",new A.ie(),B.e));
	q($,"yz","qz",()=>A.al("GLB_EXTRA_DATA",new A.i4(),B.e));
	q($,"yL","qK",()=>A.nx("^(?:\\/(?:[^/~]|~0|~1)*)*$"));
	q($,"B9","ol",()=>A.uQ(1));
	q($,"Bc","tp",()=>A.uM());
	q($,"Bg","tt",()=>A.pa());
	q($,"Bd","tq",()=>{var p=A.v3();
	p.a[3]=1;
	return p});
	q($,"Be","tr",()=>A.pa());})();(function nativeSupport(){!function(){var s=function(a){var m={};
	m[a]=1;
	return Object.keys(hunkHelpers.convertToFastObject(m))[0]};
	v.getIsolateTag=function(a){return s("___dart_"+a+v.isolateTag)};
	var r="___dart_isolate_tags_";
	var q=Object[r]||(Object[r]=Object.create(null));
	var p="_ZxYxX";
	for(var o=0;;o++){var n=s(p+"_"+o+"_");
	if(!(n in q)){q[n]=1;
	v.isolateTag=n;
	break}}v.dispatchPropertyName=v.getIsolateTag("dispatch_record");}();
	hunkHelpers.setOrUpdateInterceptorsByTag({ArrayBuffer:J.cV,DataView:A.dF,ArrayBufferView:A.dF,Float32Array:A.f8,Float64Array:A.f9,Int16Array:A.fa,Int32Array:A.fb,Int8Array:A.fc,Uint16Array:A.fd,Uint32Array:A.fe,Uint8ClampedArray:A.dG,CanvasPixelArray:A.dG,Uint8Array:A.cy});
	hunkHelpers.setOrUpdateLeafTags({ArrayBuffer:true,DataView:true,ArrayBufferView:false,Float32Array:true,Float64Array:true,Int16Array:true,Int32Array:true,Int8Array:true,Uint16Array:true,Uint32Array:true,Uint8ClampedArray:true,CanvasPixelArray:true,Uint8Array:false});
	A.d_.$nativeSuperclassTag="ArrayBufferView";
	A.e7.$nativeSuperclassTag="ArrayBufferView";
	A.e8.$nativeSuperclassTag="ArrayBufferView";
	A.dE.$nativeSuperclassTag="ArrayBufferView";
	A.e9.$nativeSuperclassTag="ArrayBufferView";
	A.ea.$nativeSuperclassTag="ArrayBufferView";
	A.aw.$nativeSuperclassTag="ArrayBufferView";})();
	Function.prototype.$1=function(a){return this(a)};
	Function.prototype.$0=function(){return this()};
	Function.prototype.$2=function(a,b){return this(a,b)};
	Function.prototype.$1$1=function(a){return this(a)};
	Function.prototype.$1$0=function(){return this()};
	Function.prototype.$3=function(a,b,c){return this(a,b,c)};
	Function.prototype.$4=function(a,b,c,d){return this(a,b,c,d)};
	Function.prototype.$1$2=function(a,b){return this(a,b)};
	Function.prototype.$2$0=function(){return this()};
	convertAllToFastObject(w);
(function(a){if(typeof document==="undefined"){a(null);
	return}if(typeof document.currentScript!="undefined"){a(document.currentScript);
	return}var s=document.scripts;
	function onLoad(b){for(var q=0;q<s.length;++q)s[q].removeEventListener("load",onLoad,false);
	a(b.target);}for(var r=0;r<s.length;++r)s[r].addEventListener("load",onLoad,false);})(function(a){v.currentScript=a;
	var s=A.xD;
	if(typeof dartMainRunner==="function")dartMainRunner(s,[]);
	else s([]);});})(); 
} (gltf_validator_dart$1));

var gltf_validator_dart = /*@__PURE__*/getDefaultExportFromCjs$1(gltf_validator_dart$1);

/*
 * # Copyright (c) 2016-2019 The Khronos Group Inc.
 * #
 * # Licensed under the Apache License, Version 2.0 (the "License");
 * # you may not use this file except in compliance with the License.
 * # You may obtain a copy of the License at
 * #
 * #     http://www.apache.org/licenses/LICENSE-2.0
 * #
 * # Unless required by applicable law or agreed to in writing, software
 * # distributed under the License is distributed on an "AS IS" BASIS,
 * # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * # See the License for the specific language governing permissions and
 * # limitations under the License.
 */


/**
 * Validates an asset from bytes.
 * @param {Uint8Array} data - Byte array containing glTF or GLB data.
 * @param {ValidationOptions} options - Object with validation options.
 * @returns {Promise} Promise with validation result in object form.
 */
const validateBytes = (data, options) => gltf_validator_dart.validateBytes(data, options);

/**
 @typedef {Object} ValidationOptions
 @property {string} uri - Absolute or relative asset URI that will be copied to validation report.
 @property {string} format - Set to `glb` or `gltf` to skip auto-detection of the asset format based on the first byte; any other value will be ignored. This option has no effect on `validateString`.
 @property {ExternalResourceFunction} externalResourceFunction - Function for loading external resources. If omitted, external resources are not validated.
 @property {boolean} writeTimestamp - Set to `false` to omit timestamp from the validation report.
 @property {number} maxIssues - Max number of reported issues. Use `0` for unlimited output.
 @property {string[]} ignoredIssues - Array of ignored issue codes.
 @property {string[]} onlyIssues - Array of only issues to consider. Cannot be used along with ignoredIssues.
 @property {Object} severityOverrides - Object with overridden severities for issue codes.
 */

/**
 * @callback ExternalResourceFunction
 * @param {string} uri - Relative URI of the external resource.
 * @returns {Promise} - Promise with Uint8Array data.
 */

const ignoredIssues = [
    // This sample renderer supports tangent space generation.
    "MESH_PRIMITIVE_GENERATED_TANGENT_SPACE"
];

var main = async () => {
    const canvas = document.getElementById("canvas");
    const context = canvas.getContext("webgl2", {
        alpha: false,
        antialias: true,
    });
    const view = new GltfView(context);
    const resourceLoader = view.createResourceLoader();
    const state = view.createState();
    state.renderingParameters.useDirectionalLightsWithDisabledIBL = true;

    const pathProvider = new GltfModelPathProvider(
        "https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Assets/main"
    );
    await pathProvider.initialize();
    const environmentPaths = fillEnvironmentWithPaths(
        {
            Cannon_Exterior: "Cannon Exterior",
            footprint_court: "Footprint Court",
            pisa: "Pisa",
            doge2: "Doge's palace",
            ennis: "Dining room",
            field: "Field",
            helipad: "Helipad Goldenhour",
            papermill: "Papermill Ruins",
            neutral: "Studio Neutral",
            Colorful_Studio: "Colorful Studio",
            Wide_Street: "Wide Street",
        },
        "https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Environments/low_resolution_hdrs/"
    );

    const uiModel = new UIModel(app, pathProvider, environmentPaths);


    const validation = uiModel.model.pipe(
        mergeMap((model) => {
            const func = async(model) => {
                try {
                    const fileType = typeof model.mainFile;
                    if (fileType == "string"){
                        const externalRefFunction = (uri) => {
                            const parent = model.mainFile.substring(0, model.mainFile.lastIndexOf("/") + 1);
                            return new Promise((resolve, reject) => {
                                fetch(parent + uri).then(response => {
                                    response.arrayBuffer().then(buffer => {
                                        resolve(new Uint8Array(buffer));
                                    }).catch(error => {
                                        reject(error);
                                    });
                                }).catch(error => {
                                    reject(error);
                                });
                            });
                        };
                        const response = await fetch(model.mainFile);
                        const buffer = await response.arrayBuffer();
                        return await validateBytes(new Uint8Array(buffer), {
                            externalResourceFunction: externalRefFunction,
                            uri: model.mainFile,
                            ignoredIssues
                        });
                    } else if (Array.isArray(model.mainFile)) {
                        const externalRefFunction = (uri) => {
                            uri = "/" + uri;
                            return new Promise((resolve, reject) => {
                                let foundFile = undefined;
                                for (let i = 0; i < model.additionalFiles.length; i++) {
                                    const file = model.additionalFiles[i];
                                    if (file[0] == uri) {
                                        foundFile = file[1];
                                        break;
                                    }
                                }
                                if (foundFile) {
                                    foundFile.arrayBuffer().then((buffer) => {
                                        resolve(new Uint8Array(buffer));
                                    }).catch((error) => {
                                        reject(error);
                                    });
                                } else {
                                    reject("File not found");
                                }
                            });
                        };

                        const buffer = await model.mainFile[1].arrayBuffer();
                        return await validateBytes(new Uint8Array(buffer),
                            {
                                externalResourceFunction: externalRefFunction,
                                uri: model.mainFile[0],
                                ignoredIssues
                            });
                    }
                } catch (error) {
                    console.error(error);
                }
            };
            return from(func(model)).pipe(catchError((error) => { console.error(`Validation failed: ${error}`); return EMPTY; }));
        })
    );

    // whenever a new model is selected, load it and when complete pass the loaded gltf
    // into a stream back into the UI
    const gltfLoaded = uiModel.model.pipe(
        mergeMap((model) => {
            uiModel.goToLoadingState();

            // Workaround for errors in ktx lib after loading an asset with ktx2 files for the second time:
            resourceLoader.initKtxLib();

            return from(
                resourceLoader
                    .loadGltf(model.mainFile, model.additionalFiles)
                    .then((gltf) => {
                        state.gltf = gltf;
                        const defaultScene = state.gltf.scene;
                        state.sceneIndex = defaultScene === undefined ? 0 : defaultScene;
                        state.cameraIndex = undefined;

                        if (state.gltf.scenes.length != 0) {
                            if (state.sceneIndex > state.gltf.scenes.length - 1) {
                                state.sceneIndex = 0;
                            }
                            const scene = state.gltf.scenes[state.sceneIndex];
                            scene.applyTransformHierarchy(state.gltf);
                            state.userCamera.perspective.aspectRatio = canvas.width / canvas.height;
                            state.userCamera.resetView(state.gltf, state.sceneIndex);

                            const queryString = window.location.search;
                            const urlParams = new URLSearchParams(queryString);
                            let yaw = urlParams.get("yaw") ?? 0;
                            yaw = yaw * (Math.PI / 180) / state.userCamera.orbitSpeed;
                            let pitch = urlParams.get("pitch") ?? 0;
                            pitch = pitch * (Math.PI / 180) / state.userCamera.orbitSpeed;
                            const distance = urlParams.get("distance") ?? 0;
                            state.userCamera.orbit(yaw, pitch);
                            state.userCamera.zoomBy(distance);

                            // Try to start as many animations as possible without generating conficts.
                            state.animationIndices = [];
                            for (let i = 0; i < gltf.animations.length; i++) {
                                if (
                                    !gltf
                                        .nonDisjointAnimations(state.animationIndices)
                                        .includes(i)
                                ) {
                                    state.animationIndices.push(i);
                                }
                            }
                            state.animationTimer.start();
                        }

                        uiModel.exitLoadingState();

                        return state;
                    }).catch((error) => {
                        console.error("Loading failed: "+ error);
                        resourceLoader
                            .loadGltf(undefined, undefined)
                            .then((gltf) => {
                                state.gltf = gltf;
                                state.sceneIndex = 0;
                                state.cameraIndex = undefined;

                                uiModel.exitLoadingState();
                                redraw = true;
                            }); 
                        return state;
                    })
            );
        }),
        catchError((error) => {
            console.error(error);
            uiModel.exitLoadingState();
            return EMPTY;
        }),
        share()
    );

    // Disable all animations which are not disjoint to the current selection of animations.
    uiModel.disabledAnimations(
        uiModel.activeAnimations.pipe(
            map((animationIndices) =>
                state.gltf.nonDisjointAnimations(animationIndices)
            )
        )
    );

    const sceneChangedObservable = uiModel.scene.pipe(
        map((sceneIndex) => {
            state.sceneIndex = sceneIndex;
            state.cameraIndex = undefined;
            const scene = state.gltf.scenes[state.sceneIndex];
            if (scene !== undefined) {
                scene.applyTransformHierarchy(state.gltf);
                state.userCamera.resetView(state.gltf, state.sceneIndex);
            }
        }),
        share()
    );

    const statisticsUpdateObservable = merge$1(
        sceneChangedObservable,
        gltfLoaded
    ).pipe(map(() => view.gatherStatistics(state)));

    const cameraExportChangedObservable = uiModel.cameraValuesExport.pipe(
        map(() => {
            const camera =
        state.cameraIndex === undefined
            ? state.userCamera
            : state.gltf.cameras[state.cameraIndex];
            return camera.getDescription(state.gltf);
        })
    );

    const downloadDataURL = (filename, dataURL) => {
        const element = document.createElement("a");
        element.setAttribute("href", dataURL);
        element.setAttribute("download", filename);
        element.style.display = "none";
        document.body.appendChild(element);
        element.click();
        document.body.removeChild(element);
    };

    cameraExportChangedObservable.subscribe((cameraDesc) => {
        const gltf = JSON.stringify(cameraDesc, undefined, 4);
        const dataURL = "data:text/plain;charset=utf-8," + encodeURIComponent(gltf);
        downloadDataURL("camera.gltf", dataURL);
    });

    uiModel.captureCanvas.subscribe(() => {
        view.renderFrame(state, canvas.width, canvas.height);
        const dataURL = canvas.toDataURL();
        downloadDataURL("capture.png", dataURL);
    });

    // Only redraw glTF view upon user inputs, or when an animation is playing.
    let redraw = false;
    const listenForRedraw = (stream) => stream.subscribe(() => (redraw = true));

    uiModel.scene.subscribe(
        (scene) => (state.sceneIndex = scene !== -1 ? scene : undefined)
    );
    listenForRedraw(uiModel.scene);

    uiModel.camera.subscribe(
        (camera) => (state.cameraIndex = camera !== -1 ? camera : undefined)
    );
    listenForRedraw(uiModel.camera);

    uiModel.variant.subscribe((variant) => (state.variant = variant));
    listenForRedraw(uiModel.variant);

    uiModel.tonemap.subscribe(
        (tonemap) => (state.renderingParameters.toneMap = tonemap)
    );
    listenForRedraw(uiModel.tonemap);

    uiModel.debugchannel.subscribe(
        (debugchannel) => (state.renderingParameters.debugOutput = debugchannel)
    );
    listenForRedraw(uiModel.debugchannel);

    uiModel.skinningEnabled.subscribe(
        (skinningEnabled) => (state.renderingParameters.skinning = skinningEnabled)
    );
    listenForRedraw(uiModel.skinningEnabled);

    uiModel.exposure.subscribe(
        (exposure) =>
            (state.renderingParameters.exposure = 1.0 / Math.pow(2.0, exposure))
    );
    listenForRedraw(uiModel.exposure);

    uiModel.morphingEnabled.subscribe(
        (morphingEnabled) => (state.renderingParameters.morphing = morphingEnabled)
    );
    listenForRedraw(uiModel.morphingEnabled);

    uiModel.clearcoatEnabled.subscribe(
        (clearcoatEnabled) =>
            (state.renderingParameters.enabledExtensions.KHR_materials_clearcoat =
        clearcoatEnabled)
    );
    listenForRedraw(uiModel.clearcoatEnabled);

    uiModel.sheenEnabled.subscribe(
        (sheenEnabled) =>
            (state.renderingParameters.enabledExtensions.KHR_materials_sheen =
        sheenEnabled)
    );
    listenForRedraw(uiModel.sheenEnabled);

    uiModel.transmissionEnabled.subscribe(
        (transmissionEnabled) =>
            (state.renderingParameters.enabledExtensions.KHR_materials_transmission =
        transmissionEnabled)
    );
    listenForRedraw(uiModel.transmissionEnabled);

    uiModel.diffuseTransmissionEnabled.subscribe(
        (diffuseTransmissionEnabled) =>
            (state.renderingParameters.enabledExtensions.KHR_materials_diffuse_transmission =
        diffuseTransmissionEnabled)
    );
    listenForRedraw(uiModel.diffuseTransmissionEnabled);

    uiModel.volumeEnabled.subscribe(
        (volumeEnabled) =>
            (state.renderingParameters.enabledExtensions.KHR_materials_volume =
        volumeEnabled)
    );
    listenForRedraw(uiModel.volumeEnabled);

    uiModel.iorEnabled.subscribe(
        (iorEnabled) =>
            (state.renderingParameters.enabledExtensions.KHR_materials_ior =
        iorEnabled)
    );
    listenForRedraw(uiModel.iorEnabled);

    uiModel.iridescenceEnabled.subscribe(
        (iridescenceEnabled) =>
            (state.renderingParameters.enabledExtensions.KHR_materials_iridescence =
        iridescenceEnabled)
    );
    listenForRedraw(uiModel.iridescenceEnabled);

    uiModel.anisotropyEnabled.subscribe(
        (anisotropyEnabled) =>
            (state.renderingParameters.enabledExtensions.KHR_materials_anisotropy =
        anisotropyEnabled)
    );
    listenForRedraw(uiModel.anisotropyEnabled);

    uiModel.dispersionEnabled.subscribe(
        (dispersionEnabled) =>
            (state.renderingParameters.enabledExtensions.KHR_materials_dispersion =
        dispersionEnabled)
    );
    listenForRedraw(uiModel.dispersionEnabled);

    uiModel.specularEnabled.subscribe(
        (specularEnabled) =>
            (state.renderingParameters.enabledExtensions.KHR_materials_specular =
        specularEnabled)
    );
    listenForRedraw(uiModel.specularEnabled);

    uiModel.emissiveStrengthEnabled.subscribe(
        (enabled) =>
            (state.renderingParameters.enabledExtensions.KHR_materials_emissive_strength =
        enabled)
    );
    listenForRedraw(uiModel.emissiveStrengthEnabled);

    uiModel.iblEnabled.subscribe(
        (iblEnabled) => (state.renderingParameters.useIBL = iblEnabled)
    );
    listenForRedraw(uiModel.iblEnabled);

    uiModel.iblIntensity.subscribe(
        (iblIntensity) =>
            (state.renderingParameters.iblIntensity = Math.pow(10, iblIntensity))
    );
    listenForRedraw(uiModel.iblIntensity);

    uiModel.renderEnvEnabled.subscribe(
        (renderEnvEnabled) =>
            (state.renderingParameters.renderEnvironmentMap = renderEnvEnabled)
    );
    listenForRedraw(uiModel.renderEnvEnabled);

    uiModel.blurEnvEnabled.subscribe(
        (blurEnvEnabled) =>
            (state.renderingParameters.blurEnvironmentMap = blurEnvEnabled)
    );
    listenForRedraw(uiModel.blurEnvEnabled);

    uiModel.punctualLightsEnabled.subscribe(
        (punctualLightsEnabled) =>
            (state.renderingParameters.usePunctual = punctualLightsEnabled)
    );
    listenForRedraw(uiModel.punctualLightsEnabled);

    uiModel.environmentRotation.subscribe((environmentRotation) => {
        switch (environmentRotation) {
        case "+Z":
            state.renderingParameters.environmentRotation = 90.0;
            break;
        case "-X":
            state.renderingParameters.environmentRotation = 180.0;
            break;
        case "-Z":
            state.renderingParameters.environmentRotation = 270.0;
            break;
        case "+X":
            state.renderingParameters.environmentRotation = 0.0;
            break;
        }
    });
    listenForRedraw(uiModel.environmentRotation);

    uiModel.clearColor.subscribe(
        (clearColor) => (state.renderingParameters.clearColor = clearColor)
    );
    listenForRedraw(uiModel.clearColor);

    uiModel.animationPlay.subscribe((animationPlay) => {
        if (animationPlay) {
            state.animationTimer.unpause();
        } else {
            state.animationTimer.pause();
        }
    });

    uiModel.activeAnimations.subscribe(
        (animations) => (state.animationIndices = animations)
    );
    listenForRedraw(uiModel.activeAnimations);

    uiModel.hdr.subscribe((hdr) => {
        resourceLoader.loadEnvironment(hdr.hdr_path).then((environment) => {
            state.environment = environment;
            // We need to wait until the environment is loaded to redraw
            redraw = true;
        });
    });

    uiModel.attachGltfLoaded(gltfLoaded);
    uiModel.updateValidationReport(validation);
    uiModel.updateStatistics(statisticsUpdateObservable);
    const sceneChangedStateObservable = uiModel.scene.pipe(map(() => state));
    uiModel.attachCameraChangeObservable(sceneChangedStateObservable);

    uiModel.orbit.subscribe((orbit) => {
        if (state.cameraIndex === undefined) {
            state.userCamera.orbit(orbit.deltaPhi, orbit.deltaTheta);
        }
    });
    listenForRedraw(uiModel.orbit);

    uiModel.pan.subscribe((pan) => {
        if (state.cameraIndex === undefined) {
            state.userCamera.pan(pan.deltaX, -pan.deltaY);
        }
    });
    listenForRedraw(uiModel.pan);

    uiModel.zoom.subscribe((zoom) => {
        if (state.cameraIndex === undefined) {
            state.userCamera.zoomBy(zoom.deltaZoom);
        }
    });
    listenForRedraw(uiModel.zoom);

    listenForRedraw(gltfLoaded);

    // configure the animation loop
    const past = {};
    const update = () => {
        const devicePixelRatio = window.devicePixelRatio || 1;

        // set the size of the drawingBuffer based on the size it's displayed.
        canvas.width = Math.floor(canvas.clientWidth * devicePixelRatio);
        canvas.height = Math.floor(canvas.clientHeight * devicePixelRatio);
        redraw |= !state.animationTimer.paused && state.animationIndices.length > 0;
        redraw |= past.width != canvas.width || past.height != canvas.height;

        // Refit view if canvas changes significantly
        if((canvas.width/past.width <0.5 || canvas.width/past.width>2.0 )||
            (canvas.height/past.height <0.5 || canvas.height/past.height>2.0 ))
        {
            state.userCamera.perspective.aspectRatio = canvas.width / canvas.height;
            state.userCamera.fitViewToScene(state.gltf, state.sceneIndex);
        }


        past.width = canvas.width;
        past.height = canvas.height;

        if (redraw) {
            view.renderFrame(state, canvas.width, canvas.height);
            redraw = false;
        }

        window.requestAnimationFrame(update);
    };

    // After this start executing animation loop.
    window.requestAnimationFrame(update);
};

export { main as default };
//# sourceMappingURL=GltfSVApp.js.map
